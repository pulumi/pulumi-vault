// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "../utilities";

/**
 * Manages an Kubernetes auth backend role in a Vault server. See the [Vault
 * documentation](https://www.vaultproject.io/docs/auth/kubernetes.html) for more
 * information.
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as vault from "@pulumi/vault";
 *
 * const kubernetes = new vault.AuthBackend("kubernetes", {type: "kubernetes"});
 * const example = new vault.kubernetes.AuthBackendRole("example", {
 *     backend: kubernetes.path,
 *     roleName: "example-role",
 *     boundServiceAccountNames: ["example"],
 *     boundServiceAccountNamespaces: ["example"],
 *     tokenTtl: 3600,
 *     tokenPolicies: [
 *         "default",
 *         "dev",
 *         "prod",
 *     ],
 *     audience: "vault",
 * });
 * ```
 *
 * ## Import
 *
 * Kubernetes auth backend role can be imported using the `path`, e.g.
 *
 * ```sh
 * $ pulumi import vault:kubernetes/authBackendRole:AuthBackendRole foo auth/kubernetes/role/foo
 * ```
 */
export class AuthBackendRole extends pulumi.CustomResource {
    /**
     * Get an existing AuthBackendRole resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: AuthBackendRoleState, opts?: pulumi.CustomResourceOptions): AuthBackendRole {
        return new AuthBackendRole(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'vault:kubernetes/authBackendRole:AuthBackendRole';

    /**
     * Returns true if the given object is an instance of AuthBackendRole.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is AuthBackendRole {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === AuthBackendRole.__pulumiType;
    }

    /**
     * The metadata to be tied to generated entity alias.
     *   This should be a list or map containing the metadata in key value pairs.
     */
    declare public readonly aliasMetadata: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * Configures how identity aliases are generated.
     * Valid choices are: `serviceaccountUid`, `serviceaccountName`. (vault-1.9+)
     */
    declare public readonly aliasNameSource: pulumi.Output<string>;
    /**
     * Audience claim to verify in the JWT.
     *
     * > Please see [aliasNameSource](https://www.vaultproject.io/api-docs/auth/kubernetes#alias_name_source)
     * before setting this to something other its default value. There are **important** security
     * implications to be aware of.
     */
    declare public readonly audience: pulumi.Output<string | undefined>;
    /**
     * Unique name of the kubernetes backend to configure.
     */
    declare public readonly backend: pulumi.Output<string | undefined>;
    /**
     * List of service account names able to access this role. If set to `["*"]` all names are allowed, both this and boundServiceAccountNamespaces can not be "*".
     */
    declare public readonly boundServiceAccountNames: pulumi.Output<string[]>;
    /**
     * A label selector for Kubernetes namespaces allowed to access this role. Accepts either a JSON or YAML object. The value should be of type LabelSelector. Currently, label selectors with matchExpressions are not supported. To use label selectors, Vault must have permission to read namespaces on the Kubernetes cluster. If set with bound_service_account_namespaces, the conditions are ORed. Requires Vault v1.16+.
     */
    declare public readonly boundServiceAccountNamespaceSelector: pulumi.Output<string | undefined>;
    /**
     * List of namespaces allowed to access this role. If set to `["*"]` all namespaces are allowed, both this and boundServiceAccountNames can not be set to "*".
     */
    declare public readonly boundServiceAccountNamespaces: pulumi.Output<string[] | undefined>;
    /**
     * The namespace to provision the resource in.
     * The value should not contain leading or trailing forward slashes.
     * The `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault/index.html#namespace).
     * *Available only for Vault Enterprise*.
     */
    declare public readonly namespace: pulumi.Output<string | undefined>;
    /**
     * Name of the role.
     */
    declare public readonly roleName: pulumi.Output<string>;
    /**
     * Specifies the blocks of IP addresses which are allowed to use the generated token
     */
    declare public readonly tokenBoundCidrs: pulumi.Output<string[] | undefined>;
    /**
     * Generated Token's Explicit Maximum TTL in seconds
     */
    declare public readonly tokenExplicitMaxTtl: pulumi.Output<number | undefined>;
    /**
     * The maximum lifetime of the generated token
     */
    declare public readonly tokenMaxTtl: pulumi.Output<number | undefined>;
    /**
     * If true, the 'default' policy will not automatically be added to generated tokens
     */
    declare public readonly tokenNoDefaultPolicy: pulumi.Output<boolean | undefined>;
    /**
     * The maximum number of times a token may be used, a value of zero means unlimited
     */
    declare public readonly tokenNumUses: pulumi.Output<number | undefined>;
    /**
     * Generated Token's Period
     */
    declare public readonly tokenPeriod: pulumi.Output<number | undefined>;
    /**
     * Generated Token's Policies
     */
    declare public readonly tokenPolicies: pulumi.Output<string[] | undefined>;
    /**
     * The initial ttl of the token to generate in seconds
     */
    declare public readonly tokenTtl: pulumi.Output<number | undefined>;
    /**
     * The type of token to generate, service or batch
     */
    declare public readonly tokenType: pulumi.Output<string | undefined>;

    /**
     * Create a AuthBackendRole resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: AuthBackendRoleArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: AuthBackendRoleArgs | AuthBackendRoleState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as AuthBackendRoleState | undefined;
            resourceInputs["aliasMetadata"] = state?.aliasMetadata;
            resourceInputs["aliasNameSource"] = state?.aliasNameSource;
            resourceInputs["audience"] = state?.audience;
            resourceInputs["backend"] = state?.backend;
            resourceInputs["boundServiceAccountNames"] = state?.boundServiceAccountNames;
            resourceInputs["boundServiceAccountNamespaceSelector"] = state?.boundServiceAccountNamespaceSelector;
            resourceInputs["boundServiceAccountNamespaces"] = state?.boundServiceAccountNamespaces;
            resourceInputs["namespace"] = state?.namespace;
            resourceInputs["roleName"] = state?.roleName;
            resourceInputs["tokenBoundCidrs"] = state?.tokenBoundCidrs;
            resourceInputs["tokenExplicitMaxTtl"] = state?.tokenExplicitMaxTtl;
            resourceInputs["tokenMaxTtl"] = state?.tokenMaxTtl;
            resourceInputs["tokenNoDefaultPolicy"] = state?.tokenNoDefaultPolicy;
            resourceInputs["tokenNumUses"] = state?.tokenNumUses;
            resourceInputs["tokenPeriod"] = state?.tokenPeriod;
            resourceInputs["tokenPolicies"] = state?.tokenPolicies;
            resourceInputs["tokenTtl"] = state?.tokenTtl;
            resourceInputs["tokenType"] = state?.tokenType;
        } else {
            const args = argsOrState as AuthBackendRoleArgs | undefined;
            if (args?.boundServiceAccountNames === undefined && !opts.urn) {
                throw new Error("Missing required property 'boundServiceAccountNames'");
            }
            if (args?.roleName === undefined && !opts.urn) {
                throw new Error("Missing required property 'roleName'");
            }
            resourceInputs["aliasMetadata"] = args?.aliasMetadata;
            resourceInputs["aliasNameSource"] = args?.aliasNameSource;
            resourceInputs["audience"] = args?.audience;
            resourceInputs["backend"] = args?.backend;
            resourceInputs["boundServiceAccountNames"] = args?.boundServiceAccountNames;
            resourceInputs["boundServiceAccountNamespaceSelector"] = args?.boundServiceAccountNamespaceSelector;
            resourceInputs["boundServiceAccountNamespaces"] = args?.boundServiceAccountNamespaces;
            resourceInputs["namespace"] = args?.namespace;
            resourceInputs["roleName"] = args?.roleName;
            resourceInputs["tokenBoundCidrs"] = args?.tokenBoundCidrs;
            resourceInputs["tokenExplicitMaxTtl"] = args?.tokenExplicitMaxTtl;
            resourceInputs["tokenMaxTtl"] = args?.tokenMaxTtl;
            resourceInputs["tokenNoDefaultPolicy"] = args?.tokenNoDefaultPolicy;
            resourceInputs["tokenNumUses"] = args?.tokenNumUses;
            resourceInputs["tokenPeriod"] = args?.tokenPeriod;
            resourceInputs["tokenPolicies"] = args?.tokenPolicies;
            resourceInputs["tokenTtl"] = args?.tokenTtl;
            resourceInputs["tokenType"] = args?.tokenType;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(AuthBackendRole.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering AuthBackendRole resources.
 */
export interface AuthBackendRoleState {
    /**
     * The metadata to be tied to generated entity alias.
     *   This should be a list or map containing the metadata in key value pairs.
     */
    aliasMetadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Configures how identity aliases are generated.
     * Valid choices are: `serviceaccountUid`, `serviceaccountName`. (vault-1.9+)
     */
    aliasNameSource?: pulumi.Input<string>;
    /**
     * Audience claim to verify in the JWT.
     *
     * > Please see [aliasNameSource](https://www.vaultproject.io/api-docs/auth/kubernetes#alias_name_source)
     * before setting this to something other its default value. There are **important** security
     * implications to be aware of.
     */
    audience?: pulumi.Input<string>;
    /**
     * Unique name of the kubernetes backend to configure.
     */
    backend?: pulumi.Input<string>;
    /**
     * List of service account names able to access this role. If set to `["*"]` all names are allowed, both this and boundServiceAccountNamespaces can not be "*".
     */
    boundServiceAccountNames?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A label selector for Kubernetes namespaces allowed to access this role. Accepts either a JSON or YAML object. The value should be of type LabelSelector. Currently, label selectors with matchExpressions are not supported. To use label selectors, Vault must have permission to read namespaces on the Kubernetes cluster. If set with bound_service_account_namespaces, the conditions are ORed. Requires Vault v1.16+.
     */
    boundServiceAccountNamespaceSelector?: pulumi.Input<string>;
    /**
     * List of namespaces allowed to access this role. If set to `["*"]` all namespaces are allowed, both this and boundServiceAccountNames can not be set to "*".
     */
    boundServiceAccountNamespaces?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The namespace to provision the resource in.
     * The value should not contain leading or trailing forward slashes.
     * The `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault/index.html#namespace).
     * *Available only for Vault Enterprise*.
     */
    namespace?: pulumi.Input<string>;
    /**
     * Name of the role.
     */
    roleName?: pulumi.Input<string>;
    /**
     * Specifies the blocks of IP addresses which are allowed to use the generated token
     */
    tokenBoundCidrs?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Generated Token's Explicit Maximum TTL in seconds
     */
    tokenExplicitMaxTtl?: pulumi.Input<number>;
    /**
     * The maximum lifetime of the generated token
     */
    tokenMaxTtl?: pulumi.Input<number>;
    /**
     * If true, the 'default' policy will not automatically be added to generated tokens
     */
    tokenNoDefaultPolicy?: pulumi.Input<boolean>;
    /**
     * The maximum number of times a token may be used, a value of zero means unlimited
     */
    tokenNumUses?: pulumi.Input<number>;
    /**
     * Generated Token's Period
     */
    tokenPeriod?: pulumi.Input<number>;
    /**
     * Generated Token's Policies
     */
    tokenPolicies?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The initial ttl of the token to generate in seconds
     */
    tokenTtl?: pulumi.Input<number>;
    /**
     * The type of token to generate, service or batch
     */
    tokenType?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a AuthBackendRole resource.
 */
export interface AuthBackendRoleArgs {
    /**
     * The metadata to be tied to generated entity alias.
     *   This should be a list or map containing the metadata in key value pairs.
     */
    aliasMetadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Configures how identity aliases are generated.
     * Valid choices are: `serviceaccountUid`, `serviceaccountName`. (vault-1.9+)
     */
    aliasNameSource?: pulumi.Input<string>;
    /**
     * Audience claim to verify in the JWT.
     *
     * > Please see [aliasNameSource](https://www.vaultproject.io/api-docs/auth/kubernetes#alias_name_source)
     * before setting this to something other its default value. There are **important** security
     * implications to be aware of.
     */
    audience?: pulumi.Input<string>;
    /**
     * Unique name of the kubernetes backend to configure.
     */
    backend?: pulumi.Input<string>;
    /**
     * List of service account names able to access this role. If set to `["*"]` all names are allowed, both this and boundServiceAccountNamespaces can not be "*".
     */
    boundServiceAccountNames: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A label selector for Kubernetes namespaces allowed to access this role. Accepts either a JSON or YAML object. The value should be of type LabelSelector. Currently, label selectors with matchExpressions are not supported. To use label selectors, Vault must have permission to read namespaces on the Kubernetes cluster. If set with bound_service_account_namespaces, the conditions are ORed. Requires Vault v1.16+.
     */
    boundServiceAccountNamespaceSelector?: pulumi.Input<string>;
    /**
     * List of namespaces allowed to access this role. If set to `["*"]` all namespaces are allowed, both this and boundServiceAccountNames can not be set to "*".
     */
    boundServiceAccountNamespaces?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The namespace to provision the resource in.
     * The value should not contain leading or trailing forward slashes.
     * The `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault/index.html#namespace).
     * *Available only for Vault Enterprise*.
     */
    namespace?: pulumi.Input<string>;
    /**
     * Name of the role.
     */
    roleName: pulumi.Input<string>;
    /**
     * Specifies the blocks of IP addresses which are allowed to use the generated token
     */
    tokenBoundCidrs?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Generated Token's Explicit Maximum TTL in seconds
     */
    tokenExplicitMaxTtl?: pulumi.Input<number>;
    /**
     * The maximum lifetime of the generated token
     */
    tokenMaxTtl?: pulumi.Input<number>;
    /**
     * If true, the 'default' policy will not automatically be added to generated tokens
     */
    tokenNoDefaultPolicy?: pulumi.Input<boolean>;
    /**
     * The maximum number of times a token may be used, a value of zero means unlimited
     */
    tokenNumUses?: pulumi.Input<number>;
    /**
     * Generated Token's Period
     */
    tokenPeriod?: pulumi.Input<number>;
    /**
     * Generated Token's Policies
     */
    tokenPolicies?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The initial ttl of the token to generate in seconds
     */
    tokenTtl?: pulumi.Input<number>;
    /**
     * The type of token to generate, service or batch
     */
    tokenType?: pulumi.Input<string>;
}
