// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AuthBackendTune {
    /**
     * List of headers to whitelist and allowing
     * a plugin to include them in the response.
     */
    allowedResponseHeaders?: string[];
    /**
     * Specifies the list of keys that will
     * not be HMAC'd by audit devices in the request data object.
     */
    auditNonHmacRequestKeys?: string[];
    /**
     * Specifies the list of keys that will
     * not be HMAC'd by audit devices in the response data object.
     */
    auditNonHmacResponseKeys?: string[];
    /**
     * Specifies the default time-to-live.
     * If set, this overrides the global default.
     * Must be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)
     */
    defaultLeaseTtl?: string;
    /**
     * Specifies whether to show this mount in
     * the UI-specific listing endpoint. Valid values are "unauth" or "hidden".
     */
    listingVisibility?: string;
    /**
     * Specifies the maximum time-to-live.
     * If set, this overrides the global default.
     * Must be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)
     */
    maxLeaseTtl?: string;
    /**
     * List of headers to whitelist and
     * pass from the request to the backend.
     */
    passthroughRequestHeaders?: string[];
    /**
     * Specifies the type of tokens that should be returned by
     * the mount. Valid values are "default-service", "default-batch", "service", "batch".
     */
    tokenType?: string;
}

export interface GetPolicyDocumentRule {
    /**
     * Whitelists a list of keys and values that are permitted on the given path. See Parameters below.
     */
    allowedParameters?: outputs.GetPolicyDocumentRuleAllowedParameter[];
    /**
     * A list of capabilities that this rule apply to `path`. For example, ["read", "write"].
     */
    capabilities: string[];
    /**
     * Blacklists a list of parameter and values. Any values specified here take precedence over `allowedParameter`. See Parameters below.
     */
    deniedParameters?: outputs.GetPolicyDocumentRuleDeniedParameter[];
    /**
     * Description of the rule. Will be added as a comment to rendered rule.
     */
    description?: string;
    /**
     * The maximum allowed TTL that clients can specify for a wrapped response.
     */
    maxWrappingTtl?: string;
    /**
     * The minimum allowed TTL that clients can specify for a wrapped response.
     */
    minWrappingTtl?: string;
    /**
     * A path in Vault that this rule applies to.
     */
    path: string;
    /**
     * A list of parameters that must be specified.
     */
    requiredParameters?: string[];
}

export interface GetPolicyDocumentRuleAllowedParameter {
    /**
     * name of permitted or denied parameter.
     */
    key: string;
    /**
     * list of values what are permitted or denied by policy rule.
     */
    values: string[];
}

export interface GetPolicyDocumentRuleDeniedParameter {
    /**
     * name of permitted or denied parameter.
     */
    key: string;
    /**
     * list of values what are permitted or denied by policy rule.
     */
    values: string[];
}

export namespace azure {
    export interface BackendRoleAzureGroup {
        groupName: string;
        objectId: string;
    }

    export interface BackendRoleAzureRole {
        roleId: string;
        roleName: string;
        scope: string;
    }

}

export namespace config {
    export interface AuthLogin {
        method?: string;
        /**
         * The authentication engine's namespace. Conflicts with use_root_namespace
         */
        namespace?: string;
        parameters?: {[key: string]: string};
        path: string;
        /**
         * Authenticate to the root Vault namespace. Conflicts with namespace
         */
        useRootNamespace?: boolean;
    }

    export interface AuthLoginAws {
        /**
         * The AWS access key ID.
         */
        awsAccessKeyId?: string;
        /**
         * The IAM endpoint URL.
         */
        awsIamEndpoint?: string;
        /**
         * The name of the AWS profile.
         */
        awsProfile?: string;
        /**
         * The AWS region.
         */
        awsRegion?: string;
        /**
         * The ARN of the AWS Role to assume.Used during STS AssumeRole
         */
        awsRoleArn?: string;
        /**
         * Specifies the name to attach to the AWS role session. Used during STS AssumeRole
         */
        awsRoleSessionName?: string;
        /**
         * The AWS secret access key.
         */
        awsSecretAccessKey?: string;
        /**
         * The AWS session token.
         */
        awsSessionToken?: string;
        /**
         * Path to the AWS shared credentials file.
         */
        awsSharedCredentialsFile?: string;
        /**
         * The STS endpoint URL.
         */
        awsStsEndpoint?: string;
        /**
         * Path to the file containing an OAuth 2.0 access token or OpenID Connect ID token.
         */
        awsWebIdentityTokenFile?: string;
        /**
         * The Vault header value to include in the STS signing request.
         */
        headerValue?: string;
        /**
         * The path where the authentication engine is mounted.
         */
        mount?: string;
        /**
         * The authentication engine's namespace. Conflicts with use_root_namespace
         */
        namespace?: string;
        /**
         * The Vault role to use when logging into Vault.
         */
        role: string;
        /**
         * Authenticate to the root Vault namespace. Conflicts with namespace
         */
        useRootNamespace?: boolean;
    }

    export interface AuthLoginAzure {
        /**
         * The identity's client ID.
         */
        clientId?: string;
        /**
         * A signed JSON Web Token. If not specified on will be created automatically
         */
        jwt?: string;
        /**
         * The path where the authentication engine is mounted.
         */
        mount?: string;
        /**
         * The authentication engine's namespace. Conflicts with use_root_namespace
         */
        namespace?: string;
        /**
         * The resource group for the machine that generated the MSI token. This information can be obtained through instance metadata.
         */
        resourceGroupName: string;
        /**
         * Name of the login role.
         */
        role: string;
        /**
         * The scopes to include in the token request.
         */
        scope?: string;
        /**
         * The subscription ID for the machine that generated the MSI token. This information can be obtained through instance metadata.
         */
        subscriptionId: string;
        /**
         * Provides the tenant ID to use in a multi-tenant authentication scenario.
         */
        tenantId?: string;
        /**
         * Authenticate to the root Vault namespace. Conflicts with namespace
         */
        useRootNamespace?: boolean;
        /**
         * The virtual machine name for the machine that generated the MSI token. This information can be obtained through instance metadata.
         */
        vmName?: string;
        /**
         * The virtual machine scale set name for the machine that generated the MSI token. This information can be obtained through instance metadata.
         */
        vmssName?: string;
    }

    export interface AuthLoginCert {
        /**
         * Path to a file containing the client certificate.
         */
        certFile: string;
        /**
         * Path to a file containing the private key that the certificate was issued for.
         */
        keyFile: string;
        /**
         * The path where the authentication engine is mounted.
         */
        mount?: string;
        /**
         * Name of the certificate's role
         */
        name?: string;
        /**
         * The authentication engine's namespace. Conflicts with use_root_namespace
         */
        namespace?: string;
        /**
         * Authenticate to the root Vault namespace. Conflicts with namespace
         */
        useRootNamespace?: boolean;
    }

    export interface AuthLoginGcp {
        /**
         * Path to the Google Cloud credentials file.
         */
        credentials?: string;
        /**
         * A signed JSON Web Token.
         */
        jwt?: string;
        /**
         * The path where the authentication engine is mounted.
         */
        mount?: string;
        /**
         * The authentication engine's namespace. Conflicts with use_root_namespace
         */
        namespace?: string;
        /**
         * Name of the login role.
         */
        role: string;
        /**
         * IAM service account.
         */
        serviceAccount?: string;
        /**
         * Authenticate to the root Vault namespace. Conflicts with namespace
         */
        useRootNamespace?: boolean;
    }

    export interface AuthLoginJwt {
        /**
         * A signed JSON Web Token.
         */
        jwt: string;
        /**
         * The path where the authentication engine is mounted.
         */
        mount?: string;
        /**
         * The authentication engine's namespace. Conflicts with use_root_namespace
         */
        namespace?: string;
        /**
         * Name of the login role.
         */
        role: string;
        /**
         * Authenticate to the root Vault namespace. Conflicts with namespace
         */
        useRootNamespace?: boolean;
    }

    export interface AuthLoginKerberos {
        /**
         * Disable the Kerberos FAST negotiation.
         */
        disableFastNegotiation?: boolean;
        /**
         * The Kerberos keytab file containing the entry of the login entity.
         */
        keytabPath?: string;
        /**
         * A valid Kerberos configuration file e.g. /etc/krb5.conf.
         */
        krb5confPath?: string;
        /**
         * The path where the authentication engine is mounted.
         */
        mount?: string;
        /**
         * The authentication engine's namespace. Conflicts with use_root_namespace
         */
        namespace?: string;
        /**
         * The Kerberos server's authoritative authentication domain
         */
        realm?: string;
        /**
         * Strip the host from the username found in the keytab.
         */
        removeInstanceName?: boolean;
        /**
         * The service principle name.
         */
        service?: string;
        /**
         * Simple and Protected GSSAPI Negotiation Mechanism (SPNEGO) token
         */
        token?: string;
        /**
         * Authenticate to the root Vault namespace. Conflicts with namespace
         */
        useRootNamespace?: boolean;
        /**
         * The username to login into Kerberos with.
         */
        username?: string;
    }

    export interface AuthLoginOci {
        /**
         * Authentication type to use when getting OCI credentials.
         */
        authType: string;
        /**
         * The path where the authentication engine is mounted.
         */
        mount?: string;
        /**
         * The authentication engine's namespace. Conflicts with use_root_namespace
         */
        namespace?: string;
        /**
         * Name of the login role.
         */
        role: string;
        /**
         * Authenticate to the root Vault namespace. Conflicts with namespace
         */
        useRootNamespace?: boolean;
    }

    export interface AuthLoginOidc {
        /**
         * The callback address. Must be a valid URI without the path.
         */
        callbackAddress?: string;
        /**
         * The callback listener's address. Must be a valid URI without the path.
         */
        callbackListenerAddress?: string;
        /**
         * The path where the authentication engine is mounted.
         */
        mount?: string;
        /**
         * The authentication engine's namespace. Conflicts with use_root_namespace
         */
        namespace?: string;
        /**
         * Name of the login role.
         */
        role: string;
        /**
         * Authenticate to the root Vault namespace. Conflicts with namespace
         */
        useRootNamespace?: boolean;
    }

    export interface AuthLoginRadius {
        /**
         * The path where the authentication engine is mounted.
         */
        mount?: string;
        /**
         * The authentication engine's namespace. Conflicts with use_root_namespace
         */
        namespace?: string;
        /**
         * The Radius password for username.
         */
        password: string;
        /**
         * Authenticate to the root Vault namespace. Conflicts with namespace
         */
        useRootNamespace?: boolean;
        /**
         * The Radius username.
         */
        username: string;
    }

    export interface AuthLoginTokenFile {
        /**
         * The name of a file containing a single line that is a valid Vault token
         */
        filename: string;
        /**
         * The authentication engine's namespace. Conflicts with use_root_namespace
         */
        namespace?: string;
        /**
         * Authenticate to the root Vault namespace. Conflicts with namespace
         */
        useRootNamespace?: boolean;
    }

    export interface AuthLoginUserpass {
        /**
         * The path where the authentication engine is mounted.
         */
        mount?: string;
        /**
         * The authentication engine's namespace. Conflicts with use_root_namespace
         */
        namespace?: string;
        /**
         * Login with password
         */
        password?: string;
        /**
         * Login with password from a file
         */
        passwordFile?: string;
        /**
         * Authenticate to the root Vault namespace. Conflicts with namespace
         */
        useRootNamespace?: boolean;
        /**
         * Login with username
         */
        username: string;
    }

    export interface ClientAuth {
        /**
         * Path to a file containing the client certificate.
         */
        certFile: string;
        /**
         * Path to a file containing the private key that the certificate was issued for.
         */
        keyFile: string;
    }

    export interface Headers {
        /**
         * The header name
         */
        name: string;
        /**
         * The header value
         */
        value: string;
    }

    export interface UiCustomMessageLink {
        /**
         * The URL of the hyperlink
         */
        href: string;
        /**
         * The title of the hyperlink
         */
        title: string;
    }

}

export namespace database {
    export interface SecretBackendConnectionCassandra {
        /**
         * The number of seconds to use as a connection timeout.
         */
        connectTimeout?: number;
        /**
         * Cassandra hosts to connect to.
         */
        hosts?: string[];
        /**
         * Whether to skip verification of the server certificate when using TLS.
         */
        insecureTls?: boolean;
        /**
         * The password to use when authenticating with Cassandra.
         */
        password?: string;
        /**
         * Concatenated PEM blocks containing a certificate and private key; a certificate, private key, and issuing CA certificate; or just a CA certificate.
         */
        pemBundle?: string;
        /**
         * Specifies JSON containing a certificate and private key; a certificate, private key, and issuing CA certificate; or just a CA certificate.
         */
        pemJson?: string;
        /**
         * The transport port to use to connect to Cassandra.
         */
        port?: number;
        /**
         * The CQL protocol version to use.
         */
        protocolVersion?: number;
        /**
         * Whether to use TLS when connecting to Cassandra.
         */
        tls?: boolean;
        /**
         * The username to use when authenticating with Cassandra.
         */
        username?: string;
    }

    export interface SecretBackendConnectionCouchbase {
        /**
         * Required if `tls` is `true`. Specifies the certificate authority of the Couchbase server, as a PEM certificate that has been base64 encoded.
         */
        base64Pem?: string;
        /**
         * Required for Couchbase versions prior to 6.5.0. This is only used to verify vault's connection to the server.
         */
        bucketName?: string;
        /**
         * A set of Couchbase URIs to connect to. Must use `couchbases://` scheme if `tls` is `true`.
         */
        hosts: string[];
        /**
         * Specifies whether to skip verification of the server certificate when using TLS.
         */
        insecureTls?: boolean;
        /**
         * Specifies the password corresponding to the given username.
         */
        password: string;
        /**
         * Specifies whether to use TLS when connecting to Couchbase.
         */
        tls?: boolean;
        /**
         * Specifies the username for Vault to use.
         */
        username: string;
        /**
         * Template describing how dynamic usernames are generated.
         */
        usernameTemplate?: string;
    }

    export interface SecretBackendConnectionElasticsearch {
        /**
         * The path to a PEM-encoded CA cert file to use to verify the Elasticsearch server's identity
         */
        caCert?: string;
        /**
         * The path to a directory of PEM-encoded CA cert files to use to verify the Elasticsearch server's identity
         */
        caPath?: string;
        /**
         * The path to the certificate for the Elasticsearch client to present for communication
         */
        clientCert?: string;
        /**
         * The path to the key for the Elasticsearch client to use for communication
         */
        clientKey?: string;
        /**
         * Whether to disable certificate verification
         */
        insecure?: boolean;
        /**
         * The password to be used in the connection URL
         */
        password: string;
        /**
         * This, if set, is used to set the SNI host when connecting via TLS
         */
        tlsServerName?: string;
        /**
         * The URL for Elasticsearch's API
         */
        url: string;
        /**
         * The username to be used in the connection URL
         */
        username: string;
        /**
         * Template describing how dynamic usernames are generated.
         */
        usernameTemplate?: string;
    }

    export interface SecretBackendConnectionHana {
        /**
         * Connection string to use to connect to the database.
         */
        connectionUrl?: string;
        /**
         * Disable special character escaping in username and password
         */
        disableEscaping?: boolean;
        /**
         * Maximum number of seconds a connection may be reused.
         */
        maxConnectionLifetime?: number;
        /**
         * Maximum number of idle connections to the database.
         */
        maxIdleConnections?: number;
        /**
         * Maximum number of open connections to the database.
         */
        maxOpenConnections?: number;
        /**
         * The root credential password used in the connection URL
         */
        password?: string;
        /**
         * The root credential username used in the connection URL
         */
        username?: string;
    }

    export interface SecretBackendConnectionInfluxdb {
        /**
         * The number of seconds to use as a connection timeout.
         */
        connectTimeout?: number;
        /**
         * Influxdb host to connect to.
         */
        host: string;
        /**
         * Whether to skip verification of the server certificate when using TLS.
         */
        insecureTls?: boolean;
        /**
         * Specifies the password corresponding to the given username.
         */
        password: string;
        /**
         * Concatenated PEM blocks containing a certificate and private key; a certificate, private key, and issuing CA certificate; or just a CA certificate.
         */
        pemBundle?: string;
        /**
         * Specifies JSON containing a certificate and private key; a certificate, private key, and issuing CA certificate; or just a CA certificate.
         */
        pemJson?: string;
        /**
         * The transport port to use to connect to Influxdb.
         */
        port?: number;
        /**
         * Whether to use TLS when connecting to Influxdb.
         */
        tls?: boolean;
        /**
         * Specifies the username to use for superuser access.
         */
        username: string;
        /**
         * Template describing how dynamic usernames are generated.
         */
        usernameTemplate?: string;
    }

    export interface SecretBackendConnectionMongodb {
        /**
         * Connection string to use to connect to the database.
         */
        connectionUrl?: string;
        /**
         * Maximum number of seconds a connection may be reused.
         */
        maxConnectionLifetime?: number;
        /**
         * Maximum number of idle connections to the database.
         */
        maxIdleConnections?: number;
        /**
         * Maximum number of open connections to the database.
         */
        maxOpenConnections?: number;
        /**
         * The root credential password used in the connection URL
         */
        password?: string;
        /**
         * The root credential username used in the connection URL
         */
        username?: string;
        /**
         * Username generation template.
         */
        usernameTemplate?: string;
    }

    export interface SecretBackendConnectionMongodbatlas {
        /**
         * The Private Programmatic API Key used to connect with MongoDB Atlas API.
         */
        privateKey: string;
        /**
         * The Project ID the Database User should be created within.
         */
        projectId: string;
        /**
         * The Public Programmatic API Key used to authenticate with the MongoDB Atlas API.
         */
        publicKey: string;
    }

    export interface SecretBackendConnectionMssql {
        /**
         * Connection string to use to connect to the database.
         */
        connectionUrl?: string;
        /**
         * Set to true when the target is a Contained Database, e.g. AzureSQL.
         */
        containedDb?: boolean;
        /**
         * Disable special character escaping in username and password
         */
        disableEscaping?: boolean;
        /**
         * Maximum number of seconds a connection may be reused.
         */
        maxConnectionLifetime?: number;
        /**
         * Maximum number of idle connections to the database.
         */
        maxIdleConnections?: number;
        /**
         * Maximum number of open connections to the database.
         */
        maxOpenConnections?: number;
        /**
         * The root credential password used in the connection URL
         */
        password?: string;
        /**
         * The root credential username used in the connection URL
         */
        username?: string;
        /**
         * Username generation template.
         */
        usernameTemplate?: string;
    }

    export interface SecretBackendConnectionMysql {
        /**
         * Specify alternative authorization type. (Only 'gcp_iam' is valid currently)
         */
        authType?: string;
        /**
         * Connection string to use to connect to the database.
         */
        connectionUrl?: string;
        /**
         * Maximum number of seconds a connection may be reused.
         */
        maxConnectionLifetime?: number;
        /**
         * Maximum number of idle connections to the database.
         */
        maxIdleConnections?: number;
        /**
         * Maximum number of open connections to the database.
         */
        maxOpenConnections?: number;
        /**
         * The root credential password used in the connection URL
         */
        password?: string;
        /**
         * A JSON encoded credential for use with IAM authorization
         */
        serviceAccountJson?: string;
        /**
         * x509 CA file for validating the certificate presented by the MySQL server. Must be PEM encoded.
         */
        tlsCa?: string;
        /**
         * x509 certificate for connecting to the database. This must be a PEM encoded version of the private key and the certificate combined.
         */
        tlsCertificateKey?: string;
        /**
         * The root credential username used in the connection URL
         */
        username?: string;
        /**
         * Username generation template.
         */
        usernameTemplate?: string;
    }

    export interface SecretBackendConnectionMysqlAurora {
        /**
         * Specify alternative authorization type. (Only 'gcp_iam' is valid currently)
         */
        authType?: string;
        /**
         * Connection string to use to connect to the database.
         */
        connectionUrl?: string;
        /**
         * Maximum number of seconds a connection may be reused.
         */
        maxConnectionLifetime?: number;
        /**
         * Maximum number of idle connections to the database.
         */
        maxIdleConnections?: number;
        /**
         * Maximum number of open connections to the database.
         */
        maxOpenConnections?: number;
        /**
         * The root credential password used in the connection URL
         */
        password?: string;
        /**
         * A JSON encoded credential for use with IAM authorization
         */
        serviceAccountJson?: string;
        /**
         * x509 CA file for validating the certificate presented by the MySQL server. Must be PEM encoded.
         */
        tlsCa?: string;
        /**
         * x509 certificate for connecting to the database. This must be a PEM encoded version of the private key and the certificate combined.
         */
        tlsCertificateKey?: string;
        /**
         * The root credential username used in the connection URL
         */
        username?: string;
        /**
         * Username generation template.
         */
        usernameTemplate?: string;
    }

    export interface SecretBackendConnectionMysqlLegacy {
        /**
         * Specify alternative authorization type. (Only 'gcp_iam' is valid currently)
         */
        authType?: string;
        /**
         * Connection string to use to connect to the database.
         */
        connectionUrl?: string;
        /**
         * Maximum number of seconds a connection may be reused.
         */
        maxConnectionLifetime?: number;
        /**
         * Maximum number of idle connections to the database.
         */
        maxIdleConnections?: number;
        /**
         * Maximum number of open connections to the database.
         */
        maxOpenConnections?: number;
        /**
         * The root credential password used in the connection URL
         */
        password?: string;
        /**
         * A JSON encoded credential for use with IAM authorization
         */
        serviceAccountJson?: string;
        /**
         * x509 CA file for validating the certificate presented by the MySQL server. Must be PEM encoded.
         */
        tlsCa?: string;
        /**
         * x509 certificate for connecting to the database. This must be a PEM encoded version of the private key and the certificate combined.
         */
        tlsCertificateKey?: string;
        /**
         * The root credential username used in the connection URL
         */
        username?: string;
        /**
         * Username generation template.
         */
        usernameTemplate?: string;
    }

    export interface SecretBackendConnectionMysqlRds {
        /**
         * Specify alternative authorization type. (Only 'gcp_iam' is valid currently)
         */
        authType?: string;
        /**
         * Connection string to use to connect to the database.
         */
        connectionUrl?: string;
        /**
         * Maximum number of seconds a connection may be reused.
         */
        maxConnectionLifetime?: number;
        /**
         * Maximum number of idle connections to the database.
         */
        maxIdleConnections?: number;
        /**
         * Maximum number of open connections to the database.
         */
        maxOpenConnections?: number;
        /**
         * The root credential password used in the connection URL
         */
        password?: string;
        /**
         * A JSON encoded credential for use with IAM authorization
         */
        serviceAccountJson?: string;
        /**
         * x509 CA file for validating the certificate presented by the MySQL server. Must be PEM encoded.
         */
        tlsCa?: string;
        /**
         * x509 certificate for connecting to the database. This must be a PEM encoded version of the private key and the certificate combined.
         */
        tlsCertificateKey?: string;
        /**
         * The root credential username used in the connection URL
         */
        username?: string;
        /**
         * Username generation template.
         */
        usernameTemplate?: string;
    }

    export interface SecretBackendConnectionOracle {
        /**
         * Connection string to use to connect to the database.
         */
        connectionUrl?: string;
        /**
         * Set to true to disconnect any open sessions prior to running the revocation statements.
         */
        disconnectSessions?: boolean;
        /**
         * Maximum number of seconds a connection may be reused.
         */
        maxConnectionLifetime?: number;
        /**
         * Maximum number of idle connections to the database.
         */
        maxIdleConnections?: number;
        /**
         * Maximum number of open connections to the database.
         */
        maxOpenConnections?: number;
        /**
         * The root credential password used in the connection URL
         */
        password?: string;
        /**
         * Set to true in order to split statements after semi-colons.
         */
        splitStatements?: boolean;
        /**
         * The root credential username used in the connection URL
         */
        username?: string;
        /**
         * Username generation template.
         */
        usernameTemplate?: string;
    }

    export interface SecretBackendConnectionPostgresql {
        /**
         * Specify alternative authorization type. (Only 'gcp_iam' is valid currently)
         */
        authType?: string;
        /**
         * Connection string to use to connect to the database.
         */
        connectionUrl?: string;
        /**
         * Disable special character escaping in username and password
         */
        disableEscaping?: boolean;
        /**
         * Maximum number of seconds a connection may be reused.
         */
        maxConnectionLifetime?: number;
        /**
         * Maximum number of idle connections to the database.
         */
        maxIdleConnections?: number;
        /**
         * Maximum number of open connections to the database.
         */
        maxOpenConnections?: number;
        /**
         * The root credential password used in the connection URL
         */
        password?: string;
        /**
         * A JSON encoded credential for use with IAM authorization
         */
        serviceAccountJson?: string;
        /**
         * The root credential username used in the connection URL
         */
        username?: string;
        /**
         * Username generation template.
         */
        usernameTemplate?: string;
    }

    export interface SecretBackendConnectionRedis {
        /**
         * The contents of a PEM-encoded CA cert file to use to verify the Redis server's identity.
         */
        caCert?: string;
        /**
         * Specifies the host to connect to
         */
        host: string;
        /**
         * Specifies whether to skip verification of the server certificate when using TLS.
         */
        insecureTls?: boolean;
        /**
         * Specifies the password corresponding to the given username.
         */
        password: string;
        /**
         * The transport port to use to connect to Redis.
         */
        port?: number;
        /**
         * Specifies whether to use TLS when connecting to Redis.
         */
        tls?: boolean;
        /**
         * Specifies the username for Vault to use.
         */
        username: string;
    }

    export interface SecretBackendConnectionRedisElasticache {
        /**
         * The AWS secret key id to use to talk to ElastiCache. If omitted the credentials chain provider is used instead.
         */
        password?: string;
        /**
         * The AWS region where the ElastiCache cluster is hosted. If omitted the plugin tries to infer the region from the environment.
         */
        region?: string;
        /**
         * The configuration endpoint for the ElastiCache cluster to connect to.
         */
        url: string;
        /**
         * The AWS access key id to use to talk to ElastiCache. If omitted the credentials chain provider is used instead.
         */
        username?: string;
    }

    export interface SecretBackendConnectionRedshift {
        /**
         * Connection string to use to connect to the database.
         */
        connectionUrl?: string;
        /**
         * Disable special character escaping in username and password
         */
        disableEscaping?: boolean;
        /**
         * Maximum number of seconds a connection may be reused.
         */
        maxConnectionLifetime?: number;
        /**
         * Maximum number of idle connections to the database.
         */
        maxIdleConnections?: number;
        /**
         * Maximum number of open connections to the database.
         */
        maxOpenConnections?: number;
        /**
         * The root credential password used in the connection URL
         */
        password?: string;
        /**
         * The root credential username used in the connection URL
         */
        username?: string;
        /**
         * Username generation template.
         */
        usernameTemplate?: string;
    }

    export interface SecretBackendConnectionSnowflake {
        /**
         * Connection string to use to connect to the database.
         */
        connectionUrl?: string;
        /**
         * Maximum number of seconds a connection may be reused.
         */
        maxConnectionLifetime?: number;
        /**
         * Maximum number of idle connections to the database.
         */
        maxIdleConnections?: number;
        /**
         * Maximum number of open connections to the database.
         */
        maxOpenConnections?: number;
        /**
         * The root credential password used in the connection URL
         */
        password?: string;
        /**
         * The root credential username used in the connection URL
         */
        username?: string;
        /**
         * Username generation template.
         */
        usernameTemplate?: string;
    }

    export interface SecretsMountCassandra {
        /**
         * A list of roles that are allowed to use this
         * connection.
         */
        allowedRoles?: string[];
        /**
         * The number of seconds to use as a connection timeout.
         */
        connectTimeout?: number;
        /**
         * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
         *
         * Supported list of database secrets engines that can be configured:
         */
        data?: {[key: string]: string};
        /**
         * Cassandra hosts to connect to.
         */
        hosts?: string[];
        /**
         * Whether to skip verification of the server certificate when using TLS.
         */
        insecureTls?: boolean;
        /**
         * Name of the database connection.
         */
        name: string;
        /**
         * The password to use when authenticating with Cassandra.
         */
        password?: string;
        /**
         * Concatenated PEM blocks containing a certificate and private key; a certificate, private key, and issuing CA certificate; or just a CA certificate.
         */
        pemBundle?: string;
        /**
         * Specifies JSON containing a certificate and private key; a certificate, private key, and issuing CA certificate; or just a CA certificate.
         */
        pemJson?: string;
        /**
         * Specifies the name of the plugin to use.
         */
        pluginName: string;
        /**
         * The transport port to use to connect to Cassandra.
         */
        port?: number;
        /**
         * The CQL protocol version to use.
         */
        protocolVersion?: number;
        /**
         * A list of database statements to be executed to rotate the root user's credentials.
         */
        rootRotationStatements?: string[];
        /**
         * Whether to use TLS when connecting to Cassandra.
         */
        tls?: boolean;
        /**
         * The username to use when authenticating with Cassandra.
         */
        username?: string;
        /**
         * Whether the connection should be verified on
         * initial configuration or not.
         */
        verifyConnection?: boolean;
    }

    export interface SecretsMountCouchbase {
        /**
         * A list of roles that are allowed to use this
         * connection.
         */
        allowedRoles?: string[];
        /**
         * Required if `tls` is `true`. Specifies the certificate authority of the Couchbase server, as a PEM certificate that has been base64 encoded.
         */
        base64Pem?: string;
        /**
         * Required for Couchbase versions prior to 6.5.0. This is only used to verify vault's connection to the server.
         */
        bucketName?: string;
        /**
         * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
         *
         * Supported list of database secrets engines that can be configured:
         */
        data?: {[key: string]: string};
        /**
         * A set of Couchbase URIs to connect to. Must use `couchbases://` scheme if `tls` is `true`.
         */
        hosts: string[];
        /**
         * Specifies whether to skip verification of the server certificate when using TLS.
         */
        insecureTls?: boolean;
        /**
         * Name of the database connection.
         */
        name: string;
        /**
         * Specifies the password corresponding to the given username.
         */
        password: string;
        /**
         * Specifies the name of the plugin to use.
         */
        pluginName: string;
        /**
         * A list of database statements to be executed to rotate the root user's credentials.
         */
        rootRotationStatements?: string[];
        /**
         * Specifies whether to use TLS when connecting to Couchbase.
         */
        tls?: boolean;
        /**
         * Specifies the username for Vault to use.
         */
        username: string;
        /**
         * Template describing how dynamic usernames are generated.
         */
        usernameTemplate?: string;
        /**
         * Whether the connection should be verified on
         * initial configuration or not.
         */
        verifyConnection?: boolean;
    }

    export interface SecretsMountElasticsearch {
        /**
         * A list of roles that are allowed to use this
         * connection.
         */
        allowedRoles?: string[];
        /**
         * The path to a PEM-encoded CA cert file to use to verify the Elasticsearch server's identity
         */
        caCert?: string;
        /**
         * The path to a directory of PEM-encoded CA cert files to use to verify the Elasticsearch server's identity
         */
        caPath?: string;
        /**
         * The path to the certificate for the Elasticsearch client to present for communication
         */
        clientCert?: string;
        /**
         * The path to the key for the Elasticsearch client to use for communication
         */
        clientKey?: string;
        /**
         * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
         *
         * Supported list of database secrets engines that can be configured:
         */
        data?: {[key: string]: string};
        /**
         * Whether to disable certificate verification
         */
        insecure?: boolean;
        /**
         * Name of the database connection.
         */
        name: string;
        /**
         * The password to be used in the connection URL
         */
        password: string;
        /**
         * Specifies the name of the plugin to use.
         */
        pluginName: string;
        /**
         * A list of database statements to be executed to rotate the root user's credentials.
         */
        rootRotationStatements?: string[];
        /**
         * This, if set, is used to set the SNI host when connecting via TLS
         */
        tlsServerName?: string;
        /**
         * The URL for Elasticsearch's API
         */
        url: string;
        /**
         * The username to be used in the connection URL
         */
        username: string;
        /**
         * Template describing how dynamic usernames are generated.
         */
        usernameTemplate?: string;
        /**
         * Whether the connection should be verified on
         * initial configuration or not.
         */
        verifyConnection?: boolean;
    }

    export interface SecretsMountHana {
        /**
         * A list of roles that are allowed to use this
         * connection.
         */
        allowedRoles?: string[];
        /**
         * Connection string to use to connect to the database.
         */
        connectionUrl?: string;
        /**
         * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
         *
         * Supported list of database secrets engines that can be configured:
         */
        data?: {[key: string]: string};
        /**
         * Disable special character escaping in username and password
         */
        disableEscaping?: boolean;
        /**
         * Maximum number of seconds a connection may be reused.
         */
        maxConnectionLifetime?: number;
        /**
         * Maximum number of idle connections to the database.
         */
        maxIdleConnections?: number;
        /**
         * Maximum number of open connections to the database.
         */
        maxOpenConnections?: number;
        /**
         * Name of the database connection.
         */
        name: string;
        /**
         * The root credential password used in the connection URL
         */
        password?: string;
        /**
         * Specifies the name of the plugin to use.
         */
        pluginName: string;
        /**
         * A list of database statements to be executed to rotate the root user's credentials.
         */
        rootRotationStatements?: string[];
        /**
         * The root credential username used in the connection URL
         */
        username?: string;
        /**
         * Whether the connection should be verified on
         * initial configuration or not.
         */
        verifyConnection?: boolean;
    }

    export interface SecretsMountInfluxdb {
        /**
         * A list of roles that are allowed to use this
         * connection.
         */
        allowedRoles?: string[];
        /**
         * The number of seconds to use as a connection timeout.
         */
        connectTimeout?: number;
        /**
         * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
         *
         * Supported list of database secrets engines that can be configured:
         */
        data?: {[key: string]: string};
        /**
         * Influxdb host to connect to.
         */
        host: string;
        /**
         * Whether to skip verification of the server certificate when using TLS.
         */
        insecureTls?: boolean;
        /**
         * Name of the database connection.
         */
        name: string;
        /**
         * Specifies the password corresponding to the given username.
         */
        password: string;
        /**
         * Concatenated PEM blocks containing a certificate and private key; a certificate, private key, and issuing CA certificate; or just a CA certificate.
         */
        pemBundle?: string;
        /**
         * Specifies JSON containing a certificate and private key; a certificate, private key, and issuing CA certificate; or just a CA certificate.
         */
        pemJson?: string;
        /**
         * Specifies the name of the plugin to use.
         */
        pluginName: string;
        /**
         * The transport port to use to connect to Influxdb.
         */
        port?: number;
        /**
         * A list of database statements to be executed to rotate the root user's credentials.
         */
        rootRotationStatements?: string[];
        /**
         * Whether to use TLS when connecting to Influxdb.
         */
        tls?: boolean;
        /**
         * Specifies the username to use for superuser access.
         */
        username: string;
        /**
         * Template describing how dynamic usernames are generated.
         */
        usernameTemplate?: string;
        /**
         * Whether the connection should be verified on
         * initial configuration or not.
         */
        verifyConnection?: boolean;
    }

    export interface SecretsMountMongodb {
        /**
         * A list of roles that are allowed to use this
         * connection.
         */
        allowedRoles?: string[];
        /**
         * Connection string to use to connect to the database.
         */
        connectionUrl?: string;
        /**
         * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
         *
         * Supported list of database secrets engines that can be configured:
         */
        data?: {[key: string]: string};
        /**
         * Maximum number of seconds a connection may be reused.
         */
        maxConnectionLifetime?: number;
        /**
         * Maximum number of idle connections to the database.
         */
        maxIdleConnections?: number;
        /**
         * Maximum number of open connections to the database.
         */
        maxOpenConnections?: number;
        /**
         * Name of the database connection.
         */
        name: string;
        /**
         * The root credential password used in the connection URL
         */
        password?: string;
        /**
         * Specifies the name of the plugin to use.
         */
        pluginName: string;
        /**
         * A list of database statements to be executed to rotate the root user's credentials.
         */
        rootRotationStatements?: string[];
        /**
         * The root credential username used in the connection URL
         */
        username?: string;
        /**
         * Username generation template.
         */
        usernameTemplate?: string;
        /**
         * Whether the connection should be verified on
         * initial configuration or not.
         */
        verifyConnection?: boolean;
    }

    export interface SecretsMountMongodbatla {
        /**
         * A list of roles that are allowed to use this
         * connection.
         */
        allowedRoles?: string[];
        /**
         * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
         *
         * Supported list of database secrets engines that can be configured:
         */
        data?: {[key: string]: string};
        /**
         * Name of the database connection.
         */
        name: string;
        /**
         * Specifies the name of the plugin to use.
         */
        pluginName: string;
        /**
         * The Private Programmatic API Key used to connect with MongoDB Atlas API.
         */
        privateKey: string;
        /**
         * The Project ID the Database User should be created within.
         */
        projectId: string;
        /**
         * The Public Programmatic API Key used to authenticate with the MongoDB Atlas API.
         */
        publicKey: string;
        /**
         * A list of database statements to be executed to rotate the root user's credentials.
         */
        rootRotationStatements?: string[];
        /**
         * Whether the connection should be verified on
         * initial configuration or not.
         */
        verifyConnection?: boolean;
    }

    export interface SecretsMountMssql {
        /**
         * A list of roles that are allowed to use this
         * connection.
         */
        allowedRoles?: string[];
        /**
         * Connection string to use to connect to the database.
         */
        connectionUrl?: string;
        /**
         * Set to true when the target is a Contained Database, e.g. AzureSQL.
         */
        containedDb?: boolean;
        /**
         * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
         *
         * Supported list of database secrets engines that can be configured:
         */
        data?: {[key: string]: string};
        /**
         * Disable special character escaping in username and password
         */
        disableEscaping?: boolean;
        /**
         * Maximum number of seconds a connection may be reused.
         */
        maxConnectionLifetime?: number;
        /**
         * Maximum number of idle connections to the database.
         */
        maxIdleConnections?: number;
        /**
         * Maximum number of open connections to the database.
         */
        maxOpenConnections?: number;
        /**
         * Name of the database connection.
         */
        name: string;
        /**
         * The root credential password used in the connection URL
         */
        password?: string;
        /**
         * Specifies the name of the plugin to use.
         */
        pluginName: string;
        /**
         * A list of database statements to be executed to rotate the root user's credentials.
         */
        rootRotationStatements?: string[];
        /**
         * The root credential username used in the connection URL
         */
        username?: string;
        /**
         * Username generation template.
         */
        usernameTemplate?: string;
        /**
         * Whether the connection should be verified on
         * initial configuration or not.
         */
        verifyConnection?: boolean;
    }

    export interface SecretsMountMysql {
        /**
         * A list of roles that are allowed to use this
         * connection.
         */
        allowedRoles?: string[];
        /**
         * Specify alternative authorization type. (Only 'gcp_iam' is valid currently)
         */
        authType?: string;
        /**
         * Connection string to use to connect to the database.
         */
        connectionUrl?: string;
        /**
         * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
         *
         * Supported list of database secrets engines that can be configured:
         */
        data?: {[key: string]: string};
        /**
         * Maximum number of seconds a connection may be reused.
         */
        maxConnectionLifetime?: number;
        /**
         * Maximum number of idle connections to the database.
         */
        maxIdleConnections?: number;
        /**
         * Maximum number of open connections to the database.
         */
        maxOpenConnections?: number;
        /**
         * Name of the database connection.
         */
        name: string;
        /**
         * The root credential password used in the connection URL
         */
        password?: string;
        /**
         * Specifies the name of the plugin to use.
         */
        pluginName: string;
        /**
         * A list of database statements to be executed to rotate the root user's credentials.
         */
        rootRotationStatements?: string[];
        /**
         * A JSON encoded credential for use with IAM authorization
         */
        serviceAccountJson?: string;
        /**
         * x509 CA file for validating the certificate presented by the MySQL server. Must be PEM encoded.
         */
        tlsCa?: string;
        /**
         * x509 certificate for connecting to the database. This must be a PEM encoded version of the private key and the certificate combined.
         */
        tlsCertificateKey?: string;
        /**
         * The root credential username used in the connection URL
         */
        username?: string;
        /**
         * Username generation template.
         */
        usernameTemplate?: string;
        /**
         * Whether the connection should be verified on
         * initial configuration or not.
         */
        verifyConnection?: boolean;
    }

    export interface SecretsMountMysqlAurora {
        /**
         * A list of roles that are allowed to use this
         * connection.
         */
        allowedRoles?: string[];
        /**
         * Specify alternative authorization type. (Only 'gcp_iam' is valid currently)
         */
        authType?: string;
        /**
         * Connection string to use to connect to the database.
         */
        connectionUrl?: string;
        /**
         * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
         *
         * Supported list of database secrets engines that can be configured:
         */
        data?: {[key: string]: string};
        /**
         * Maximum number of seconds a connection may be reused.
         */
        maxConnectionLifetime?: number;
        /**
         * Maximum number of idle connections to the database.
         */
        maxIdleConnections?: number;
        /**
         * Maximum number of open connections to the database.
         */
        maxOpenConnections?: number;
        /**
         * Name of the database connection.
         */
        name: string;
        /**
         * The root credential password used in the connection URL
         */
        password?: string;
        /**
         * Specifies the name of the plugin to use.
         */
        pluginName: string;
        /**
         * A list of database statements to be executed to rotate the root user's credentials.
         */
        rootRotationStatements?: string[];
        /**
         * A JSON encoded credential for use with IAM authorization
         */
        serviceAccountJson?: string;
        /**
         * x509 CA file for validating the certificate presented by the MySQL server. Must be PEM encoded.
         */
        tlsCa?: string;
        /**
         * x509 certificate for connecting to the database. This must be a PEM encoded version of the private key and the certificate combined.
         */
        tlsCertificateKey?: string;
        /**
         * The root credential username used in the connection URL
         */
        username?: string;
        /**
         * Username generation template.
         */
        usernameTemplate?: string;
        /**
         * Whether the connection should be verified on
         * initial configuration or not.
         */
        verifyConnection?: boolean;
    }

    export interface SecretsMountMysqlLegacy {
        /**
         * A list of roles that are allowed to use this
         * connection.
         */
        allowedRoles?: string[];
        /**
         * Specify alternative authorization type. (Only 'gcp_iam' is valid currently)
         */
        authType?: string;
        /**
         * Connection string to use to connect to the database.
         */
        connectionUrl?: string;
        /**
         * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
         *
         * Supported list of database secrets engines that can be configured:
         */
        data?: {[key: string]: string};
        /**
         * Maximum number of seconds a connection may be reused.
         */
        maxConnectionLifetime?: number;
        /**
         * Maximum number of idle connections to the database.
         */
        maxIdleConnections?: number;
        /**
         * Maximum number of open connections to the database.
         */
        maxOpenConnections?: number;
        /**
         * Name of the database connection.
         */
        name: string;
        /**
         * The root credential password used in the connection URL
         */
        password?: string;
        /**
         * Specifies the name of the plugin to use.
         */
        pluginName: string;
        /**
         * A list of database statements to be executed to rotate the root user's credentials.
         */
        rootRotationStatements?: string[];
        /**
         * A JSON encoded credential for use with IAM authorization
         */
        serviceAccountJson?: string;
        /**
         * x509 CA file for validating the certificate presented by the MySQL server. Must be PEM encoded.
         */
        tlsCa?: string;
        /**
         * x509 certificate for connecting to the database. This must be a PEM encoded version of the private key and the certificate combined.
         */
        tlsCertificateKey?: string;
        /**
         * The root credential username used in the connection URL
         */
        username?: string;
        /**
         * Username generation template.
         */
        usernameTemplate?: string;
        /**
         * Whether the connection should be verified on
         * initial configuration or not.
         */
        verifyConnection?: boolean;
    }

    export interface SecretsMountMysqlRd {
        /**
         * A list of roles that are allowed to use this
         * connection.
         */
        allowedRoles?: string[];
        /**
         * Specify alternative authorization type. (Only 'gcp_iam' is valid currently)
         */
        authType?: string;
        /**
         * Connection string to use to connect to the database.
         */
        connectionUrl?: string;
        /**
         * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
         *
         * Supported list of database secrets engines that can be configured:
         */
        data?: {[key: string]: string};
        /**
         * Maximum number of seconds a connection may be reused.
         */
        maxConnectionLifetime?: number;
        /**
         * Maximum number of idle connections to the database.
         */
        maxIdleConnections?: number;
        /**
         * Maximum number of open connections to the database.
         */
        maxOpenConnections?: number;
        /**
         * Name of the database connection.
         */
        name: string;
        /**
         * The root credential password used in the connection URL
         */
        password?: string;
        /**
         * Specifies the name of the plugin to use.
         */
        pluginName: string;
        /**
         * A list of database statements to be executed to rotate the root user's credentials.
         */
        rootRotationStatements?: string[];
        /**
         * A JSON encoded credential for use with IAM authorization
         */
        serviceAccountJson?: string;
        /**
         * x509 CA file for validating the certificate presented by the MySQL server. Must be PEM encoded.
         */
        tlsCa?: string;
        /**
         * x509 certificate for connecting to the database. This must be a PEM encoded version of the private key and the certificate combined.
         */
        tlsCertificateKey?: string;
        /**
         * The root credential username used in the connection URL
         */
        username?: string;
        /**
         * Username generation template.
         */
        usernameTemplate?: string;
        /**
         * Whether the connection should be verified on
         * initial configuration or not.
         */
        verifyConnection?: boolean;
    }

    export interface SecretsMountOracle {
        /**
         * A list of roles that are allowed to use this
         * connection.
         */
        allowedRoles?: string[];
        /**
         * Connection string to use to connect to the database.
         */
        connectionUrl?: string;
        /**
         * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
         *
         * Supported list of database secrets engines that can be configured:
         */
        data?: {[key: string]: string};
        /**
         * Set to true to disconnect any open sessions prior to running the revocation statements.
         */
        disconnectSessions?: boolean;
        /**
         * Maximum number of seconds a connection may be reused.
         */
        maxConnectionLifetime?: number;
        /**
         * Maximum number of idle connections to the database.
         */
        maxIdleConnections?: number;
        /**
         * Maximum number of open connections to the database.
         */
        maxOpenConnections?: number;
        /**
         * Name of the database connection.
         */
        name: string;
        /**
         * The root credential password used in the connection URL
         */
        password?: string;
        /**
         * Specifies the name of the plugin to use.
         */
        pluginName: string;
        /**
         * A list of database statements to be executed to rotate the root user's credentials.
         */
        rootRotationStatements?: string[];
        /**
         * Set to true in order to split statements after semi-colons.
         */
        splitStatements?: boolean;
        /**
         * The root credential username used in the connection URL
         */
        username?: string;
        /**
         * Username generation template.
         */
        usernameTemplate?: string;
        /**
         * Whether the connection should be verified on
         * initial configuration or not.
         */
        verifyConnection?: boolean;
    }

    export interface SecretsMountPostgresql {
        /**
         * A list of roles that are allowed to use this
         * connection.
         */
        allowedRoles?: string[];
        /**
         * Specify alternative authorization type. (Only 'gcp_iam' is valid currently)
         */
        authType?: string;
        /**
         * Connection string to use to connect to the database.
         */
        connectionUrl?: string;
        /**
         * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
         *
         * Supported list of database secrets engines that can be configured:
         */
        data?: {[key: string]: string};
        /**
         * Disable special character escaping in username and password
         */
        disableEscaping?: boolean;
        /**
         * Maximum number of seconds a connection may be reused.
         */
        maxConnectionLifetime?: number;
        /**
         * Maximum number of idle connections to the database.
         */
        maxIdleConnections?: number;
        /**
         * Maximum number of open connections to the database.
         */
        maxOpenConnections?: number;
        /**
         * Name of the database connection.
         */
        name: string;
        /**
         * The root credential password used in the connection URL
         */
        password?: string;
        /**
         * Specifies the name of the plugin to use.
         */
        pluginName: string;
        /**
         * A list of database statements to be executed to rotate the root user's credentials.
         */
        rootRotationStatements?: string[];
        /**
         * A JSON encoded credential for use with IAM authorization
         */
        serviceAccountJson?: string;
        /**
         * The root credential username used in the connection URL
         */
        username?: string;
        /**
         * Username generation template.
         */
        usernameTemplate?: string;
        /**
         * Whether the connection should be verified on
         * initial configuration or not.
         */
        verifyConnection?: boolean;
    }

    export interface SecretsMountRedi {
        /**
         * A list of roles that are allowed to use this
         * connection.
         */
        allowedRoles?: string[];
        /**
         * The contents of a PEM-encoded CA cert file to use to verify the Redis server's identity.
         */
        caCert?: string;
        /**
         * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
         *
         * Supported list of database secrets engines that can be configured:
         */
        data?: {[key: string]: string};
        /**
         * Specifies the host to connect to
         */
        host: string;
        /**
         * Specifies whether to skip verification of the server certificate when using TLS.
         */
        insecureTls?: boolean;
        /**
         * Name of the database connection.
         */
        name: string;
        /**
         * Specifies the password corresponding to the given username.
         */
        password: string;
        /**
         * Specifies the name of the plugin to use.
         */
        pluginName: string;
        /**
         * The transport port to use to connect to Redis.
         */
        port?: number;
        /**
         * A list of database statements to be executed to rotate the root user's credentials.
         */
        rootRotationStatements?: string[];
        /**
         * Specifies whether to use TLS when connecting to Redis.
         */
        tls?: boolean;
        /**
         * Specifies the username for Vault to use.
         */
        username: string;
        /**
         * Whether the connection should be verified on
         * initial configuration or not.
         */
        verifyConnection?: boolean;
    }

    export interface SecretsMountRedisElasticach {
        /**
         * A list of roles that are allowed to use this
         * connection.
         */
        allowedRoles?: string[];
        /**
         * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
         *
         * Supported list of database secrets engines that can be configured:
         */
        data?: {[key: string]: string};
        /**
         * Name of the database connection.
         */
        name: string;
        /**
         * The AWS secret key id to use to talk to ElastiCache. If omitted the credentials chain provider is used instead.
         */
        password?: string;
        /**
         * Specifies the name of the plugin to use.
         */
        pluginName: string;
        /**
         * The AWS region where the ElastiCache cluster is hosted. If omitted the plugin tries to infer the region from the environment.
         */
        region?: string;
        /**
         * A list of database statements to be executed to rotate the root user's credentials.
         */
        rootRotationStatements?: string[];
        /**
         * The configuration endpoint for the ElastiCache cluster to connect to.
         */
        url: string;
        /**
         * The AWS access key id to use to talk to ElastiCache. If omitted the credentials chain provider is used instead.
         */
        username?: string;
        /**
         * Whether the connection should be verified on
         * initial configuration or not.
         */
        verifyConnection?: boolean;
    }

    export interface SecretsMountRedshift {
        /**
         * A list of roles that are allowed to use this
         * connection.
         */
        allowedRoles?: string[];
        /**
         * Connection string to use to connect to the database.
         */
        connectionUrl?: string;
        /**
         * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
         *
         * Supported list of database secrets engines that can be configured:
         */
        data?: {[key: string]: string};
        /**
         * Disable special character escaping in username and password
         */
        disableEscaping?: boolean;
        /**
         * Maximum number of seconds a connection may be reused.
         */
        maxConnectionLifetime?: number;
        /**
         * Maximum number of idle connections to the database.
         */
        maxIdleConnections?: number;
        /**
         * Maximum number of open connections to the database.
         */
        maxOpenConnections?: number;
        /**
         * Name of the database connection.
         */
        name: string;
        /**
         * The root credential password used in the connection URL
         */
        password?: string;
        /**
         * Specifies the name of the plugin to use.
         */
        pluginName: string;
        /**
         * A list of database statements to be executed to rotate the root user's credentials.
         */
        rootRotationStatements?: string[];
        /**
         * The root credential username used in the connection URL
         */
        username?: string;
        /**
         * Username generation template.
         */
        usernameTemplate?: string;
        /**
         * Whether the connection should be verified on
         * initial configuration or not.
         */
        verifyConnection?: boolean;
    }

    export interface SecretsMountSnowflake {
        /**
         * A list of roles that are allowed to use this
         * connection.
         */
        allowedRoles?: string[];
        /**
         * Connection string to use to connect to the database.
         */
        connectionUrl?: string;
        /**
         * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
         *
         * Supported list of database secrets engines that can be configured:
         */
        data?: {[key: string]: string};
        /**
         * Maximum number of seconds a connection may be reused.
         */
        maxConnectionLifetime?: number;
        /**
         * Maximum number of idle connections to the database.
         */
        maxIdleConnections?: number;
        /**
         * Maximum number of open connections to the database.
         */
        maxOpenConnections?: number;
        /**
         * Name of the database connection.
         */
        name: string;
        /**
         * The root credential password used in the connection URL
         */
        password?: string;
        /**
         * Specifies the name of the plugin to use.
         */
        pluginName: string;
        /**
         * A list of database statements to be executed to rotate the root user's credentials.
         */
        rootRotationStatements?: string[];
        /**
         * The root credential username used in the connection URL
         */
        username?: string;
        /**
         * Username generation template.
         */
        usernameTemplate?: string;
        /**
         * Whether the connection should be verified on
         * initial configuration or not.
         */
        verifyConnection?: boolean;
    }

}

export namespace gcp {
    export interface AuthBackendCustomEndpoint {
        /**
         * Replaces the service endpoint used in API requests to `https://www.googleapis.com`.
         */
        api?: string;
        /**
         * Replaces the service endpoint used in API requests to `https://compute.googleapis.com`.
         *
         * The endpoint value provided for a given key has the form of `scheme://host:port`.
         * The `scheme://` and `:port` portions of the endpoint value are optional.
         */
        compute?: string;
        /**
         * Replaces the service endpoint used in API requests to `https://cloudresourcemanager.googleapis.com`.
         */
        crm?: string;
        /**
         * Replaces the service endpoint used in API requests to `https://iam.googleapis.com`.
         */
        iam?: string;
    }

    export interface AuthBackendTune {
        /**
         * List of headers to whitelist and allowing
         * a plugin to include them in the response.
         */
        allowedResponseHeaders?: string[];
        /**
         * Specifies the list of keys that will
         * not be HMAC'd by audit devices in the request data object.
         */
        auditNonHmacRequestKeys?: string[];
        /**
         * Specifies the list of keys that will
         * not be HMAC'd by audit devices in the response data object.
         */
        auditNonHmacResponseKeys?: string[];
        /**
         * Specifies the default time-to-live.
         * If set, this overrides the global default.
         * Must be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)
         */
        defaultLeaseTtl?: string;
        /**
         * Specifies whether to show this mount in
         * the UI-specific listing endpoint. Valid values are "unauth" or "hidden".
         */
        listingVisibility?: string;
        /**
         * Specifies the maximum time-to-live.
         * If set, this overrides the global default.
         * Must be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)
         */
        maxLeaseTtl?: string;
        /**
         * List of headers to whitelist and
         * pass from the request to the backend.
         */
        passthroughRequestHeaders?: string[];
        /**
         * Specifies the type of tokens that should be returned by
         * the mount. Valid values are "default-service", "default-batch", "service", "batch".
         *
         *
         * For more details on the usage of each argument consult the [Vault GCP API documentation](https://www.vaultproject.io/api-docs/auth/gcp#configure).
         */
        tokenType?: string;
    }

    export interface SecretRolesetBinding {
        /**
         * Resource or resource path for which IAM policy information will be bound. The resource path may be specified in a few different [formats](https://www.vaultproject.io/docs/secrets/gcp/index.html#roleset-bindings).
         */
        resource: string;
        /**
         * List of [GCP IAM roles](https://cloud.google.com/iam/docs/understanding-roles) for the resource.
         */
        roles: string[];
    }

    export interface SecretStaticAccountBinding {
        /**
         * Resource or resource path for which IAM policy information will be bound. The resource path may be specified in a few different [formats](https://www.vaultproject.io/docs/secrets/gcp/index.html#bindings).
         */
        resource: string;
        /**
         * List of [GCP IAM roles](https://cloud.google.com/iam/docs/understanding-roles) for the resource.
         */
        roles: string[];
    }

}

export namespace github {
    export interface AuthBackendTune {
        /**
         * List of headers to whitelist and allowing
         * a plugin to include them in the response.
         */
        allowedResponseHeaders?: string[];
        /**
         * Specifies the list of keys that will
         * not be HMAC'd by audit devices in the request data object.
         */
        auditNonHmacRequestKeys?: string[];
        /**
         * Specifies the list of keys that will
         * not be HMAC'd by audit devices in the response data object.
         */
        auditNonHmacResponseKeys?: string[];
        /**
         * Specifies the default time-to-live.
         * If set, this overrides the global default.
         * Must be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)
         */
        defaultLeaseTtl?: string;
        /**
         * Specifies whether to show this mount in
         * the UI-specific listing endpoint. Valid values are "unauth" or "hidden".
         */
        listingVisibility?: string;
        /**
         * Specifies the maximum time-to-live.
         * If set, this overrides the global default.
         * Must be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)
         */
        maxLeaseTtl?: string;
        /**
         * List of headers to whitelist and
         * pass from the request to the backend.
         */
        passthroughRequestHeaders?: string[];
        /**
         * Specifies the type of tokens that should be returned by
         * the mount. Valid values are "default-service", "default-batch", "service", "batch".
         */
        tokenType?: string;
    }

}

export namespace identity {
    export interface GetEntityAlias {
        /**
         * Canonical ID of the Alias
         */
        canonicalId: string;
        /**
         * Creation time of the Alias
         */
        creationTime: string;
        /**
         * ID of the alias
         */
        id: string;
        /**
         * Last update time of the alias
         */
        lastUpdateTime: string;
        /**
         * List of canonical IDs merged with this alias
         */
        mergedFromCanonicalIds: string[];
        /**
         * Arbitrary metadata
         */
        metadata: {[key: string]: string};
        /**
         * Authentication mount acccessor which this alias belongs to
         */
        mountAccessor: string;
        /**
         * Authentication mount path which this alias belongs to
         */
        mountPath: string;
        /**
         * Authentication mount type which this alias belongs to
         */
        mountType: string;
        /**
         * Name of the alias
         */
        name: string;
    }

}

export namespace jwt {
    export interface AuthBackendTune {
        /**
         * List of headers to whitelist and allowing
         * a plugin to include them in the response.
         */
        allowedResponseHeaders?: string[];
        /**
         * Specifies the list of keys that will
         * not be HMAC'd by audit devices in the request data object.
         */
        auditNonHmacRequestKeys?: string[];
        /**
         * Specifies the list of keys that will
         * not be HMAC'd by audit devices in the response data object.
         */
        auditNonHmacResponseKeys?: string[];
        /**
         * Specifies the default time-to-live.
         * If set, this overrides the global default.
         * Must be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)
         */
        defaultLeaseTtl?: string;
        /**
         * Specifies whether to show this mount in
         * the UI-specific listing endpoint. Valid values are "unauth" or "hidden".
         */
        listingVisibility?: string;
        /**
         * Specifies the maximum time-to-live.
         * If set, this overrides the global default.
         * Must be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)
         */
        maxLeaseTtl?: string;
        /**
         * List of headers to whitelist and
         * pass from the request to the backend.
         */
        passthroughRequestHeaders?: string[];
        /**
         * Specifies the type of tokens that should be returned by
         * the mount. Valid values are "default-service", "default-batch", "service", "batch".
         */
        tokenType?: string;
    }

}

export namespace kv {
    export interface SecretV2CustomMetadata {
        /**
         * If true, all keys will require the cas parameter to be set on all write requests.
         */
        casRequired?: boolean;
        /**
         * A mapping whose keys are the top-level data keys returned from
         * Vault and whose values are the corresponding values. This map can only
         * represent string data, so any non-string values returned from Vault are
         * serialized as JSON.
         */
        data?: {[key: string]: string};
        /**
         * If set, specifies the length of time before a version is deleted.
         */
        deleteVersionAfter?: number;
        /**
         * The number of versions to keep per key.
         */
        maxVersions?: number;
    }

}

export namespace managed {
    export interface KeysAw {
        /**
         * The AWS access key to use
         */
        accessKey: string;
        /**
         * If no existing key can be found in the referenced backend, instructs Vault to generate a key within the backend
         */
        allowGenerateKey: boolean;
        /**
         * Controls the ability for Vault to replace through generation or importing a key into the configured backend even if a key is present, if set to false those operations are forbidden if a key exists.
         */
        allowReplaceKey: boolean;
        /**
         * Controls the ability for Vault to import a key to the configured backend, if 'false', those operations will be forbidden
         */
        allowStoreKey: boolean;
        /**
         * Allow usage from any mount point within the namespace if 'true'
         */
        anyMount: boolean;
        /**
         * The curve to use for an ECDSA key. Used when keyType is 'ECDSA'. Required if 'allow_generate_key' is true
         */
        curve?: string;
        /**
         * Used to specify a custom AWS endpoint
         */
        endpoint?: string;
        /**
         * The size in bits for an RSA key. This field is required when 'key_type' is 'RSA'
         */
        keyBits: string;
        /**
         * The type of key to use
         */
        keyType: string;
        /**
         * An identifier for the key
         */
        kmsKey: string;
        /**
         * A unique lowercase name that serves as identifying the key
         */
        name: string;
        /**
         * The AWS region where the keys are stored (or will be stored)
         */
        region: string;
        /**
         * The AWS secret key to use
         */
        secretKey: string;
        /**
         * ID of the managed key read from Vault
         */
        uuid: string;
    }

    export interface KeysAzure {
        /**
         * If no existing key can be found in the referenced backend, instructs Vault to generate a key within the backend
         */
        allowGenerateKey: boolean;
        /**
         * Controls the ability for Vault to replace through generation or importing a key into the configured backend even if a key is present, if set to false those operations are forbidden if a key exists.
         */
        allowReplaceKey: boolean;
        /**
         * Controls the ability for Vault to import a key to the configured backend, if 'false', those operations will be forbidden
         */
        allowStoreKey: boolean;
        /**
         * Allow usage from any mount point within the namespace if 'true'
         */
        anyMount: boolean;
        /**
         * The client id for credentials to query the Azure APIs
         */
        clientId: string;
        /**
         * The client secret for credentials to query the Azure APIs
         */
        clientSecret: string;
        /**
         * The Azure Cloud environment API endpoints to use
         */
        environment: string;
        /**
         * The size in bits for an RSA key. This field is required when 'key_type' is 'RSA' or when 'allow_generate_key' is true
         */
        keyBits?: string;
        /**
         * The Key Vault key to use for encryption and decryption
         */
        keyName: string;
        /**
         * The type of key to use
         */
        keyType: string;
        /**
         * A unique lowercase name that serves as identifying the key
         */
        name: string;
        /**
         * The Azure Key Vault resource's DNS Suffix to connect to
         */
        resource: string;
        /**
         * The tenant id for the Azure Active Directory organization
         */
        tenantId: string;
        /**
         * ID of the managed key read from Vault
         */
        uuid: string;
        /**
         * The Key Vault vault to use the encryption keys for encryption and decryption
         */
        vaultName: string;
    }

    export interface KeysPkc {
        /**
         * If no existing key can be found in the referenced backend, instructs Vault to generate a key within the backend
         */
        allowGenerateKey: boolean;
        /**
         * Controls the ability for Vault to replace through generation or importing a key into the configured backend even if a key is present, if set to false those operations are forbidden if a key exists.
         */
        allowReplaceKey: boolean;
        /**
         * Controls the ability for Vault to import a key to the configured backend, if 'false', those operations will be forbidden
         */
        allowStoreKey: boolean;
        /**
         * Allow usage from any mount point within the namespace if 'true'
         */
        anyMount: boolean;
        /**
         * Supplies the curve value when using the 'CKM_ECDSA' mechanism. Required if 'allow_generate_key' is true
         */
        curve?: string;
        /**
         * Force all operations to open up a read-write session to the HSM
         */
        forceRwSession?: string;
        /**
         * Supplies the size in bits of the key when using 'CKM_RSA_PKCS_PSS', 'CKM_RSA_PKCS_OAEP' or 'CKM_RSA_PKCS' as a value for 'mechanism'. Required if 'allow_generate_key' is true
         */
        keyBits?: string;
        /**
         * The id of a PKCS#11 key to use
         */
        keyId: string;
        /**
         * The label of the key to use
         */
        keyLabel: string;
        /**
         * The name of the kmsLibrary stanza to use from Vault's config to lookup the local library path
         */
        library: string;
        /**
         * The encryption/decryption mechanism to use, specified as a hexadecimal (prefixed by 0x) string.
         */
        mechanism: string;
        /**
         * A unique lowercase name that serves as identifying the key
         */
        name: string;
        /**
         * The PIN for login
         */
        pin: string;
        /**
         * The slot number to use, specified as a string in a decimal format (e.g. '2305843009213693953')
         */
        slot?: string;
        /**
         * The slot token label to use
         */
        tokenLabel?: string;
        /**
         * ID of the managed key read from Vault
         */
        uuid: string;
    }

}

export namespace okta {
    export interface AuthBackendGroup {
        /**
         * Name of the Okta group
         */
        groupName: string;
        /**
         * Policies to associate with this group
         */
        policies: string[];
    }

    export interface AuthBackendUser {
        /**
         * Groups within the Okta auth backend to associate with this user
         */
        groups?: string[];
        /**
         * Policies to associate with this user
         */
        policies?: string[];
        /**
         * Name of the user within Okta
         */
        username: string;
    }

}

export namespace pkiSecret {
    export interface BackendConfigEstAuthenticators {
        /**
         * "The accessor (required) and certRole (optional) properties for cert auth backends".
         */
        cert?: {[key: string]: string};
        /**
         * "The accessor (required) property for user pass auth backends".
         */
        userpass?: {[key: string]: string};
    }

    export interface GetBackendConfigEstAuthenticator {
        /**
         * "The accessor and certRole properties for cert auth backends".
         */
        cert?: {[key: string]: string};
        /**
         * "The accessor property for user pass auth backends".
         */
        userpass?: {[key: string]: string};
    }

    export interface SecretBackendRolePolicyIdentifier {
        /**
         * The URL of the CPS for the policy identifier
         *
         * Example usage:
         */
        cps?: string;
        /**
         * A notice for the policy identifier
         */
        notice?: string;
        /**
         * The OID for the policy identifier
         */
        oid: string;
    }

}

export namespace rabbitMq {
    export interface SecretBackendRoleVhost {
        /**
         * The configure permissions for this vhost.
         */
        configure: string;
        /**
         * The vhost to set permissions for.
         */
        host: string;
        /**
         * The read permissions for this vhost.
         */
        read: string;
        /**
         * The write permissions for this vhost.
         */
        write: string;
    }

    export interface SecretBackendRoleVhostTopic {
        /**
         * The vhost to set permissions for.
         */
        host: string;
        /**
         * Specifies a map of virtual hosts to permissions.
         */
        vhosts?: outputs.rabbitMq.SecretBackendRoleVhostTopicVhost[];
    }

    export interface SecretBackendRoleVhostTopicVhost {
        /**
         * The read permissions for this vhost.
         */
        read: string;
        /**
         * The vhost to set permissions for.
         */
        topic: string;
        /**
         * The write permissions for this vhost.
         */
        write: string;
    }

}

export namespace secrets {
    export interface SyncAssociationMetadata {
        /**
         * Subkey of the associated secret.
         */
        subKey: string;
        /**
         * A map of sync statuses for each subkey of the associated secret
         * (for ex. `{kv_624bea/aws-token/dev: "SYNCED", kv_624bea/aws-token/prod: "SYNCED"}`).
         */
        syncStatus: string;
        /**
         * A map of duration strings specifying when each subkey of the associated
         * secret was last updated.
         * (for ex.
         * `{kv_624bea/aws-token/dev: "2024-03-21T12:42:02.558533-07:00",
         * kv_624bea/aws-token/prod: "2024-03-21T12:42:02.558533-07:00"}`).
         */
        updatedAt: string;
    }

}

export namespace ssh {
    export interface SecretBackendRoleAllowedUserKeyConfig {
        /**
         * List of allowed key lengths, vault-1.10 and above
         */
        lengths: number[];
        /**
         * Key type, choices:
         * rsa, ecdsa, ec, dsa, ed25519, ssh-rsa, ssh-dss, ssh-ed25519, ecdsa-sha2-nistp256, ecdsa-sha2-nistp384, ecdsa-sha2-nistp521
         */
        type: string;
    }

}
