// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Vault.Ssh
{
    public static class GetSecretBackendSign
    {
        /// <summary>
        /// This is a data source which can be used to sign an SSH public key
        /// 
        /// ## Example Usage
        /// 
        /// ```csharp
        /// using System.Collections.Generic;
        /// using System.Linq;
        /// using Pulumi;
        /// using Vault = Pulumi.Vault;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     var test = Vault.Ssh.GetSecretBackendSign.Invoke(new()
        ///     {
        ///         Path = "ssh",
        ///         PublicKey = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDR6q4PTcuIkpdGEqaCaxnR8/REqlbSiEIKaRZkVSjiTXOaiSfUsy9cY2+7+oO9fLMUrhylImerjzEoagX1IjYvc9IeUBaRnfacN7QwUDfstgp2jknbg7rNX9j9nFxwltV/jYQPcRq8Ud0wn1nb4qixq+diM7+Up+xJOeaKxbpjEUJH5dcvaBB+Aa24tJpjOQxtFyQ6dUxlgJu0tcygZR92kKYCVjZDohlSED3i/Ak2KFwqCKx2IZWq9z1vMEgmRzv++4Qt1OsbpW8itiCyWn6lmV33eDCdjMrr9TEThQNnMinPrHdmVUnPZ/OomP+rLDRE9lQR16uaSvKhg5TWOFIXRPyEhX9arEATrE4KSWeQN2qgHOb6P24YqgEm1ZdHJq25q/nBBAa1x0tFMiWqZwOsGeJ9nTeOeyiqFKH5YRBo6DIy3ag3taFsfQSve6oqjnrudUd1hJ8/bNSz8amECfP0ULvAEAgpiurj3eCPc3OcXl4tAld9F6KwabEJV5eelcs= user@example.com",
        ///         Name = "test",
        ///         ValidPrincipals = "my-user",
        ///     });
        /// 
        /// });
        /// ```
        /// </summary>
        public static Task<GetSecretBackendSignResult> InvokeAsync(GetSecretBackendSignArgs args, InvokeOptions? options = null)
            => global::Pulumi.Deployment.Instance.InvokeAsync<GetSecretBackendSignResult>("vault:ssh/getSecretBackendSign:getSecretBackendSign", args ?? new GetSecretBackendSignArgs(), options.WithDefaults());

        /// <summary>
        /// This is a data source which can be used to sign an SSH public key
        /// 
        /// ## Example Usage
        /// 
        /// ```csharp
        /// using System.Collections.Generic;
        /// using System.Linq;
        /// using Pulumi;
        /// using Vault = Pulumi.Vault;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     var test = Vault.Ssh.GetSecretBackendSign.Invoke(new()
        ///     {
        ///         Path = "ssh",
        ///         PublicKey = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDR6q4PTcuIkpdGEqaCaxnR8/REqlbSiEIKaRZkVSjiTXOaiSfUsy9cY2+7+oO9fLMUrhylImerjzEoagX1IjYvc9IeUBaRnfacN7QwUDfstgp2jknbg7rNX9j9nFxwltV/jYQPcRq8Ud0wn1nb4qixq+diM7+Up+xJOeaKxbpjEUJH5dcvaBB+Aa24tJpjOQxtFyQ6dUxlgJu0tcygZR92kKYCVjZDohlSED3i/Ak2KFwqCKx2IZWq9z1vMEgmRzv++4Qt1OsbpW8itiCyWn6lmV33eDCdjMrr9TEThQNnMinPrHdmVUnPZ/OomP+rLDRE9lQR16uaSvKhg5TWOFIXRPyEhX9arEATrE4KSWeQN2qgHOb6P24YqgEm1ZdHJq25q/nBBAa1x0tFMiWqZwOsGeJ9nTeOeyiqFKH5YRBo6DIy3ag3taFsfQSve6oqjnrudUd1hJ8/bNSz8amECfP0ULvAEAgpiurj3eCPc3OcXl4tAld9F6KwabEJV5eelcs= user@example.com",
        ///         Name = "test",
        ///         ValidPrincipals = "my-user",
        ///     });
        /// 
        /// });
        /// ```
        /// </summary>
        public static Output<GetSecretBackendSignResult> Invoke(GetSecretBackendSignInvokeArgs args, InvokeOptions? options = null)
            => global::Pulumi.Deployment.Instance.Invoke<GetSecretBackendSignResult>("vault:ssh/getSecretBackendSign:getSecretBackendSign", args ?? new GetSecretBackendSignInvokeArgs(), options.WithDefaults());

        /// <summary>
        /// This is a data source which can be used to sign an SSH public key
        /// 
        /// ## Example Usage
        /// 
        /// ```csharp
        /// using System.Collections.Generic;
        /// using System.Linq;
        /// using Pulumi;
        /// using Vault = Pulumi.Vault;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     var test = Vault.Ssh.GetSecretBackendSign.Invoke(new()
        ///     {
        ///         Path = "ssh",
        ///         PublicKey = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDR6q4PTcuIkpdGEqaCaxnR8/REqlbSiEIKaRZkVSjiTXOaiSfUsy9cY2+7+oO9fLMUrhylImerjzEoagX1IjYvc9IeUBaRnfacN7QwUDfstgp2jknbg7rNX9j9nFxwltV/jYQPcRq8Ud0wn1nb4qixq+diM7+Up+xJOeaKxbpjEUJH5dcvaBB+Aa24tJpjOQxtFyQ6dUxlgJu0tcygZR92kKYCVjZDohlSED3i/Ak2KFwqCKx2IZWq9z1vMEgmRzv++4Qt1OsbpW8itiCyWn6lmV33eDCdjMrr9TEThQNnMinPrHdmVUnPZ/OomP+rLDRE9lQR16uaSvKhg5TWOFIXRPyEhX9arEATrE4KSWeQN2qgHOb6P24YqgEm1ZdHJq25q/nBBAa1x0tFMiWqZwOsGeJ9nTeOeyiqFKH5YRBo6DIy3ag3taFsfQSve6oqjnrudUd1hJ8/bNSz8amECfP0ULvAEAgpiurj3eCPc3OcXl4tAld9F6KwabEJV5eelcs= user@example.com",
        ///         Name = "test",
        ///         ValidPrincipals = "my-user",
        ///     });
        /// 
        /// });
        /// ```
        /// </summary>
        public static Output<GetSecretBackendSignResult> Invoke(GetSecretBackendSignInvokeArgs args, InvokeOutputOptions options)
            => global::Pulumi.Deployment.Instance.Invoke<GetSecretBackendSignResult>("vault:ssh/getSecretBackendSign:getSecretBackendSign", args ?? new GetSecretBackendSignInvokeArgs(), options.WithDefaults());
    }


    public sealed class GetSecretBackendSignArgs : global::Pulumi.InvokeArgs
    {
        /// <summary>
        /// Specifies the type of certificate to be created; either "user" or "host".
        /// </summary>
        [Input("certType")]
        public string? CertType { get; set; }

        [Input("criticalOptions")]
        private Dictionary<string, string>? _criticalOptions;

        /// <summary>
        /// Specifies a map of the critical options that the certificate should be signed for. Defaults to none.
        /// </summary>
        public Dictionary<string, string> CriticalOptions
        {
            get => _criticalOptions ?? (_criticalOptions = new Dictionary<string, string>());
            set => _criticalOptions = value;
        }

        [Input("extensions")]
        private Dictionary<string, string>? _extensions;

        /// <summary>
        /// Specifies a map of the extensions that the certificate should be signed for. Defaults to none.
        /// </summary>
        public Dictionary<string, string> Extensions
        {
            get => _extensions ?? (_extensions = new Dictionary<string, string>());
            set => _extensions = value;
        }

        /// <summary>
        /// Specifies the key id that the created certificate should have. If not specified, the display name of the token will be used.
        /// </summary>
        [Input("keyId")]
        public string? KeyId { get; set; }

        /// <summary>
        /// Specifies the name of the role to sign.
        /// </summary>
        [Input("name", required: true)]
        public string Name { get; set; } = null!;

        [Input("namespace")]
        public string? Namespace { get; set; }

        /// <summary>
        /// Full path where SSH backend is mounted.
        /// </summary>
        [Input("path", required: true)]
        public string Path { get; set; } = null!;

        /// <summary>
        /// Specifies the SSH public key that should be signed.
        /// </summary>
        [Input("publicKey", required: true)]
        public string PublicKey { get; set; } = null!;

        /// <summary>
        /// Specifies the Requested Time To Live. Cannot be greater than the role's MaxTtl value. If not provided, the role's ttl value will be used. Note that the role values default to system values if not explicitly set.
        /// </summary>
        [Input("ttl")]
        public string? Ttl { get; set; }

        /// <summary>
        /// Specifies valid principals, either usernames or hostnames, that the certificate should be signed for. Required unless the role has specified AllowEmptyPrincipals or a value has been set for either the DefaultUser or DefaultUserTemplate role parameters.
        /// </summary>
        [Input("validPrincipals")]
        public string? ValidPrincipals { get; set; }

        public GetSecretBackendSignArgs()
        {
        }
        public static new GetSecretBackendSignArgs Empty => new GetSecretBackendSignArgs();
    }

    public sealed class GetSecretBackendSignInvokeArgs : global::Pulumi.InvokeArgs
    {
        /// <summary>
        /// Specifies the type of certificate to be created; either "user" or "host".
        /// </summary>
        [Input("certType")]
        public Input<string>? CertType { get; set; }

        [Input("criticalOptions")]
        private InputMap<string>? _criticalOptions;

        /// <summary>
        /// Specifies a map of the critical options that the certificate should be signed for. Defaults to none.
        /// </summary>
        public InputMap<string> CriticalOptions
        {
            get => _criticalOptions ?? (_criticalOptions = new InputMap<string>());
            set => _criticalOptions = value;
        }

        [Input("extensions")]
        private InputMap<string>? _extensions;

        /// <summary>
        /// Specifies a map of the extensions that the certificate should be signed for. Defaults to none.
        /// </summary>
        public InputMap<string> Extensions
        {
            get => _extensions ?? (_extensions = new InputMap<string>());
            set => _extensions = value;
        }

        /// <summary>
        /// Specifies the key id that the created certificate should have. If not specified, the display name of the token will be used.
        /// </summary>
        [Input("keyId")]
        public Input<string>? KeyId { get; set; }

        /// <summary>
        /// Specifies the name of the role to sign.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        [Input("namespace")]
        public Input<string>? Namespace { get; set; }

        /// <summary>
        /// Full path where SSH backend is mounted.
        /// </summary>
        [Input("path", required: true)]
        public Input<string> Path { get; set; } = null!;

        /// <summary>
        /// Specifies the SSH public key that should be signed.
        /// </summary>
        [Input("publicKey", required: true)]
        public Input<string> PublicKey { get; set; } = null!;

        /// <summary>
        /// Specifies the Requested Time To Live. Cannot be greater than the role's MaxTtl value. If not provided, the role's ttl value will be used. Note that the role values default to system values if not explicitly set.
        /// </summary>
        [Input("ttl")]
        public Input<string>? Ttl { get; set; }

        /// <summary>
        /// Specifies valid principals, either usernames or hostnames, that the certificate should be signed for. Required unless the role has specified AllowEmptyPrincipals or a value has been set for either the DefaultUser or DefaultUserTemplate role parameters.
        /// </summary>
        [Input("validPrincipals")]
        public Input<string>? ValidPrincipals { get; set; }

        public GetSecretBackendSignInvokeArgs()
        {
        }
        public static new GetSecretBackendSignInvokeArgs Empty => new GetSecretBackendSignInvokeArgs();
    }


    [OutputType]
    public sealed class GetSecretBackendSignResult
    {
        public readonly string? CertType;
        public readonly ImmutableDictionary<string, string>? CriticalOptions;
        public readonly ImmutableDictionary<string, string>? Extensions;
        /// <summary>
        /// The provider-assigned unique ID for this managed resource.
        /// </summary>
        public readonly string Id;
        public readonly string? KeyId;
        public readonly string Name;
        public readonly string? Namespace;
        public readonly string Path;
        public readonly string PublicKey;
        /// <summary>
        /// The serial number of the certificate returned from Vault
        /// </summary>
        public readonly string SerialNumber;
        /// <summary>
        /// The signed certificate returned from Vault
        /// </summary>
        public readonly string SignedKey;
        public readonly string? Ttl;
        public readonly string? ValidPrincipals;

        [OutputConstructor]
        private GetSecretBackendSignResult(
            string? certType,

            ImmutableDictionary<string, string>? criticalOptions,

            ImmutableDictionary<string, string>? extensions,

            string id,

            string? keyId,

            string name,

            string? @namespace,

            string path,

            string publicKey,

            string serialNumber,

            string signedKey,

            string? ttl,

            string? validPrincipals)
        {
            CertType = certType;
            CriticalOptions = criticalOptions;
            Extensions = extensions;
            Id = id;
            KeyId = keyId;
            Name = name;
            Namespace = @namespace;
            Path = path;
            PublicKey = publicKey;
            SerialNumber = serialNumber;
            SignedKey = signedKey;
            Ttl = ttl;
            ValidPrincipals = validPrincipals;
        }
    }
}
