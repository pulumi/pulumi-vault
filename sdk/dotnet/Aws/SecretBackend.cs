// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Vault.Aws
{
    /// <summary>
    /// Creates an AWS Secret Backend for Vault. AWS secret backends can then issue AWS
    /// access keys and secret keys, once a role has been added to the backend.
    /// 
    /// &gt; **Important** All data provided in the resource configuration will be
    /// written in cleartext to state and plan files generated by Terraform, and
    /// will appear in the console output when Terraform runs. Protect these
    /// artifacts accordingly. See
    /// the main provider documentation
    /// for more details.
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Vault = Pulumi.Vault;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var aws = new Vault.Aws.SecretBackend("aws", new()
    ///     {
    ///         AccessKey = "AKIA.....",
    ///         SecretKey = "AWS secret key",
    ///         RotationSchedule = "0 * * * SAT",
    ///         RotationWindow = 3600,
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### Using Write-Only Secret Key
    /// 
    /// The `SecretKeyWo` field allows you to configure the AWS secret key without
    /// storing it in Terraform state. This is recommended for enhanced security.
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Vault = Pulumi.Vault;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var aws = new Vault.Aws.SecretBackend("aws", new()
    ///     {
    ///         AccessKey = "AKIA.....",
    ///         SecretKeyWo = awsSecretKey,
    ///         SecretKeyWoVersion = 1,
    ///         RotationSchedule = "0 * * * SAT",
    ///         RotationWindow = 3600,
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// To update the `SecretKeyWo` value, increment the `SecretKeyWoVersion`:
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Vault = Pulumi.Vault;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var aws = new Vault.Aws.SecretBackend("aws", new()
    ///     {
    ///         AccessKey = "AKIA.....",
    ///         SecretKeyWo = awsSecretKey,
    ///         SecretKeyWoVersion = 2,
    ///         RotationSchedule = "0 * * * SAT",
    ///         RotationWindow = 3600,
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### Using Workload Identity Federation
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Vault = Pulumi.Vault;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var aws = new Vault.Aws.SecretBackend("aws", new()
    ///     {
    ///         IdentityTokenAudience = "&lt;TOKEN_AUDIENCE&gt;",
    ///         IdentityTokenTtl = "&lt;TOKEN_TTL&gt;",
    ///         RoleArn = "&lt;AWS_ROLE_ARN&gt;",
    ///         RotationSchedule = "0 * * * SAT",
    ///         RotationWindow = 3600,
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Ephemeral Attributes Reference
    /// 
    /// These attributes are write-only and will not be persisted to Terraform state.
    /// Requires Terraform 1.11+.
    /// 
    /// * `SecretKeyWo` - (Optional) The AWS Secret Key this backend should use to
    /// issue new credentials. This is a write-only field and will not be stored in state.
    /// Vault uses the official AWS SDK to authenticate, and thus can also use standard AWS
    /// environment credentials, shared file credentials or IAM role/ECS task credentials.
    /// Conflicts with `SecretKey`.
    /// 
    /// * `SecretKeyWoVersion` - (Optional, Required if `SecretKeyWo` is set) A version counter for the
    /// `SecretKeyWo` field. Incrementing this value will trigger an update to the secret key.
    /// 
    /// ## Tutorials
    /// 
    /// Refer to the Inject Secrets into Terraform Using the Vault Provider tutorial for a step-by-step usage example.
    /// 
    /// ## Import
    /// 
    /// AWS secret backends can be imported using the `Path`, e.g.
    /// 
    /// ```sh
    /// $ pulumi import vault:aws/secretBackend:SecretBackend aws aws
    /// ```
    /// </summary>
    [VaultResourceType("vault:aws/secretBackend:SecretBackend")]
    public partial class SecretBackend : global::Pulumi.CustomResource
    {
        /// <summary>
        /// The AWS Access Key ID this backend should use to
        /// issue new credentials. Vault uses the official AWS SDK to authenticate, and thus can also use standard AWS environment credentials, shared file credentials or IAM role/ECS task credentials.
        /// </summary>
        [Output("accessKey")]
        public Output<string?> AccessKey { get; private set; } = null!;

        /// <summary>
        /// Accessor of the mount
        /// </summary>
        [Output("accessor")]
        public Output<string> Accessor { get; private set; } = null!;

        /// <summary>
        /// List of managed key registry entry names that the mount in question is allowed to access
        /// </summary>
        [Output("allowedManagedKeys")]
        public Output<ImmutableArray<string>> AllowedManagedKeys { get; private set; } = null!;

        /// <summary>
        /// List of headers to allow and pass from the request to the plugin
        /// </summary>
        [Output("allowedResponseHeaders")]
        public Output<ImmutableArray<string>> AllowedResponseHeaders { get; private set; } = null!;

        /// <summary>
        /// Specifies the list of keys that will not be HMAC'd by audit devices in the request data object.
        /// </summary>
        [Output("auditNonHmacRequestKeys")]
        public Output<ImmutableArray<string>> AuditNonHmacRequestKeys { get; private set; } = null!;

        /// <summary>
        /// Specifies the list of keys that will not be HMAC'd by audit devices in the response data object.
        /// </summary>
        [Output("auditNonHmacResponseKeys")]
        public Output<ImmutableArray<string>> AuditNonHmacResponseKeys { get; private set; } = null!;

        /// <summary>
        /// Default lease duration for secrets in seconds
        /// </summary>
        [Output("defaultLeaseTtlSeconds")]
        public Output<int> DefaultLeaseTtlSeconds { get; private set; } = null!;

        /// <summary>
        /// List of headers to allow and pass from the request to the plugin
        /// </summary>
        [Output("delegatedAuthAccessors")]
        public Output<ImmutableArray<string>> DelegatedAuthAccessors { get; private set; } = null!;

        /// <summary>
        /// Human-friendly description of the mount for the backend.
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// Cancels all upcoming rotations of the root credential until unset. Requires Vault Enterprise 1.19+.
        /// </summary>
        [Output("disableAutomatedRotation")]
        public Output<bool?> DisableAutomatedRotation { get; private set; } = null!;

        /// <summary>
        /// If set, opts out of mount migration on path updates.
        /// See here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)
        /// </summary>
        [Output("disableRemount")]
        public Output<bool?> DisableRemount { get; private set; } = null!;

        /// <summary>
        /// Enable the secrets engine to access Vault's external entropy source
        /// </summary>
        [Output("externalEntropyAccess")]
        public Output<bool?> ExternalEntropyAccess { get; private set; } = null!;

        /// <summary>
        /// If set to true, disables caching.
        /// </summary>
        [Output("forceNoCache")]
        public Output<bool> ForceNoCache { get; private set; } = null!;

        /// <summary>
        /// Specifies a custom HTTP IAM endpoint to use.
        /// </summary>
        [Output("iamEndpoint")]
        public Output<string?> IamEndpoint { get; private set; } = null!;

        /// <summary>
        /// The audience claim value. Requires Vault 1.16+.
        /// </summary>
        [Output("identityTokenAudience")]
        public Output<string?> IdentityTokenAudience { get; private set; } = null!;

        /// <summary>
        /// The key to use for signing identity tokens.
        /// </summary>
        [Output("identityTokenKey")]
        public Output<string?> IdentityTokenKey { get; private set; } = null!;

        /// <summary>
        /// The TTL of generated identity tokens in seconds. Requires Vault 1.16+.
        /// </summary>
        [Output("identityTokenTtl")]
        public Output<int> IdentityTokenTtl { get; private set; } = null!;

        /// <summary>
        /// Specifies whether to show this mount in the UI-specific listing endpoint
        /// </summary>
        [Output("listingVisibility")]
        public Output<string?> ListingVisibility { get; private set; } = null!;

        /// <summary>
        /// Specifies if the secret backend is local only
        /// </summary>
        [Output("local")]
        public Output<bool?> Local { get; private set; } = null!;

        /// <summary>
        /// Maximum possible lease duration for secrets in seconds
        /// </summary>
        [Output("maxLeaseTtlSeconds")]
        public Output<int> MaxLeaseTtlSeconds { get; private set; } = null!;

        /// <summary>
        /// Number of max retries the client should use for recoverable errors.
        /// </summary>
        [Output("maxRetries")]
        public Output<int?> MaxRetries { get; private set; } = null!;

        /// <summary>
        /// The namespace to provision the resource in.
        /// The value should not contain leading or trailing forward slashes.
        /// The `Namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault/index.html#namespace).
        /// *Available only for Vault Enterprise*.
        /// </summary>
        [Output("namespace")]
        public Output<string?> Namespace { get; private set; } = null!;

        /// <summary>
        /// Specifies mount type specific options that are passed to the backend
        /// </summary>
        [Output("options")]
        public Output<ImmutableDictionary<string, string>?> Options { get; private set; } = null!;

        /// <summary>
        /// List of headers to allow and pass from the request to the plugin
        /// </summary>
        [Output("passthroughRequestHeaders")]
        public Output<ImmutableArray<string>> PassthroughRequestHeaders { get; private set; } = null!;

        /// <summary>
        /// The unique path this backend should be mounted at. Must
        /// not begin or end with a `/`. Defaults to `Aws`.
        /// </summary>
        [Output("path")]
        public Output<string?> Path { get; private set; } = null!;

        /// <summary>
        /// Specifies the semantic version of the plugin to use, e.g. 'v1.0.0'
        /// </summary>
        [Output("pluginVersion")]
        public Output<string?> PluginVersion { get; private set; } = null!;

        /// <summary>
        /// The AWS region for API calls. Defaults to `us-east-1`.
        /// 
        /// &gt; **Important** The same limitation noted above for the `AccessKey` parameter
        /// also applies to the `Region` parameter. Vault versions 1.2.3 and older will not
        /// allow Terraform to detect (and thus correct) drift in the `Region` parameter,
        /// while newer versions of Vault will.
        /// </summary>
        [Output("region")]
        public Output<string> Region { get; private set; } = null!;

        /// <summary>
        /// Role ARN to assume for plugin identity token federation. Requires Vault 1.16+.
        /// </summary>
        [Output("roleArn")]
        public Output<string?> RoleArn { get; private set; } = null!;

        /// <summary>
        /// The amount of time in seconds Vault should wait before rotating the root credential. 
        /// A zero value tells Vault not to rotate the root credential. The minimum rotation period is 10 seconds. Requires Vault Enterprise 1.19+.
        /// </summary>
        [Output("rotationPeriod")]
        public Output<int?> RotationPeriod { get; private set; } = null!;

        /// <summary>
        /// The schedule, in [cron-style time format](https://en.wikipedia.org/wiki/Cron),
        /// defining the schedule on which Vault should rotate the root token. Requires Vault Enterprise 1.19+.
        /// </summary>
        [Output("rotationSchedule")]
        public Output<string?> RotationSchedule { get; private set; } = null!;

        /// <summary>
        /// The maximum amount of time in seconds allowed to complete
        /// a rotation when a scheduled token rotation occurs. The default rotation window is
        /// unbound and the minimum allowable window is `3600`. Requires Vault Enterprise 1.19+.
        /// </summary>
        [Output("rotationWindow")]
        public Output<int?> RotationWindow { get; private set; } = null!;

        /// <summary>
        /// Enable seal wrapping for the mount, causing values stored by the mount to be wrapped by the seal's encryption capability
        /// </summary>
        [Output("sealWrap")]
        public Output<bool> SealWrap { get; private set; } = null!;

        /// <summary>
        /// The AWS Secret Key this backend should use to
        /// issue new credentials. Vault uses the official AWS SDK to authenticate, and thus can also use standard AWS environment credentials, shared file credentials or IAM role/ECS task credentials. Conflicts with `SecretKeyWo`.
        /// 
        /// &gt; **Important** Vault version 1.2.3 and older does not support reading the configured
        /// credentials back from the API, With these older versions, Terraform cannot detect and correct drift
        /// on `AccessKey` or `SecretKey`. Changing the values, however, _will_
        /// overwrite the previously stored values. With versions of Vault newer than
        /// 1.2.3, reading the `AccessKey` only is supported, and so drifts of the
        /// `AccessKey` will be detected and corrected, but drifts on the `SecretKey`
        /// will not.
        /// </summary>
        [Output("secretKey")]
        public Output<string?> SecretKey { get; private set; } = null!;

        /// <summary>
        /// **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        /// The AWS Secret Access Key to use when generating new credentials. This is a write-only field and will not be read back from Vault.
        /// </summary>
        [Output("secretKeyWo")]
        public Output<string?> SecretKeyWo { get; private set; } = null!;

        /// <summary>
        /// A version counter for the write-only SecretKeyWo field. Incrementing this value will trigger an update to the secret_key.
        /// </summary>
        [Output("secretKeyWoVersion")]
        public Output<int?> SecretKeyWoVersion { get; private set; } = null!;

        /// <summary>
        /// Specifies a custom HTTP STS endpoint to use.
        /// </summary>
        [Output("stsEndpoint")]
        public Output<string?> StsEndpoint { get; private set; } = null!;

        /// <summary>
        /// Ordered list of `StsEndpoint`s to try if the defined one fails. Requires Vault 1.19+
        /// </summary>
        [Output("stsFallbackEndpoints")]
        public Output<ImmutableArray<string>> StsFallbackEndpoints { get; private set; } = null!;

        /// <summary>
        /// Ordered list of `StsRegion`s matching the fallback endpoints. Should correspond in order with those endpoints. Requires Vault 1.19+
        /// </summary>
        [Output("stsFallbackRegions")]
        public Output<ImmutableArray<string>> StsFallbackRegions { get; private set; } = null!;

        /// <summary>
        /// Specifies the region of the STS endpoint. Should be included if `StsEndpoint` is supplied. Requires Vault 1.19+
        /// </summary>
        [Output("stsRegion")]
        public Output<string?> StsRegion { get; private set; } = null!;

        /// <summary>
        /// Template describing how dynamic usernames are generated. The username template is used to generate both IAM usernames (capped at 64 characters) and STS usernames (capped at 32 characters). If no template is provided the field defaults to the template:
        /// 
        /// ```
        /// {{ if (eq .Type "STS") }}
        /// {{ printf "vault-%s-%s" (unix_time) (random 20) | truncate 32 }}
        /// {{ else }}
        /// {{ printf "vault-%s-%s-%s" (printf "%s-%s" (.DisplayName) (.PolicyName) | truncate 42) (unix_time) (random 20) | truncate 64 }}
        /// {{ end }}
        /// 
        /// ```
        /// </summary>
        [Output("usernameTemplate")]
        public Output<string> UsernameTemplate { get; private set; } = null!;


        /// <summary>
        /// Create a SecretBackend resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public SecretBackend(string name, SecretBackendArgs? args = null, CustomResourceOptions? options = null)
            : base("vault:aws/secretBackend:SecretBackend", name, args ?? new SecretBackendArgs(), MakeResourceOptions(options, ""))
        {
        }

        private SecretBackend(string name, Input<string> id, SecretBackendState? state = null, CustomResourceOptions? options = null)
            : base("vault:aws/secretBackend:SecretBackend", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                AdditionalSecretOutputs =
                {
                    "accessKey",
                    "secretKey",
                    "secretKeyWo",
                },
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing SecretBackend resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static SecretBackend Get(string name, Input<string> id, SecretBackendState? state = null, CustomResourceOptions? options = null)
        {
            return new SecretBackend(name, id, state, options);
        }
    }

    public sealed class SecretBackendArgs : global::Pulumi.ResourceArgs
    {
        [Input("accessKey")]
        private Input<string>? _accessKey;

        /// <summary>
        /// The AWS Access Key ID this backend should use to
        /// issue new credentials. Vault uses the official AWS SDK to authenticate, and thus can also use standard AWS environment credentials, shared file credentials or IAM role/ECS task credentials.
        /// </summary>
        public Input<string>? AccessKey
        {
            get => _accessKey;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _accessKey = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        [Input("allowedManagedKeys")]
        private InputList<string>? _allowedManagedKeys;

        /// <summary>
        /// List of managed key registry entry names that the mount in question is allowed to access
        /// </summary>
        public InputList<string> AllowedManagedKeys
        {
            get => _allowedManagedKeys ?? (_allowedManagedKeys = new InputList<string>());
            set => _allowedManagedKeys = value;
        }

        [Input("allowedResponseHeaders")]
        private InputList<string>? _allowedResponseHeaders;

        /// <summary>
        /// List of headers to allow and pass from the request to the plugin
        /// </summary>
        public InputList<string> AllowedResponseHeaders
        {
            get => _allowedResponseHeaders ?? (_allowedResponseHeaders = new InputList<string>());
            set => _allowedResponseHeaders = value;
        }

        [Input("auditNonHmacRequestKeys")]
        private InputList<string>? _auditNonHmacRequestKeys;

        /// <summary>
        /// Specifies the list of keys that will not be HMAC'd by audit devices in the request data object.
        /// </summary>
        public InputList<string> AuditNonHmacRequestKeys
        {
            get => _auditNonHmacRequestKeys ?? (_auditNonHmacRequestKeys = new InputList<string>());
            set => _auditNonHmacRequestKeys = value;
        }

        [Input("auditNonHmacResponseKeys")]
        private InputList<string>? _auditNonHmacResponseKeys;

        /// <summary>
        /// Specifies the list of keys that will not be HMAC'd by audit devices in the response data object.
        /// </summary>
        public InputList<string> AuditNonHmacResponseKeys
        {
            get => _auditNonHmacResponseKeys ?? (_auditNonHmacResponseKeys = new InputList<string>());
            set => _auditNonHmacResponseKeys = value;
        }

        /// <summary>
        /// Default lease duration for secrets in seconds
        /// </summary>
        [Input("defaultLeaseTtlSeconds")]
        public Input<int>? DefaultLeaseTtlSeconds { get; set; }

        [Input("delegatedAuthAccessors")]
        private InputList<string>? _delegatedAuthAccessors;

        /// <summary>
        /// List of headers to allow and pass from the request to the plugin
        /// </summary>
        public InputList<string> DelegatedAuthAccessors
        {
            get => _delegatedAuthAccessors ?? (_delegatedAuthAccessors = new InputList<string>());
            set => _delegatedAuthAccessors = value;
        }

        /// <summary>
        /// Human-friendly description of the mount for the backend.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// Cancels all upcoming rotations of the root credential until unset. Requires Vault Enterprise 1.19+.
        /// </summary>
        [Input("disableAutomatedRotation")]
        public Input<bool>? DisableAutomatedRotation { get; set; }

        /// <summary>
        /// If set, opts out of mount migration on path updates.
        /// See here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)
        /// </summary>
        [Input("disableRemount")]
        public Input<bool>? DisableRemount { get; set; }

        /// <summary>
        /// Enable the secrets engine to access Vault's external entropy source
        /// </summary>
        [Input("externalEntropyAccess")]
        public Input<bool>? ExternalEntropyAccess { get; set; }

        /// <summary>
        /// If set to true, disables caching.
        /// </summary>
        [Input("forceNoCache")]
        public Input<bool>? ForceNoCache { get; set; }

        /// <summary>
        /// Specifies a custom HTTP IAM endpoint to use.
        /// </summary>
        [Input("iamEndpoint")]
        public Input<string>? IamEndpoint { get; set; }

        /// <summary>
        /// The audience claim value. Requires Vault 1.16+.
        /// </summary>
        [Input("identityTokenAudience")]
        public Input<string>? IdentityTokenAudience { get; set; }

        /// <summary>
        /// The key to use for signing identity tokens.
        /// </summary>
        [Input("identityTokenKey")]
        public Input<string>? IdentityTokenKey { get; set; }

        /// <summary>
        /// The TTL of generated identity tokens in seconds. Requires Vault 1.16+.
        /// </summary>
        [Input("identityTokenTtl")]
        public Input<int>? IdentityTokenTtl { get; set; }

        /// <summary>
        /// Specifies whether to show this mount in the UI-specific listing endpoint
        /// </summary>
        [Input("listingVisibility")]
        public Input<string>? ListingVisibility { get; set; }

        /// <summary>
        /// Specifies if the secret backend is local only
        /// </summary>
        [Input("local")]
        public Input<bool>? Local { get; set; }

        /// <summary>
        /// Maximum possible lease duration for secrets in seconds
        /// </summary>
        [Input("maxLeaseTtlSeconds")]
        public Input<int>? MaxLeaseTtlSeconds { get; set; }

        /// <summary>
        /// Number of max retries the client should use for recoverable errors.
        /// </summary>
        [Input("maxRetries")]
        public Input<int>? MaxRetries { get; set; }

        /// <summary>
        /// The namespace to provision the resource in.
        /// The value should not contain leading or trailing forward slashes.
        /// The `Namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault/index.html#namespace).
        /// *Available only for Vault Enterprise*.
        /// </summary>
        [Input("namespace")]
        public Input<string>? Namespace { get; set; }

        [Input("options")]
        private InputMap<string>? _options;

        /// <summary>
        /// Specifies mount type specific options that are passed to the backend
        /// </summary>
        public InputMap<string> Options
        {
            get => _options ?? (_options = new InputMap<string>());
            set => _options = value;
        }

        [Input("passthroughRequestHeaders")]
        private InputList<string>? _passthroughRequestHeaders;

        /// <summary>
        /// List of headers to allow and pass from the request to the plugin
        /// </summary>
        public InputList<string> PassthroughRequestHeaders
        {
            get => _passthroughRequestHeaders ?? (_passthroughRequestHeaders = new InputList<string>());
            set => _passthroughRequestHeaders = value;
        }

        /// <summary>
        /// The unique path this backend should be mounted at. Must
        /// not begin or end with a `/`. Defaults to `Aws`.
        /// </summary>
        [Input("path")]
        public Input<string>? Path { get; set; }

        /// <summary>
        /// Specifies the semantic version of the plugin to use, e.g. 'v1.0.0'
        /// </summary>
        [Input("pluginVersion")]
        public Input<string>? PluginVersion { get; set; }

        /// <summary>
        /// The AWS region for API calls. Defaults to `us-east-1`.
        /// 
        /// &gt; **Important** The same limitation noted above for the `AccessKey` parameter
        /// also applies to the `Region` parameter. Vault versions 1.2.3 and older will not
        /// allow Terraform to detect (and thus correct) drift in the `Region` parameter,
        /// while newer versions of Vault will.
        /// </summary>
        [Input("region")]
        public Input<string>? Region { get; set; }

        /// <summary>
        /// Role ARN to assume for plugin identity token federation. Requires Vault 1.16+.
        /// </summary>
        [Input("roleArn")]
        public Input<string>? RoleArn { get; set; }

        /// <summary>
        /// The amount of time in seconds Vault should wait before rotating the root credential. 
        /// A zero value tells Vault not to rotate the root credential. The minimum rotation period is 10 seconds. Requires Vault Enterprise 1.19+.
        /// </summary>
        [Input("rotationPeriod")]
        public Input<int>? RotationPeriod { get; set; }

        /// <summary>
        /// The schedule, in [cron-style time format](https://en.wikipedia.org/wiki/Cron),
        /// defining the schedule on which Vault should rotate the root token. Requires Vault Enterprise 1.19+.
        /// </summary>
        [Input("rotationSchedule")]
        public Input<string>? RotationSchedule { get; set; }

        /// <summary>
        /// The maximum amount of time in seconds allowed to complete
        /// a rotation when a scheduled token rotation occurs. The default rotation window is
        /// unbound and the minimum allowable window is `3600`. Requires Vault Enterprise 1.19+.
        /// </summary>
        [Input("rotationWindow")]
        public Input<int>? RotationWindow { get; set; }

        /// <summary>
        /// Enable seal wrapping for the mount, causing values stored by the mount to be wrapped by the seal's encryption capability
        /// </summary>
        [Input("sealWrap")]
        public Input<bool>? SealWrap { get; set; }

        [Input("secretKey")]
        private Input<string>? _secretKey;

        /// <summary>
        /// The AWS Secret Key this backend should use to
        /// issue new credentials. Vault uses the official AWS SDK to authenticate, and thus can also use standard AWS environment credentials, shared file credentials or IAM role/ECS task credentials. Conflicts with `SecretKeyWo`.
        /// 
        /// &gt; **Important** Vault version 1.2.3 and older does not support reading the configured
        /// credentials back from the API, With these older versions, Terraform cannot detect and correct drift
        /// on `AccessKey` or `SecretKey`. Changing the values, however, _will_
        /// overwrite the previously stored values. With versions of Vault newer than
        /// 1.2.3, reading the `AccessKey` only is supported, and so drifts of the
        /// `AccessKey` will be detected and corrected, but drifts on the `SecretKey`
        /// will not.
        /// </summary>
        public Input<string>? SecretKey
        {
            get => _secretKey;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _secretKey = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        [Input("secretKeyWo")]
        private Input<string>? _secretKeyWo;

        /// <summary>
        /// **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        /// The AWS Secret Access Key to use when generating new credentials. This is a write-only field and will not be read back from Vault.
        /// </summary>
        public Input<string>? SecretKeyWo
        {
            get => _secretKeyWo;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _secretKeyWo = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// A version counter for the write-only SecretKeyWo field. Incrementing this value will trigger an update to the secret_key.
        /// </summary>
        [Input("secretKeyWoVersion")]
        public Input<int>? SecretKeyWoVersion { get; set; }

        /// <summary>
        /// Specifies a custom HTTP STS endpoint to use.
        /// </summary>
        [Input("stsEndpoint")]
        public Input<string>? StsEndpoint { get; set; }

        [Input("stsFallbackEndpoints")]
        private InputList<string>? _stsFallbackEndpoints;

        /// <summary>
        /// Ordered list of `StsEndpoint`s to try if the defined one fails. Requires Vault 1.19+
        /// </summary>
        public InputList<string> StsFallbackEndpoints
        {
            get => _stsFallbackEndpoints ?? (_stsFallbackEndpoints = new InputList<string>());
            set => _stsFallbackEndpoints = value;
        }

        [Input("stsFallbackRegions")]
        private InputList<string>? _stsFallbackRegions;

        /// <summary>
        /// Ordered list of `StsRegion`s matching the fallback endpoints. Should correspond in order with those endpoints. Requires Vault 1.19+
        /// </summary>
        public InputList<string> StsFallbackRegions
        {
            get => _stsFallbackRegions ?? (_stsFallbackRegions = new InputList<string>());
            set => _stsFallbackRegions = value;
        }

        /// <summary>
        /// Specifies the region of the STS endpoint. Should be included if `StsEndpoint` is supplied. Requires Vault 1.19+
        /// </summary>
        [Input("stsRegion")]
        public Input<string>? StsRegion { get; set; }

        /// <summary>
        /// Template describing how dynamic usernames are generated. The username template is used to generate both IAM usernames (capped at 64 characters) and STS usernames (capped at 32 characters). If no template is provided the field defaults to the template:
        /// 
        /// ```
        /// {{ if (eq .Type "STS") }}
        /// {{ printf "vault-%s-%s" (unix_time) (random 20) | truncate 32 }}
        /// {{ else }}
        /// {{ printf "vault-%s-%s-%s" (printf "%s-%s" (.DisplayName) (.PolicyName) | truncate 42) (unix_time) (random 20) | truncate 64 }}
        /// {{ end }}
        /// 
        /// ```
        /// </summary>
        [Input("usernameTemplate")]
        public Input<string>? UsernameTemplate { get; set; }

        public SecretBackendArgs()
        {
        }
        public static new SecretBackendArgs Empty => new SecretBackendArgs();
    }

    public sealed class SecretBackendState : global::Pulumi.ResourceArgs
    {
        [Input("accessKey")]
        private Input<string>? _accessKey;

        /// <summary>
        /// The AWS Access Key ID this backend should use to
        /// issue new credentials. Vault uses the official AWS SDK to authenticate, and thus can also use standard AWS environment credentials, shared file credentials or IAM role/ECS task credentials.
        /// </summary>
        public Input<string>? AccessKey
        {
            get => _accessKey;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _accessKey = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// Accessor of the mount
        /// </summary>
        [Input("accessor")]
        public Input<string>? Accessor { get; set; }

        [Input("allowedManagedKeys")]
        private InputList<string>? _allowedManagedKeys;

        /// <summary>
        /// List of managed key registry entry names that the mount in question is allowed to access
        /// </summary>
        public InputList<string> AllowedManagedKeys
        {
            get => _allowedManagedKeys ?? (_allowedManagedKeys = new InputList<string>());
            set => _allowedManagedKeys = value;
        }

        [Input("allowedResponseHeaders")]
        private InputList<string>? _allowedResponseHeaders;

        /// <summary>
        /// List of headers to allow and pass from the request to the plugin
        /// </summary>
        public InputList<string> AllowedResponseHeaders
        {
            get => _allowedResponseHeaders ?? (_allowedResponseHeaders = new InputList<string>());
            set => _allowedResponseHeaders = value;
        }

        [Input("auditNonHmacRequestKeys")]
        private InputList<string>? _auditNonHmacRequestKeys;

        /// <summary>
        /// Specifies the list of keys that will not be HMAC'd by audit devices in the request data object.
        /// </summary>
        public InputList<string> AuditNonHmacRequestKeys
        {
            get => _auditNonHmacRequestKeys ?? (_auditNonHmacRequestKeys = new InputList<string>());
            set => _auditNonHmacRequestKeys = value;
        }

        [Input("auditNonHmacResponseKeys")]
        private InputList<string>? _auditNonHmacResponseKeys;

        /// <summary>
        /// Specifies the list of keys that will not be HMAC'd by audit devices in the response data object.
        /// </summary>
        public InputList<string> AuditNonHmacResponseKeys
        {
            get => _auditNonHmacResponseKeys ?? (_auditNonHmacResponseKeys = new InputList<string>());
            set => _auditNonHmacResponseKeys = value;
        }

        /// <summary>
        /// Default lease duration for secrets in seconds
        /// </summary>
        [Input("defaultLeaseTtlSeconds")]
        public Input<int>? DefaultLeaseTtlSeconds { get; set; }

        [Input("delegatedAuthAccessors")]
        private InputList<string>? _delegatedAuthAccessors;

        /// <summary>
        /// List of headers to allow and pass from the request to the plugin
        /// </summary>
        public InputList<string> DelegatedAuthAccessors
        {
            get => _delegatedAuthAccessors ?? (_delegatedAuthAccessors = new InputList<string>());
            set => _delegatedAuthAccessors = value;
        }

        /// <summary>
        /// Human-friendly description of the mount for the backend.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// Cancels all upcoming rotations of the root credential until unset. Requires Vault Enterprise 1.19+.
        /// </summary>
        [Input("disableAutomatedRotation")]
        public Input<bool>? DisableAutomatedRotation { get; set; }

        /// <summary>
        /// If set, opts out of mount migration on path updates.
        /// See here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)
        /// </summary>
        [Input("disableRemount")]
        public Input<bool>? DisableRemount { get; set; }

        /// <summary>
        /// Enable the secrets engine to access Vault's external entropy source
        /// </summary>
        [Input("externalEntropyAccess")]
        public Input<bool>? ExternalEntropyAccess { get; set; }

        /// <summary>
        /// If set to true, disables caching.
        /// </summary>
        [Input("forceNoCache")]
        public Input<bool>? ForceNoCache { get; set; }

        /// <summary>
        /// Specifies a custom HTTP IAM endpoint to use.
        /// </summary>
        [Input("iamEndpoint")]
        public Input<string>? IamEndpoint { get; set; }

        /// <summary>
        /// The audience claim value. Requires Vault 1.16+.
        /// </summary>
        [Input("identityTokenAudience")]
        public Input<string>? IdentityTokenAudience { get; set; }

        /// <summary>
        /// The key to use for signing identity tokens.
        /// </summary>
        [Input("identityTokenKey")]
        public Input<string>? IdentityTokenKey { get; set; }

        /// <summary>
        /// The TTL of generated identity tokens in seconds. Requires Vault 1.16+.
        /// </summary>
        [Input("identityTokenTtl")]
        public Input<int>? IdentityTokenTtl { get; set; }

        /// <summary>
        /// Specifies whether to show this mount in the UI-specific listing endpoint
        /// </summary>
        [Input("listingVisibility")]
        public Input<string>? ListingVisibility { get; set; }

        /// <summary>
        /// Specifies if the secret backend is local only
        /// </summary>
        [Input("local")]
        public Input<bool>? Local { get; set; }

        /// <summary>
        /// Maximum possible lease duration for secrets in seconds
        /// </summary>
        [Input("maxLeaseTtlSeconds")]
        public Input<int>? MaxLeaseTtlSeconds { get; set; }

        /// <summary>
        /// Number of max retries the client should use for recoverable errors.
        /// </summary>
        [Input("maxRetries")]
        public Input<int>? MaxRetries { get; set; }

        /// <summary>
        /// The namespace to provision the resource in.
        /// The value should not contain leading or trailing forward slashes.
        /// The `Namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault/index.html#namespace).
        /// *Available only for Vault Enterprise*.
        /// </summary>
        [Input("namespace")]
        public Input<string>? Namespace { get; set; }

        [Input("options")]
        private InputMap<string>? _options;

        /// <summary>
        /// Specifies mount type specific options that are passed to the backend
        /// </summary>
        public InputMap<string> Options
        {
            get => _options ?? (_options = new InputMap<string>());
            set => _options = value;
        }

        [Input("passthroughRequestHeaders")]
        private InputList<string>? _passthroughRequestHeaders;

        /// <summary>
        /// List of headers to allow and pass from the request to the plugin
        /// </summary>
        public InputList<string> PassthroughRequestHeaders
        {
            get => _passthroughRequestHeaders ?? (_passthroughRequestHeaders = new InputList<string>());
            set => _passthroughRequestHeaders = value;
        }

        /// <summary>
        /// The unique path this backend should be mounted at. Must
        /// not begin or end with a `/`. Defaults to `Aws`.
        /// </summary>
        [Input("path")]
        public Input<string>? Path { get; set; }

        /// <summary>
        /// Specifies the semantic version of the plugin to use, e.g. 'v1.0.0'
        /// </summary>
        [Input("pluginVersion")]
        public Input<string>? PluginVersion { get; set; }

        /// <summary>
        /// The AWS region for API calls. Defaults to `us-east-1`.
        /// 
        /// &gt; **Important** The same limitation noted above for the `AccessKey` parameter
        /// also applies to the `Region` parameter. Vault versions 1.2.3 and older will not
        /// allow Terraform to detect (and thus correct) drift in the `Region` parameter,
        /// while newer versions of Vault will.
        /// </summary>
        [Input("region")]
        public Input<string>? Region { get; set; }

        /// <summary>
        /// Role ARN to assume for plugin identity token federation. Requires Vault 1.16+.
        /// </summary>
        [Input("roleArn")]
        public Input<string>? RoleArn { get; set; }

        /// <summary>
        /// The amount of time in seconds Vault should wait before rotating the root credential. 
        /// A zero value tells Vault not to rotate the root credential. The minimum rotation period is 10 seconds. Requires Vault Enterprise 1.19+.
        /// </summary>
        [Input("rotationPeriod")]
        public Input<int>? RotationPeriod { get; set; }

        /// <summary>
        /// The schedule, in [cron-style time format](https://en.wikipedia.org/wiki/Cron),
        /// defining the schedule on which Vault should rotate the root token. Requires Vault Enterprise 1.19+.
        /// </summary>
        [Input("rotationSchedule")]
        public Input<string>? RotationSchedule { get; set; }

        /// <summary>
        /// The maximum amount of time in seconds allowed to complete
        /// a rotation when a scheduled token rotation occurs. The default rotation window is
        /// unbound and the minimum allowable window is `3600`. Requires Vault Enterprise 1.19+.
        /// </summary>
        [Input("rotationWindow")]
        public Input<int>? RotationWindow { get; set; }

        /// <summary>
        /// Enable seal wrapping for the mount, causing values stored by the mount to be wrapped by the seal's encryption capability
        /// </summary>
        [Input("sealWrap")]
        public Input<bool>? SealWrap { get; set; }

        [Input("secretKey")]
        private Input<string>? _secretKey;

        /// <summary>
        /// The AWS Secret Key this backend should use to
        /// issue new credentials. Vault uses the official AWS SDK to authenticate, and thus can also use standard AWS environment credentials, shared file credentials or IAM role/ECS task credentials. Conflicts with `SecretKeyWo`.
        /// 
        /// &gt; **Important** Vault version 1.2.3 and older does not support reading the configured
        /// credentials back from the API, With these older versions, Terraform cannot detect and correct drift
        /// on `AccessKey` or `SecretKey`. Changing the values, however, _will_
        /// overwrite the previously stored values. With versions of Vault newer than
        /// 1.2.3, reading the `AccessKey` only is supported, and so drifts of the
        /// `AccessKey` will be detected and corrected, but drifts on the `SecretKey`
        /// will not.
        /// </summary>
        public Input<string>? SecretKey
        {
            get => _secretKey;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _secretKey = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        [Input("secretKeyWo")]
        private Input<string>? _secretKeyWo;

        /// <summary>
        /// **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        /// The AWS Secret Access Key to use when generating new credentials. This is a write-only field and will not be read back from Vault.
        /// </summary>
        public Input<string>? SecretKeyWo
        {
            get => _secretKeyWo;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _secretKeyWo = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// A version counter for the write-only SecretKeyWo field. Incrementing this value will trigger an update to the secret_key.
        /// </summary>
        [Input("secretKeyWoVersion")]
        public Input<int>? SecretKeyWoVersion { get; set; }

        /// <summary>
        /// Specifies a custom HTTP STS endpoint to use.
        /// </summary>
        [Input("stsEndpoint")]
        public Input<string>? StsEndpoint { get; set; }

        [Input("stsFallbackEndpoints")]
        private InputList<string>? _stsFallbackEndpoints;

        /// <summary>
        /// Ordered list of `StsEndpoint`s to try if the defined one fails. Requires Vault 1.19+
        /// </summary>
        public InputList<string> StsFallbackEndpoints
        {
            get => _stsFallbackEndpoints ?? (_stsFallbackEndpoints = new InputList<string>());
            set => _stsFallbackEndpoints = value;
        }

        [Input("stsFallbackRegions")]
        private InputList<string>? _stsFallbackRegions;

        /// <summary>
        /// Ordered list of `StsRegion`s matching the fallback endpoints. Should correspond in order with those endpoints. Requires Vault 1.19+
        /// </summary>
        public InputList<string> StsFallbackRegions
        {
            get => _stsFallbackRegions ?? (_stsFallbackRegions = new InputList<string>());
            set => _stsFallbackRegions = value;
        }

        /// <summary>
        /// Specifies the region of the STS endpoint. Should be included if `StsEndpoint` is supplied. Requires Vault 1.19+
        /// </summary>
        [Input("stsRegion")]
        public Input<string>? StsRegion { get; set; }

        /// <summary>
        /// Template describing how dynamic usernames are generated. The username template is used to generate both IAM usernames (capped at 64 characters) and STS usernames (capped at 32 characters). If no template is provided the field defaults to the template:
        /// 
        /// ```
        /// {{ if (eq .Type "STS") }}
        /// {{ printf "vault-%s-%s" (unix_time) (random 20) | truncate 32 }}
        /// {{ else }}
        /// {{ printf "vault-%s-%s-%s" (printf "%s-%s" (.DisplayName) (.PolicyName) | truncate 42) (unix_time) (random 20) | truncate 64 }}
        /// {{ end }}
        /// 
        /// ```
        /// </summary>
        [Input("usernameTemplate")]
        public Input<string>? UsernameTemplate { get; set; }

        public SecretBackendState()
        {
        }
        public static new SecretBackendState Empty => new SecretBackendState();
    }
}
