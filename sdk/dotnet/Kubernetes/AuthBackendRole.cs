// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Vault.Kubernetes
{
    /// <summary>
    /// Manages an Kubernetes auth backend role in a Vault server. See the [Vault
    /// documentation](https://www.vaultproject.io/docs/auth/kubernetes.html) for more
    /// information.
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using Pulumi;
    /// using Vault = Pulumi.Vault;
    /// 
    /// class MyStack : Stack
    /// {
    ///     public MyStack()
    ///     {
    ///         var kubernetes = new Vault.AuthBackend("kubernetes", new Vault.AuthBackendArgs
    ///         {
    ///             Type = "kubernetes",
    ///         });
    ///         var example = new Vault.Kubernetes.AuthBackendRole("example", new Vault.Kubernetes.AuthBackendRoleArgs
    ///         {
    ///             Backend = kubernetes.Path,
    ///             BoundServiceAccountNames = 
    ///             {
    ///                 "example",
    ///             },
    ///             BoundServiceAccountNamespaces = 
    ///             {
    ///                 "example",
    ///             },
    ///             Policies = 
    ///             {
    ///                 "default",
    ///                 "dev",
    ///                 "prod",
    ///             },
    ///             RoleName = "example-role",
    ///             Ttl = 3600,
    ///         });
    ///     }
    /// 
    /// }
    /// ```
    /// </summary>
    public partial class AuthBackendRole : Pulumi.CustomResource
    {
        /// <summary>
        /// Optional Audience claim to verify in the JWT.
        /// </summary>
        [Output("audience")]
        public Output<string?> Audience { get; private set; } = null!;

        /// <summary>
        /// Unique name of the kubernetes backend to configure.
        /// </summary>
        [Output("backend")]
        public Output<string?> Backend { get; private set; } = null!;

        /// <summary>
        /// List of CIDRs valid as the source address for login requests. This value is also encoded into any resulting token.
        /// </summary>
        [Output("boundCidrs")]
        public Output<ImmutableArray<string>> BoundCidrs { get; private set; } = null!;

        /// <summary>
        /// List of service account names able to access this role. If set to `["*"]` all names are allowed, both this and bound_service_account_namespaces can not be "*".
        /// </summary>
        [Output("boundServiceAccountNames")]
        public Output<ImmutableArray<string>> BoundServiceAccountNames { get; private set; } = null!;

        /// <summary>
        /// List of namespaces allowed to access this role. If set to `["*"]` all namespaces are allowed, both this and bound_service_account_names can not be set to "*".
        /// </summary>
        [Output("boundServiceAccountNamespaces")]
        public Output<ImmutableArray<string>> BoundServiceAccountNamespaces { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed lifetime of tokens issued in seconds using this role.
        /// </summary>
        [Output("maxTtl")]
        public Output<int?> MaxTtl { get; private set; } = null!;

        /// <summary>
        /// Number of times issued tokens can be used. Setting this to 0 or leaving it unset means unlimited uses.
        /// </summary>
        [Output("numUses")]
        public Output<int?> NumUses { get; private set; } = null!;

        /// <summary>
        /// If set, indicates that the token generated using this role should never expire. The token should be renewed within the duration specified by this value. At each renewal, the token's TTL will be set to the value of this parameter.
        /// </summary>
        [Output("period")]
        public Output<int?> Period { get; private set; } = null!;

        /// <summary>
        /// Policies to be set on tokens issued using this role.
        /// </summary>
        [Output("policies")]
        public Output<ImmutableArray<string>> Policies { get; private set; } = null!;

        /// <summary>
        /// Name of the role.
        /// </summary>
        [Output("roleName")]
        public Output<string> RoleName { get; private set; } = null!;

        /// <summary>
        /// Specifies the blocks of IP addresses which are allowed to use the generated token
        /// </summary>
        [Output("tokenBoundCidrs")]
        public Output<ImmutableArray<string>> TokenBoundCidrs { get; private set; } = null!;

        /// <summary>
        /// Generated Token's Explicit Maximum TTL in seconds
        /// </summary>
        [Output("tokenExplicitMaxTtl")]
        public Output<int?> TokenExplicitMaxTtl { get; private set; } = null!;

        /// <summary>
        /// The maximum lifetime of the generated token
        /// </summary>
        [Output("tokenMaxTtl")]
        public Output<int?> TokenMaxTtl { get; private set; } = null!;

        /// <summary>
        /// If true, the 'default' policy will not automatically be added to generated tokens
        /// </summary>
        [Output("tokenNoDefaultPolicy")]
        public Output<bool?> TokenNoDefaultPolicy { get; private set; } = null!;

        /// <summary>
        /// The maximum number of times a token may be used, a value of zero means unlimited
        /// </summary>
        [Output("tokenNumUses")]
        public Output<int?> TokenNumUses { get; private set; } = null!;

        /// <summary>
        /// Generated Token's Period
        /// </summary>
        [Output("tokenPeriod")]
        public Output<int?> TokenPeriod { get; private set; } = null!;

        /// <summary>
        /// Generated Token's Policies
        /// </summary>
        [Output("tokenPolicies")]
        public Output<ImmutableArray<string>> TokenPolicies { get; private set; } = null!;

        /// <summary>
        /// The initial ttl of the token to generate in seconds
        /// </summary>
        [Output("tokenTtl")]
        public Output<int?> TokenTtl { get; private set; } = null!;

        /// <summary>
        /// The type of token to generate, service or batch
        /// </summary>
        [Output("tokenType")]
        public Output<string?> TokenType { get; private set; } = null!;

        /// <summary>
        /// The TTL period of tokens issued using this role in seconds.
        /// </summary>
        [Output("ttl")]
        public Output<int?> Ttl { get; private set; } = null!;


        /// <summary>
        /// Create a AuthBackendRole resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public AuthBackendRole(string name, AuthBackendRoleArgs args, CustomResourceOptions? options = null)
            : base("vault:kubernetes/authBackendRole:AuthBackendRole", name, args ?? new AuthBackendRoleArgs(), MakeResourceOptions(options, ""))
        {
        }

        private AuthBackendRole(string name, Input<string> id, AuthBackendRoleState? state = null, CustomResourceOptions? options = null)
            : base("vault:kubernetes/authBackendRole:AuthBackendRole", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing AuthBackendRole resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static AuthBackendRole Get(string name, Input<string> id, AuthBackendRoleState? state = null, CustomResourceOptions? options = null)
        {
            return new AuthBackendRole(name, id, state, options);
        }
    }

    public sealed class AuthBackendRoleArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Optional Audience claim to verify in the JWT.
        /// </summary>
        [Input("audience")]
        public Input<string>? Audience { get; set; }

        /// <summary>
        /// Unique name of the kubernetes backend to configure.
        /// </summary>
        [Input("backend")]
        public Input<string>? Backend { get; set; }

        [Input("boundCidrs")]
        private InputList<string>? _boundCidrs;

        /// <summary>
        /// List of CIDRs valid as the source address for login requests. This value is also encoded into any resulting token.
        /// </summary>
        [Obsolete(@"use `token_bound_cidrs` instead if you are running Vault >= 1.2")]
        public InputList<string> BoundCidrs
        {
            get => _boundCidrs ?? (_boundCidrs = new InputList<string>());
            set => _boundCidrs = value;
        }

        [Input("boundServiceAccountNames", required: true)]
        private InputList<string>? _boundServiceAccountNames;

        /// <summary>
        /// List of service account names able to access this role. If set to `["*"]` all names are allowed, both this and bound_service_account_namespaces can not be "*".
        /// </summary>
        public InputList<string> BoundServiceAccountNames
        {
            get => _boundServiceAccountNames ?? (_boundServiceAccountNames = new InputList<string>());
            set => _boundServiceAccountNames = value;
        }

        [Input("boundServiceAccountNamespaces", required: true)]
        private InputList<string>? _boundServiceAccountNamespaces;

        /// <summary>
        /// List of namespaces allowed to access this role. If set to `["*"]` all namespaces are allowed, both this and bound_service_account_names can not be set to "*".
        /// </summary>
        public InputList<string> BoundServiceAccountNamespaces
        {
            get => _boundServiceAccountNamespaces ?? (_boundServiceAccountNamespaces = new InputList<string>());
            set => _boundServiceAccountNamespaces = value;
        }

        /// <summary>
        /// The maximum allowed lifetime of tokens issued in seconds using this role.
        /// </summary>
        [Input("maxTtl")]
        public Input<int>? MaxTtl { get; set; }

        /// <summary>
        /// Number of times issued tokens can be used. Setting this to 0 or leaving it unset means unlimited uses.
        /// </summary>
        [Input("numUses")]
        public Input<int>? NumUses { get; set; }

        /// <summary>
        /// If set, indicates that the token generated using this role should never expire. The token should be renewed within the duration specified by this value. At each renewal, the token's TTL will be set to the value of this parameter.
        /// </summary>
        [Input("period")]
        public Input<int>? Period { get; set; }

        [Input("policies")]
        private InputList<string>? _policies;

        /// <summary>
        /// Policies to be set on tokens issued using this role.
        /// </summary>
        [Obsolete(@"use `token_policies` instead if you are running Vault >= 1.2")]
        public InputList<string> Policies
        {
            get => _policies ?? (_policies = new InputList<string>());
            set => _policies = value;
        }

        /// <summary>
        /// Name of the role.
        /// </summary>
        [Input("roleName", required: true)]
        public Input<string> RoleName { get; set; } = null!;

        [Input("tokenBoundCidrs")]
        private InputList<string>? _tokenBoundCidrs;

        /// <summary>
        /// Specifies the blocks of IP addresses which are allowed to use the generated token
        /// </summary>
        public InputList<string> TokenBoundCidrs
        {
            get => _tokenBoundCidrs ?? (_tokenBoundCidrs = new InputList<string>());
            set => _tokenBoundCidrs = value;
        }

        /// <summary>
        /// Generated Token's Explicit Maximum TTL in seconds
        /// </summary>
        [Input("tokenExplicitMaxTtl")]
        public Input<int>? TokenExplicitMaxTtl { get; set; }

        /// <summary>
        /// The maximum lifetime of the generated token
        /// </summary>
        [Input("tokenMaxTtl")]
        public Input<int>? TokenMaxTtl { get; set; }

        /// <summary>
        /// If true, the 'default' policy will not automatically be added to generated tokens
        /// </summary>
        [Input("tokenNoDefaultPolicy")]
        public Input<bool>? TokenNoDefaultPolicy { get; set; }

        /// <summary>
        /// The maximum number of times a token may be used, a value of zero means unlimited
        /// </summary>
        [Input("tokenNumUses")]
        public Input<int>? TokenNumUses { get; set; }

        /// <summary>
        /// Generated Token's Period
        /// </summary>
        [Input("tokenPeriod")]
        public Input<int>? TokenPeriod { get; set; }

        [Input("tokenPolicies")]
        private InputList<string>? _tokenPolicies;

        /// <summary>
        /// Generated Token's Policies
        /// </summary>
        public InputList<string> TokenPolicies
        {
            get => _tokenPolicies ?? (_tokenPolicies = new InputList<string>());
            set => _tokenPolicies = value;
        }

        /// <summary>
        /// The initial ttl of the token to generate in seconds
        /// </summary>
        [Input("tokenTtl")]
        public Input<int>? TokenTtl { get; set; }

        /// <summary>
        /// The type of token to generate, service or batch
        /// </summary>
        [Input("tokenType")]
        public Input<string>? TokenType { get; set; }

        /// <summary>
        /// The TTL period of tokens issued using this role in seconds.
        /// </summary>
        [Input("ttl")]
        public Input<int>? Ttl { get; set; }

        public AuthBackendRoleArgs()
        {
        }
    }

    public sealed class AuthBackendRoleState : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Optional Audience claim to verify in the JWT.
        /// </summary>
        [Input("audience")]
        public Input<string>? Audience { get; set; }

        /// <summary>
        /// Unique name of the kubernetes backend to configure.
        /// </summary>
        [Input("backend")]
        public Input<string>? Backend { get; set; }

        [Input("boundCidrs")]
        private InputList<string>? _boundCidrs;

        /// <summary>
        /// List of CIDRs valid as the source address for login requests. This value is also encoded into any resulting token.
        /// </summary>
        [Obsolete(@"use `token_bound_cidrs` instead if you are running Vault >= 1.2")]
        public InputList<string> BoundCidrs
        {
            get => _boundCidrs ?? (_boundCidrs = new InputList<string>());
            set => _boundCidrs = value;
        }

        [Input("boundServiceAccountNames")]
        private InputList<string>? _boundServiceAccountNames;

        /// <summary>
        /// List of service account names able to access this role. If set to `["*"]` all names are allowed, both this and bound_service_account_namespaces can not be "*".
        /// </summary>
        public InputList<string> BoundServiceAccountNames
        {
            get => _boundServiceAccountNames ?? (_boundServiceAccountNames = new InputList<string>());
            set => _boundServiceAccountNames = value;
        }

        [Input("boundServiceAccountNamespaces")]
        private InputList<string>? _boundServiceAccountNamespaces;

        /// <summary>
        /// List of namespaces allowed to access this role. If set to `["*"]` all namespaces are allowed, both this and bound_service_account_names can not be set to "*".
        /// </summary>
        public InputList<string> BoundServiceAccountNamespaces
        {
            get => _boundServiceAccountNamespaces ?? (_boundServiceAccountNamespaces = new InputList<string>());
            set => _boundServiceAccountNamespaces = value;
        }

        /// <summary>
        /// The maximum allowed lifetime of tokens issued in seconds using this role.
        /// </summary>
        [Input("maxTtl")]
        public Input<int>? MaxTtl { get; set; }

        /// <summary>
        /// Number of times issued tokens can be used. Setting this to 0 or leaving it unset means unlimited uses.
        /// </summary>
        [Input("numUses")]
        public Input<int>? NumUses { get; set; }

        /// <summary>
        /// If set, indicates that the token generated using this role should never expire. The token should be renewed within the duration specified by this value. At each renewal, the token's TTL will be set to the value of this parameter.
        /// </summary>
        [Input("period")]
        public Input<int>? Period { get; set; }

        [Input("policies")]
        private InputList<string>? _policies;

        /// <summary>
        /// Policies to be set on tokens issued using this role.
        /// </summary>
        [Obsolete(@"use `token_policies` instead if you are running Vault >= 1.2")]
        public InputList<string> Policies
        {
            get => _policies ?? (_policies = new InputList<string>());
            set => _policies = value;
        }

        /// <summary>
        /// Name of the role.
        /// </summary>
        [Input("roleName")]
        public Input<string>? RoleName { get; set; }

        [Input("tokenBoundCidrs")]
        private InputList<string>? _tokenBoundCidrs;

        /// <summary>
        /// Specifies the blocks of IP addresses which are allowed to use the generated token
        /// </summary>
        public InputList<string> TokenBoundCidrs
        {
            get => _tokenBoundCidrs ?? (_tokenBoundCidrs = new InputList<string>());
            set => _tokenBoundCidrs = value;
        }

        /// <summary>
        /// Generated Token's Explicit Maximum TTL in seconds
        /// </summary>
        [Input("tokenExplicitMaxTtl")]
        public Input<int>? TokenExplicitMaxTtl { get; set; }

        /// <summary>
        /// The maximum lifetime of the generated token
        /// </summary>
        [Input("tokenMaxTtl")]
        public Input<int>? TokenMaxTtl { get; set; }

        /// <summary>
        /// If true, the 'default' policy will not automatically be added to generated tokens
        /// </summary>
        [Input("tokenNoDefaultPolicy")]
        public Input<bool>? TokenNoDefaultPolicy { get; set; }

        /// <summary>
        /// The maximum number of times a token may be used, a value of zero means unlimited
        /// </summary>
        [Input("tokenNumUses")]
        public Input<int>? TokenNumUses { get; set; }

        /// <summary>
        /// Generated Token's Period
        /// </summary>
        [Input("tokenPeriod")]
        public Input<int>? TokenPeriod { get; set; }

        [Input("tokenPolicies")]
        private InputList<string>? _tokenPolicies;

        /// <summary>
        /// Generated Token's Policies
        /// </summary>
        public InputList<string> TokenPolicies
        {
            get => _tokenPolicies ?? (_tokenPolicies = new InputList<string>());
            set => _tokenPolicies = value;
        }

        /// <summary>
        /// The initial ttl of the token to generate in seconds
        /// </summary>
        [Input("tokenTtl")]
        public Input<int>? TokenTtl { get; set; }

        /// <summary>
        /// The type of token to generate, service or batch
        /// </summary>
        [Input("tokenType")]
        public Input<string>? TokenType { get; set; }

        /// <summary>
        /// The TTL period of tokens issued using this role in seconds.
        /// </summary>
        [Input("ttl")]
        public Input<int>? Ttl { get; set; }

        public AuthBackendRoleState()
        {
        }
    }
}
