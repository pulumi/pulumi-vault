// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Vault.Kubernetes
{
    /// <summary>
    /// Manages an Kubernetes auth backend role in a Vault server. See the [Vault
    /// documentation](https://www.vaultproject.io/docs/auth/kubernetes.html) for more
    /// information.
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Vault = Pulumi.Vault;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var kubernetes = new Vault.AuthBackend("kubernetes", new()
    ///     {
    ///         Type = "kubernetes",
    ///     });
    /// 
    ///     var example = new Vault.Kubernetes.AuthBackendRole("example", new()
    ///     {
    ///         Backend = kubernetes.Path,
    ///         RoleName = "example-role",
    ///         BoundServiceAccountNames = new[]
    ///         {
    ///             "example",
    ///         },
    ///         BoundServiceAccountNamespaces = new[]
    ///         {
    ///             "example",
    ///         },
    ///         TokenTtl = 3600,
    ///         TokenPolicies = new[]
    ///         {
    ///             "default",
    ///             "dev",
    ///             "prod",
    ///         },
    ///         Audience = "vault",
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// Kubernetes auth backend role can be imported using the `path`, e.g.
    /// 
    /// ```sh
    /// $ pulumi import vault:kubernetes/authBackendRole:AuthBackendRole foo auth/kubernetes/role/foo
    /// ```
    /// </summary>
    [VaultResourceType("vault:kubernetes/authBackendRole:AuthBackendRole")]
    public partial class AuthBackendRole : global::Pulumi.CustomResource
    {
        /// <summary>
        /// The metadata to be tied to generated entity alias.
        ///   This should be a list or map containing the metadata in key value pairs.
        /// </summary>
        [Output("aliasMetadata")]
        public Output<ImmutableDictionary<string, string>?> AliasMetadata { get; private set; } = null!;

        /// <summary>
        /// Configures how identity aliases are generated.
        /// Valid choices are: `ServiceaccountUid`, `ServiceaccountName`. (vault-1.9+)
        /// </summary>
        [Output("aliasNameSource")]
        public Output<string> AliasNameSource { get; private set; } = null!;

        /// <summary>
        /// Audience claim to verify in the JWT.
        /// 
        /// &gt; Please see [AliasNameSource](https://www.vaultproject.io/api-docs/auth/kubernetes#alias_name_source)
        /// before setting this to something other its default value. There are **important** security
        /// implications to be aware of.
        /// </summary>
        [Output("audience")]
        public Output<string?> Audience { get; private set; } = null!;

        /// <summary>
        /// Unique name of the kubernetes backend to configure.
        /// </summary>
        [Output("backend")]
        public Output<string?> Backend { get; private set; } = null!;

        /// <summary>
        /// List of service account names able to access this role. If set to `["*"]` all names are allowed, both this and BoundServiceAccountNamespaces can not be "*".
        /// </summary>
        [Output("boundServiceAccountNames")]
        public Output<ImmutableArray<string>> BoundServiceAccountNames { get; private set; } = null!;

        /// <summary>
        /// A label selector for Kubernetes namespaces allowed to access this role. Accepts either a JSON or YAML object. The value should be of type LabelSelector. Currently, label selectors with matchExpressions are not supported. To use label selectors, Vault must have permission to read namespaces on the Kubernetes cluster. If set with bound_service_account_namespaces, the conditions are ORed. Requires Vault v1.16+.
        /// </summary>
        [Output("boundServiceAccountNamespaceSelector")]
        public Output<string?> BoundServiceAccountNamespaceSelector { get; private set; } = null!;

        /// <summary>
        /// List of namespaces allowed to access this role. If set to `["*"]` all namespaces are allowed, both this and BoundServiceAccountNames can not be set to "*".
        /// </summary>
        [Output("boundServiceAccountNamespaces")]
        public Output<ImmutableArray<string>> BoundServiceAccountNamespaces { get; private set; } = null!;

        /// <summary>
        /// The namespace to provision the resource in.
        /// The value should not contain leading or trailing forward slashes.
        /// The `Namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault/index.html#namespace).
        /// *Available only for Vault Enterprise*.
        /// </summary>
        [Output("namespace")]
        public Output<string?> Namespace { get; private set; } = null!;

        /// <summary>
        /// Name of the role.
        /// </summary>
        [Output("roleName")]
        public Output<string> RoleName { get; private set; } = null!;

        /// <summary>
        /// Specifies the blocks of IP addresses which are allowed to use the generated token
        /// </summary>
        [Output("tokenBoundCidrs")]
        public Output<ImmutableArray<string>> TokenBoundCidrs { get; private set; } = null!;

        /// <summary>
        /// Generated Token's Explicit Maximum TTL in seconds
        /// </summary>
        [Output("tokenExplicitMaxTtl")]
        public Output<int?> TokenExplicitMaxTtl { get; private set; } = null!;

        /// <summary>
        /// The maximum lifetime of the generated token
        /// </summary>
        [Output("tokenMaxTtl")]
        public Output<int?> TokenMaxTtl { get; private set; } = null!;

        /// <summary>
        /// If true, the 'default' policy will not automatically be added to generated tokens
        /// </summary>
        [Output("tokenNoDefaultPolicy")]
        public Output<bool?> TokenNoDefaultPolicy { get; private set; } = null!;

        /// <summary>
        /// The maximum number of times a token may be used, a value of zero means unlimited
        /// </summary>
        [Output("tokenNumUses")]
        public Output<int?> TokenNumUses { get; private set; } = null!;

        /// <summary>
        /// Generated Token's Period
        /// </summary>
        [Output("tokenPeriod")]
        public Output<int?> TokenPeriod { get; private set; } = null!;

        /// <summary>
        /// Generated Token's Policies
        /// </summary>
        [Output("tokenPolicies")]
        public Output<ImmutableArray<string>> TokenPolicies { get; private set; } = null!;

        /// <summary>
        /// The initial ttl of the token to generate in seconds
        /// </summary>
        [Output("tokenTtl")]
        public Output<int?> TokenTtl { get; private set; } = null!;

        /// <summary>
        /// The type of token to generate, service or batch
        /// </summary>
        [Output("tokenType")]
        public Output<string?> TokenType { get; private set; } = null!;


        /// <summary>
        /// Create a AuthBackendRole resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public AuthBackendRole(string name, AuthBackendRoleArgs args, CustomResourceOptions? options = null)
            : base("vault:kubernetes/authBackendRole:AuthBackendRole", name, args ?? new AuthBackendRoleArgs(), MakeResourceOptions(options, ""))
        {
        }

        private AuthBackendRole(string name, Input<string> id, AuthBackendRoleState? state = null, CustomResourceOptions? options = null)
            : base("vault:kubernetes/authBackendRole:AuthBackendRole", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing AuthBackendRole resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static AuthBackendRole Get(string name, Input<string> id, AuthBackendRoleState? state = null, CustomResourceOptions? options = null)
        {
            return new AuthBackendRole(name, id, state, options);
        }
    }

    public sealed class AuthBackendRoleArgs : global::Pulumi.ResourceArgs
    {
        [Input("aliasMetadata")]
        private InputMap<string>? _aliasMetadata;

        /// <summary>
        /// The metadata to be tied to generated entity alias.
        ///   This should be a list or map containing the metadata in key value pairs.
        /// </summary>
        public InputMap<string> AliasMetadata
        {
            get => _aliasMetadata ?? (_aliasMetadata = new InputMap<string>());
            set => _aliasMetadata = value;
        }

        /// <summary>
        /// Configures how identity aliases are generated.
        /// Valid choices are: `ServiceaccountUid`, `ServiceaccountName`. (vault-1.9+)
        /// </summary>
        [Input("aliasNameSource")]
        public Input<string>? AliasNameSource { get; set; }

        /// <summary>
        /// Audience claim to verify in the JWT.
        /// 
        /// &gt; Please see [AliasNameSource](https://www.vaultproject.io/api-docs/auth/kubernetes#alias_name_source)
        /// before setting this to something other its default value. There are **important** security
        /// implications to be aware of.
        /// </summary>
        [Input("audience")]
        public Input<string>? Audience { get; set; }

        /// <summary>
        /// Unique name of the kubernetes backend to configure.
        /// </summary>
        [Input("backend")]
        public Input<string>? Backend { get; set; }

        [Input("boundServiceAccountNames", required: true)]
        private InputList<string>? _boundServiceAccountNames;

        /// <summary>
        /// List of service account names able to access this role. If set to `["*"]` all names are allowed, both this and BoundServiceAccountNamespaces can not be "*".
        /// </summary>
        public InputList<string> BoundServiceAccountNames
        {
            get => _boundServiceAccountNames ?? (_boundServiceAccountNames = new InputList<string>());
            set => _boundServiceAccountNames = value;
        }

        /// <summary>
        /// A label selector for Kubernetes namespaces allowed to access this role. Accepts either a JSON or YAML object. The value should be of type LabelSelector. Currently, label selectors with matchExpressions are not supported. To use label selectors, Vault must have permission to read namespaces on the Kubernetes cluster. If set with bound_service_account_namespaces, the conditions are ORed. Requires Vault v1.16+.
        /// </summary>
        [Input("boundServiceAccountNamespaceSelector")]
        public Input<string>? BoundServiceAccountNamespaceSelector { get; set; }

        [Input("boundServiceAccountNamespaces")]
        private InputList<string>? _boundServiceAccountNamespaces;

        /// <summary>
        /// List of namespaces allowed to access this role. If set to `["*"]` all namespaces are allowed, both this and BoundServiceAccountNames can not be set to "*".
        /// </summary>
        public InputList<string> BoundServiceAccountNamespaces
        {
            get => _boundServiceAccountNamespaces ?? (_boundServiceAccountNamespaces = new InputList<string>());
            set => _boundServiceAccountNamespaces = value;
        }

        /// <summary>
        /// The namespace to provision the resource in.
        /// The value should not contain leading or trailing forward slashes.
        /// The `Namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault/index.html#namespace).
        /// *Available only for Vault Enterprise*.
        /// </summary>
        [Input("namespace")]
        public Input<string>? Namespace { get; set; }

        /// <summary>
        /// Name of the role.
        /// </summary>
        [Input("roleName", required: true)]
        public Input<string> RoleName { get; set; } = null!;

        [Input("tokenBoundCidrs")]
        private InputList<string>? _tokenBoundCidrs;

        /// <summary>
        /// Specifies the blocks of IP addresses which are allowed to use the generated token
        /// </summary>
        public InputList<string> TokenBoundCidrs
        {
            get => _tokenBoundCidrs ?? (_tokenBoundCidrs = new InputList<string>());
            set => _tokenBoundCidrs = value;
        }

        /// <summary>
        /// Generated Token's Explicit Maximum TTL in seconds
        /// </summary>
        [Input("tokenExplicitMaxTtl")]
        public Input<int>? TokenExplicitMaxTtl { get; set; }

        /// <summary>
        /// The maximum lifetime of the generated token
        /// </summary>
        [Input("tokenMaxTtl")]
        public Input<int>? TokenMaxTtl { get; set; }

        /// <summary>
        /// If true, the 'default' policy will not automatically be added to generated tokens
        /// </summary>
        [Input("tokenNoDefaultPolicy")]
        public Input<bool>? TokenNoDefaultPolicy { get; set; }

        /// <summary>
        /// The maximum number of times a token may be used, a value of zero means unlimited
        /// </summary>
        [Input("tokenNumUses")]
        public Input<int>? TokenNumUses { get; set; }

        /// <summary>
        /// Generated Token's Period
        /// </summary>
        [Input("tokenPeriod")]
        public Input<int>? TokenPeriod { get; set; }

        [Input("tokenPolicies")]
        private InputList<string>? _tokenPolicies;

        /// <summary>
        /// Generated Token's Policies
        /// </summary>
        public InputList<string> TokenPolicies
        {
            get => _tokenPolicies ?? (_tokenPolicies = new InputList<string>());
            set => _tokenPolicies = value;
        }

        /// <summary>
        /// The initial ttl of the token to generate in seconds
        /// </summary>
        [Input("tokenTtl")]
        public Input<int>? TokenTtl { get; set; }

        /// <summary>
        /// The type of token to generate, service or batch
        /// </summary>
        [Input("tokenType")]
        public Input<string>? TokenType { get; set; }

        public AuthBackendRoleArgs()
        {
        }
        public static new AuthBackendRoleArgs Empty => new AuthBackendRoleArgs();
    }

    public sealed class AuthBackendRoleState : global::Pulumi.ResourceArgs
    {
        [Input("aliasMetadata")]
        private InputMap<string>? _aliasMetadata;

        /// <summary>
        /// The metadata to be tied to generated entity alias.
        ///   This should be a list or map containing the metadata in key value pairs.
        /// </summary>
        public InputMap<string> AliasMetadata
        {
            get => _aliasMetadata ?? (_aliasMetadata = new InputMap<string>());
            set => _aliasMetadata = value;
        }

        /// <summary>
        /// Configures how identity aliases are generated.
        /// Valid choices are: `ServiceaccountUid`, `ServiceaccountName`. (vault-1.9+)
        /// </summary>
        [Input("aliasNameSource")]
        public Input<string>? AliasNameSource { get; set; }

        /// <summary>
        /// Audience claim to verify in the JWT.
        /// 
        /// &gt; Please see [AliasNameSource](https://www.vaultproject.io/api-docs/auth/kubernetes#alias_name_source)
        /// before setting this to something other its default value. There are **important** security
        /// implications to be aware of.
        /// </summary>
        [Input("audience")]
        public Input<string>? Audience { get; set; }

        /// <summary>
        /// Unique name of the kubernetes backend to configure.
        /// </summary>
        [Input("backend")]
        public Input<string>? Backend { get; set; }

        [Input("boundServiceAccountNames")]
        private InputList<string>? _boundServiceAccountNames;

        /// <summary>
        /// List of service account names able to access this role. If set to `["*"]` all names are allowed, both this and BoundServiceAccountNamespaces can not be "*".
        /// </summary>
        public InputList<string> BoundServiceAccountNames
        {
            get => _boundServiceAccountNames ?? (_boundServiceAccountNames = new InputList<string>());
            set => _boundServiceAccountNames = value;
        }

        /// <summary>
        /// A label selector for Kubernetes namespaces allowed to access this role. Accepts either a JSON or YAML object. The value should be of type LabelSelector. Currently, label selectors with matchExpressions are not supported. To use label selectors, Vault must have permission to read namespaces on the Kubernetes cluster. If set with bound_service_account_namespaces, the conditions are ORed. Requires Vault v1.16+.
        /// </summary>
        [Input("boundServiceAccountNamespaceSelector")]
        public Input<string>? BoundServiceAccountNamespaceSelector { get; set; }

        [Input("boundServiceAccountNamespaces")]
        private InputList<string>? _boundServiceAccountNamespaces;

        /// <summary>
        /// List of namespaces allowed to access this role. If set to `["*"]` all namespaces are allowed, both this and BoundServiceAccountNames can not be set to "*".
        /// </summary>
        public InputList<string> BoundServiceAccountNamespaces
        {
            get => _boundServiceAccountNamespaces ?? (_boundServiceAccountNamespaces = new InputList<string>());
            set => _boundServiceAccountNamespaces = value;
        }

        /// <summary>
        /// The namespace to provision the resource in.
        /// The value should not contain leading or trailing forward slashes.
        /// The `Namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault/index.html#namespace).
        /// *Available only for Vault Enterprise*.
        /// </summary>
        [Input("namespace")]
        public Input<string>? Namespace { get; set; }

        /// <summary>
        /// Name of the role.
        /// </summary>
        [Input("roleName")]
        public Input<string>? RoleName { get; set; }

        [Input("tokenBoundCidrs")]
        private InputList<string>? _tokenBoundCidrs;

        /// <summary>
        /// Specifies the blocks of IP addresses which are allowed to use the generated token
        /// </summary>
        public InputList<string> TokenBoundCidrs
        {
            get => _tokenBoundCidrs ?? (_tokenBoundCidrs = new InputList<string>());
            set => _tokenBoundCidrs = value;
        }

        /// <summary>
        /// Generated Token's Explicit Maximum TTL in seconds
        /// </summary>
        [Input("tokenExplicitMaxTtl")]
        public Input<int>? TokenExplicitMaxTtl { get; set; }

        /// <summary>
        /// The maximum lifetime of the generated token
        /// </summary>
        [Input("tokenMaxTtl")]
        public Input<int>? TokenMaxTtl { get; set; }

        /// <summary>
        /// If true, the 'default' policy will not automatically be added to generated tokens
        /// </summary>
        [Input("tokenNoDefaultPolicy")]
        public Input<bool>? TokenNoDefaultPolicy { get; set; }

        /// <summary>
        /// The maximum number of times a token may be used, a value of zero means unlimited
        /// </summary>
        [Input("tokenNumUses")]
        public Input<int>? TokenNumUses { get; set; }

        /// <summary>
        /// Generated Token's Period
        /// </summary>
        [Input("tokenPeriod")]
        public Input<int>? TokenPeriod { get; set; }

        [Input("tokenPolicies")]
        private InputList<string>? _tokenPolicies;

        /// <summary>
        /// Generated Token's Policies
        /// </summary>
        public InputList<string> TokenPolicies
        {
            get => _tokenPolicies ?? (_tokenPolicies = new InputList<string>());
            set => _tokenPolicies = value;
        }

        /// <summary>
        /// The initial ttl of the token to generate in seconds
        /// </summary>
        [Input("tokenTtl")]
        public Input<int>? TokenTtl { get; set; }

        /// <summary>
        /// The type of token to generate, service or batch
        /// </summary>
        [Input("tokenType")]
        public Input<string>? TokenType { get; set; }

        public AuthBackendRoleState()
        {
        }
        public static new AuthBackendRoleState Empty => new AuthBackendRoleState();
    }
}
