// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.vault.transit;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class SecretBackendKeyArgs extends com.pulumi.resources.ResourceArgs {

    public static final SecretBackendKeyArgs Empty = new SecretBackendKeyArgs();

    /**
     * Enables taking backup of entire keyring in the plaintext format. Once set, this cannot be disabled.
     * * Refer to Vault API documentation on key backups for more information: [Backup Key](https://www.vaultproject.io/api-docs/secret/transit#backup-key)
     * 
     */
    @Import(name="allowPlaintextBackup")
    private @Nullable Output<Boolean> allowPlaintextBackup;

    /**
     * @return Enables taking backup of entire keyring in the plaintext format. Once set, this cannot be disabled.
     * * Refer to Vault API documentation on key backups for more information: [Backup Key](https://www.vaultproject.io/api-docs/secret/transit#backup-key)
     * 
     */
    public Optional<Output<Boolean>> allowPlaintextBackup() {
        return Optional.ofNullable(this.allowPlaintextBackup);
    }

    /**
     * Amount of seconds the key should live before being automatically rotated.
     * A value of 0 disables automatic rotation for the key.
     * 
     */
    @Import(name="autoRotatePeriod")
    private @Nullable Output<Integer> autoRotatePeriod;

    /**
     * @return Amount of seconds the key should live before being automatically rotated.
     * A value of 0 disables automatic rotation for the key.
     * 
     */
    public Optional<Output<Integer>> autoRotatePeriod() {
        return Optional.ofNullable(this.autoRotatePeriod);
    }

    /**
     * The path the transit secret backend is mounted at, with no leading or trailing `/`s.
     * 
     */
    @Import(name="backend", required=true)
    private Output<String> backend;

    /**
     * @return The path the transit secret backend is mounted at, with no leading or trailing `/`s.
     * 
     */
    public Output<String> backend() {
        return this.backend;
    }

    /**
     * Whether or not to support convergent encryption, where the same plaintext creates the same ciphertext. This requires `derived` to be set to `true`.
     * 
     */
    @Import(name="convergentEncryption")
    private @Nullable Output<Boolean> convergentEncryption;

    /**
     * @return Whether or not to support convergent encryption, where the same plaintext creates the same ciphertext. This requires `derived` to be set to `true`.
     * 
     */
    public Optional<Output<Boolean>> convergentEncryption() {
        return Optional.ofNullable(this.convergentEncryption);
    }

    /**
     * Specifies if the key is allowed to be deleted.
     * 
     */
    @Import(name="deletionAllowed")
    private @Nullable Output<Boolean> deletionAllowed;

    /**
     * @return Specifies if the key is allowed to be deleted.
     * 
     */
    public Optional<Output<Boolean>> deletionAllowed() {
        return Optional.ofNullable(this.deletionAllowed);
    }

    /**
     * Specifies if key derivation is to be used. If enabled, all encrypt/decrypt requests to this key must provide a context which is used for key derivation.
     * 
     */
    @Import(name="derived")
    private @Nullable Output<Boolean> derived;

    /**
     * @return Specifies if key derivation is to be used. If enabled, all encrypt/decrypt requests to this key must provide a context which is used for key derivation.
     * 
     */
    public Optional<Output<Boolean>> derived() {
        return Optional.ofNullable(this.derived);
    }

    /**
     * Enables keys to be exportable. This allows for all valid private keys in the keyring to be exported. Once set, this cannot be disabled.
     * 
     */
    @Import(name="exportable")
    private @Nullable Output<Boolean> exportable;

    /**
     * @return Enables keys to be exportable. This allows for all valid private keys in the keyring to be exported. Once set, this cannot be disabled.
     * 
     */
    public Optional<Output<Boolean>> exportable() {
        return Optional.ofNullable(this.exportable);
    }

    /**
     * The elliptic curve algorithm to use for hybrid signatures.
     * Supported key types are `ecdsa-p256`, `ecdsa-p384`, `ecdsa-p521`, and `ed25519`.
     * 
     */
    @Import(name="hybridKeyTypeEc")
    private @Nullable Output<String> hybridKeyTypeEc;

    /**
     * @return The elliptic curve algorithm to use for hybrid signatures.
     * Supported key types are `ecdsa-p256`, `ecdsa-p384`, `ecdsa-p521`, and `ed25519`.
     * 
     */
    public Optional<Output<String>> hybridKeyTypeEc() {
        return Optional.ofNullable(this.hybridKeyTypeEc);
    }

    /**
     * The post-quantum algorithm to use for hybrid signatures.
     * Currently, ML-DSA is the only supported key type.
     * 
     */
    @Import(name="hybridKeyTypePqc")
    private @Nullable Output<String> hybridKeyTypePqc;

    /**
     * @return The post-quantum algorithm to use for hybrid signatures.
     * Currently, ML-DSA is the only supported key type.
     * 
     */
    public Optional<Output<String>> hybridKeyTypePqc() {
        return Optional.ofNullable(this.hybridKeyTypePqc);
    }

    /**
     * The key size in bytes for algorithms that allow variable key sizes. Currently only applicable to HMAC, where it must be between 32 and 512 bytes.
     * 
     */
    @Import(name="keySize")
    private @Nullable Output<Integer> keySize;

    /**
     * @return The key size in bytes for algorithms that allow variable key sizes. Currently only applicable to HMAC, where it must be between 32 and 512 bytes.
     * 
     */
    public Optional<Output<Integer>> keySize() {
        return Optional.ofNullable(this.keySize);
    }

    /**
     * Minimum key version to use for decryption.
     * 
     */
    @Import(name="minDecryptionVersion")
    private @Nullable Output<Integer> minDecryptionVersion;

    /**
     * @return Minimum key version to use for decryption.
     * 
     */
    public Optional<Output<Integer>> minDecryptionVersion() {
        return Optional.ofNullable(this.minDecryptionVersion);
    }

    /**
     * Minimum key version to use for encryption
     * 
     */
    @Import(name="minEncryptionVersion")
    private @Nullable Output<Integer> minEncryptionVersion;

    /**
     * @return Minimum key version to use for encryption
     * 
     */
    public Optional<Output<Integer>> minEncryptionVersion() {
        return Optional.ofNullable(this.minEncryptionVersion);
    }

    /**
     * The name to identify this key within the backend. Must be unique within the backend.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The name to identify this key within the backend. Must be unique within the backend.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * The namespace to provision the resource in.
     * The value should not contain leading or trailing forward slashes.
     * The `namespace` is always relative to the provider&#39;s configured [namespace](https://www.terraform.io/docs/providers/vault/index.html#namespace).
     * *Available only for Vault Enterprise*.
     * 
     */
    @Import(name="namespace")
    private @Nullable Output<String> namespace;

    /**
     * @return The namespace to provision the resource in.
     * The value should not contain leading or trailing forward slashes.
     * The `namespace` is always relative to the provider&#39;s configured [namespace](https://www.terraform.io/docs/providers/vault/index.html#namespace).
     * *Available only for Vault Enterprise*.
     * 
     */
    public Optional<Output<String>> namespace() {
        return Optional.ofNullable(this.namespace);
    }

    /**
     * The parameter set to use for ML-DSA. Required for
     * ML-DSA and hybrid keys. Valid values are `44`, `65`, and `87`.
     * 
     */
    @Import(name="parameterSet")
    private @Nullable Output<String> parameterSet;

    /**
     * @return The parameter set to use for ML-DSA. Required for
     * ML-DSA and hybrid keys. Valid values are `44`, `65`, and `87`.
     * 
     */
    public Optional<Output<String>> parameterSet() {
        return Optional.ofNullable(this.parameterSet);
    }

    /**
     * Specifies the type of key to create. The currently-supported types are: `aes128-gcm96`, `aes256-gcm96` (default), `chacha20-poly1305`, `ed25519`, `ecdsa-p256`, `ecdsa-p384`, `ecdsa-p521`, `hmac`, `rsa-2048`, `rsa-3072` and `rsa-4096`.
     * * Refer to the Vault documentation on transit key types for more information: [Key Types](https://www.vaultproject.io/docs/secrets/transit#key-types)
     * 
     */
    @Import(name="type")
    private @Nullable Output<String> type;

    /**
     * @return Specifies the type of key to create. The currently-supported types are: `aes128-gcm96`, `aes256-gcm96` (default), `chacha20-poly1305`, `ed25519`, `ecdsa-p256`, `ecdsa-p384`, `ecdsa-p521`, `hmac`, `rsa-2048`, `rsa-3072` and `rsa-4096`.
     * * Refer to the Vault documentation on transit key types for more information: [Key Types](https://www.vaultproject.io/docs/secrets/transit#key-types)
     * 
     */
    public Optional<Output<String>> type() {
        return Optional.ofNullable(this.type);
    }

    private SecretBackendKeyArgs() {}

    private SecretBackendKeyArgs(SecretBackendKeyArgs $) {
        this.allowPlaintextBackup = $.allowPlaintextBackup;
        this.autoRotatePeriod = $.autoRotatePeriod;
        this.backend = $.backend;
        this.convergentEncryption = $.convergentEncryption;
        this.deletionAllowed = $.deletionAllowed;
        this.derived = $.derived;
        this.exportable = $.exportable;
        this.hybridKeyTypeEc = $.hybridKeyTypeEc;
        this.hybridKeyTypePqc = $.hybridKeyTypePqc;
        this.keySize = $.keySize;
        this.minDecryptionVersion = $.minDecryptionVersion;
        this.minEncryptionVersion = $.minEncryptionVersion;
        this.name = $.name;
        this.namespace = $.namespace;
        this.parameterSet = $.parameterSet;
        this.type = $.type;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(SecretBackendKeyArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private SecretBackendKeyArgs $;

        public Builder() {
            $ = new SecretBackendKeyArgs();
        }

        public Builder(SecretBackendKeyArgs defaults) {
            $ = new SecretBackendKeyArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param allowPlaintextBackup Enables taking backup of entire keyring in the plaintext format. Once set, this cannot be disabled.
         * * Refer to Vault API documentation on key backups for more information: [Backup Key](https://www.vaultproject.io/api-docs/secret/transit#backup-key)
         * 
         * @return builder
         * 
         */
        public Builder allowPlaintextBackup(@Nullable Output<Boolean> allowPlaintextBackup) {
            $.allowPlaintextBackup = allowPlaintextBackup;
            return this;
        }

        /**
         * @param allowPlaintextBackup Enables taking backup of entire keyring in the plaintext format. Once set, this cannot be disabled.
         * * Refer to Vault API documentation on key backups for more information: [Backup Key](https://www.vaultproject.io/api-docs/secret/transit#backup-key)
         * 
         * @return builder
         * 
         */
        public Builder allowPlaintextBackup(Boolean allowPlaintextBackup) {
            return allowPlaintextBackup(Output.of(allowPlaintextBackup));
        }

        /**
         * @param autoRotatePeriod Amount of seconds the key should live before being automatically rotated.
         * A value of 0 disables automatic rotation for the key.
         * 
         * @return builder
         * 
         */
        public Builder autoRotatePeriod(@Nullable Output<Integer> autoRotatePeriod) {
            $.autoRotatePeriod = autoRotatePeriod;
            return this;
        }

        /**
         * @param autoRotatePeriod Amount of seconds the key should live before being automatically rotated.
         * A value of 0 disables automatic rotation for the key.
         * 
         * @return builder
         * 
         */
        public Builder autoRotatePeriod(Integer autoRotatePeriod) {
            return autoRotatePeriod(Output.of(autoRotatePeriod));
        }

        /**
         * @param backend The path the transit secret backend is mounted at, with no leading or trailing `/`s.
         * 
         * @return builder
         * 
         */
        public Builder backend(Output<String> backend) {
            $.backend = backend;
            return this;
        }

        /**
         * @param backend The path the transit secret backend is mounted at, with no leading or trailing `/`s.
         * 
         * @return builder
         * 
         */
        public Builder backend(String backend) {
            return backend(Output.of(backend));
        }

        /**
         * @param convergentEncryption Whether or not to support convergent encryption, where the same plaintext creates the same ciphertext. This requires `derived` to be set to `true`.
         * 
         * @return builder
         * 
         */
        public Builder convergentEncryption(@Nullable Output<Boolean> convergentEncryption) {
            $.convergentEncryption = convergentEncryption;
            return this;
        }

        /**
         * @param convergentEncryption Whether or not to support convergent encryption, where the same plaintext creates the same ciphertext. This requires `derived` to be set to `true`.
         * 
         * @return builder
         * 
         */
        public Builder convergentEncryption(Boolean convergentEncryption) {
            return convergentEncryption(Output.of(convergentEncryption));
        }

        /**
         * @param deletionAllowed Specifies if the key is allowed to be deleted.
         * 
         * @return builder
         * 
         */
        public Builder deletionAllowed(@Nullable Output<Boolean> deletionAllowed) {
            $.deletionAllowed = deletionAllowed;
            return this;
        }

        /**
         * @param deletionAllowed Specifies if the key is allowed to be deleted.
         * 
         * @return builder
         * 
         */
        public Builder deletionAllowed(Boolean deletionAllowed) {
            return deletionAllowed(Output.of(deletionAllowed));
        }

        /**
         * @param derived Specifies if key derivation is to be used. If enabled, all encrypt/decrypt requests to this key must provide a context which is used for key derivation.
         * 
         * @return builder
         * 
         */
        public Builder derived(@Nullable Output<Boolean> derived) {
            $.derived = derived;
            return this;
        }

        /**
         * @param derived Specifies if key derivation is to be used. If enabled, all encrypt/decrypt requests to this key must provide a context which is used for key derivation.
         * 
         * @return builder
         * 
         */
        public Builder derived(Boolean derived) {
            return derived(Output.of(derived));
        }

        /**
         * @param exportable Enables keys to be exportable. This allows for all valid private keys in the keyring to be exported. Once set, this cannot be disabled.
         * 
         * @return builder
         * 
         */
        public Builder exportable(@Nullable Output<Boolean> exportable) {
            $.exportable = exportable;
            return this;
        }

        /**
         * @param exportable Enables keys to be exportable. This allows for all valid private keys in the keyring to be exported. Once set, this cannot be disabled.
         * 
         * @return builder
         * 
         */
        public Builder exportable(Boolean exportable) {
            return exportable(Output.of(exportable));
        }

        /**
         * @param hybridKeyTypeEc The elliptic curve algorithm to use for hybrid signatures.
         * Supported key types are `ecdsa-p256`, `ecdsa-p384`, `ecdsa-p521`, and `ed25519`.
         * 
         * @return builder
         * 
         */
        public Builder hybridKeyTypeEc(@Nullable Output<String> hybridKeyTypeEc) {
            $.hybridKeyTypeEc = hybridKeyTypeEc;
            return this;
        }

        /**
         * @param hybridKeyTypeEc The elliptic curve algorithm to use for hybrid signatures.
         * Supported key types are `ecdsa-p256`, `ecdsa-p384`, `ecdsa-p521`, and `ed25519`.
         * 
         * @return builder
         * 
         */
        public Builder hybridKeyTypeEc(String hybridKeyTypeEc) {
            return hybridKeyTypeEc(Output.of(hybridKeyTypeEc));
        }

        /**
         * @param hybridKeyTypePqc The post-quantum algorithm to use for hybrid signatures.
         * Currently, ML-DSA is the only supported key type.
         * 
         * @return builder
         * 
         */
        public Builder hybridKeyTypePqc(@Nullable Output<String> hybridKeyTypePqc) {
            $.hybridKeyTypePqc = hybridKeyTypePqc;
            return this;
        }

        /**
         * @param hybridKeyTypePqc The post-quantum algorithm to use for hybrid signatures.
         * Currently, ML-DSA is the only supported key type.
         * 
         * @return builder
         * 
         */
        public Builder hybridKeyTypePqc(String hybridKeyTypePqc) {
            return hybridKeyTypePqc(Output.of(hybridKeyTypePqc));
        }

        /**
         * @param keySize The key size in bytes for algorithms that allow variable key sizes. Currently only applicable to HMAC, where it must be between 32 and 512 bytes.
         * 
         * @return builder
         * 
         */
        public Builder keySize(@Nullable Output<Integer> keySize) {
            $.keySize = keySize;
            return this;
        }

        /**
         * @param keySize The key size in bytes for algorithms that allow variable key sizes. Currently only applicable to HMAC, where it must be between 32 and 512 bytes.
         * 
         * @return builder
         * 
         */
        public Builder keySize(Integer keySize) {
            return keySize(Output.of(keySize));
        }

        /**
         * @param minDecryptionVersion Minimum key version to use for decryption.
         * 
         * @return builder
         * 
         */
        public Builder minDecryptionVersion(@Nullable Output<Integer> minDecryptionVersion) {
            $.minDecryptionVersion = minDecryptionVersion;
            return this;
        }

        /**
         * @param minDecryptionVersion Minimum key version to use for decryption.
         * 
         * @return builder
         * 
         */
        public Builder minDecryptionVersion(Integer minDecryptionVersion) {
            return minDecryptionVersion(Output.of(minDecryptionVersion));
        }

        /**
         * @param minEncryptionVersion Minimum key version to use for encryption
         * 
         * @return builder
         * 
         */
        public Builder minEncryptionVersion(@Nullable Output<Integer> minEncryptionVersion) {
            $.minEncryptionVersion = minEncryptionVersion;
            return this;
        }

        /**
         * @param minEncryptionVersion Minimum key version to use for encryption
         * 
         * @return builder
         * 
         */
        public Builder minEncryptionVersion(Integer minEncryptionVersion) {
            return minEncryptionVersion(Output.of(minEncryptionVersion));
        }

        /**
         * @param name The name to identify this key within the backend. Must be unique within the backend.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The name to identify this key within the backend. Must be unique within the backend.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param namespace The namespace to provision the resource in.
         * The value should not contain leading or trailing forward slashes.
         * The `namespace` is always relative to the provider&#39;s configured [namespace](https://www.terraform.io/docs/providers/vault/index.html#namespace).
         * *Available only for Vault Enterprise*.
         * 
         * @return builder
         * 
         */
        public Builder namespace(@Nullable Output<String> namespace) {
            $.namespace = namespace;
            return this;
        }

        /**
         * @param namespace The namespace to provision the resource in.
         * The value should not contain leading or trailing forward slashes.
         * The `namespace` is always relative to the provider&#39;s configured [namespace](https://www.terraform.io/docs/providers/vault/index.html#namespace).
         * *Available only for Vault Enterprise*.
         * 
         * @return builder
         * 
         */
        public Builder namespace(String namespace) {
            return namespace(Output.of(namespace));
        }

        /**
         * @param parameterSet The parameter set to use for ML-DSA. Required for
         * ML-DSA and hybrid keys. Valid values are `44`, `65`, and `87`.
         * 
         * @return builder
         * 
         */
        public Builder parameterSet(@Nullable Output<String> parameterSet) {
            $.parameterSet = parameterSet;
            return this;
        }

        /**
         * @param parameterSet The parameter set to use for ML-DSA. Required for
         * ML-DSA and hybrid keys. Valid values are `44`, `65`, and `87`.
         * 
         * @return builder
         * 
         */
        public Builder parameterSet(String parameterSet) {
            return parameterSet(Output.of(parameterSet));
        }

        /**
         * @param type Specifies the type of key to create. The currently-supported types are: `aes128-gcm96`, `aes256-gcm96` (default), `chacha20-poly1305`, `ed25519`, `ecdsa-p256`, `ecdsa-p384`, `ecdsa-p521`, `hmac`, `rsa-2048`, `rsa-3072` and `rsa-4096`.
         * * Refer to the Vault documentation on transit key types for more information: [Key Types](https://www.vaultproject.io/docs/secrets/transit#key-types)
         * 
         * @return builder
         * 
         */
        public Builder type(@Nullable Output<String> type) {
            $.type = type;
            return this;
        }

        /**
         * @param type Specifies the type of key to create. The currently-supported types are: `aes128-gcm96`, `aes256-gcm96` (default), `chacha20-poly1305`, `ed25519`, `ecdsa-p256`, `ecdsa-p384`, `ecdsa-p521`, `hmac`, `rsa-2048`, `rsa-3072` and `rsa-4096`.
         * * Refer to the Vault documentation on transit key types for more information: [Key Types](https://www.vaultproject.io/docs/secrets/transit#key-types)
         * 
         * @return builder
         * 
         */
        public Builder type(String type) {
            return type(Output.of(type));
        }

        public SecretBackendKeyArgs build() {
            if ($.backend == null) {
                throw new MissingRequiredPropertyException("SecretBackendKeyArgs", "backend");
            }
            return $;
        }
    }

}
