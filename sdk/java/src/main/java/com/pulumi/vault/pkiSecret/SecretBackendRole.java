// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.vault.pkiSecret;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.vault.Utilities;
import com.pulumi.vault.pkiSecret.SecretBackendRoleArgs;
import com.pulumi.vault.pkiSecret.inputs.SecretBackendRoleState;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Creates a role on an PKI Secret Backend for Vault.
 * 
 * ## Example Usage
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.vault.Mount;
 * import com.pulumi.vault.MountArgs;
 * import com.pulumi.vault.pkiSecret.SecretBackendRole;
 * import com.pulumi.vault.pkiSecret.SecretBackendRoleArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var pki = new Mount(&#34;pki&#34;, MountArgs.builder()        
 *             .path(&#34;pki&#34;)
 *             .type(&#34;pki&#34;)
 *             .defaultLeaseTtlSeconds(3600)
 *             .maxLeaseTtlSeconds(86400)
 *             .build());
 * 
 *         var role = new SecretBackendRole(&#34;role&#34;, SecretBackendRoleArgs.builder()        
 *             .backend(pki.path())
 *             .ttl(3600)
 *             .allowIpSans(true)
 *             .keyType(&#34;rsa&#34;)
 *             .keyBits(4096)
 *             .allowedDomains(            
 *                 &#34;example.com&#34;,
 *                 &#34;my.domain&#34;)
 *             .allowSubdomains(true)
 *             .build());
 * 
 *     }
 * }
 * ```
 * 
 * ## Import
 * 
 * PKI secret backend roles can be imported using the `path`, e.g.
 * 
 * ```sh
 *  $ pulumi import vault:pkiSecret/secretBackendRole:SecretBackendRole role pki/roles/my_role
 * ```
 * 
 */
@ResourceType(type="vault:pkiSecret/secretBackendRole:SecretBackendRole")
public class SecretBackendRole extends com.pulumi.resources.CustomResource {
    /**
     * Flag to allow any name
     * 
     */
    @Export(name="allowAnyName", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> allowAnyName;

    /**
     * @return Flag to allow any name
     * 
     */
    public Output<Optional<Boolean>> allowAnyName() {
        return Codegen.optional(this.allowAnyName);
    }
    /**
     * Flag to allow certificates matching the actual domain
     * 
     */
    @Export(name="allowBareDomains", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> allowBareDomains;

    /**
     * @return Flag to allow certificates matching the actual domain
     * 
     */
    public Output<Optional<Boolean>> allowBareDomains() {
        return Codegen.optional(this.allowBareDomains);
    }
    /**
     * Flag to allow names containing glob patterns.
     * 
     */
    @Export(name="allowGlobDomains", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> allowGlobDomains;

    /**
     * @return Flag to allow names containing glob patterns.
     * 
     */
    public Output<Optional<Boolean>> allowGlobDomains() {
        return Codegen.optional(this.allowGlobDomains);
    }
    /**
     * Flag to allow IP SANs
     * 
     */
    @Export(name="allowIpSans", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> allowIpSans;

    /**
     * @return Flag to allow IP SANs
     * 
     */
    public Output<Optional<Boolean>> allowIpSans() {
        return Codegen.optional(this.allowIpSans);
    }
    /**
     * Flag to allow certificates for localhost
     * 
     */
    @Export(name="allowLocalhost", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> allowLocalhost;

    /**
     * @return Flag to allow certificates for localhost
     * 
     */
    public Output<Optional<Boolean>> allowLocalhost() {
        return Codegen.optional(this.allowLocalhost);
    }
    /**
     * Flag to allow certificates matching subdomains
     * 
     */
    @Export(name="allowSubdomains", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> allowSubdomains;

    /**
     * @return Flag to allow certificates matching subdomains
     * 
     */
    public Output<Optional<Boolean>> allowSubdomains() {
        return Codegen.optional(this.allowSubdomains);
    }
    /**
     * Flag to allow wildcard certificates.
     * 
     */
    @Export(name="allowWildcardCertificates", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> allowWildcardCertificates;

    /**
     * @return Flag to allow wildcard certificates.
     * 
     */
    public Output<Optional<Boolean>> allowWildcardCertificates() {
        return Codegen.optional(this.allowWildcardCertificates);
    }
    /**
     * List of allowed domains for certificates
     * 
     */
    @Export(name="allowedDomains", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> allowedDomains;

    /**
     * @return List of allowed domains for certificates
     * 
     */
    public Output<Optional<List<String>>> allowedDomains() {
        return Codegen.optional(this.allowedDomains);
    }
    /**
     * Flag, if set, `allowed_domains` can be specified using identity template expressions such as `{{identity.entity.aliases.&lt;mount accessor&gt;.name}}`.
     * 
     */
    @Export(name="allowedDomainsTemplate", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> allowedDomainsTemplate;

    /**
     * @return Flag, if set, `allowed_domains` can be specified using identity template expressions such as `{{identity.entity.aliases.&lt;mount accessor&gt;.name}}`.
     * 
     */
    public Output<Optional<Boolean>> allowedDomainsTemplate() {
        return Codegen.optional(this.allowedDomainsTemplate);
    }
    /**
     * Defines allowed custom SANs
     * 
     */
    @Export(name="allowedOtherSans", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> allowedOtherSans;

    /**
     * @return Defines allowed custom SANs
     * 
     */
    public Output<Optional<List<String>>> allowedOtherSans() {
        return Codegen.optional(this.allowedOtherSans);
    }
    /**
     * An array of allowed serial numbers to put in Subject
     * 
     */
    @Export(name="allowedSerialNumbers", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> allowedSerialNumbers;

    /**
     * @return An array of allowed serial numbers to put in Subject
     * 
     */
    public Output<Optional<List<String>>> allowedSerialNumbers() {
        return Codegen.optional(this.allowedSerialNumbers);
    }
    /**
     * Defines allowed URI SANs
     * 
     */
    @Export(name="allowedUriSans", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> allowedUriSans;

    /**
     * @return Defines allowed URI SANs
     * 
     */
    public Output<Optional<List<String>>> allowedUriSans() {
        return Codegen.optional(this.allowedUriSans);
    }
    /**
     * Flag, if set, `allowed_uri_sans` can be specified using identity template expressions such as `{{identity.entity.aliases.&lt;mount accessor&gt;.name}}`.
     * 
     */
    @Export(name="allowedUriSansTemplate", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> allowedUriSansTemplate;

    /**
     * @return Flag, if set, `allowed_uri_sans` can be specified using identity template expressions such as `{{identity.entity.aliases.&lt;mount accessor&gt;.name}}`.
     * 
     */
    public Output<Boolean> allowedUriSansTemplate() {
        return this.allowedUriSansTemplate;
    }
    /**
     * Defines allowed User IDs
     * 
     */
    @Export(name="allowedUserIds", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> allowedUserIds;

    /**
     * @return Defines allowed User IDs
     * 
     */
    public Output<Optional<List<String>>> allowedUserIds() {
        return Codegen.optional(this.allowedUserIds);
    }
    /**
     * The path the PKI secret backend is mounted at, with no leading or trailing `/`s.
     * 
     */
    @Export(name="backend", refs={String.class}, tree="[0]")
    private Output<String> backend;

    /**
     * @return The path the PKI secret backend is mounted at, with no leading or trailing `/`s.
     * 
     */
    public Output<String> backend() {
        return this.backend;
    }
    /**
     * Flag to mark basic constraints valid when issuing non-CA certificates
     * 
     */
    @Export(name="basicConstraintsValidForNonCa", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> basicConstraintsValidForNonCa;

    /**
     * @return Flag to mark basic constraints valid when issuing non-CA certificates
     * 
     */
    public Output<Optional<Boolean>> basicConstraintsValidForNonCa() {
        return Codegen.optional(this.basicConstraintsValidForNonCa);
    }
    /**
     * Flag to specify certificates for client use
     * 
     */
    @Export(name="clientFlag", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> clientFlag;

    /**
     * @return Flag to specify certificates for client use
     * 
     */
    public Output<Optional<Boolean>> clientFlag() {
        return Codegen.optional(this.clientFlag);
    }
    /**
     * Flag to specify certificates for code signing use
     * 
     */
    @Export(name="codeSigningFlag", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> codeSigningFlag;

    /**
     * @return Flag to specify certificates for code signing use
     * 
     */
    public Output<Optional<Boolean>> codeSigningFlag() {
        return Codegen.optional(this.codeSigningFlag);
    }
    /**
     * The country of generated certificates
     * 
     */
    @Export(name="countries", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> countries;

    /**
     * @return The country of generated certificates
     * 
     */
    public Output<Optional<List<String>>> countries() {
        return Codegen.optional(this.countries);
    }
    /**
     * Flag to specify certificates for email protection use
     * 
     */
    @Export(name="emailProtectionFlag", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> emailProtectionFlag;

    /**
     * @return Flag to specify certificates for email protection use
     * 
     */
    public Output<Optional<Boolean>> emailProtectionFlag() {
        return Codegen.optional(this.emailProtectionFlag);
    }
    /**
     * Flag to allow only valid host names
     * 
     */
    @Export(name="enforceHostnames", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> enforceHostnames;

    /**
     * @return Flag to allow only valid host names
     * 
     */
    public Output<Optional<Boolean>> enforceHostnames() {
        return Codegen.optional(this.enforceHostnames);
    }
    /**
     * Specify the allowed extended key usage constraint on issued certificates
     * 
     */
    @Export(name="extKeyUsages", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> extKeyUsages;

    /**
     * @return Specify the allowed extended key usage constraint on issued certificates
     * 
     */
    public Output<Optional<List<String>>> extKeyUsages() {
        return Codegen.optional(this.extKeyUsages);
    }
    /**
     * Flag to generate leases with certificates
     * 
     */
    @Export(name="generateLease", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> generateLease;

    /**
     * @return Flag to generate leases with certificates
     * 
     */
    public Output<Optional<Boolean>> generateLease() {
        return Codegen.optional(this.generateLease);
    }
    /**
     * Specifies the default issuer of this request. May
     * be the value `default`, a name, or an issuer ID. Use ACLs to prevent access to
     * the `/pki/issuer/:issuer_ref/{issue,sign}/:name` paths to prevent users
     * overriding the role&#39;s `issuer_ref` value.
     * 
     */
    @Export(name="issuerRef", refs={String.class}, tree="[0]")
    private Output<String> issuerRef;

    /**
     * @return Specifies the default issuer of this request. May
     * be the value `default`, a name, or an issuer ID. Use ACLs to prevent access to
     * the `/pki/issuer/:issuer_ref/{issue,sign}/:name` paths to prevent users
     * overriding the role&#39;s `issuer_ref` value.
     * 
     */
    public Output<String> issuerRef() {
        return this.issuerRef;
    }
    /**
     * The number of bits of generated keys
     * 
     */
    @Export(name="keyBits", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> keyBits;

    /**
     * @return The number of bits of generated keys
     * 
     */
    public Output<Optional<Integer>> keyBits() {
        return Codegen.optional(this.keyBits);
    }
    /**
     * The generated key type, choices: `rsa`, `ec`, `ed25519`, `any`
     * Defaults to `rsa`
     * 
     */
    @Export(name="keyType", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> keyType;

    /**
     * @return The generated key type, choices: `rsa`, `ec`, `ed25519`, `any`
     * Defaults to `rsa`
     * 
     */
    public Output<Optional<String>> keyType() {
        return Codegen.optional(this.keyType);
    }
    /**
     * Specify the allowed key usage constraint on issued certificates
     * 
     */
    @Export(name="keyUsages", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> keyUsages;

    /**
     * @return Specify the allowed key usage constraint on issued certificates
     * 
     */
    public Output<List<String>> keyUsages() {
        return this.keyUsages;
    }
    /**
     * The locality of generated certificates
     * 
     */
    @Export(name="localities", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> localities;

    /**
     * @return The locality of generated certificates
     * 
     */
    public Output<Optional<List<String>>> localities() {
        return Codegen.optional(this.localities);
    }
    /**
     * The maximum lease TTL, in seconds, for the role.
     * 
     */
    @Export(name="maxTtl", refs={String.class}, tree="[0]")
    private Output<String> maxTtl;

    /**
     * @return The maximum lease TTL, in seconds, for the role.
     * 
     */
    public Output<String> maxTtl() {
        return this.maxTtl;
    }
    /**
     * The name to identify this role within the backend. Must be unique within the backend.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The name to identify this role within the backend. Must be unique within the backend.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * The namespace to provision the resource in.
     * The value should not contain leading or trailing forward slashes.
     * The `namespace` is always relative to the provider&#39;s configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).
     * *Available only for Vault Enterprise*.
     * 
     */
    @Export(name="namespace", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> namespace;

    /**
     * @return The namespace to provision the resource in.
     * The value should not contain leading or trailing forward slashes.
     * The `namespace` is always relative to the provider&#39;s configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).
     * *Available only for Vault Enterprise*.
     * 
     */
    public Output<Optional<String>> namespace() {
        return Codegen.optional(this.namespace);
    }
    /**
     * Flag to not store certificates in the storage backend
     * 
     */
    @Export(name="noStore", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> noStore;

    /**
     * @return Flag to not store certificates in the storage backend
     * 
     */
    public Output<Optional<Boolean>> noStore() {
        return Codegen.optional(this.noStore);
    }
    /**
     * Specifies the duration by which to backdate the NotBefore property.
     * 
     */
    @Export(name="notBeforeDuration", refs={String.class}, tree="[0]")
    private Output<String> notBeforeDuration;

    /**
     * @return Specifies the duration by which to backdate the NotBefore property.
     * 
     */
    public Output<String> notBeforeDuration() {
        return this.notBeforeDuration;
    }
    /**
     * The organization unit of generated certificates
     * 
     */
    @Export(name="organizationUnit", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> organizationUnit;

    /**
     * @return The organization unit of generated certificates
     * 
     */
    public Output<Optional<List<String>>> organizationUnit() {
        return Codegen.optional(this.organizationUnit);
    }
    /**
     * The organization of generated certificates
     * 
     */
    @Export(name="organizations", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> organizations;

    /**
     * @return The organization of generated certificates
     * 
     */
    public Output<Optional<List<String>>> organizations() {
        return Codegen.optional(this.organizations);
    }
    /**
     * Specify the list of allowed policies OIDs. Use with Vault 1.10 or before. For Vault 1.11+, use `policy_identifier` blocks instead
     * 
     */
    @Export(name="policyIdentifiers", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> policyIdentifiers;

    /**
     * @return Specify the list of allowed policies OIDs. Use with Vault 1.10 or before. For Vault 1.11+, use `policy_identifier` blocks instead
     * 
     */
    public Output<Optional<List<String>>> policyIdentifiers() {
        return Codegen.optional(this.policyIdentifiers);
    }
    /**
     * The postal code of generated certificates
     * 
     */
    @Export(name="postalCodes", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> postalCodes;

    /**
     * @return The postal code of generated certificates
     * 
     */
    public Output<Optional<List<String>>> postalCodes() {
        return Codegen.optional(this.postalCodes);
    }
    /**
     * The province of generated certificates
     * 
     */
    @Export(name="provinces", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> provinces;

    /**
     * @return The province of generated certificates
     * 
     */
    public Output<Optional<List<String>>> provinces() {
        return Codegen.optional(this.provinces);
    }
    /**
     * Flag to force CN usage
     * 
     */
    @Export(name="requireCn", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> requireCn;

    /**
     * @return Flag to force CN usage
     * 
     */
    public Output<Optional<Boolean>> requireCn() {
        return Codegen.optional(this.requireCn);
    }
    /**
     * Flag to specify certificates for server use
     * 
     */
    @Export(name="serverFlag", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> serverFlag;

    /**
     * @return Flag to specify certificates for server use
     * 
     */
    public Output<Optional<Boolean>> serverFlag() {
        return Codegen.optional(this.serverFlag);
    }
    /**
     * The street address of generated certificates
     * 
     */
    @Export(name="streetAddresses", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> streetAddresses;

    /**
     * @return The street address of generated certificates
     * 
     */
    public Output<Optional<List<String>>> streetAddresses() {
        return Codegen.optional(this.streetAddresses);
    }
    /**
     * The TTL, in seconds, for any certificate issued against this role.
     * 
     */
    @Export(name="ttl", refs={String.class}, tree="[0]")
    private Output<String> ttl;

    /**
     * @return The TTL, in seconds, for any certificate issued against this role.
     * 
     */
    public Output<String> ttl() {
        return this.ttl;
    }
    /**
     * Flag to use the CN in the CSR
     * 
     */
    @Export(name="useCsrCommonName", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> useCsrCommonName;

    /**
     * @return Flag to use the CN in the CSR
     * 
     */
    public Output<Optional<Boolean>> useCsrCommonName() {
        return Codegen.optional(this.useCsrCommonName);
    }
    /**
     * Flag to use the SANs in the CSR
     * 
     */
    @Export(name="useCsrSans", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> useCsrSans;

    /**
     * @return Flag to use the SANs in the CSR
     * 
     */
    public Output<Optional<Boolean>> useCsrSans() {
        return Codegen.optional(this.useCsrSans);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public SecretBackendRole(String name) {
        this(name, SecretBackendRoleArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public SecretBackendRole(String name, SecretBackendRoleArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public SecretBackendRole(String name, SecretBackendRoleArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("vault:pkiSecret/secretBackendRole:SecretBackendRole", name, args == null ? SecretBackendRoleArgs.Empty : args, makeResourceOptions(options, Codegen.empty()));
    }

    private SecretBackendRole(String name, Output<String> id, @Nullable SecretBackendRoleState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("vault:pkiSecret/secretBackendRole:SecretBackendRole", name, state, makeResourceOptions(options, id));
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static SecretBackendRole get(String name, Output<String> id, @Nullable SecretBackendRoleState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new SecretBackendRole(name, id, state, options);
    }
}
