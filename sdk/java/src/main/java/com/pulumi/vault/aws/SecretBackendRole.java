// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.vault.aws;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.vault.Utilities;
import com.pulumi.vault.aws.SecretBackendRoleArgs;
import com.pulumi.vault.aws.inputs.SecretBackendRoleState;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * ## Example Usage
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.vault.aws.SecretBackend;
 * import com.pulumi.vault.aws.SecretBackendArgs;
 * import com.pulumi.vault.aws.SecretBackendRole;
 * import com.pulumi.vault.aws.SecretBackendRoleArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var aws = new SecretBackend("aws", SecretBackendArgs.builder()
 *             .accessKey("AKIA.....")
 *             .secretKey("AWS secret key")
 *             .build());
 * 
 *         var role = new SecretBackendRole("role", SecretBackendRoleArgs.builder()
 *             .backend(aws.path())
 *             .name("deploy")
 *             .credentialType("iam_user")
 *             .policyDocument("""
 * {
 *   "Version": "2012-10-17",
 *   "Statement": [
 *     {
 *       "Effect": "Allow",
 *       "Action": "iam:*",
 *       "Resource": "*"
 *     }
 *   ]
 * }
 *             """)
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ## Import
 * 
 * AWS secret backend roles can be imported using the `path`, e.g.
 * 
 * ```sh
 * $ pulumi import vault:aws/secretBackendRole:SecretBackendRole role aws/roles/deploy
 * ```
 * 
 */
@ResourceType(type="vault:aws/secretBackendRole:SecretBackendRole")
public class SecretBackendRole extends com.pulumi.resources.CustomResource {
    /**
     * The path the AWS secret backend is mounted at,
     * with no leading or trailing `/`s.
     * 
     */
    @Export(name="backend", refs={String.class}, tree="[0]")
    private Output<String> backend;

    /**
     * @return The path the AWS secret backend is mounted at,
     * with no leading or trailing `/`s.
     * 
     */
    public Output<String> backend() {
        return this.backend;
    }
    /**
     * Specifies the type of credential to be used when
     * retrieving credentials from the role. Must be one of `iamUser`, `assumedRole`, or
     * `federationToken`.
     * 
     */
    @Export(name="credentialType", refs={String.class}, tree="[0]")
    private Output<String> credentialType;

    /**
     * @return Specifies the type of credential to be used when
     * retrieving credentials from the role. Must be one of `iamUser`, `assumedRole`, or
     * `federationToken`.
     * 
     */
    public Output<String> credentialType() {
        return this.credentialType;
    }
    /**
     * The default TTL in seconds for STS credentials.
     * When a TTL is not specified when STS credentials are requested,
     * and a default TTL is specified on the role,
     * then this default TTL will be used. Valid only when `credentialType` is one of
     * `assumedRole` or `federationToken`.
     * 
     */
    @Export(name="defaultStsTtl", refs={Integer.class}, tree="[0]")
    private Output<Integer> defaultStsTtl;

    /**
     * @return The default TTL in seconds for STS credentials.
     * When a TTL is not specified when STS credentials are requested,
     * and a default TTL is specified on the role,
     * then this default TTL will be used. Valid only when `credentialType` is one of
     * `assumedRole` or `federationToken`.
     * 
     */
    public Output<Integer> defaultStsTtl() {
        return this.defaultStsTtl;
    }
    /**
     * External ID to set for assume role creds.
     * Valid only when `credentialType` is set to `assumedRole`.
     * 
     */
    @Export(name="externalId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> externalId;

    /**
     * @return External ID to set for assume role creds.
     * Valid only when `credentialType` is set to `assumedRole`.
     * 
     */
    public Output<Optional<String>> externalId() {
        return Codegen.optional(this.externalId);
    }
    /**
     * A list of IAM group names. IAM users generated
     * against this vault role will be added to these IAM Groups. For a credential
     * type of `assumedRole` or `federationToken`, the policies sent to the
     * corresponding AWS call (sts:AssumeRole or sts:GetFederation) will be the
     * policies from each group in `iamGroups` combined with the `policyDocument`
     * and `policyArns` parameters.
     * 
     */
    @Export(name="iamGroups", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> iamGroups;

    /**
     * @return A list of IAM group names. IAM users generated
     * against this vault role will be added to these IAM Groups. For a credential
     * type of `assumedRole` or `federationToken`, the policies sent to the
     * corresponding AWS call (sts:AssumeRole or sts:GetFederation) will be the
     * policies from each group in `iamGroups` combined with the `policyDocument`
     * and `policyArns` parameters.
     * 
     */
    public Output<Optional<List<String>>> iamGroups() {
        return Codegen.optional(this.iamGroups);
    }
    /**
     * A map of strings representing key/value pairs
     * to be used as tags for any IAM user that is created by this role.
     * 
     */
    @Export(name="iamTags", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> iamTags;

    /**
     * @return A map of strings representing key/value pairs
     * to be used as tags for any IAM user that is created by this role.
     * 
     */
    public Output<Optional<Map<String,String>>> iamTags() {
        return Codegen.optional(this.iamTags);
    }
    /**
     * The max allowed TTL in seconds for STS credentials
     * (credentials TTL are capped to `maxStsTtl`). Valid only when `credentialType` is
     * one of `assumedRole` or `federationToken`.
     * 
     */
    @Export(name="maxStsTtl", refs={Integer.class}, tree="[0]")
    private Output<Integer> maxStsTtl;

    /**
     * @return The max allowed TTL in seconds for STS credentials
     * (credentials TTL are capped to `maxStsTtl`). Valid only when `credentialType` is
     * one of `assumedRole` or `federationToken`.
     * 
     */
    public Output<Integer> maxStsTtl() {
        return this.maxStsTtl;
    }
    /**
     * The name to identify this role within the backend.
     * Must be unique within the backend.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The name to identify this role within the backend.
     * Must be unique within the backend.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * The namespace to provision the resource in.
     * The value should not contain leading or trailing forward slashes.
     * The `namespace` is always relative to the provider&#39;s configured [namespace](https://www.terraform.io/docs/providers/vault/index.html#namespace).
     * *Available only for Vault Enterprise*.
     * 
     */
    @Export(name="namespace", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> namespace;

    /**
     * @return The namespace to provision the resource in.
     * The value should not contain leading or trailing forward slashes.
     * The `namespace` is always relative to the provider&#39;s configured [namespace](https://www.terraform.io/docs/providers/vault/index.html#namespace).
     * *Available only for Vault Enterprise*.
     * 
     */
    public Output<Optional<String>> namespace() {
        return Codegen.optional(this.namespace);
    }
    /**
     * The ARN of the AWS Permissions
     * Boundary to attach to IAM users created in the role. Valid only when
     * `credentialType` is `iamUser`. If not specified, then no permissions boundary
     * policy will be attached.
     * 
     */
    @Export(name="permissionsBoundaryArn", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> permissionsBoundaryArn;

    /**
     * @return The ARN of the AWS Permissions
     * Boundary to attach to IAM users created in the role. Valid only when
     * `credentialType` is `iamUser`. If not specified, then no permissions boundary
     * policy will be attached.
     * 
     */
    public Output<Optional<String>> permissionsBoundaryArn() {
        return Codegen.optional(this.permissionsBoundaryArn);
    }
    /**
     * Specifies a list of AWS managed policy ARNs. The
     * behavior depends on the credential type. With `iamUser`, the policies will be
     * attached to IAM users when they are requested. With `assumedRole` and
     * `federationToken`, the policy ARNs will act as a filter on what the credentials
     * can do, similar to `policyDocument`. When `credentialType` is `iamUser` or
     * `federationToken`, at least one of `policyDocument` or `policyArns` must
     * be specified.
     * 
     */
    @Export(name="policyArns", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> policyArns;

    /**
     * @return Specifies a list of AWS managed policy ARNs. The
     * behavior depends on the credential type. With `iamUser`, the policies will be
     * attached to IAM users when they are requested. With `assumedRole` and
     * `federationToken`, the policy ARNs will act as a filter on what the credentials
     * can do, similar to `policyDocument`. When `credentialType` is `iamUser` or
     * `federationToken`, at least one of `policyDocument` or `policyArns` must
     * be specified.
     * 
     */
    public Output<Optional<List<String>>> policyArns() {
        return Codegen.optional(this.policyArns);
    }
    /**
     * The IAM policy document for the role. The
     * behavior depends on the credential type. With `iamUser`, the policy document
     * will be attached to the IAM user generated and augment the permissions the IAM
     * user has. With `assumedRole` and `federationToken`, the policy document will
     * act as a filter on what the credentials can do, similar to `policyArns`.
     * 
     */
    @Export(name="policyDocument", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> policyDocument;

    /**
     * @return The IAM policy document for the role. The
     * behavior depends on the credential type. With `iamUser`, the policy document
     * will be attached to the IAM user generated and augment the permissions the IAM
     * user has. With `assumedRole` and `federationToken`, the policy document will
     * act as a filter on what the credentials can do, similar to `policyArns`.
     * 
     */
    public Output<Optional<String>> policyDocument() {
        return Codegen.optional(this.policyDocument);
    }
    /**
     * Specifies the ARNs of the AWS roles this Vault role
     * is allowed to assume. Required when `credentialType` is `assumedRole` and
     * prohibited otherwise.
     * 
     */
    @Export(name="roleArns", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> roleArns;

    /**
     * @return Specifies the ARNs of the AWS roles this Vault role
     * is allowed to assume. Required when `credentialType` is `assumedRole` and
     * prohibited otherwise.
     * 
     */
    public Output<Optional<List<String>>> roleArns() {
        return Codegen.optional(this.roleArns);
    }
    /**
     * A map of strings representing key/value pairs to be set
     * during assume role creds creation. Valid only when `credentialType` is set to
     * `assumedRole`.
     * 
     */
    @Export(name="sessionTags", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> sessionTags;

    /**
     * @return A map of strings representing key/value pairs to be set
     * during assume role creds creation. Valid only when `credentialType` is set to
     * `assumedRole`.
     * 
     */
    public Output<Optional<Map<String,String>>> sessionTags() {
        return Codegen.optional(this.sessionTags);
    }
    /**
     * The path for the user name. Valid only when
     * `credentialType` is `iamUser`. Default is `/`.
     * 
     */
    @Export(name="userPath", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> userPath;

    /**
     * @return The path for the user name. Valid only when
     * `credentialType` is `iamUser`. Default is `/`.
     * 
     */
    public Output<Optional<String>> userPath() {
        return Codegen.optional(this.userPath);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public SecretBackendRole(java.lang.String name) {
        this(name, SecretBackendRoleArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public SecretBackendRole(java.lang.String name, SecretBackendRoleArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public SecretBackendRole(java.lang.String name, SecretBackendRoleArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("vault:aws/secretBackendRole:SecretBackendRole", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private SecretBackendRole(java.lang.String name, Output<java.lang.String> id, @Nullable SecretBackendRoleState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("vault:aws/secretBackendRole:SecretBackendRole", name, state, makeResourceOptions(options, id), false);
    }

    private static SecretBackendRoleArgs makeArgs(SecretBackendRoleArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? SecretBackendRoleArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static SecretBackendRole get(java.lang.String name, Output<java.lang.String> id, @Nullable SecretBackendRoleState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new SecretBackendRole(name, id, state, options);
    }
}
