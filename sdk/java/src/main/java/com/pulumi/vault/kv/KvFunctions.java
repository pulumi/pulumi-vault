// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.vault.kv;

import com.pulumi.core.Output;
import com.pulumi.core.TypeShape;
import com.pulumi.deployment.Deployment;
import com.pulumi.deployment.InvokeOptions;
import com.pulumi.vault.Utilities;
import com.pulumi.vault.kv.inputs.GetSecretArgs;
import com.pulumi.vault.kv.inputs.GetSecretPlainArgs;
import com.pulumi.vault.kv.inputs.GetSecretSubkeysV2Args;
import com.pulumi.vault.kv.inputs.GetSecretSubkeysV2PlainArgs;
import com.pulumi.vault.kv.inputs.GetSecretV2Args;
import com.pulumi.vault.kv.inputs.GetSecretV2PlainArgs;
import com.pulumi.vault.kv.inputs.GetSecretsListArgs;
import com.pulumi.vault.kv.inputs.GetSecretsListPlainArgs;
import com.pulumi.vault.kv.inputs.GetSecretsListV2Args;
import com.pulumi.vault.kv.inputs.GetSecretsListV2PlainArgs;
import com.pulumi.vault.kv.outputs.GetSecretResult;
import com.pulumi.vault.kv.outputs.GetSecretSubkeysV2Result;
import com.pulumi.vault.kv.outputs.GetSecretV2Result;
import com.pulumi.vault.kv.outputs.GetSecretsListResult;
import com.pulumi.vault.kv.outputs.GetSecretsListV2Result;
import java.util.concurrent.CompletableFuture;

public final class KvFunctions {
    /**
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.vault.Mount;
     * import com.pulumi.vault.MountArgs;
     * import com.pulumi.vault.kv.Secret;
     * import com.pulumi.vault.kv.SecretArgs;
     * import com.pulumi.vault.kv.KvFunctions;
     * import com.pulumi.vault.generic.inputs.GetSecretArgs;
     * import static com.pulumi.codegen.internal.Serialization.*;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var kvv1 = new Mount(&#34;kvv1&#34;, MountArgs.builder()        
     *             .path(&#34;kvv1&#34;)
     *             .type(&#34;kv&#34;)
     *             .options(Map.of(&#34;version&#34;, &#34;1&#34;))
     *             .description(&#34;KV Version 1 secret engine mount&#34;)
     *             .build());
     * 
     *         var secret = new Secret(&#34;secret&#34;, SecretArgs.builder()        
     *             .path(kvv1.path().applyValue(path -&gt; String.format(&#34;%s/secret&#34;, path)))
     *             .dataJson(serializeJson(
     *                 jsonObject(
     *                     jsonProperty(&#34;zip&#34;, &#34;zap&#34;),
     *                     jsonProperty(&#34;foo&#34;, &#34;bar&#34;)
     *                 )))
     *             .build());
     * 
     *         final var secretData = KvFunctions.getSecret(GetSecretArgs.builder()
     *             .path(secret.path())
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Required Vault Capabilities
     * 
     * Use of this resource requires the `read` capability on the given path.
     * 
     */
    public static Output<GetSecretResult> getSecret(GetSecretArgs args) {
        return getSecret(args, InvokeOptions.Empty);
    }
    /**
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.vault.Mount;
     * import com.pulumi.vault.MountArgs;
     * import com.pulumi.vault.kv.Secret;
     * import com.pulumi.vault.kv.SecretArgs;
     * import com.pulumi.vault.kv.KvFunctions;
     * import com.pulumi.vault.generic.inputs.GetSecretArgs;
     * import static com.pulumi.codegen.internal.Serialization.*;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var kvv1 = new Mount(&#34;kvv1&#34;, MountArgs.builder()        
     *             .path(&#34;kvv1&#34;)
     *             .type(&#34;kv&#34;)
     *             .options(Map.of(&#34;version&#34;, &#34;1&#34;))
     *             .description(&#34;KV Version 1 secret engine mount&#34;)
     *             .build());
     * 
     *         var secret = new Secret(&#34;secret&#34;, SecretArgs.builder()        
     *             .path(kvv1.path().applyValue(path -&gt; String.format(&#34;%s/secret&#34;, path)))
     *             .dataJson(serializeJson(
     *                 jsonObject(
     *                     jsonProperty(&#34;zip&#34;, &#34;zap&#34;),
     *                     jsonProperty(&#34;foo&#34;, &#34;bar&#34;)
     *                 )))
     *             .build());
     * 
     *         final var secretData = KvFunctions.getSecret(GetSecretArgs.builder()
     *             .path(secret.path())
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Required Vault Capabilities
     * 
     * Use of this resource requires the `read` capability on the given path.
     * 
     */
    public static CompletableFuture<GetSecretResult> getSecretPlain(GetSecretPlainArgs args) {
        return getSecretPlain(args, InvokeOptions.Empty);
    }
    /**
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.vault.Mount;
     * import com.pulumi.vault.MountArgs;
     * import com.pulumi.vault.kv.Secret;
     * import com.pulumi.vault.kv.SecretArgs;
     * import com.pulumi.vault.kv.KvFunctions;
     * import com.pulumi.vault.generic.inputs.GetSecretArgs;
     * import static com.pulumi.codegen.internal.Serialization.*;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var kvv1 = new Mount(&#34;kvv1&#34;, MountArgs.builder()        
     *             .path(&#34;kvv1&#34;)
     *             .type(&#34;kv&#34;)
     *             .options(Map.of(&#34;version&#34;, &#34;1&#34;))
     *             .description(&#34;KV Version 1 secret engine mount&#34;)
     *             .build());
     * 
     *         var secret = new Secret(&#34;secret&#34;, SecretArgs.builder()        
     *             .path(kvv1.path().applyValue(path -&gt; String.format(&#34;%s/secret&#34;, path)))
     *             .dataJson(serializeJson(
     *                 jsonObject(
     *                     jsonProperty(&#34;zip&#34;, &#34;zap&#34;),
     *                     jsonProperty(&#34;foo&#34;, &#34;bar&#34;)
     *                 )))
     *             .build());
     * 
     *         final var secretData = KvFunctions.getSecret(GetSecretArgs.builder()
     *             .path(secret.path())
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Required Vault Capabilities
     * 
     * Use of this resource requires the `read` capability on the given path.
     * 
     */
    public static Output<GetSecretResult> getSecret(GetSecretArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("vault:kv/getSecret:getSecret", TypeShape.of(GetSecretResult.class), args, Utilities.withVersion(options));
    }
    /**
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.vault.Mount;
     * import com.pulumi.vault.MountArgs;
     * import com.pulumi.vault.kv.Secret;
     * import com.pulumi.vault.kv.SecretArgs;
     * import com.pulumi.vault.kv.KvFunctions;
     * import com.pulumi.vault.generic.inputs.GetSecretArgs;
     * import static com.pulumi.codegen.internal.Serialization.*;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var kvv1 = new Mount(&#34;kvv1&#34;, MountArgs.builder()        
     *             .path(&#34;kvv1&#34;)
     *             .type(&#34;kv&#34;)
     *             .options(Map.of(&#34;version&#34;, &#34;1&#34;))
     *             .description(&#34;KV Version 1 secret engine mount&#34;)
     *             .build());
     * 
     *         var secret = new Secret(&#34;secret&#34;, SecretArgs.builder()        
     *             .path(kvv1.path().applyValue(path -&gt; String.format(&#34;%s/secret&#34;, path)))
     *             .dataJson(serializeJson(
     *                 jsonObject(
     *                     jsonProperty(&#34;zip&#34;, &#34;zap&#34;),
     *                     jsonProperty(&#34;foo&#34;, &#34;bar&#34;)
     *                 )))
     *             .build());
     * 
     *         final var secretData = KvFunctions.getSecret(GetSecretArgs.builder()
     *             .path(secret.path())
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Required Vault Capabilities
     * 
     * Use of this resource requires the `read` capability on the given path.
     * 
     */
    public static CompletableFuture<GetSecretResult> getSecretPlain(GetSecretPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("vault:kv/getSecret:getSecret", TypeShape.of(GetSecretResult.class), args, Utilities.withVersion(options));
    }
    /**
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.vault.Mount;
     * import com.pulumi.vault.MountArgs;
     * import com.pulumi.vault.kv.SecretV2;
     * import com.pulumi.vault.kv.SecretV2Args;
     * import com.pulumi.vault.kv.KvFunctions;
     * import com.pulumi.vault.kv.inputs.GetSecretSubkeysV2Args;
     * import static com.pulumi.codegen.internal.Serialization.*;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var kvv2 = new Mount(&#34;kvv2&#34;, MountArgs.builder()        
     *             .path(&#34;kvv2&#34;)
     *             .type(&#34;kv&#34;)
     *             .options(Map.of(&#34;version&#34;, &#34;2&#34;))
     *             .description(&#34;KV Version 2 secret engine mount&#34;)
     *             .build());
     * 
     *         var awsSecret = new SecretV2(&#34;awsSecret&#34;, SecretV2Args.builder()        
     *             .mount(kvv2.path())
     *             .dataJson(serializeJson(
     *                 jsonObject(
     *                     jsonProperty(&#34;zip&#34;, &#34;zap&#34;),
     *                     jsonProperty(&#34;foo&#34;, &#34;bar&#34;)
     *                 )))
     *             .build());
     * 
     *         final var test = KvFunctions.getSecretSubkeysV2(GetSecretSubkeysV2Args.builder()
     *             .mount(kvv2.path())
     *             .name(awsSecret.name())
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Required Vault Capabilities
     * 
     * Use of this resource requires the `read` capability on the given path.
     * 
     */
    public static Output<GetSecretSubkeysV2Result> getSecretSubkeysV2(GetSecretSubkeysV2Args args) {
        return getSecretSubkeysV2(args, InvokeOptions.Empty);
    }
    /**
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.vault.Mount;
     * import com.pulumi.vault.MountArgs;
     * import com.pulumi.vault.kv.SecretV2;
     * import com.pulumi.vault.kv.SecretV2Args;
     * import com.pulumi.vault.kv.KvFunctions;
     * import com.pulumi.vault.kv.inputs.GetSecretSubkeysV2Args;
     * import static com.pulumi.codegen.internal.Serialization.*;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var kvv2 = new Mount(&#34;kvv2&#34;, MountArgs.builder()        
     *             .path(&#34;kvv2&#34;)
     *             .type(&#34;kv&#34;)
     *             .options(Map.of(&#34;version&#34;, &#34;2&#34;))
     *             .description(&#34;KV Version 2 secret engine mount&#34;)
     *             .build());
     * 
     *         var awsSecret = new SecretV2(&#34;awsSecret&#34;, SecretV2Args.builder()        
     *             .mount(kvv2.path())
     *             .dataJson(serializeJson(
     *                 jsonObject(
     *                     jsonProperty(&#34;zip&#34;, &#34;zap&#34;),
     *                     jsonProperty(&#34;foo&#34;, &#34;bar&#34;)
     *                 )))
     *             .build());
     * 
     *         final var test = KvFunctions.getSecretSubkeysV2(GetSecretSubkeysV2Args.builder()
     *             .mount(kvv2.path())
     *             .name(awsSecret.name())
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Required Vault Capabilities
     * 
     * Use of this resource requires the `read` capability on the given path.
     * 
     */
    public static CompletableFuture<GetSecretSubkeysV2Result> getSecretSubkeysV2Plain(GetSecretSubkeysV2PlainArgs args) {
        return getSecretSubkeysV2Plain(args, InvokeOptions.Empty);
    }
    /**
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.vault.Mount;
     * import com.pulumi.vault.MountArgs;
     * import com.pulumi.vault.kv.SecretV2;
     * import com.pulumi.vault.kv.SecretV2Args;
     * import com.pulumi.vault.kv.KvFunctions;
     * import com.pulumi.vault.kv.inputs.GetSecretSubkeysV2Args;
     * import static com.pulumi.codegen.internal.Serialization.*;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var kvv2 = new Mount(&#34;kvv2&#34;, MountArgs.builder()        
     *             .path(&#34;kvv2&#34;)
     *             .type(&#34;kv&#34;)
     *             .options(Map.of(&#34;version&#34;, &#34;2&#34;))
     *             .description(&#34;KV Version 2 secret engine mount&#34;)
     *             .build());
     * 
     *         var awsSecret = new SecretV2(&#34;awsSecret&#34;, SecretV2Args.builder()        
     *             .mount(kvv2.path())
     *             .dataJson(serializeJson(
     *                 jsonObject(
     *                     jsonProperty(&#34;zip&#34;, &#34;zap&#34;),
     *                     jsonProperty(&#34;foo&#34;, &#34;bar&#34;)
     *                 )))
     *             .build());
     * 
     *         final var test = KvFunctions.getSecretSubkeysV2(GetSecretSubkeysV2Args.builder()
     *             .mount(kvv2.path())
     *             .name(awsSecret.name())
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Required Vault Capabilities
     * 
     * Use of this resource requires the `read` capability on the given path.
     * 
     */
    public static Output<GetSecretSubkeysV2Result> getSecretSubkeysV2(GetSecretSubkeysV2Args args, InvokeOptions options) {
        return Deployment.getInstance().invoke("vault:kv/getSecretSubkeysV2:getSecretSubkeysV2", TypeShape.of(GetSecretSubkeysV2Result.class), args, Utilities.withVersion(options));
    }
    /**
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.vault.Mount;
     * import com.pulumi.vault.MountArgs;
     * import com.pulumi.vault.kv.SecretV2;
     * import com.pulumi.vault.kv.SecretV2Args;
     * import com.pulumi.vault.kv.KvFunctions;
     * import com.pulumi.vault.kv.inputs.GetSecretSubkeysV2Args;
     * import static com.pulumi.codegen.internal.Serialization.*;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var kvv2 = new Mount(&#34;kvv2&#34;, MountArgs.builder()        
     *             .path(&#34;kvv2&#34;)
     *             .type(&#34;kv&#34;)
     *             .options(Map.of(&#34;version&#34;, &#34;2&#34;))
     *             .description(&#34;KV Version 2 secret engine mount&#34;)
     *             .build());
     * 
     *         var awsSecret = new SecretV2(&#34;awsSecret&#34;, SecretV2Args.builder()        
     *             .mount(kvv2.path())
     *             .dataJson(serializeJson(
     *                 jsonObject(
     *                     jsonProperty(&#34;zip&#34;, &#34;zap&#34;),
     *                     jsonProperty(&#34;foo&#34;, &#34;bar&#34;)
     *                 )))
     *             .build());
     * 
     *         final var test = KvFunctions.getSecretSubkeysV2(GetSecretSubkeysV2Args.builder()
     *             .mount(kvv2.path())
     *             .name(awsSecret.name())
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Required Vault Capabilities
     * 
     * Use of this resource requires the `read` capability on the given path.
     * 
     */
    public static CompletableFuture<GetSecretSubkeysV2Result> getSecretSubkeysV2Plain(GetSecretSubkeysV2PlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("vault:kv/getSecretSubkeysV2:getSecretSubkeysV2", TypeShape.of(GetSecretSubkeysV2Result.class), args, Utilities.withVersion(options));
    }
    /**
     * ## Required Vault Capabilities
     * 
     * Use of this resource requires the `read` capability on the given path.
     * 
     */
    public static Output<GetSecretV2Result> getSecretV2(GetSecretV2Args args) {
        return getSecretV2(args, InvokeOptions.Empty);
    }
    /**
     * ## Required Vault Capabilities
     * 
     * Use of this resource requires the `read` capability on the given path.
     * 
     */
    public static CompletableFuture<GetSecretV2Result> getSecretV2Plain(GetSecretV2PlainArgs args) {
        return getSecretV2Plain(args, InvokeOptions.Empty);
    }
    /**
     * ## Required Vault Capabilities
     * 
     * Use of this resource requires the `read` capability on the given path.
     * 
     */
    public static Output<GetSecretV2Result> getSecretV2(GetSecretV2Args args, InvokeOptions options) {
        return Deployment.getInstance().invoke("vault:kv/getSecretV2:getSecretV2", TypeShape.of(GetSecretV2Result.class), args, Utilities.withVersion(options));
    }
    /**
     * ## Required Vault Capabilities
     * 
     * Use of this resource requires the `read` capability on the given path.
     * 
     */
    public static CompletableFuture<GetSecretV2Result> getSecretV2Plain(GetSecretV2PlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("vault:kv/getSecretV2:getSecretV2", TypeShape.of(GetSecretV2Result.class), args, Utilities.withVersion(options));
    }
    /**
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.vault.Mount;
     * import com.pulumi.vault.MountArgs;
     * import com.pulumi.vault.kv.Secret;
     * import com.pulumi.vault.kv.SecretArgs;
     * import com.pulumi.vault.kv.KvFunctions;
     * import com.pulumi.vault.kv.inputs.GetSecretsListArgs;
     * import static com.pulumi.codegen.internal.Serialization.*;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var kvv1 = new Mount(&#34;kvv1&#34;, MountArgs.builder()        
     *             .path(&#34;kvv1&#34;)
     *             .type(&#34;kv&#34;)
     *             .options(Map.of(&#34;version&#34;, &#34;1&#34;))
     *             .description(&#34;KV Version 1 secret engine mount&#34;)
     *             .build());
     * 
     *         var awsSecret = new Secret(&#34;awsSecret&#34;, SecretArgs.builder()        
     *             .path(kvv1.path().applyValue(path -&gt; String.format(&#34;%s/aws-secret&#34;, path)))
     *             .dataJson(serializeJson(
     *                 jsonObject(
     *                     jsonProperty(&#34;zip&#34;, &#34;zap&#34;)
     *                 )))
     *             .build());
     * 
     *         var azureSecret = new Secret(&#34;azureSecret&#34;, SecretArgs.builder()        
     *             .path(kvv1.path().applyValue(path -&gt; String.format(&#34;%s/azure-secret&#34;, path)))
     *             .dataJson(serializeJson(
     *                 jsonObject(
     *                     jsonProperty(&#34;foo&#34;, &#34;bar&#34;)
     *                 )))
     *             .build());
     * 
     *         final var secrets = KvFunctions.getSecretsList(GetSecretsListArgs.builder()
     *             .path(kvv1.path())
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Required Vault Capabilities
     * 
     * Use of this resource requires the `read` capability on the given path.
     * 
     */
    public static Output<GetSecretsListResult> getSecretsList(GetSecretsListArgs args) {
        return getSecretsList(args, InvokeOptions.Empty);
    }
    /**
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.vault.Mount;
     * import com.pulumi.vault.MountArgs;
     * import com.pulumi.vault.kv.Secret;
     * import com.pulumi.vault.kv.SecretArgs;
     * import com.pulumi.vault.kv.KvFunctions;
     * import com.pulumi.vault.kv.inputs.GetSecretsListArgs;
     * import static com.pulumi.codegen.internal.Serialization.*;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var kvv1 = new Mount(&#34;kvv1&#34;, MountArgs.builder()        
     *             .path(&#34;kvv1&#34;)
     *             .type(&#34;kv&#34;)
     *             .options(Map.of(&#34;version&#34;, &#34;1&#34;))
     *             .description(&#34;KV Version 1 secret engine mount&#34;)
     *             .build());
     * 
     *         var awsSecret = new Secret(&#34;awsSecret&#34;, SecretArgs.builder()        
     *             .path(kvv1.path().applyValue(path -&gt; String.format(&#34;%s/aws-secret&#34;, path)))
     *             .dataJson(serializeJson(
     *                 jsonObject(
     *                     jsonProperty(&#34;zip&#34;, &#34;zap&#34;)
     *                 )))
     *             .build());
     * 
     *         var azureSecret = new Secret(&#34;azureSecret&#34;, SecretArgs.builder()        
     *             .path(kvv1.path().applyValue(path -&gt; String.format(&#34;%s/azure-secret&#34;, path)))
     *             .dataJson(serializeJson(
     *                 jsonObject(
     *                     jsonProperty(&#34;foo&#34;, &#34;bar&#34;)
     *                 )))
     *             .build());
     * 
     *         final var secrets = KvFunctions.getSecretsList(GetSecretsListArgs.builder()
     *             .path(kvv1.path())
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Required Vault Capabilities
     * 
     * Use of this resource requires the `read` capability on the given path.
     * 
     */
    public static CompletableFuture<GetSecretsListResult> getSecretsListPlain(GetSecretsListPlainArgs args) {
        return getSecretsListPlain(args, InvokeOptions.Empty);
    }
    /**
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.vault.Mount;
     * import com.pulumi.vault.MountArgs;
     * import com.pulumi.vault.kv.Secret;
     * import com.pulumi.vault.kv.SecretArgs;
     * import com.pulumi.vault.kv.KvFunctions;
     * import com.pulumi.vault.kv.inputs.GetSecretsListArgs;
     * import static com.pulumi.codegen.internal.Serialization.*;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var kvv1 = new Mount(&#34;kvv1&#34;, MountArgs.builder()        
     *             .path(&#34;kvv1&#34;)
     *             .type(&#34;kv&#34;)
     *             .options(Map.of(&#34;version&#34;, &#34;1&#34;))
     *             .description(&#34;KV Version 1 secret engine mount&#34;)
     *             .build());
     * 
     *         var awsSecret = new Secret(&#34;awsSecret&#34;, SecretArgs.builder()        
     *             .path(kvv1.path().applyValue(path -&gt; String.format(&#34;%s/aws-secret&#34;, path)))
     *             .dataJson(serializeJson(
     *                 jsonObject(
     *                     jsonProperty(&#34;zip&#34;, &#34;zap&#34;)
     *                 )))
     *             .build());
     * 
     *         var azureSecret = new Secret(&#34;azureSecret&#34;, SecretArgs.builder()        
     *             .path(kvv1.path().applyValue(path -&gt; String.format(&#34;%s/azure-secret&#34;, path)))
     *             .dataJson(serializeJson(
     *                 jsonObject(
     *                     jsonProperty(&#34;foo&#34;, &#34;bar&#34;)
     *                 )))
     *             .build());
     * 
     *         final var secrets = KvFunctions.getSecretsList(GetSecretsListArgs.builder()
     *             .path(kvv1.path())
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Required Vault Capabilities
     * 
     * Use of this resource requires the `read` capability on the given path.
     * 
     */
    public static Output<GetSecretsListResult> getSecretsList(GetSecretsListArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("vault:kv/getSecretsList:getSecretsList", TypeShape.of(GetSecretsListResult.class), args, Utilities.withVersion(options));
    }
    /**
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.vault.Mount;
     * import com.pulumi.vault.MountArgs;
     * import com.pulumi.vault.kv.Secret;
     * import com.pulumi.vault.kv.SecretArgs;
     * import com.pulumi.vault.kv.KvFunctions;
     * import com.pulumi.vault.kv.inputs.GetSecretsListArgs;
     * import static com.pulumi.codegen.internal.Serialization.*;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var kvv1 = new Mount(&#34;kvv1&#34;, MountArgs.builder()        
     *             .path(&#34;kvv1&#34;)
     *             .type(&#34;kv&#34;)
     *             .options(Map.of(&#34;version&#34;, &#34;1&#34;))
     *             .description(&#34;KV Version 1 secret engine mount&#34;)
     *             .build());
     * 
     *         var awsSecret = new Secret(&#34;awsSecret&#34;, SecretArgs.builder()        
     *             .path(kvv1.path().applyValue(path -&gt; String.format(&#34;%s/aws-secret&#34;, path)))
     *             .dataJson(serializeJson(
     *                 jsonObject(
     *                     jsonProperty(&#34;zip&#34;, &#34;zap&#34;)
     *                 )))
     *             .build());
     * 
     *         var azureSecret = new Secret(&#34;azureSecret&#34;, SecretArgs.builder()        
     *             .path(kvv1.path().applyValue(path -&gt; String.format(&#34;%s/azure-secret&#34;, path)))
     *             .dataJson(serializeJson(
     *                 jsonObject(
     *                     jsonProperty(&#34;foo&#34;, &#34;bar&#34;)
     *                 )))
     *             .build());
     * 
     *         final var secrets = KvFunctions.getSecretsList(GetSecretsListArgs.builder()
     *             .path(kvv1.path())
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Required Vault Capabilities
     * 
     * Use of this resource requires the `read` capability on the given path.
     * 
     */
    public static CompletableFuture<GetSecretsListResult> getSecretsListPlain(GetSecretsListPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("vault:kv/getSecretsList:getSecretsList", TypeShape.of(GetSecretsListResult.class), args, Utilities.withVersion(options));
    }
    /**
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.vault.Mount;
     * import com.pulumi.vault.MountArgs;
     * import com.pulumi.vault.kv.SecretV2;
     * import com.pulumi.vault.kv.SecretV2Args;
     * import com.pulumi.vault.kv.KvFunctions;
     * import com.pulumi.vault.kv.inputs.GetSecretsListV2Args;
     * import static com.pulumi.codegen.internal.Serialization.*;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var kvv2 = new Mount(&#34;kvv2&#34;, MountArgs.builder()        
     *             .path(&#34;kvv2&#34;)
     *             .type(&#34;kv&#34;)
     *             .options(Map.of(&#34;version&#34;, &#34;2&#34;))
     *             .description(&#34;KV Version 2 secret engine mount&#34;)
     *             .build());
     * 
     *         var awsSecret = new SecretV2(&#34;awsSecret&#34;, SecretV2Args.builder()        
     *             .mount(kvv2.path())
     *             .dataJson(serializeJson(
     *                 jsonObject(
     *                     jsonProperty(&#34;zip&#34;, &#34;zap&#34;)
     *                 )))
     *             .build());
     * 
     *         var azureSecret = new SecretV2(&#34;azureSecret&#34;, SecretV2Args.builder()        
     *             .mount(kvv2.path())
     *             .dataJson(serializeJson(
     *                 jsonObject(
     *                     jsonProperty(&#34;foo&#34;, &#34;bar&#34;)
     *                 )))
     *             .build());
     * 
     *         var nestedSecret = new SecretV2(&#34;nestedSecret&#34;, SecretV2Args.builder()        
     *             .mount(kvv2.path())
     *             .dataJson(serializeJson(
     *                 jsonObject(
     *                     jsonProperty(&#34;password&#34;, &#34;test&#34;)
     *                 )))
     *             .build());
     * 
     *         final var secrets = KvFunctions.getSecretsListV2(GetSecretsListV2Args.builder()
     *             .mount(kvv2.path())
     *             .build());
     * 
     *         final var nestedSecrets = KvFunctions.getSecretsListV2(GetSecretsListV2Args.builder()
     *             .mount(kvv2.path())
     *             .name(vault_kv_secret_v2.test_2().name())
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Required Vault Capabilities
     * 
     * Use of this resource requires the `read` capability on the given path.
     * 
     */
    public static Output<GetSecretsListV2Result> getSecretsListV2(GetSecretsListV2Args args) {
        return getSecretsListV2(args, InvokeOptions.Empty);
    }
    /**
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.vault.Mount;
     * import com.pulumi.vault.MountArgs;
     * import com.pulumi.vault.kv.SecretV2;
     * import com.pulumi.vault.kv.SecretV2Args;
     * import com.pulumi.vault.kv.KvFunctions;
     * import com.pulumi.vault.kv.inputs.GetSecretsListV2Args;
     * import static com.pulumi.codegen.internal.Serialization.*;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var kvv2 = new Mount(&#34;kvv2&#34;, MountArgs.builder()        
     *             .path(&#34;kvv2&#34;)
     *             .type(&#34;kv&#34;)
     *             .options(Map.of(&#34;version&#34;, &#34;2&#34;))
     *             .description(&#34;KV Version 2 secret engine mount&#34;)
     *             .build());
     * 
     *         var awsSecret = new SecretV2(&#34;awsSecret&#34;, SecretV2Args.builder()        
     *             .mount(kvv2.path())
     *             .dataJson(serializeJson(
     *                 jsonObject(
     *                     jsonProperty(&#34;zip&#34;, &#34;zap&#34;)
     *                 )))
     *             .build());
     * 
     *         var azureSecret = new SecretV2(&#34;azureSecret&#34;, SecretV2Args.builder()        
     *             .mount(kvv2.path())
     *             .dataJson(serializeJson(
     *                 jsonObject(
     *                     jsonProperty(&#34;foo&#34;, &#34;bar&#34;)
     *                 )))
     *             .build());
     * 
     *         var nestedSecret = new SecretV2(&#34;nestedSecret&#34;, SecretV2Args.builder()        
     *             .mount(kvv2.path())
     *             .dataJson(serializeJson(
     *                 jsonObject(
     *                     jsonProperty(&#34;password&#34;, &#34;test&#34;)
     *                 )))
     *             .build());
     * 
     *         final var secrets = KvFunctions.getSecretsListV2(GetSecretsListV2Args.builder()
     *             .mount(kvv2.path())
     *             .build());
     * 
     *         final var nestedSecrets = KvFunctions.getSecretsListV2(GetSecretsListV2Args.builder()
     *             .mount(kvv2.path())
     *             .name(vault_kv_secret_v2.test_2().name())
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Required Vault Capabilities
     * 
     * Use of this resource requires the `read` capability on the given path.
     * 
     */
    public static CompletableFuture<GetSecretsListV2Result> getSecretsListV2Plain(GetSecretsListV2PlainArgs args) {
        return getSecretsListV2Plain(args, InvokeOptions.Empty);
    }
    /**
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.vault.Mount;
     * import com.pulumi.vault.MountArgs;
     * import com.pulumi.vault.kv.SecretV2;
     * import com.pulumi.vault.kv.SecretV2Args;
     * import com.pulumi.vault.kv.KvFunctions;
     * import com.pulumi.vault.kv.inputs.GetSecretsListV2Args;
     * import static com.pulumi.codegen.internal.Serialization.*;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var kvv2 = new Mount(&#34;kvv2&#34;, MountArgs.builder()        
     *             .path(&#34;kvv2&#34;)
     *             .type(&#34;kv&#34;)
     *             .options(Map.of(&#34;version&#34;, &#34;2&#34;))
     *             .description(&#34;KV Version 2 secret engine mount&#34;)
     *             .build());
     * 
     *         var awsSecret = new SecretV2(&#34;awsSecret&#34;, SecretV2Args.builder()        
     *             .mount(kvv2.path())
     *             .dataJson(serializeJson(
     *                 jsonObject(
     *                     jsonProperty(&#34;zip&#34;, &#34;zap&#34;)
     *                 )))
     *             .build());
     * 
     *         var azureSecret = new SecretV2(&#34;azureSecret&#34;, SecretV2Args.builder()        
     *             .mount(kvv2.path())
     *             .dataJson(serializeJson(
     *                 jsonObject(
     *                     jsonProperty(&#34;foo&#34;, &#34;bar&#34;)
     *                 )))
     *             .build());
     * 
     *         var nestedSecret = new SecretV2(&#34;nestedSecret&#34;, SecretV2Args.builder()        
     *             .mount(kvv2.path())
     *             .dataJson(serializeJson(
     *                 jsonObject(
     *                     jsonProperty(&#34;password&#34;, &#34;test&#34;)
     *                 )))
     *             .build());
     * 
     *         final var secrets = KvFunctions.getSecretsListV2(GetSecretsListV2Args.builder()
     *             .mount(kvv2.path())
     *             .build());
     * 
     *         final var nestedSecrets = KvFunctions.getSecretsListV2(GetSecretsListV2Args.builder()
     *             .mount(kvv2.path())
     *             .name(vault_kv_secret_v2.test_2().name())
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Required Vault Capabilities
     * 
     * Use of this resource requires the `read` capability on the given path.
     * 
     */
    public static Output<GetSecretsListV2Result> getSecretsListV2(GetSecretsListV2Args args, InvokeOptions options) {
        return Deployment.getInstance().invoke("vault:kv/getSecretsListV2:getSecretsListV2", TypeShape.of(GetSecretsListV2Result.class), args, Utilities.withVersion(options));
    }
    /**
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.vault.Mount;
     * import com.pulumi.vault.MountArgs;
     * import com.pulumi.vault.kv.SecretV2;
     * import com.pulumi.vault.kv.SecretV2Args;
     * import com.pulumi.vault.kv.KvFunctions;
     * import com.pulumi.vault.kv.inputs.GetSecretsListV2Args;
     * import static com.pulumi.codegen.internal.Serialization.*;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var kvv2 = new Mount(&#34;kvv2&#34;, MountArgs.builder()        
     *             .path(&#34;kvv2&#34;)
     *             .type(&#34;kv&#34;)
     *             .options(Map.of(&#34;version&#34;, &#34;2&#34;))
     *             .description(&#34;KV Version 2 secret engine mount&#34;)
     *             .build());
     * 
     *         var awsSecret = new SecretV2(&#34;awsSecret&#34;, SecretV2Args.builder()        
     *             .mount(kvv2.path())
     *             .dataJson(serializeJson(
     *                 jsonObject(
     *                     jsonProperty(&#34;zip&#34;, &#34;zap&#34;)
     *                 )))
     *             .build());
     * 
     *         var azureSecret = new SecretV2(&#34;azureSecret&#34;, SecretV2Args.builder()        
     *             .mount(kvv2.path())
     *             .dataJson(serializeJson(
     *                 jsonObject(
     *                     jsonProperty(&#34;foo&#34;, &#34;bar&#34;)
     *                 )))
     *             .build());
     * 
     *         var nestedSecret = new SecretV2(&#34;nestedSecret&#34;, SecretV2Args.builder()        
     *             .mount(kvv2.path())
     *             .dataJson(serializeJson(
     *                 jsonObject(
     *                     jsonProperty(&#34;password&#34;, &#34;test&#34;)
     *                 )))
     *             .build());
     * 
     *         final var secrets = KvFunctions.getSecretsListV2(GetSecretsListV2Args.builder()
     *             .mount(kvv2.path())
     *             .build());
     * 
     *         final var nestedSecrets = KvFunctions.getSecretsListV2(GetSecretsListV2Args.builder()
     *             .mount(kvv2.path())
     *             .name(vault_kv_secret_v2.test_2().name())
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Required Vault Capabilities
     * 
     * Use of this resource requires the `read` capability on the given path.
     * 
     */
    public static CompletableFuture<GetSecretsListV2Result> getSecretsListV2Plain(GetSecretsListV2PlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("vault:kv/getSecretsListV2:getSecretsListV2", TypeShape.of(GetSecretsListV2Result.class), args, Utilities.withVersion(options));
    }
}
