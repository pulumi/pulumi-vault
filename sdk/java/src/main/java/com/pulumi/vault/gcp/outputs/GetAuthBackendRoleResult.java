// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.vault.gcp.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class GetAuthBackendRoleResult {
    private @Nullable String backend;
    /**
     * @return GCP regions bound to the role. Returned when `type` is `gce`.
     * 
     */
    private List<String> boundInstanceGroups;
    /**
     * @return GCP labels bound to the role. Returned when `type` is `gce`.
     * 
     */
    private List<String> boundLabels;
    /**
     * @return GCP projects bound to the role.
     * 
     */
    private List<String> boundProjects;
    /**
     * @return GCP regions bound to the role. Returned when `type` is `gce`.
     * 
     */
    private List<String> boundRegions;
    /**
     * @return GCP service accounts bound to the role. Returned when `type` is `iam`.
     * 
     */
    private List<String> boundServiceAccounts;
    /**
     * @return GCP zones bound to the role. Returned when `type` is `gce`.
     * 
     */
    private List<String> boundZones;
    /**
     * @return The provider-assigned unique ID for this managed resource.
     * 
     */
    private String id;
    private @Nullable String namespace;
    /**
     * @return The RoleID of the GCP role.
     * 
     */
    private String roleId;
    private String roleName;
    /**
     * @return List of CIDR blocks; if set, specifies blocks of IP
     * addresses which can authenticate successfully, and ties the resulting token to these blocks
     * as well.
     * 
     */
    private @Nullable List<String> tokenBoundCidrs;
    /**
     * @return If set, will encode an
     * [explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)
     * onto the token in number of seconds. This is a hard cap even if `token_ttl` and
     * `token_max_ttl` would otherwise allow a renewal.
     * 
     */
    private @Nullable Integer tokenExplicitMaxTtl;
    /**
     * @return The maximum lifetime for generated tokens in number of seconds.
     * Its current value will be referenced at renewal time.
     * 
     */
    private @Nullable Integer tokenMaxTtl;
    /**
     * @return If set, the default policy will not be set on
     * generated tokens; otherwise it will be added to the policies set in token_policies.
     * 
     */
    private @Nullable Boolean tokenNoDefaultPolicy;
    /**
     * @return The
     * [period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),
     * if any, in number of seconds to set on the token.
     * 
     */
    private @Nullable Integer tokenNumUses;
    /**
     * @return (Optional) If set, indicates that the
     * token generated using this role should never expire. The token should be renewed within the
     * duration specified by this value. At each renewal, the token&#39;s TTL will be set to the
     * value of this field. Specified in seconds.
     * 
     */
    private @Nullable Integer tokenPeriod;
    /**
     * @return List of policies to encode onto generated tokens. Depending
     * on the auth method, this list may be supplemented by user/group/other values.
     * 
     */
    private @Nullable List<String> tokenPolicies;
    /**
     * @return The incremental lifetime for generated tokens in number of seconds.
     * Its current value will be referenced at renewal time.
     * 
     */
    private @Nullable Integer tokenTtl;
    /**
     * @return The type of token that should be generated. Can be `service`,
     * `batch`, or `default` to use the mount&#39;s tuned default (which unless changed will be
     * `service` tokens). For token store roles, there are two additional possibilities:
     * `default-service` and `default-batch` which specify the type to return unless the client
     * requests a different type at generation time.
     * 
     */
    private @Nullable String tokenType;
    /**
     * @return Type of GCP role. Expected values are `iam` or `gce`.
     * 
     */
    private String type;

    private GetAuthBackendRoleResult() {}
    public Optional<String> backend() {
        return Optional.ofNullable(this.backend);
    }
    /**
     * @return GCP regions bound to the role. Returned when `type` is `gce`.
     * 
     */
    public List<String> boundInstanceGroups() {
        return this.boundInstanceGroups;
    }
    /**
     * @return GCP labels bound to the role. Returned when `type` is `gce`.
     * 
     */
    public List<String> boundLabels() {
        return this.boundLabels;
    }
    /**
     * @return GCP projects bound to the role.
     * 
     */
    public List<String> boundProjects() {
        return this.boundProjects;
    }
    /**
     * @return GCP regions bound to the role. Returned when `type` is `gce`.
     * 
     */
    public List<String> boundRegions() {
        return this.boundRegions;
    }
    /**
     * @return GCP service accounts bound to the role. Returned when `type` is `iam`.
     * 
     */
    public List<String> boundServiceAccounts() {
        return this.boundServiceAccounts;
    }
    /**
     * @return GCP zones bound to the role. Returned when `type` is `gce`.
     * 
     */
    public List<String> boundZones() {
        return this.boundZones;
    }
    /**
     * @return The provider-assigned unique ID for this managed resource.
     * 
     */
    public String id() {
        return this.id;
    }
    public Optional<String> namespace() {
        return Optional.ofNullable(this.namespace);
    }
    /**
     * @return The RoleID of the GCP role.
     * 
     */
    public String roleId() {
        return this.roleId;
    }
    public String roleName() {
        return this.roleName;
    }
    /**
     * @return List of CIDR blocks; if set, specifies blocks of IP
     * addresses which can authenticate successfully, and ties the resulting token to these blocks
     * as well.
     * 
     */
    public List<String> tokenBoundCidrs() {
        return this.tokenBoundCidrs == null ? List.of() : this.tokenBoundCidrs;
    }
    /**
     * @return If set, will encode an
     * [explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)
     * onto the token in number of seconds. This is a hard cap even if `token_ttl` and
     * `token_max_ttl` would otherwise allow a renewal.
     * 
     */
    public Optional<Integer> tokenExplicitMaxTtl() {
        return Optional.ofNullable(this.tokenExplicitMaxTtl);
    }
    /**
     * @return The maximum lifetime for generated tokens in number of seconds.
     * Its current value will be referenced at renewal time.
     * 
     */
    public Optional<Integer> tokenMaxTtl() {
        return Optional.ofNullable(this.tokenMaxTtl);
    }
    /**
     * @return If set, the default policy will not be set on
     * generated tokens; otherwise it will be added to the policies set in token_policies.
     * 
     */
    public Optional<Boolean> tokenNoDefaultPolicy() {
        return Optional.ofNullable(this.tokenNoDefaultPolicy);
    }
    /**
     * @return The
     * [period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),
     * if any, in number of seconds to set on the token.
     * 
     */
    public Optional<Integer> tokenNumUses() {
        return Optional.ofNullable(this.tokenNumUses);
    }
    /**
     * @return (Optional) If set, indicates that the
     * token generated using this role should never expire. The token should be renewed within the
     * duration specified by this value. At each renewal, the token&#39;s TTL will be set to the
     * value of this field. Specified in seconds.
     * 
     */
    public Optional<Integer> tokenPeriod() {
        return Optional.ofNullable(this.tokenPeriod);
    }
    /**
     * @return List of policies to encode onto generated tokens. Depending
     * on the auth method, this list may be supplemented by user/group/other values.
     * 
     */
    public List<String> tokenPolicies() {
        return this.tokenPolicies == null ? List.of() : this.tokenPolicies;
    }
    /**
     * @return The incremental lifetime for generated tokens in number of seconds.
     * Its current value will be referenced at renewal time.
     * 
     */
    public Optional<Integer> tokenTtl() {
        return Optional.ofNullable(this.tokenTtl);
    }
    /**
     * @return The type of token that should be generated. Can be `service`,
     * `batch`, or `default` to use the mount&#39;s tuned default (which unless changed will be
     * `service` tokens). For token store roles, there are two additional possibilities:
     * `default-service` and `default-batch` which specify the type to return unless the client
     * requests a different type at generation time.
     * 
     */
    public Optional<String> tokenType() {
        return Optional.ofNullable(this.tokenType);
    }
    /**
     * @return Type of GCP role. Expected values are `iam` or `gce`.
     * 
     */
    public String type() {
        return this.type;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetAuthBackendRoleResult defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable String backend;
        private List<String> boundInstanceGroups;
        private List<String> boundLabels;
        private List<String> boundProjects;
        private List<String> boundRegions;
        private List<String> boundServiceAccounts;
        private List<String> boundZones;
        private String id;
        private @Nullable String namespace;
        private String roleId;
        private String roleName;
        private @Nullable List<String> tokenBoundCidrs;
        private @Nullable Integer tokenExplicitMaxTtl;
        private @Nullable Integer tokenMaxTtl;
        private @Nullable Boolean tokenNoDefaultPolicy;
        private @Nullable Integer tokenNumUses;
        private @Nullable Integer tokenPeriod;
        private @Nullable List<String> tokenPolicies;
        private @Nullable Integer tokenTtl;
        private @Nullable String tokenType;
        private String type;
        public Builder() {}
        public Builder(GetAuthBackendRoleResult defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.backend = defaults.backend;
    	      this.boundInstanceGroups = defaults.boundInstanceGroups;
    	      this.boundLabels = defaults.boundLabels;
    	      this.boundProjects = defaults.boundProjects;
    	      this.boundRegions = defaults.boundRegions;
    	      this.boundServiceAccounts = defaults.boundServiceAccounts;
    	      this.boundZones = defaults.boundZones;
    	      this.id = defaults.id;
    	      this.namespace = defaults.namespace;
    	      this.roleId = defaults.roleId;
    	      this.roleName = defaults.roleName;
    	      this.tokenBoundCidrs = defaults.tokenBoundCidrs;
    	      this.tokenExplicitMaxTtl = defaults.tokenExplicitMaxTtl;
    	      this.tokenMaxTtl = defaults.tokenMaxTtl;
    	      this.tokenNoDefaultPolicy = defaults.tokenNoDefaultPolicy;
    	      this.tokenNumUses = defaults.tokenNumUses;
    	      this.tokenPeriod = defaults.tokenPeriod;
    	      this.tokenPolicies = defaults.tokenPolicies;
    	      this.tokenTtl = defaults.tokenTtl;
    	      this.tokenType = defaults.tokenType;
    	      this.type = defaults.type;
        }

        @CustomType.Setter
        public Builder backend(@Nullable String backend) {

            this.backend = backend;
            return this;
        }
        @CustomType.Setter
        public Builder boundInstanceGroups(List<String> boundInstanceGroups) {
            if (boundInstanceGroups == null) {
              throw new MissingRequiredPropertyException("GetAuthBackendRoleResult", "boundInstanceGroups");
            }
            this.boundInstanceGroups = boundInstanceGroups;
            return this;
        }
        public Builder boundInstanceGroups(String... boundInstanceGroups) {
            return boundInstanceGroups(List.of(boundInstanceGroups));
        }
        @CustomType.Setter
        public Builder boundLabels(List<String> boundLabels) {
            if (boundLabels == null) {
              throw new MissingRequiredPropertyException("GetAuthBackendRoleResult", "boundLabels");
            }
            this.boundLabels = boundLabels;
            return this;
        }
        public Builder boundLabels(String... boundLabels) {
            return boundLabels(List.of(boundLabels));
        }
        @CustomType.Setter
        public Builder boundProjects(List<String> boundProjects) {
            if (boundProjects == null) {
              throw new MissingRequiredPropertyException("GetAuthBackendRoleResult", "boundProjects");
            }
            this.boundProjects = boundProjects;
            return this;
        }
        public Builder boundProjects(String... boundProjects) {
            return boundProjects(List.of(boundProjects));
        }
        @CustomType.Setter
        public Builder boundRegions(List<String> boundRegions) {
            if (boundRegions == null) {
              throw new MissingRequiredPropertyException("GetAuthBackendRoleResult", "boundRegions");
            }
            this.boundRegions = boundRegions;
            return this;
        }
        public Builder boundRegions(String... boundRegions) {
            return boundRegions(List.of(boundRegions));
        }
        @CustomType.Setter
        public Builder boundServiceAccounts(List<String> boundServiceAccounts) {
            if (boundServiceAccounts == null) {
              throw new MissingRequiredPropertyException("GetAuthBackendRoleResult", "boundServiceAccounts");
            }
            this.boundServiceAccounts = boundServiceAccounts;
            return this;
        }
        public Builder boundServiceAccounts(String... boundServiceAccounts) {
            return boundServiceAccounts(List.of(boundServiceAccounts));
        }
        @CustomType.Setter
        public Builder boundZones(List<String> boundZones) {
            if (boundZones == null) {
              throw new MissingRequiredPropertyException("GetAuthBackendRoleResult", "boundZones");
            }
            this.boundZones = boundZones;
            return this;
        }
        public Builder boundZones(String... boundZones) {
            return boundZones(List.of(boundZones));
        }
        @CustomType.Setter
        public Builder id(String id) {
            if (id == null) {
              throw new MissingRequiredPropertyException("GetAuthBackendRoleResult", "id");
            }
            this.id = id;
            return this;
        }
        @CustomType.Setter
        public Builder namespace(@Nullable String namespace) {

            this.namespace = namespace;
            return this;
        }
        @CustomType.Setter
        public Builder roleId(String roleId) {
            if (roleId == null) {
              throw new MissingRequiredPropertyException("GetAuthBackendRoleResult", "roleId");
            }
            this.roleId = roleId;
            return this;
        }
        @CustomType.Setter
        public Builder roleName(String roleName) {
            if (roleName == null) {
              throw new MissingRequiredPropertyException("GetAuthBackendRoleResult", "roleName");
            }
            this.roleName = roleName;
            return this;
        }
        @CustomType.Setter
        public Builder tokenBoundCidrs(@Nullable List<String> tokenBoundCidrs) {

            this.tokenBoundCidrs = tokenBoundCidrs;
            return this;
        }
        public Builder tokenBoundCidrs(String... tokenBoundCidrs) {
            return tokenBoundCidrs(List.of(tokenBoundCidrs));
        }
        @CustomType.Setter
        public Builder tokenExplicitMaxTtl(@Nullable Integer tokenExplicitMaxTtl) {

            this.tokenExplicitMaxTtl = tokenExplicitMaxTtl;
            return this;
        }
        @CustomType.Setter
        public Builder tokenMaxTtl(@Nullable Integer tokenMaxTtl) {

            this.tokenMaxTtl = tokenMaxTtl;
            return this;
        }
        @CustomType.Setter
        public Builder tokenNoDefaultPolicy(@Nullable Boolean tokenNoDefaultPolicy) {

            this.tokenNoDefaultPolicy = tokenNoDefaultPolicy;
            return this;
        }
        @CustomType.Setter
        public Builder tokenNumUses(@Nullable Integer tokenNumUses) {

            this.tokenNumUses = tokenNumUses;
            return this;
        }
        @CustomType.Setter
        public Builder tokenPeriod(@Nullable Integer tokenPeriod) {

            this.tokenPeriod = tokenPeriod;
            return this;
        }
        @CustomType.Setter
        public Builder tokenPolicies(@Nullable List<String> tokenPolicies) {

            this.tokenPolicies = tokenPolicies;
            return this;
        }
        public Builder tokenPolicies(String... tokenPolicies) {
            return tokenPolicies(List.of(tokenPolicies));
        }
        @CustomType.Setter
        public Builder tokenTtl(@Nullable Integer tokenTtl) {

            this.tokenTtl = tokenTtl;
            return this;
        }
        @CustomType.Setter
        public Builder tokenType(@Nullable String tokenType) {

            this.tokenType = tokenType;
            return this;
        }
        @CustomType.Setter
        public Builder type(String type) {
            if (type == null) {
              throw new MissingRequiredPropertyException("GetAuthBackendRoleResult", "type");
            }
            this.type = type;
            return this;
        }
        public GetAuthBackendRoleResult build() {
            final var _resultValue = new GetAuthBackendRoleResult();
            _resultValue.backend = backend;
            _resultValue.boundInstanceGroups = boundInstanceGroups;
            _resultValue.boundLabels = boundLabels;
            _resultValue.boundProjects = boundProjects;
            _resultValue.boundRegions = boundRegions;
            _resultValue.boundServiceAccounts = boundServiceAccounts;
            _resultValue.boundZones = boundZones;
            _resultValue.id = id;
            _resultValue.namespace = namespace;
            _resultValue.roleId = roleId;
            _resultValue.roleName = roleName;
            _resultValue.tokenBoundCidrs = tokenBoundCidrs;
            _resultValue.tokenExplicitMaxTtl = tokenExplicitMaxTtl;
            _resultValue.tokenMaxTtl = tokenMaxTtl;
            _resultValue.tokenNoDefaultPolicy = tokenNoDefaultPolicy;
            _resultValue.tokenNumUses = tokenNumUses;
            _resultValue.tokenPeriod = tokenPeriod;
            _resultValue.tokenPolicies = tokenPolicies;
            _resultValue.tokenTtl = tokenTtl;
            _resultValue.tokenType = tokenType;
            _resultValue.type = type;
            return _resultValue;
        }
    }
}
