// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.vault.kubernetes.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class GetAuthBackendRoleResult {
    /**
     * @return Method used for generating identity aliases. (vault-1.9+)
     * 
     */
    private String aliasNameSource;
    /**
     * @return Audience claim to verify in the JWT.
     * 
     */
    private @Nullable String audience;
    private @Nullable String backend;
    /**
     * @return List of service account names able to access this role. If set to &#34;*&#34; all names are allowed, both this and bound_service_account_namespaces can not be &#34;*&#34;.
     * 
     */
    private List<String> boundServiceAccountNames;
    /**
     * @return List of namespaces allowed to access this role. If set to &#34;*&#34; all namespaces are allowed, both this and bound_service_account_names can not be set to &#34;*&#34;.
     * 
     */
    private List<String> boundServiceAccountNamespaces;
    /**
     * @return The provider-assigned unique ID for this managed resource.
     * 
     */
    private String id;
    private @Nullable String namespace;
    private String roleName;
    /**
     * @return List of CIDR blocks; if set, specifies blocks of IP
     * addresses which can authenticate successfully, and ties the resulting token to these blocks
     * as well.
     * 
     */
    private @Nullable List<String> tokenBoundCidrs;
    /**
     * @return If set, will encode an
     * [explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)
     * onto the token in number of seconds. This is a hard cap even if `token_ttl` and
     * `token_max_ttl` would otherwise allow a renewal.
     * 
     */
    private @Nullable Integer tokenExplicitMaxTtl;
    /**
     * @return The maximum lifetime for generated tokens in number of seconds.
     * Its current value will be referenced at renewal time.
     * 
     */
    private @Nullable Integer tokenMaxTtl;
    /**
     * @return If set, the default policy will not be set on
     * generated tokens; otherwise it will be added to the policies set in token_policies.
     * 
     */
    private @Nullable Boolean tokenNoDefaultPolicy;
    /**
     * @return The
     * [period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),
     * if any, in number of seconds to set on the token.
     * 
     */
    private @Nullable Integer tokenNumUses;
    /**
     * @return (Optional) If set, indicates that the
     * token generated using this role should never expire. The token should be renewed within the
     * duration specified by this value. At each renewal, the token&#39;s TTL will be set to the
     * value of this field. Specified in seconds.
     * 
     */
    private @Nullable Integer tokenPeriod;
    /**
     * @return List of policies to encode onto generated tokens. Depending
     * on the auth method, this list may be supplemented by user/group/other values.
     * 
     */
    private @Nullable List<String> tokenPolicies;
    /**
     * @return The incremental lifetime for generated tokens in number of seconds.
     * Its current value will be referenced at renewal time.
     * 
     */
    private @Nullable Integer tokenTtl;
    /**
     * @return The type of token that should be generated. Can be `service`,
     * `batch`, or `default` to use the mount&#39;s tuned default (which unless changed will be
     * `service` tokens). For token store roles, there are two additional possibilities:
     * `default-service` and `default-batch` which specify the type to return unless the client
     * requests a different type at generation time.
     * 
     */
    private @Nullable String tokenType;

    private GetAuthBackendRoleResult() {}
    /**
     * @return Method used for generating identity aliases. (vault-1.9+)
     * 
     */
    public String aliasNameSource() {
        return this.aliasNameSource;
    }
    /**
     * @return Audience claim to verify in the JWT.
     * 
     */
    public Optional<String> audience() {
        return Optional.ofNullable(this.audience);
    }
    public Optional<String> backend() {
        return Optional.ofNullable(this.backend);
    }
    /**
     * @return List of service account names able to access this role. If set to &#34;*&#34; all names are allowed, both this and bound_service_account_namespaces can not be &#34;*&#34;.
     * 
     */
    public List<String> boundServiceAccountNames() {
        return this.boundServiceAccountNames;
    }
    /**
     * @return List of namespaces allowed to access this role. If set to &#34;*&#34; all namespaces are allowed, both this and bound_service_account_names can not be set to &#34;*&#34;.
     * 
     */
    public List<String> boundServiceAccountNamespaces() {
        return this.boundServiceAccountNamespaces;
    }
    /**
     * @return The provider-assigned unique ID for this managed resource.
     * 
     */
    public String id() {
        return this.id;
    }
    public Optional<String> namespace() {
        return Optional.ofNullable(this.namespace);
    }
    public String roleName() {
        return this.roleName;
    }
    /**
     * @return List of CIDR blocks; if set, specifies blocks of IP
     * addresses which can authenticate successfully, and ties the resulting token to these blocks
     * as well.
     * 
     */
    public List<String> tokenBoundCidrs() {
        return this.tokenBoundCidrs == null ? List.of() : this.tokenBoundCidrs;
    }
    /**
     * @return If set, will encode an
     * [explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)
     * onto the token in number of seconds. This is a hard cap even if `token_ttl` and
     * `token_max_ttl` would otherwise allow a renewal.
     * 
     */
    public Optional<Integer> tokenExplicitMaxTtl() {
        return Optional.ofNullable(this.tokenExplicitMaxTtl);
    }
    /**
     * @return The maximum lifetime for generated tokens in number of seconds.
     * Its current value will be referenced at renewal time.
     * 
     */
    public Optional<Integer> tokenMaxTtl() {
        return Optional.ofNullable(this.tokenMaxTtl);
    }
    /**
     * @return If set, the default policy will not be set on
     * generated tokens; otherwise it will be added to the policies set in token_policies.
     * 
     */
    public Optional<Boolean> tokenNoDefaultPolicy() {
        return Optional.ofNullable(this.tokenNoDefaultPolicy);
    }
    /**
     * @return The
     * [period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),
     * if any, in number of seconds to set on the token.
     * 
     */
    public Optional<Integer> tokenNumUses() {
        return Optional.ofNullable(this.tokenNumUses);
    }
    /**
     * @return (Optional) If set, indicates that the
     * token generated using this role should never expire. The token should be renewed within the
     * duration specified by this value. At each renewal, the token&#39;s TTL will be set to the
     * value of this field. Specified in seconds.
     * 
     */
    public Optional<Integer> tokenPeriod() {
        return Optional.ofNullable(this.tokenPeriod);
    }
    /**
     * @return List of policies to encode onto generated tokens. Depending
     * on the auth method, this list may be supplemented by user/group/other values.
     * 
     */
    public List<String> tokenPolicies() {
        return this.tokenPolicies == null ? List.of() : this.tokenPolicies;
    }
    /**
     * @return The incremental lifetime for generated tokens in number of seconds.
     * Its current value will be referenced at renewal time.
     * 
     */
    public Optional<Integer> tokenTtl() {
        return Optional.ofNullable(this.tokenTtl);
    }
    /**
     * @return The type of token that should be generated. Can be `service`,
     * `batch`, or `default` to use the mount&#39;s tuned default (which unless changed will be
     * `service` tokens). For token store roles, there are two additional possibilities:
     * `default-service` and `default-batch` which specify the type to return unless the client
     * requests a different type at generation time.
     * 
     */
    public Optional<String> tokenType() {
        return Optional.ofNullable(this.tokenType);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetAuthBackendRoleResult defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String aliasNameSource;
        private @Nullable String audience;
        private @Nullable String backend;
        private List<String> boundServiceAccountNames;
        private List<String> boundServiceAccountNamespaces;
        private String id;
        private @Nullable String namespace;
        private String roleName;
        private @Nullable List<String> tokenBoundCidrs;
        private @Nullable Integer tokenExplicitMaxTtl;
        private @Nullable Integer tokenMaxTtl;
        private @Nullable Boolean tokenNoDefaultPolicy;
        private @Nullable Integer tokenNumUses;
        private @Nullable Integer tokenPeriod;
        private @Nullable List<String> tokenPolicies;
        private @Nullable Integer tokenTtl;
        private @Nullable String tokenType;
        public Builder() {}
        public Builder(GetAuthBackendRoleResult defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.aliasNameSource = defaults.aliasNameSource;
    	      this.audience = defaults.audience;
    	      this.backend = defaults.backend;
    	      this.boundServiceAccountNames = defaults.boundServiceAccountNames;
    	      this.boundServiceAccountNamespaces = defaults.boundServiceAccountNamespaces;
    	      this.id = defaults.id;
    	      this.namespace = defaults.namespace;
    	      this.roleName = defaults.roleName;
    	      this.tokenBoundCidrs = defaults.tokenBoundCidrs;
    	      this.tokenExplicitMaxTtl = defaults.tokenExplicitMaxTtl;
    	      this.tokenMaxTtl = defaults.tokenMaxTtl;
    	      this.tokenNoDefaultPolicy = defaults.tokenNoDefaultPolicy;
    	      this.tokenNumUses = defaults.tokenNumUses;
    	      this.tokenPeriod = defaults.tokenPeriod;
    	      this.tokenPolicies = defaults.tokenPolicies;
    	      this.tokenTtl = defaults.tokenTtl;
    	      this.tokenType = defaults.tokenType;
        }

        @CustomType.Setter
        public Builder aliasNameSource(String aliasNameSource) {
            if (aliasNameSource == null) {
              throw new MissingRequiredPropertyException("GetAuthBackendRoleResult", "aliasNameSource");
            }
            this.aliasNameSource = aliasNameSource;
            return this;
        }
        @CustomType.Setter
        public Builder audience(@Nullable String audience) {

            this.audience = audience;
            return this;
        }
        @CustomType.Setter
        public Builder backend(@Nullable String backend) {

            this.backend = backend;
            return this;
        }
        @CustomType.Setter
        public Builder boundServiceAccountNames(List<String> boundServiceAccountNames) {
            if (boundServiceAccountNames == null) {
              throw new MissingRequiredPropertyException("GetAuthBackendRoleResult", "boundServiceAccountNames");
            }
            this.boundServiceAccountNames = boundServiceAccountNames;
            return this;
        }
        public Builder boundServiceAccountNames(String... boundServiceAccountNames) {
            return boundServiceAccountNames(List.of(boundServiceAccountNames));
        }
        @CustomType.Setter
        public Builder boundServiceAccountNamespaces(List<String> boundServiceAccountNamespaces) {
            if (boundServiceAccountNamespaces == null) {
              throw new MissingRequiredPropertyException("GetAuthBackendRoleResult", "boundServiceAccountNamespaces");
            }
            this.boundServiceAccountNamespaces = boundServiceAccountNamespaces;
            return this;
        }
        public Builder boundServiceAccountNamespaces(String... boundServiceAccountNamespaces) {
            return boundServiceAccountNamespaces(List.of(boundServiceAccountNamespaces));
        }
        @CustomType.Setter
        public Builder id(String id) {
            if (id == null) {
              throw new MissingRequiredPropertyException("GetAuthBackendRoleResult", "id");
            }
            this.id = id;
            return this;
        }
        @CustomType.Setter
        public Builder namespace(@Nullable String namespace) {

            this.namespace = namespace;
            return this;
        }
        @CustomType.Setter
        public Builder roleName(String roleName) {
            if (roleName == null) {
              throw new MissingRequiredPropertyException("GetAuthBackendRoleResult", "roleName");
            }
            this.roleName = roleName;
            return this;
        }
        @CustomType.Setter
        public Builder tokenBoundCidrs(@Nullable List<String> tokenBoundCidrs) {

            this.tokenBoundCidrs = tokenBoundCidrs;
            return this;
        }
        public Builder tokenBoundCidrs(String... tokenBoundCidrs) {
            return tokenBoundCidrs(List.of(tokenBoundCidrs));
        }
        @CustomType.Setter
        public Builder tokenExplicitMaxTtl(@Nullable Integer tokenExplicitMaxTtl) {

            this.tokenExplicitMaxTtl = tokenExplicitMaxTtl;
            return this;
        }
        @CustomType.Setter
        public Builder tokenMaxTtl(@Nullable Integer tokenMaxTtl) {

            this.tokenMaxTtl = tokenMaxTtl;
            return this;
        }
        @CustomType.Setter
        public Builder tokenNoDefaultPolicy(@Nullable Boolean tokenNoDefaultPolicy) {

            this.tokenNoDefaultPolicy = tokenNoDefaultPolicy;
            return this;
        }
        @CustomType.Setter
        public Builder tokenNumUses(@Nullable Integer tokenNumUses) {

            this.tokenNumUses = tokenNumUses;
            return this;
        }
        @CustomType.Setter
        public Builder tokenPeriod(@Nullable Integer tokenPeriod) {

            this.tokenPeriod = tokenPeriod;
            return this;
        }
        @CustomType.Setter
        public Builder tokenPolicies(@Nullable List<String> tokenPolicies) {

            this.tokenPolicies = tokenPolicies;
            return this;
        }
        public Builder tokenPolicies(String... tokenPolicies) {
            return tokenPolicies(List.of(tokenPolicies));
        }
        @CustomType.Setter
        public Builder tokenTtl(@Nullable Integer tokenTtl) {

            this.tokenTtl = tokenTtl;
            return this;
        }
        @CustomType.Setter
        public Builder tokenType(@Nullable String tokenType) {

            this.tokenType = tokenType;
            return this;
        }
        public GetAuthBackendRoleResult build() {
            final var _resultValue = new GetAuthBackendRoleResult();
            _resultValue.aliasNameSource = aliasNameSource;
            _resultValue.audience = audience;
            _resultValue.backend = backend;
            _resultValue.boundServiceAccountNames = boundServiceAccountNames;
            _resultValue.boundServiceAccountNamespaces = boundServiceAccountNamespaces;
            _resultValue.id = id;
            _resultValue.namespace = namespace;
            _resultValue.roleName = roleName;
            _resultValue.tokenBoundCidrs = tokenBoundCidrs;
            _resultValue.tokenExplicitMaxTtl = tokenExplicitMaxTtl;
            _resultValue.tokenMaxTtl = tokenMaxTtl;
            _resultValue.tokenNoDefaultPolicy = tokenNoDefaultPolicy;
            _resultValue.tokenNumUses = tokenNumUses;
            _resultValue.tokenPeriod = tokenPeriod;
            _resultValue.tokenPolicies = tokenPolicies;
            _resultValue.tokenTtl = tokenTtl;
            _resultValue.tokenType = tokenType;
            return _resultValue;
        }
    }
}
