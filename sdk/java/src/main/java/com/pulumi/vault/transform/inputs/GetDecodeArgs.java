// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.vault.transform.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Object;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class GetDecodeArgs extends com.pulumi.resources.InvokeArgs {

    public static final GetDecodeArgs Empty = new GetDecodeArgs();

    /**
     * Specifies a list of items to be decoded in a single batch. If this parameter is set, the top-level parameters &#39;value&#39;, &#39;transformation&#39; and &#39;tweak&#39; will be ignored. Each batch item within the list can specify these parameters instead.
     * 
     */
    @Import(name="batchInputs")
    private @Nullable Output<List<Map<String,Object>>> batchInputs;

    /**
     * @return Specifies a list of items to be decoded in a single batch. If this parameter is set, the top-level parameters &#39;value&#39;, &#39;transformation&#39; and &#39;tweak&#39; will be ignored. Each batch item within the list can specify these parameters instead.
     * 
     */
    public Optional<Output<List<Map<String,Object>>>> batchInputs() {
        return Optional.ofNullable(this.batchInputs);
    }

    /**
     * The result of decoding a batch.
     * 
     */
    @Import(name="batchResults")
    private @Nullable Output<List<Map<String,Object>>> batchResults;

    /**
     * @return The result of decoding a batch.
     * 
     */
    public Optional<Output<List<Map<String,Object>>>> batchResults() {
        return Optional.ofNullable(this.batchResults);
    }

    /**
     * The result of decoding a value.
     * 
     */
    @Import(name="decodedValue")
    private @Nullable Output<String> decodedValue;

    /**
     * @return The result of decoding a value.
     * 
     */
    public Optional<Output<String>> decodedValue() {
        return Optional.ofNullable(this.decodedValue);
    }

    /**
     * The namespace of the target resource.
     * The value should not contain leading or trailing forward slashes.
     * The `namespace` is always relative to the provider&#39;s configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).
     * *Available only for Vault Enterprise*.
     * 
     */
    @Import(name="namespace")
    private @Nullable Output<String> namespace;

    /**
     * @return The namespace of the target resource.
     * The value should not contain leading or trailing forward slashes.
     * The `namespace` is always relative to the provider&#39;s configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).
     * *Available only for Vault Enterprise*.
     * 
     */
    public Optional<Output<String>> namespace() {
        return Optional.ofNullable(this.namespace);
    }

    /**
     * Path to where the back-end is mounted within Vault.
     * 
     */
    @Import(name="path", required=true)
    private Output<String> path;

    /**
     * @return Path to where the back-end is mounted within Vault.
     * 
     */
    public Output<String> path() {
        return this.path;
    }

    /**
     * The name of the role.
     * 
     */
    @Import(name="roleName", required=true)
    private Output<String> roleName;

    /**
     * @return The name of the role.
     * 
     */
    public Output<String> roleName() {
        return this.roleName;
    }

    /**
     * The transformation to perform. If no value is provided and the role contains a single transformation, this value will be inferred from the role.
     * 
     */
    @Import(name="transformation")
    private @Nullable Output<String> transformation;

    /**
     * @return The transformation to perform. If no value is provided and the role contains a single transformation, this value will be inferred from the role.
     * 
     */
    public Optional<Output<String>> transformation() {
        return Optional.ofNullable(this.transformation);
    }

    /**
     * The tweak value to use. Only applicable for FPE transformations
     * 
     */
    @Import(name="tweak")
    private @Nullable Output<String> tweak;

    /**
     * @return The tweak value to use. Only applicable for FPE transformations
     * 
     */
    public Optional<Output<String>> tweak() {
        return Optional.ofNullable(this.tweak);
    }

    /**
     * The value in which to decode.
     * 
     */
    @Import(name="value")
    private @Nullable Output<String> value;

    /**
     * @return The value in which to decode.
     * 
     */
    public Optional<Output<String>> value() {
        return Optional.ofNullable(this.value);
    }

    private GetDecodeArgs() {}

    private GetDecodeArgs(GetDecodeArgs $) {
        this.batchInputs = $.batchInputs;
        this.batchResults = $.batchResults;
        this.decodedValue = $.decodedValue;
        this.namespace = $.namespace;
        this.path = $.path;
        this.roleName = $.roleName;
        this.transformation = $.transformation;
        this.tweak = $.tweak;
        this.value = $.value;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(GetDecodeArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private GetDecodeArgs $;

        public Builder() {
            $ = new GetDecodeArgs();
        }

        public Builder(GetDecodeArgs defaults) {
            $ = new GetDecodeArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param batchInputs Specifies a list of items to be decoded in a single batch. If this parameter is set, the top-level parameters &#39;value&#39;, &#39;transformation&#39; and &#39;tweak&#39; will be ignored. Each batch item within the list can specify these parameters instead.
         * 
         * @return builder
         * 
         */
        public Builder batchInputs(@Nullable Output<List<Map<String,Object>>> batchInputs) {
            $.batchInputs = batchInputs;
            return this;
        }

        /**
         * @param batchInputs Specifies a list of items to be decoded in a single batch. If this parameter is set, the top-level parameters &#39;value&#39;, &#39;transformation&#39; and &#39;tweak&#39; will be ignored. Each batch item within the list can specify these parameters instead.
         * 
         * @return builder
         * 
         */
        public Builder batchInputs(List<Map<String,Object>> batchInputs) {
            return batchInputs(Output.of(batchInputs));
        }

        /**
         * @param batchInputs Specifies a list of items to be decoded in a single batch. If this parameter is set, the top-level parameters &#39;value&#39;, &#39;transformation&#39; and &#39;tweak&#39; will be ignored. Each batch item within the list can specify these parameters instead.
         * 
         * @return builder
         * 
         */
        public Builder batchInputs(Map<String,Object>... batchInputs) {
            return batchInputs(List.of(batchInputs));
        }

        /**
         * @param batchResults The result of decoding a batch.
         * 
         * @return builder
         * 
         */
        public Builder batchResults(@Nullable Output<List<Map<String,Object>>> batchResults) {
            $.batchResults = batchResults;
            return this;
        }

        /**
         * @param batchResults The result of decoding a batch.
         * 
         * @return builder
         * 
         */
        public Builder batchResults(List<Map<String,Object>> batchResults) {
            return batchResults(Output.of(batchResults));
        }

        /**
         * @param batchResults The result of decoding a batch.
         * 
         * @return builder
         * 
         */
        public Builder batchResults(Map<String,Object>... batchResults) {
            return batchResults(List.of(batchResults));
        }

        /**
         * @param decodedValue The result of decoding a value.
         * 
         * @return builder
         * 
         */
        public Builder decodedValue(@Nullable Output<String> decodedValue) {
            $.decodedValue = decodedValue;
            return this;
        }

        /**
         * @param decodedValue The result of decoding a value.
         * 
         * @return builder
         * 
         */
        public Builder decodedValue(String decodedValue) {
            return decodedValue(Output.of(decodedValue));
        }

        /**
         * @param namespace The namespace of the target resource.
         * The value should not contain leading or trailing forward slashes.
         * The `namespace` is always relative to the provider&#39;s configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).
         * *Available only for Vault Enterprise*.
         * 
         * @return builder
         * 
         */
        public Builder namespace(@Nullable Output<String> namespace) {
            $.namespace = namespace;
            return this;
        }

        /**
         * @param namespace The namespace of the target resource.
         * The value should not contain leading or trailing forward slashes.
         * The `namespace` is always relative to the provider&#39;s configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).
         * *Available only for Vault Enterprise*.
         * 
         * @return builder
         * 
         */
        public Builder namespace(String namespace) {
            return namespace(Output.of(namespace));
        }

        /**
         * @param path Path to where the back-end is mounted within Vault.
         * 
         * @return builder
         * 
         */
        public Builder path(Output<String> path) {
            $.path = path;
            return this;
        }

        /**
         * @param path Path to where the back-end is mounted within Vault.
         * 
         * @return builder
         * 
         */
        public Builder path(String path) {
            return path(Output.of(path));
        }

        /**
         * @param roleName The name of the role.
         * 
         * @return builder
         * 
         */
        public Builder roleName(Output<String> roleName) {
            $.roleName = roleName;
            return this;
        }

        /**
         * @param roleName The name of the role.
         * 
         * @return builder
         * 
         */
        public Builder roleName(String roleName) {
            return roleName(Output.of(roleName));
        }

        /**
         * @param transformation The transformation to perform. If no value is provided and the role contains a single transformation, this value will be inferred from the role.
         * 
         * @return builder
         * 
         */
        public Builder transformation(@Nullable Output<String> transformation) {
            $.transformation = transformation;
            return this;
        }

        /**
         * @param transformation The transformation to perform. If no value is provided and the role contains a single transformation, this value will be inferred from the role.
         * 
         * @return builder
         * 
         */
        public Builder transformation(String transformation) {
            return transformation(Output.of(transformation));
        }

        /**
         * @param tweak The tweak value to use. Only applicable for FPE transformations
         * 
         * @return builder
         * 
         */
        public Builder tweak(@Nullable Output<String> tweak) {
            $.tweak = tweak;
            return this;
        }

        /**
         * @param tweak The tweak value to use. Only applicable for FPE transformations
         * 
         * @return builder
         * 
         */
        public Builder tweak(String tweak) {
            return tweak(Output.of(tweak));
        }

        /**
         * @param value The value in which to decode.
         * 
         * @return builder
         * 
         */
        public Builder value(@Nullable Output<String> value) {
            $.value = value;
            return this;
        }

        /**
         * @param value The value in which to decode.
         * 
         * @return builder
         * 
         */
        public Builder value(String value) {
            return value(Output.of(value));
        }

        public GetDecodeArgs build() {
            if ($.path == null) {
                throw new MissingRequiredPropertyException("GetDecodeArgs", "path");
            }
            if ($.roleName == null) {
                throw new MissingRequiredPropertyException("GetDecodeArgs", "roleName");
            }
            return $;
        }
    }

}
