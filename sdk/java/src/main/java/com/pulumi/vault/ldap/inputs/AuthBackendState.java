// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.vault.ldap.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class AuthBackendState extends com.pulumi.resources.ResourceArgs {

    public static final AuthBackendState Empty = new AuthBackendState();

    /**
     * The accessor for this auth mount.
     * 
     */
    @Import(name="accessor")
    private @Nullable Output<String> accessor;

    /**
     * @return The accessor for this auth mount.
     * 
     */
    public Optional<Output<String>> accessor() {
        return Optional.ofNullable(this.accessor);
    }

    /**
     * DN of object to bind when performing user search
     * 
     */
    @Import(name="binddn")
    private @Nullable Output<String> binddn;

    /**
     * @return DN of object to bind when performing user search
     * 
     */
    public Optional<Output<String>> binddn() {
        return Optional.ofNullable(this.binddn);
    }

    /**
     * Password to use with `binddn` when performing user search
     * 
     */
    @Import(name="bindpass")
    private @Nullable Output<String> bindpass;

    /**
     * @return Password to use with `binddn` when performing user search
     * 
     */
    public Optional<Output<String>> bindpass() {
        return Optional.ofNullable(this.bindpass);
    }

    /**
     * Control case senstivity of objects fetched from LDAP, this is used for object matching in vault
     * 
     */
    @Import(name="caseSensitiveNames")
    private @Nullable Output<Boolean> caseSensitiveNames;

    /**
     * @return Control case senstivity of objects fetched from LDAP, this is used for object matching in vault
     * 
     */
    public Optional<Output<Boolean>> caseSensitiveNames() {
        return Optional.ofNullable(this.caseSensitiveNames);
    }

    /**
     * Trusted CA to validate TLS certificate
     * 
     */
    @Import(name="certificate")
    private @Nullable Output<String> certificate;

    /**
     * @return Trusted CA to validate TLS certificate
     * 
     */
    public Optional<Output<String>> certificate() {
        return Optional.ofNullable(this.certificate);
    }

    @Import(name="clientTlsCert")
    private @Nullable Output<String> clientTlsCert;

    public Optional<Output<String>> clientTlsCert() {
        return Optional.ofNullable(this.clientTlsCert);
    }

    @Import(name="clientTlsKey")
    private @Nullable Output<String> clientTlsKey;

    public Optional<Output<String>> clientTlsKey() {
        return Optional.ofNullable(this.clientTlsKey);
    }

    /**
     * Timeout in seconds when connecting to LDAP before attempting to connect to the next server in the URL provided in `url` (integer: 30)
     * 
     */
    @Import(name="connectionTimeout")
    private @Nullable Output<Integer> connectionTimeout;

    /**
     * @return Timeout in seconds when connecting to LDAP before attempting to connect to the next server in the URL provided in `url` (integer: 30)
     * 
     */
    public Optional<Output<Integer>> connectionTimeout() {
        return Optional.ofNullable(this.connectionTimeout);
    }

    /**
     * Prevents users from bypassing authentication when providing an empty password.
     * 
     */
    @Import(name="denyNullBind")
    private @Nullable Output<Boolean> denyNullBind;

    /**
     * @return Prevents users from bypassing authentication when providing an empty password.
     * 
     */
    public Optional<Output<Boolean>> denyNullBind() {
        return Optional.ofNullable(this.denyNullBind);
    }

    /**
     * Description for the LDAP auth backend mount
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return Description for the LDAP auth backend mount
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * Cancels all upcoming rotations of the root credential until unset. Requires Vault Enterprise 1.19+.
     * 
     */
    @Import(name="disableAutomatedRotation")
    private @Nullable Output<Boolean> disableAutomatedRotation;

    /**
     * @return Cancels all upcoming rotations of the root credential until unset. Requires Vault Enterprise 1.19+.
     * 
     */
    public Optional<Output<Boolean>> disableAutomatedRotation() {
        return Optional.ofNullable(this.disableAutomatedRotation);
    }

    /**
     * If set, opts out of mount migration on path updates.
     * See here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)
     * 
     */
    @Import(name="disableRemount")
    private @Nullable Output<Boolean> disableRemount;

    /**
     * @return If set, opts out of mount migration on path updates.
     * See here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)
     * 
     */
    public Optional<Output<Boolean>> disableRemount() {
        return Optional.ofNullable(this.disableRemount);
    }

    /**
     * Use anonymous bind to discover the bind DN of a user.
     * 
     */
    @Import(name="discoverdn")
    private @Nullable Output<Boolean> discoverdn;

    /**
     * @return Use anonymous bind to discover the bind DN of a user.
     * 
     */
    public Optional<Output<Boolean>> discoverdn() {
        return Optional.ofNullable(this.discoverdn);
    }

    /**
     * LDAP attribute to follow on objects returned by groupfilter
     * 
     */
    @Import(name="groupattr")
    private @Nullable Output<String> groupattr;

    /**
     * @return LDAP attribute to follow on objects returned by groupfilter
     * 
     */
    public Optional<Output<String>> groupattr() {
        return Optional.ofNullable(this.groupattr);
    }

    /**
     * Base DN under which to perform group search
     * 
     */
    @Import(name="groupdn")
    private @Nullable Output<String> groupdn;

    /**
     * @return Base DN under which to perform group search
     * 
     */
    public Optional<Output<String>> groupdn() {
        return Optional.ofNullable(this.groupdn);
    }

    /**
     * Go template used to construct group membership query
     * 
     */
    @Import(name="groupfilter")
    private @Nullable Output<String> groupfilter;

    /**
     * @return Go template used to construct group membership query
     * 
     */
    public Optional<Output<String>> groupfilter() {
        return Optional.ofNullable(this.groupfilter);
    }

    /**
     * Control whether or TLS certificates must be validated
     * 
     */
    @Import(name="insecureTls")
    private @Nullable Output<Boolean> insecureTls;

    /**
     * @return Control whether or TLS certificates must be validated
     * 
     */
    public Optional<Output<Boolean>> insecureTls() {
        return Optional.ofNullable(this.insecureTls);
    }

    /**
     * Specifies if the auth method is local only.
     * 
     */
    @Import(name="local")
    private @Nullable Output<Boolean> local;

    /**
     * @return Specifies if the auth method is local only.
     * 
     */
    public Optional<Output<Boolean>> local() {
        return Optional.ofNullable(this.local);
    }

    /**
     * Sets the max page size for LDAP lookups, by default it&#39;s set to -1.
     * *Available only for Vault 1.11.11+, 1.12.7+, and 1.13.3+*.
     * 
     */
    @Import(name="maxPageSize")
    private @Nullable Output<Integer> maxPageSize;

    /**
     * @return Sets the max page size for LDAP lookups, by default it&#39;s set to -1.
     * *Available only for Vault 1.11.11+, 1.12.7+, and 1.13.3+*.
     * 
     */
    public Optional<Output<Integer>> maxPageSize() {
        return Optional.ofNullable(this.maxPageSize);
    }

    /**
     * The namespace to provision the resource in.
     * The value should not contain leading or trailing forward slashes.
     * The `namespace` is always relative to the provider&#39;s configured [namespace](https://www.terraform.io/docs/providers/vault/index.html#namespace).
     * *Available only for Vault Enterprise*.
     * 
     */
    @Import(name="namespace")
    private @Nullable Output<String> namespace;

    /**
     * @return The namespace to provision the resource in.
     * The value should not contain leading or trailing forward slashes.
     * The `namespace` is always relative to the provider&#39;s configured [namespace](https://www.terraform.io/docs/providers/vault/index.html#namespace).
     * *Available only for Vault Enterprise*.
     * 
     */
    public Optional<Output<String>> namespace() {
        return Optional.ofNullable(this.namespace);
    }

    /**
     * Path to mount the LDAP auth backend under
     * 
     */
    @Import(name="path")
    private @Nullable Output<String> path;

    /**
     * @return Path to mount the LDAP auth backend under
     * 
     */
    public Optional<Output<String>> path() {
        return Optional.ofNullable(this.path);
    }

    /**
     * The amount of time in seconds Vault should wait before rotating the root credential.
     * A zero value tells Vault not to rotate the root credential. The minimum rotation period is 10 seconds. Requires Vault Enterprise 1.19+.
     * 
     */
    @Import(name="rotationPeriod")
    private @Nullable Output<Integer> rotationPeriod;

    /**
     * @return The amount of time in seconds Vault should wait before rotating the root credential.
     * A zero value tells Vault not to rotate the root credential. The minimum rotation period is 10 seconds. Requires Vault Enterprise 1.19+.
     * 
     */
    public Optional<Output<Integer>> rotationPeriod() {
        return Optional.ofNullable(this.rotationPeriod);
    }

    /**
     * The schedule, in [cron-style time format](https://en.wikipedia.org/wiki/Cron),
     * defining the schedule on which Vault should rotate the root token. Requires Vault Enterprise 1.19+.
     * 
     */
    @Import(name="rotationSchedule")
    private @Nullable Output<String> rotationSchedule;

    /**
     * @return The schedule, in [cron-style time format](https://en.wikipedia.org/wiki/Cron),
     * defining the schedule on which Vault should rotate the root token. Requires Vault Enterprise 1.19+.
     * 
     */
    public Optional<Output<String>> rotationSchedule() {
        return Optional.ofNullable(this.rotationSchedule);
    }

    /**
     * The maximum amount of time in seconds allowed to complete
     * a rotation when a scheduled token rotation occurs. The default rotation window is
     * unbound and the minimum allowable window is `3600`. Requires Vault Enterprise 1.19+.
     * 
     */
    @Import(name="rotationWindow")
    private @Nullable Output<Integer> rotationWindow;

    /**
     * @return The maximum amount of time in seconds allowed to complete
     * a rotation when a scheduled token rotation occurs. The default rotation window is
     * unbound and the minimum allowable window is `3600`. Requires Vault Enterprise 1.19+.
     * 
     */
    public Optional<Output<Integer>> rotationWindow() {
        return Optional.ofNullable(this.rotationWindow);
    }

    /**
     * Control use of TLS when conecting to LDAP
     * 
     */
    @Import(name="starttls")
    private @Nullable Output<Boolean> starttls;

    /**
     * @return Control use of TLS when conecting to LDAP
     * 
     */
    public Optional<Output<Boolean>> starttls() {
        return Optional.ofNullable(this.starttls);
    }

    /**
     * Maximum acceptable version of TLS
     * 
     */
    @Import(name="tlsMaxVersion")
    private @Nullable Output<String> tlsMaxVersion;

    /**
     * @return Maximum acceptable version of TLS
     * 
     */
    public Optional<Output<String>> tlsMaxVersion() {
        return Optional.ofNullable(this.tlsMaxVersion);
    }

    /**
     * Minimum acceptable version of TLS
     * 
     */
    @Import(name="tlsMinVersion")
    private @Nullable Output<String> tlsMinVersion;

    /**
     * @return Minimum acceptable version of TLS
     * 
     */
    public Optional<Output<String>> tlsMinVersion() {
        return Optional.ofNullable(this.tlsMinVersion);
    }

    /**
     * Specifies the blocks of IP addresses which are allowed to use the generated token
     * 
     */
    @Import(name="tokenBoundCidrs")
    private @Nullable Output<List<String>> tokenBoundCidrs;

    /**
     * @return Specifies the blocks of IP addresses which are allowed to use the generated token
     * 
     */
    public Optional<Output<List<String>>> tokenBoundCidrs() {
        return Optional.ofNullable(this.tokenBoundCidrs);
    }

    /**
     * Generated Token&#39;s Explicit Maximum TTL in seconds
     * 
     */
    @Import(name="tokenExplicitMaxTtl")
    private @Nullable Output<Integer> tokenExplicitMaxTtl;

    /**
     * @return Generated Token&#39;s Explicit Maximum TTL in seconds
     * 
     */
    public Optional<Output<Integer>> tokenExplicitMaxTtl() {
        return Optional.ofNullable(this.tokenExplicitMaxTtl);
    }

    /**
     * The maximum lifetime of the generated token
     * 
     */
    @Import(name="tokenMaxTtl")
    private @Nullable Output<Integer> tokenMaxTtl;

    /**
     * @return The maximum lifetime of the generated token
     * 
     */
    public Optional<Output<Integer>> tokenMaxTtl() {
        return Optional.ofNullable(this.tokenMaxTtl);
    }

    /**
     * If true, the &#39;default&#39; policy will not automatically be added to generated tokens
     * 
     */
    @Import(name="tokenNoDefaultPolicy")
    private @Nullable Output<Boolean> tokenNoDefaultPolicy;

    /**
     * @return If true, the &#39;default&#39; policy will not automatically be added to generated tokens
     * 
     */
    public Optional<Output<Boolean>> tokenNoDefaultPolicy() {
        return Optional.ofNullable(this.tokenNoDefaultPolicy);
    }

    /**
     * The maximum number of times a token may be used, a value of zero means unlimited
     * 
     */
    @Import(name="tokenNumUses")
    private @Nullable Output<Integer> tokenNumUses;

    /**
     * @return The maximum number of times a token may be used, a value of zero means unlimited
     * 
     */
    public Optional<Output<Integer>> tokenNumUses() {
        return Optional.ofNullable(this.tokenNumUses);
    }

    /**
     * Generated Token&#39;s Period
     * 
     */
    @Import(name="tokenPeriod")
    private @Nullable Output<Integer> tokenPeriod;

    /**
     * @return Generated Token&#39;s Period
     * 
     */
    public Optional<Output<Integer>> tokenPeriod() {
        return Optional.ofNullable(this.tokenPeriod);
    }

    /**
     * Generated Token&#39;s Policies
     * 
     */
    @Import(name="tokenPolicies")
    private @Nullable Output<List<String>> tokenPolicies;

    /**
     * @return Generated Token&#39;s Policies
     * 
     */
    public Optional<Output<List<String>>> tokenPolicies() {
        return Optional.ofNullable(this.tokenPolicies);
    }

    /**
     * The initial ttl of the token to generate in seconds
     * 
     */
    @Import(name="tokenTtl")
    private @Nullable Output<Integer> tokenTtl;

    /**
     * @return The initial ttl of the token to generate in seconds
     * 
     */
    public Optional<Output<Integer>> tokenTtl() {
        return Optional.ofNullable(this.tokenTtl);
    }

    /**
     * The type of token to generate, service or batch
     * 
     */
    @Import(name="tokenType")
    private @Nullable Output<String> tokenType;

    /**
     * @return The type of token to generate, service or batch
     * 
     */
    public Optional<Output<String>> tokenType() {
        return Optional.ofNullable(this.tokenType);
    }

    /**
     * The `userPrincipalDomain` used to construct the UPN string for the authenticating user.
     * 
     */
    @Import(name="upndomain")
    private @Nullable Output<String> upndomain;

    /**
     * @return The `userPrincipalDomain` used to construct the UPN string for the authenticating user.
     * 
     */
    public Optional<Output<String>> upndomain() {
        return Optional.ofNullable(this.upndomain);
    }

    /**
     * The URL of the LDAP server
     * 
     */
    @Import(name="url")
    private @Nullable Output<String> url;

    /**
     * @return The URL of the LDAP server
     * 
     */
    public Optional<Output<String>> url() {
        return Optional.ofNullable(this.url);
    }

    /**
     * Use the Active Directory tokenGroups constructed attribute of the user to find the group memberships
     * 
     */
    @Import(name="useTokenGroups")
    private @Nullable Output<Boolean> useTokenGroups;

    /**
     * @return Use the Active Directory tokenGroups constructed attribute of the user to find the group memberships
     * 
     */
    public Optional<Output<Boolean>> useTokenGroups() {
        return Optional.ofNullable(this.useTokenGroups);
    }

    /**
     * Attribute on user object matching username passed in
     * 
     */
    @Import(name="userattr")
    private @Nullable Output<String> userattr;

    /**
     * @return Attribute on user object matching username passed in
     * 
     */
    public Optional<Output<String>> userattr() {
        return Optional.ofNullable(this.userattr);
    }

    /**
     * Base DN under which to perform user search
     * 
     */
    @Import(name="userdn")
    private @Nullable Output<String> userdn;

    /**
     * @return Base DN under which to perform user search
     * 
     */
    public Optional<Output<String>> userdn() {
        return Optional.ofNullable(this.userdn);
    }

    /**
     * LDAP user search filter
     * 
     */
    @Import(name="userfilter")
    private @Nullable Output<String> userfilter;

    /**
     * @return LDAP user search filter
     * 
     */
    public Optional<Output<String>> userfilter() {
        return Optional.ofNullable(this.userfilter);
    }

    /**
     * Force the auth method to use the username passed by the user as the alias name.
     * 
     */
    @Import(name="usernameAsAlias")
    private @Nullable Output<Boolean> usernameAsAlias;

    /**
     * @return Force the auth method to use the username passed by the user as the alias name.
     * 
     */
    public Optional<Output<Boolean>> usernameAsAlias() {
        return Optional.ofNullable(this.usernameAsAlias);
    }

    private AuthBackendState() {}

    private AuthBackendState(AuthBackendState $) {
        this.accessor = $.accessor;
        this.binddn = $.binddn;
        this.bindpass = $.bindpass;
        this.caseSensitiveNames = $.caseSensitiveNames;
        this.certificate = $.certificate;
        this.clientTlsCert = $.clientTlsCert;
        this.clientTlsKey = $.clientTlsKey;
        this.connectionTimeout = $.connectionTimeout;
        this.denyNullBind = $.denyNullBind;
        this.description = $.description;
        this.disableAutomatedRotation = $.disableAutomatedRotation;
        this.disableRemount = $.disableRemount;
        this.discoverdn = $.discoverdn;
        this.groupattr = $.groupattr;
        this.groupdn = $.groupdn;
        this.groupfilter = $.groupfilter;
        this.insecureTls = $.insecureTls;
        this.local = $.local;
        this.maxPageSize = $.maxPageSize;
        this.namespace = $.namespace;
        this.path = $.path;
        this.rotationPeriod = $.rotationPeriod;
        this.rotationSchedule = $.rotationSchedule;
        this.rotationWindow = $.rotationWindow;
        this.starttls = $.starttls;
        this.tlsMaxVersion = $.tlsMaxVersion;
        this.tlsMinVersion = $.tlsMinVersion;
        this.tokenBoundCidrs = $.tokenBoundCidrs;
        this.tokenExplicitMaxTtl = $.tokenExplicitMaxTtl;
        this.tokenMaxTtl = $.tokenMaxTtl;
        this.tokenNoDefaultPolicy = $.tokenNoDefaultPolicy;
        this.tokenNumUses = $.tokenNumUses;
        this.tokenPeriod = $.tokenPeriod;
        this.tokenPolicies = $.tokenPolicies;
        this.tokenTtl = $.tokenTtl;
        this.tokenType = $.tokenType;
        this.upndomain = $.upndomain;
        this.url = $.url;
        this.useTokenGroups = $.useTokenGroups;
        this.userattr = $.userattr;
        this.userdn = $.userdn;
        this.userfilter = $.userfilter;
        this.usernameAsAlias = $.usernameAsAlias;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(AuthBackendState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private AuthBackendState $;

        public Builder() {
            $ = new AuthBackendState();
        }

        public Builder(AuthBackendState defaults) {
            $ = new AuthBackendState(Objects.requireNonNull(defaults));
        }

        /**
         * @param accessor The accessor for this auth mount.
         * 
         * @return builder
         * 
         */
        public Builder accessor(@Nullable Output<String> accessor) {
            $.accessor = accessor;
            return this;
        }

        /**
         * @param accessor The accessor for this auth mount.
         * 
         * @return builder
         * 
         */
        public Builder accessor(String accessor) {
            return accessor(Output.of(accessor));
        }

        /**
         * @param binddn DN of object to bind when performing user search
         * 
         * @return builder
         * 
         */
        public Builder binddn(@Nullable Output<String> binddn) {
            $.binddn = binddn;
            return this;
        }

        /**
         * @param binddn DN of object to bind when performing user search
         * 
         * @return builder
         * 
         */
        public Builder binddn(String binddn) {
            return binddn(Output.of(binddn));
        }

        /**
         * @param bindpass Password to use with `binddn` when performing user search
         * 
         * @return builder
         * 
         */
        public Builder bindpass(@Nullable Output<String> bindpass) {
            $.bindpass = bindpass;
            return this;
        }

        /**
         * @param bindpass Password to use with `binddn` when performing user search
         * 
         * @return builder
         * 
         */
        public Builder bindpass(String bindpass) {
            return bindpass(Output.of(bindpass));
        }

        /**
         * @param caseSensitiveNames Control case senstivity of objects fetched from LDAP, this is used for object matching in vault
         * 
         * @return builder
         * 
         */
        public Builder caseSensitiveNames(@Nullable Output<Boolean> caseSensitiveNames) {
            $.caseSensitiveNames = caseSensitiveNames;
            return this;
        }

        /**
         * @param caseSensitiveNames Control case senstivity of objects fetched from LDAP, this is used for object matching in vault
         * 
         * @return builder
         * 
         */
        public Builder caseSensitiveNames(Boolean caseSensitiveNames) {
            return caseSensitiveNames(Output.of(caseSensitiveNames));
        }

        /**
         * @param certificate Trusted CA to validate TLS certificate
         * 
         * @return builder
         * 
         */
        public Builder certificate(@Nullable Output<String> certificate) {
            $.certificate = certificate;
            return this;
        }

        /**
         * @param certificate Trusted CA to validate TLS certificate
         * 
         * @return builder
         * 
         */
        public Builder certificate(String certificate) {
            return certificate(Output.of(certificate));
        }

        public Builder clientTlsCert(@Nullable Output<String> clientTlsCert) {
            $.clientTlsCert = clientTlsCert;
            return this;
        }

        public Builder clientTlsCert(String clientTlsCert) {
            return clientTlsCert(Output.of(clientTlsCert));
        }

        public Builder clientTlsKey(@Nullable Output<String> clientTlsKey) {
            $.clientTlsKey = clientTlsKey;
            return this;
        }

        public Builder clientTlsKey(String clientTlsKey) {
            return clientTlsKey(Output.of(clientTlsKey));
        }

        /**
         * @param connectionTimeout Timeout in seconds when connecting to LDAP before attempting to connect to the next server in the URL provided in `url` (integer: 30)
         * 
         * @return builder
         * 
         */
        public Builder connectionTimeout(@Nullable Output<Integer> connectionTimeout) {
            $.connectionTimeout = connectionTimeout;
            return this;
        }

        /**
         * @param connectionTimeout Timeout in seconds when connecting to LDAP before attempting to connect to the next server in the URL provided in `url` (integer: 30)
         * 
         * @return builder
         * 
         */
        public Builder connectionTimeout(Integer connectionTimeout) {
            return connectionTimeout(Output.of(connectionTimeout));
        }

        /**
         * @param denyNullBind Prevents users from bypassing authentication when providing an empty password.
         * 
         * @return builder
         * 
         */
        public Builder denyNullBind(@Nullable Output<Boolean> denyNullBind) {
            $.denyNullBind = denyNullBind;
            return this;
        }

        /**
         * @param denyNullBind Prevents users from bypassing authentication when providing an empty password.
         * 
         * @return builder
         * 
         */
        public Builder denyNullBind(Boolean denyNullBind) {
            return denyNullBind(Output.of(denyNullBind));
        }

        /**
         * @param description Description for the LDAP auth backend mount
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description Description for the LDAP auth backend mount
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param disableAutomatedRotation Cancels all upcoming rotations of the root credential until unset. Requires Vault Enterprise 1.19+.
         * 
         * @return builder
         * 
         */
        public Builder disableAutomatedRotation(@Nullable Output<Boolean> disableAutomatedRotation) {
            $.disableAutomatedRotation = disableAutomatedRotation;
            return this;
        }

        /**
         * @param disableAutomatedRotation Cancels all upcoming rotations of the root credential until unset. Requires Vault Enterprise 1.19+.
         * 
         * @return builder
         * 
         */
        public Builder disableAutomatedRotation(Boolean disableAutomatedRotation) {
            return disableAutomatedRotation(Output.of(disableAutomatedRotation));
        }

        /**
         * @param disableRemount If set, opts out of mount migration on path updates.
         * See here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)
         * 
         * @return builder
         * 
         */
        public Builder disableRemount(@Nullable Output<Boolean> disableRemount) {
            $.disableRemount = disableRemount;
            return this;
        }

        /**
         * @param disableRemount If set, opts out of mount migration on path updates.
         * See here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)
         * 
         * @return builder
         * 
         */
        public Builder disableRemount(Boolean disableRemount) {
            return disableRemount(Output.of(disableRemount));
        }

        /**
         * @param discoverdn Use anonymous bind to discover the bind DN of a user.
         * 
         * @return builder
         * 
         */
        public Builder discoverdn(@Nullable Output<Boolean> discoverdn) {
            $.discoverdn = discoverdn;
            return this;
        }

        /**
         * @param discoverdn Use anonymous bind to discover the bind DN of a user.
         * 
         * @return builder
         * 
         */
        public Builder discoverdn(Boolean discoverdn) {
            return discoverdn(Output.of(discoverdn));
        }

        /**
         * @param groupattr LDAP attribute to follow on objects returned by groupfilter
         * 
         * @return builder
         * 
         */
        public Builder groupattr(@Nullable Output<String> groupattr) {
            $.groupattr = groupattr;
            return this;
        }

        /**
         * @param groupattr LDAP attribute to follow on objects returned by groupfilter
         * 
         * @return builder
         * 
         */
        public Builder groupattr(String groupattr) {
            return groupattr(Output.of(groupattr));
        }

        /**
         * @param groupdn Base DN under which to perform group search
         * 
         * @return builder
         * 
         */
        public Builder groupdn(@Nullable Output<String> groupdn) {
            $.groupdn = groupdn;
            return this;
        }

        /**
         * @param groupdn Base DN under which to perform group search
         * 
         * @return builder
         * 
         */
        public Builder groupdn(String groupdn) {
            return groupdn(Output.of(groupdn));
        }

        /**
         * @param groupfilter Go template used to construct group membership query
         * 
         * @return builder
         * 
         */
        public Builder groupfilter(@Nullable Output<String> groupfilter) {
            $.groupfilter = groupfilter;
            return this;
        }

        /**
         * @param groupfilter Go template used to construct group membership query
         * 
         * @return builder
         * 
         */
        public Builder groupfilter(String groupfilter) {
            return groupfilter(Output.of(groupfilter));
        }

        /**
         * @param insecureTls Control whether or TLS certificates must be validated
         * 
         * @return builder
         * 
         */
        public Builder insecureTls(@Nullable Output<Boolean> insecureTls) {
            $.insecureTls = insecureTls;
            return this;
        }

        /**
         * @param insecureTls Control whether or TLS certificates must be validated
         * 
         * @return builder
         * 
         */
        public Builder insecureTls(Boolean insecureTls) {
            return insecureTls(Output.of(insecureTls));
        }

        /**
         * @param local Specifies if the auth method is local only.
         * 
         * @return builder
         * 
         */
        public Builder local(@Nullable Output<Boolean> local) {
            $.local = local;
            return this;
        }

        /**
         * @param local Specifies if the auth method is local only.
         * 
         * @return builder
         * 
         */
        public Builder local(Boolean local) {
            return local(Output.of(local));
        }

        /**
         * @param maxPageSize Sets the max page size for LDAP lookups, by default it&#39;s set to -1.
         * *Available only for Vault 1.11.11+, 1.12.7+, and 1.13.3+*.
         * 
         * @return builder
         * 
         */
        public Builder maxPageSize(@Nullable Output<Integer> maxPageSize) {
            $.maxPageSize = maxPageSize;
            return this;
        }

        /**
         * @param maxPageSize Sets the max page size for LDAP lookups, by default it&#39;s set to -1.
         * *Available only for Vault 1.11.11+, 1.12.7+, and 1.13.3+*.
         * 
         * @return builder
         * 
         */
        public Builder maxPageSize(Integer maxPageSize) {
            return maxPageSize(Output.of(maxPageSize));
        }

        /**
         * @param namespace The namespace to provision the resource in.
         * The value should not contain leading or trailing forward slashes.
         * The `namespace` is always relative to the provider&#39;s configured [namespace](https://www.terraform.io/docs/providers/vault/index.html#namespace).
         * *Available only for Vault Enterprise*.
         * 
         * @return builder
         * 
         */
        public Builder namespace(@Nullable Output<String> namespace) {
            $.namespace = namespace;
            return this;
        }

        /**
         * @param namespace The namespace to provision the resource in.
         * The value should not contain leading or trailing forward slashes.
         * The `namespace` is always relative to the provider&#39;s configured [namespace](https://www.terraform.io/docs/providers/vault/index.html#namespace).
         * *Available only for Vault Enterprise*.
         * 
         * @return builder
         * 
         */
        public Builder namespace(String namespace) {
            return namespace(Output.of(namespace));
        }

        /**
         * @param path Path to mount the LDAP auth backend under
         * 
         * @return builder
         * 
         */
        public Builder path(@Nullable Output<String> path) {
            $.path = path;
            return this;
        }

        /**
         * @param path Path to mount the LDAP auth backend under
         * 
         * @return builder
         * 
         */
        public Builder path(String path) {
            return path(Output.of(path));
        }

        /**
         * @param rotationPeriod The amount of time in seconds Vault should wait before rotating the root credential.
         * A zero value tells Vault not to rotate the root credential. The minimum rotation period is 10 seconds. Requires Vault Enterprise 1.19+.
         * 
         * @return builder
         * 
         */
        public Builder rotationPeriod(@Nullable Output<Integer> rotationPeriod) {
            $.rotationPeriod = rotationPeriod;
            return this;
        }

        /**
         * @param rotationPeriod The amount of time in seconds Vault should wait before rotating the root credential.
         * A zero value tells Vault not to rotate the root credential. The minimum rotation period is 10 seconds. Requires Vault Enterprise 1.19+.
         * 
         * @return builder
         * 
         */
        public Builder rotationPeriod(Integer rotationPeriod) {
            return rotationPeriod(Output.of(rotationPeriod));
        }

        /**
         * @param rotationSchedule The schedule, in [cron-style time format](https://en.wikipedia.org/wiki/Cron),
         * defining the schedule on which Vault should rotate the root token. Requires Vault Enterprise 1.19+.
         * 
         * @return builder
         * 
         */
        public Builder rotationSchedule(@Nullable Output<String> rotationSchedule) {
            $.rotationSchedule = rotationSchedule;
            return this;
        }

        /**
         * @param rotationSchedule The schedule, in [cron-style time format](https://en.wikipedia.org/wiki/Cron),
         * defining the schedule on which Vault should rotate the root token. Requires Vault Enterprise 1.19+.
         * 
         * @return builder
         * 
         */
        public Builder rotationSchedule(String rotationSchedule) {
            return rotationSchedule(Output.of(rotationSchedule));
        }

        /**
         * @param rotationWindow The maximum amount of time in seconds allowed to complete
         * a rotation when a scheduled token rotation occurs. The default rotation window is
         * unbound and the minimum allowable window is `3600`. Requires Vault Enterprise 1.19+.
         * 
         * @return builder
         * 
         */
        public Builder rotationWindow(@Nullable Output<Integer> rotationWindow) {
            $.rotationWindow = rotationWindow;
            return this;
        }

        /**
         * @param rotationWindow The maximum amount of time in seconds allowed to complete
         * a rotation when a scheduled token rotation occurs. The default rotation window is
         * unbound and the minimum allowable window is `3600`. Requires Vault Enterprise 1.19+.
         * 
         * @return builder
         * 
         */
        public Builder rotationWindow(Integer rotationWindow) {
            return rotationWindow(Output.of(rotationWindow));
        }

        /**
         * @param starttls Control use of TLS when conecting to LDAP
         * 
         * @return builder
         * 
         */
        public Builder starttls(@Nullable Output<Boolean> starttls) {
            $.starttls = starttls;
            return this;
        }

        /**
         * @param starttls Control use of TLS when conecting to LDAP
         * 
         * @return builder
         * 
         */
        public Builder starttls(Boolean starttls) {
            return starttls(Output.of(starttls));
        }

        /**
         * @param tlsMaxVersion Maximum acceptable version of TLS
         * 
         * @return builder
         * 
         */
        public Builder tlsMaxVersion(@Nullable Output<String> tlsMaxVersion) {
            $.tlsMaxVersion = tlsMaxVersion;
            return this;
        }

        /**
         * @param tlsMaxVersion Maximum acceptable version of TLS
         * 
         * @return builder
         * 
         */
        public Builder tlsMaxVersion(String tlsMaxVersion) {
            return tlsMaxVersion(Output.of(tlsMaxVersion));
        }

        /**
         * @param tlsMinVersion Minimum acceptable version of TLS
         * 
         * @return builder
         * 
         */
        public Builder tlsMinVersion(@Nullable Output<String> tlsMinVersion) {
            $.tlsMinVersion = tlsMinVersion;
            return this;
        }

        /**
         * @param tlsMinVersion Minimum acceptable version of TLS
         * 
         * @return builder
         * 
         */
        public Builder tlsMinVersion(String tlsMinVersion) {
            return tlsMinVersion(Output.of(tlsMinVersion));
        }

        /**
         * @param tokenBoundCidrs Specifies the blocks of IP addresses which are allowed to use the generated token
         * 
         * @return builder
         * 
         */
        public Builder tokenBoundCidrs(@Nullable Output<List<String>> tokenBoundCidrs) {
            $.tokenBoundCidrs = tokenBoundCidrs;
            return this;
        }

        /**
         * @param tokenBoundCidrs Specifies the blocks of IP addresses which are allowed to use the generated token
         * 
         * @return builder
         * 
         */
        public Builder tokenBoundCidrs(List<String> tokenBoundCidrs) {
            return tokenBoundCidrs(Output.of(tokenBoundCidrs));
        }

        /**
         * @param tokenBoundCidrs Specifies the blocks of IP addresses which are allowed to use the generated token
         * 
         * @return builder
         * 
         */
        public Builder tokenBoundCidrs(String... tokenBoundCidrs) {
            return tokenBoundCidrs(List.of(tokenBoundCidrs));
        }

        /**
         * @param tokenExplicitMaxTtl Generated Token&#39;s Explicit Maximum TTL in seconds
         * 
         * @return builder
         * 
         */
        public Builder tokenExplicitMaxTtl(@Nullable Output<Integer> tokenExplicitMaxTtl) {
            $.tokenExplicitMaxTtl = tokenExplicitMaxTtl;
            return this;
        }

        /**
         * @param tokenExplicitMaxTtl Generated Token&#39;s Explicit Maximum TTL in seconds
         * 
         * @return builder
         * 
         */
        public Builder tokenExplicitMaxTtl(Integer tokenExplicitMaxTtl) {
            return tokenExplicitMaxTtl(Output.of(tokenExplicitMaxTtl));
        }

        /**
         * @param tokenMaxTtl The maximum lifetime of the generated token
         * 
         * @return builder
         * 
         */
        public Builder tokenMaxTtl(@Nullable Output<Integer> tokenMaxTtl) {
            $.tokenMaxTtl = tokenMaxTtl;
            return this;
        }

        /**
         * @param tokenMaxTtl The maximum lifetime of the generated token
         * 
         * @return builder
         * 
         */
        public Builder tokenMaxTtl(Integer tokenMaxTtl) {
            return tokenMaxTtl(Output.of(tokenMaxTtl));
        }

        /**
         * @param tokenNoDefaultPolicy If true, the &#39;default&#39; policy will not automatically be added to generated tokens
         * 
         * @return builder
         * 
         */
        public Builder tokenNoDefaultPolicy(@Nullable Output<Boolean> tokenNoDefaultPolicy) {
            $.tokenNoDefaultPolicy = tokenNoDefaultPolicy;
            return this;
        }

        /**
         * @param tokenNoDefaultPolicy If true, the &#39;default&#39; policy will not automatically be added to generated tokens
         * 
         * @return builder
         * 
         */
        public Builder tokenNoDefaultPolicy(Boolean tokenNoDefaultPolicy) {
            return tokenNoDefaultPolicy(Output.of(tokenNoDefaultPolicy));
        }

        /**
         * @param tokenNumUses The maximum number of times a token may be used, a value of zero means unlimited
         * 
         * @return builder
         * 
         */
        public Builder tokenNumUses(@Nullable Output<Integer> tokenNumUses) {
            $.tokenNumUses = tokenNumUses;
            return this;
        }

        /**
         * @param tokenNumUses The maximum number of times a token may be used, a value of zero means unlimited
         * 
         * @return builder
         * 
         */
        public Builder tokenNumUses(Integer tokenNumUses) {
            return tokenNumUses(Output.of(tokenNumUses));
        }

        /**
         * @param tokenPeriod Generated Token&#39;s Period
         * 
         * @return builder
         * 
         */
        public Builder tokenPeriod(@Nullable Output<Integer> tokenPeriod) {
            $.tokenPeriod = tokenPeriod;
            return this;
        }

        /**
         * @param tokenPeriod Generated Token&#39;s Period
         * 
         * @return builder
         * 
         */
        public Builder tokenPeriod(Integer tokenPeriod) {
            return tokenPeriod(Output.of(tokenPeriod));
        }

        /**
         * @param tokenPolicies Generated Token&#39;s Policies
         * 
         * @return builder
         * 
         */
        public Builder tokenPolicies(@Nullable Output<List<String>> tokenPolicies) {
            $.tokenPolicies = tokenPolicies;
            return this;
        }

        /**
         * @param tokenPolicies Generated Token&#39;s Policies
         * 
         * @return builder
         * 
         */
        public Builder tokenPolicies(List<String> tokenPolicies) {
            return tokenPolicies(Output.of(tokenPolicies));
        }

        /**
         * @param tokenPolicies Generated Token&#39;s Policies
         * 
         * @return builder
         * 
         */
        public Builder tokenPolicies(String... tokenPolicies) {
            return tokenPolicies(List.of(tokenPolicies));
        }

        /**
         * @param tokenTtl The initial ttl of the token to generate in seconds
         * 
         * @return builder
         * 
         */
        public Builder tokenTtl(@Nullable Output<Integer> tokenTtl) {
            $.tokenTtl = tokenTtl;
            return this;
        }

        /**
         * @param tokenTtl The initial ttl of the token to generate in seconds
         * 
         * @return builder
         * 
         */
        public Builder tokenTtl(Integer tokenTtl) {
            return tokenTtl(Output.of(tokenTtl));
        }

        /**
         * @param tokenType The type of token to generate, service or batch
         * 
         * @return builder
         * 
         */
        public Builder tokenType(@Nullable Output<String> tokenType) {
            $.tokenType = tokenType;
            return this;
        }

        /**
         * @param tokenType The type of token to generate, service or batch
         * 
         * @return builder
         * 
         */
        public Builder tokenType(String tokenType) {
            return tokenType(Output.of(tokenType));
        }

        /**
         * @param upndomain The `userPrincipalDomain` used to construct the UPN string for the authenticating user.
         * 
         * @return builder
         * 
         */
        public Builder upndomain(@Nullable Output<String> upndomain) {
            $.upndomain = upndomain;
            return this;
        }

        /**
         * @param upndomain The `userPrincipalDomain` used to construct the UPN string for the authenticating user.
         * 
         * @return builder
         * 
         */
        public Builder upndomain(String upndomain) {
            return upndomain(Output.of(upndomain));
        }

        /**
         * @param url The URL of the LDAP server
         * 
         * @return builder
         * 
         */
        public Builder url(@Nullable Output<String> url) {
            $.url = url;
            return this;
        }

        /**
         * @param url The URL of the LDAP server
         * 
         * @return builder
         * 
         */
        public Builder url(String url) {
            return url(Output.of(url));
        }

        /**
         * @param useTokenGroups Use the Active Directory tokenGroups constructed attribute of the user to find the group memberships
         * 
         * @return builder
         * 
         */
        public Builder useTokenGroups(@Nullable Output<Boolean> useTokenGroups) {
            $.useTokenGroups = useTokenGroups;
            return this;
        }

        /**
         * @param useTokenGroups Use the Active Directory tokenGroups constructed attribute of the user to find the group memberships
         * 
         * @return builder
         * 
         */
        public Builder useTokenGroups(Boolean useTokenGroups) {
            return useTokenGroups(Output.of(useTokenGroups));
        }

        /**
         * @param userattr Attribute on user object matching username passed in
         * 
         * @return builder
         * 
         */
        public Builder userattr(@Nullable Output<String> userattr) {
            $.userattr = userattr;
            return this;
        }

        /**
         * @param userattr Attribute on user object matching username passed in
         * 
         * @return builder
         * 
         */
        public Builder userattr(String userattr) {
            return userattr(Output.of(userattr));
        }

        /**
         * @param userdn Base DN under which to perform user search
         * 
         * @return builder
         * 
         */
        public Builder userdn(@Nullable Output<String> userdn) {
            $.userdn = userdn;
            return this;
        }

        /**
         * @param userdn Base DN under which to perform user search
         * 
         * @return builder
         * 
         */
        public Builder userdn(String userdn) {
            return userdn(Output.of(userdn));
        }

        /**
         * @param userfilter LDAP user search filter
         * 
         * @return builder
         * 
         */
        public Builder userfilter(@Nullable Output<String> userfilter) {
            $.userfilter = userfilter;
            return this;
        }

        /**
         * @param userfilter LDAP user search filter
         * 
         * @return builder
         * 
         */
        public Builder userfilter(String userfilter) {
            return userfilter(Output.of(userfilter));
        }

        /**
         * @param usernameAsAlias Force the auth method to use the username passed by the user as the alias name.
         * 
         * @return builder
         * 
         */
        public Builder usernameAsAlias(@Nullable Output<Boolean> usernameAsAlias) {
            $.usernameAsAlias = usernameAsAlias;
            return this;
        }

        /**
         * @param usernameAsAlias Force the auth method to use the username passed by the user as the alias name.
         * 
         * @return builder
         * 
         */
        public Builder usernameAsAlias(Boolean usernameAsAlias) {
            return usernameAsAlias(Output.of(usernameAsAlias));
        }

        public AuthBackendState build() {
            return $;
        }
    }

}
