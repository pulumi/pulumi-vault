// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.vault;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class CertAuthBackendRoleArgs extends com.pulumi.resources.ResourceArgs {

    public static final CertAuthBackendRoleArgs Empty = new CertAuthBackendRoleArgs();

    /**
     * Allowed the common names for authenticated client certificates
     * 
     */
    @Import(name="allowedCommonNames")
    private @Nullable Output<List<String>> allowedCommonNames;

    /**
     * @return Allowed the common names for authenticated client certificates
     * 
     */
    public Optional<Output<List<String>>> allowedCommonNames() {
        return Optional.ofNullable(this.allowedCommonNames);
    }

    /**
     * Allowed alternative dns names for authenticated client certificates
     * 
     */
    @Import(name="allowedDnsSans")
    private @Nullable Output<List<String>> allowedDnsSans;

    /**
     * @return Allowed alternative dns names for authenticated client certificates
     * 
     */
    public Optional<Output<List<String>>> allowedDnsSans() {
        return Optional.ofNullable(this.allowedDnsSans);
    }

    /**
     * Allowed emails for authenticated client certificates
     * 
     */
    @Import(name="allowedEmailSans")
    private @Nullable Output<List<String>> allowedEmailSans;

    /**
     * @return Allowed emails for authenticated client certificates
     * 
     */
    public Optional<Output<List<String>>> allowedEmailSans() {
        return Optional.ofNullable(this.allowedEmailSans);
    }

    /**
     * DEPRECATED: Please use the individual `allowed_X_sans` parameters instead. Allowed subject names for authenticated client certificates
     * 
     */
    @Import(name="allowedNames")
    private @Nullable Output<List<String>> allowedNames;

    /**
     * @return DEPRECATED: Please use the individual `allowed_X_sans` parameters instead. Allowed subject names for authenticated client certificates
     * 
     */
    public Optional<Output<List<String>>> allowedNames() {
        return Optional.ofNullable(this.allowedNames);
    }

    /**
     * @deprecated
     * Use allowed_organizational_units
     * 
     */
    @Deprecated /* Use allowed_organizational_units */
    @Import(name="allowedOrganizationUnits")
    private @Nullable Output<List<String>> allowedOrganizationUnits;

    /**
     * @deprecated
     * Use allowed_organizational_units
     * 
     */
    @Deprecated /* Use allowed_organizational_units */
    public Optional<Output<List<String>>> allowedOrganizationUnits() {
        return Optional.ofNullable(this.allowedOrganizationUnits);
    }

    /**
     * Allowed organization units for authenticated client certificates.
     * *In previous provider releases this field was incorrectly named `allowed_organization_units`, please update accordingly*
     * 
     */
    @Import(name="allowedOrganizationalUnits")
    private @Nullable Output<List<String>> allowedOrganizationalUnits;

    /**
     * @return Allowed organization units for authenticated client certificates.
     * *In previous provider releases this field was incorrectly named `allowed_organization_units`, please update accordingly*
     * 
     */
    public Optional<Output<List<String>>> allowedOrganizationalUnits() {
        return Optional.ofNullable(this.allowedOrganizationalUnits);
    }

    /**
     * Allowed URIs for authenticated client certificates
     * 
     */
    @Import(name="allowedUriSans")
    private @Nullable Output<List<String>> allowedUriSans;

    /**
     * @return Allowed URIs for authenticated client certificates
     * 
     */
    public Optional<Output<List<String>>> allowedUriSans() {
        return Optional.ofNullable(this.allowedUriSans);
    }

    /**
     * Path to the mounted Cert auth backend
     * 
     */
    @Import(name="backend")
    private @Nullable Output<String> backend;

    /**
     * @return Path to the mounted Cert auth backend
     * 
     */
    public Optional<Output<String>> backend() {
        return Optional.ofNullable(this.backend);
    }

    /**
     * CA certificate used to validate client certificates
     * 
     */
    @Import(name="certificate", required=true)
    private Output<String> certificate;

    /**
     * @return CA certificate used to validate client certificates
     * 
     */
    public Output<String> certificate() {
        return this.certificate;
    }

    /**
     * The name to display on tokens issued under this role.
     * 
     */
    @Import(name="displayName")
    private @Nullable Output<String> displayName;

    /**
     * @return The name to display on tokens issued under this role.
     * 
     */
    public Optional<Output<String>> displayName() {
        return Optional.ofNullable(this.displayName);
    }

    /**
     * Name of the role
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return Name of the role
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * The namespace to provision the resource in.
     * The value should not contain leading or trailing forward slashes.
     * The `namespace` is always relative to the provider&#39;s configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).
     * *Available only for Vault Enterprise*.
     * 
     */
    @Import(name="namespace")
    private @Nullable Output<String> namespace;

    /**
     * @return The namespace to provision the resource in.
     * The value should not contain leading or trailing forward slashes.
     * The `namespace` is always relative to the provider&#39;s configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).
     * *Available only for Vault Enterprise*.
     * 
     */
    public Optional<Output<String>> namespace() {
        return Optional.ofNullable(this.namespace);
    }

    /**
     * Any additional CA certificates
     * needed to verify OCSP responses. Provided as base64 encoded PEM data.
     * Requires Vault version 1.13+.
     * 
     */
    @Import(name="ocspCaCertificates")
    private @Nullable Output<String> ocspCaCertificates;

    /**
     * @return Any additional CA certificates
     * needed to verify OCSP responses. Provided as base64 encoded PEM data.
     * Requires Vault version 1.13+.
     * 
     */
    public Optional<Output<String>> ocspCaCertificates() {
        return Optional.ofNullable(this.ocspCaCertificates);
    }

    /**
     * If enabled, validate certificates&#39;
     * revocation status using OCSP. Requires Vault version 1.13+.
     * 
     */
    @Import(name="ocspEnabled")
    private @Nullable Output<Boolean> ocspEnabled;

    /**
     * @return If enabled, validate certificates&#39;
     * revocation status using OCSP. Requires Vault version 1.13+.
     * 
     */
    public Optional<Output<Boolean>> ocspEnabled() {
        return Optional.ofNullable(this.ocspEnabled);
    }

    /**
     * If true and an OCSP response cannot
     * be fetched or is of an unknown status, the login will proceed as if the
     * certificate has not been revoked.
     * Requires Vault version 1.13+.
     * 
     */
    @Import(name="ocspFailOpen")
    private @Nullable Output<Boolean> ocspFailOpen;

    /**
     * @return If true and an OCSP response cannot
     * be fetched or is of an unknown status, the login will proceed as if the
     * certificate has not been revoked.
     * Requires Vault version 1.13+.
     * 
     */
    public Optional<Output<Boolean>> ocspFailOpen() {
        return Optional.ofNullable(this.ocspFailOpen);
    }

    /**
     * If set to true, rather than
     * accepting the first successful OCSP response, query all servers and consider
     * the certificate valid only if all servers agree.
     * Requires Vault version 1.13+.
     * 
     */
    @Import(name="ocspQueryAllServers")
    private @Nullable Output<Boolean> ocspQueryAllServers;

    /**
     * @return If set to true, rather than
     * accepting the first successful OCSP response, query all servers and consider
     * the certificate valid only if all servers agree.
     * Requires Vault version 1.13+.
     * 
     */
    public Optional<Output<Boolean>> ocspQueryAllServers() {
        return Optional.ofNullable(this.ocspQueryAllServers);
    }

    /**
     * A comma-separated list of OCSP
     * server addresses. If unset, the OCSP server is determined from the
     * AuthorityInformationAccess extension on the certificate being inspected.
     * Requires Vault version 1.13+.
     * 
     */
    @Import(name="ocspServersOverrides")
    private @Nullable Output<List<String>> ocspServersOverrides;

    /**
     * @return A comma-separated list of OCSP
     * server addresses. If unset, the OCSP server is determined from the
     * AuthorityInformationAccess extension on the certificate being inspected.
     * Requires Vault version 1.13+.
     * 
     */
    public Optional<Output<List<String>>> ocspServersOverrides() {
        return Optional.ofNullable(this.ocspServersOverrides);
    }

    /**
     * TLS extensions required on
     * client certificates
     * 
     */
    @Import(name="requiredExtensions")
    private @Nullable Output<List<String>> requiredExtensions;

    /**
     * @return TLS extensions required on
     * client certificates
     * 
     */
    public Optional<Output<List<String>>> requiredExtensions() {
        return Optional.ofNullable(this.requiredExtensions);
    }

    /**
     * List of CIDR blocks; if set, specifies blocks of IP
     * addresses which can authenticate successfully, and ties the resulting token to these blocks
     * as well.
     * 
     */
    @Import(name="tokenBoundCidrs")
    private @Nullable Output<List<String>> tokenBoundCidrs;

    /**
     * @return List of CIDR blocks; if set, specifies blocks of IP
     * addresses which can authenticate successfully, and ties the resulting token to these blocks
     * as well.
     * 
     */
    public Optional<Output<List<String>>> tokenBoundCidrs() {
        return Optional.ofNullable(this.tokenBoundCidrs);
    }

    /**
     * If set, will encode an
     * [explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)
     * onto the token in number of seconds. This is a hard cap even if `token_ttl` and
     * `token_max_ttl` would otherwise allow a renewal.
     * 
     */
    @Import(name="tokenExplicitMaxTtl")
    private @Nullable Output<Integer> tokenExplicitMaxTtl;

    /**
     * @return If set, will encode an
     * [explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)
     * onto the token in number of seconds. This is a hard cap even if `token_ttl` and
     * `token_max_ttl` would otherwise allow a renewal.
     * 
     */
    public Optional<Output<Integer>> tokenExplicitMaxTtl() {
        return Optional.ofNullable(this.tokenExplicitMaxTtl);
    }

    /**
     * The maximum lifetime for generated tokens in number of seconds.
     * Its current value will be referenced at renewal time.
     * 
     */
    @Import(name="tokenMaxTtl")
    private @Nullable Output<Integer> tokenMaxTtl;

    /**
     * @return The maximum lifetime for generated tokens in number of seconds.
     * Its current value will be referenced at renewal time.
     * 
     */
    public Optional<Output<Integer>> tokenMaxTtl() {
        return Optional.ofNullable(this.tokenMaxTtl);
    }

    /**
     * If set, the default policy will not be set on
     * generated tokens; otherwise it will be added to the policies set in token_policies.
     * 
     */
    @Import(name="tokenNoDefaultPolicy")
    private @Nullable Output<Boolean> tokenNoDefaultPolicy;

    /**
     * @return If set, the default policy will not be set on
     * generated tokens; otherwise it will be added to the policies set in token_policies.
     * 
     */
    public Optional<Output<Boolean>> tokenNoDefaultPolicy() {
        return Optional.ofNullable(this.tokenNoDefaultPolicy);
    }

    /**
     * The [maximum number](https://www.vaultproject.io/api-docs/auth/cert#token_num_uses)
     * of times a generated token may be used (within its lifetime); 0 means unlimited.
     * 
     */
    @Import(name="tokenNumUses")
    private @Nullable Output<Integer> tokenNumUses;

    /**
     * @return The [maximum number](https://www.vaultproject.io/api-docs/auth/cert#token_num_uses)
     * of times a generated token may be used (within its lifetime); 0 means unlimited.
     * 
     */
    public Optional<Output<Integer>> tokenNumUses() {
        return Optional.ofNullable(this.tokenNumUses);
    }

    /**
     * If set, indicates that the
     * token generated using this role should never expire. The token should be renewed within the
     * duration specified by this value. At each renewal, the token&#39;s TTL will be set to the
     * value of this field. Specified in seconds.
     * 
     */
    @Import(name="tokenPeriod")
    private @Nullable Output<Integer> tokenPeriod;

    /**
     * @return If set, indicates that the
     * token generated using this role should never expire. The token should be renewed within the
     * duration specified by this value. At each renewal, the token&#39;s TTL will be set to the
     * value of this field. Specified in seconds.
     * 
     */
    public Optional<Output<Integer>> tokenPeriod() {
        return Optional.ofNullable(this.tokenPeriod);
    }

    /**
     * List of policies to encode onto generated tokens. Depending
     * on the auth method, this list may be supplemented by user/group/other values.
     * 
     */
    @Import(name="tokenPolicies")
    private @Nullable Output<List<String>> tokenPolicies;

    /**
     * @return List of policies to encode onto generated tokens. Depending
     * on the auth method, this list may be supplemented by user/group/other values.
     * 
     */
    public Optional<Output<List<String>>> tokenPolicies() {
        return Optional.ofNullable(this.tokenPolicies);
    }

    /**
     * The incremental lifetime for generated tokens in number of seconds.
     * Its current value will be referenced at renewal time.
     * 
     */
    @Import(name="tokenTtl")
    private @Nullable Output<Integer> tokenTtl;

    /**
     * @return The incremental lifetime for generated tokens in number of seconds.
     * Its current value will be referenced at renewal time.
     * 
     */
    public Optional<Output<Integer>> tokenTtl() {
        return Optional.ofNullable(this.tokenTtl);
    }

    /**
     * The type of token that should be generated. Can be `service`,
     * `batch`, or `default` to use the mount&#39;s tuned default (which unless changed will be
     * `service` tokens). For token store roles, there are two additional possibilities:
     * `default-service` and `default-batch` which specify the type to return unless the client
     * requests a different type at generation time.
     * 
     * For more details on the usage of each argument consult the [Vault Cert API documentation](https://www.vaultproject.io/api-docs/auth/cert).
     * 
     */
    @Import(name="tokenType")
    private @Nullable Output<String> tokenType;

    /**
     * @return The type of token that should be generated. Can be `service`,
     * `batch`, or `default` to use the mount&#39;s tuned default (which unless changed will be
     * `service` tokens). For token store roles, there are two additional possibilities:
     * `default-service` and `default-batch` which specify the type to return unless the client
     * requests a different type at generation time.
     * 
     * For more details on the usage of each argument consult the [Vault Cert API documentation](https://www.vaultproject.io/api-docs/auth/cert).
     * 
     */
    public Optional<Output<String>> tokenType() {
        return Optional.ofNullable(this.tokenType);
    }

    private CertAuthBackendRoleArgs() {}

    private CertAuthBackendRoleArgs(CertAuthBackendRoleArgs $) {
        this.allowedCommonNames = $.allowedCommonNames;
        this.allowedDnsSans = $.allowedDnsSans;
        this.allowedEmailSans = $.allowedEmailSans;
        this.allowedNames = $.allowedNames;
        this.allowedOrganizationUnits = $.allowedOrganizationUnits;
        this.allowedOrganizationalUnits = $.allowedOrganizationalUnits;
        this.allowedUriSans = $.allowedUriSans;
        this.backend = $.backend;
        this.certificate = $.certificate;
        this.displayName = $.displayName;
        this.name = $.name;
        this.namespace = $.namespace;
        this.ocspCaCertificates = $.ocspCaCertificates;
        this.ocspEnabled = $.ocspEnabled;
        this.ocspFailOpen = $.ocspFailOpen;
        this.ocspQueryAllServers = $.ocspQueryAllServers;
        this.ocspServersOverrides = $.ocspServersOverrides;
        this.requiredExtensions = $.requiredExtensions;
        this.tokenBoundCidrs = $.tokenBoundCidrs;
        this.tokenExplicitMaxTtl = $.tokenExplicitMaxTtl;
        this.tokenMaxTtl = $.tokenMaxTtl;
        this.tokenNoDefaultPolicy = $.tokenNoDefaultPolicy;
        this.tokenNumUses = $.tokenNumUses;
        this.tokenPeriod = $.tokenPeriod;
        this.tokenPolicies = $.tokenPolicies;
        this.tokenTtl = $.tokenTtl;
        this.tokenType = $.tokenType;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(CertAuthBackendRoleArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private CertAuthBackendRoleArgs $;

        public Builder() {
            $ = new CertAuthBackendRoleArgs();
        }

        public Builder(CertAuthBackendRoleArgs defaults) {
            $ = new CertAuthBackendRoleArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param allowedCommonNames Allowed the common names for authenticated client certificates
         * 
         * @return builder
         * 
         */
        public Builder allowedCommonNames(@Nullable Output<List<String>> allowedCommonNames) {
            $.allowedCommonNames = allowedCommonNames;
            return this;
        }

        /**
         * @param allowedCommonNames Allowed the common names for authenticated client certificates
         * 
         * @return builder
         * 
         */
        public Builder allowedCommonNames(List<String> allowedCommonNames) {
            return allowedCommonNames(Output.of(allowedCommonNames));
        }

        /**
         * @param allowedCommonNames Allowed the common names for authenticated client certificates
         * 
         * @return builder
         * 
         */
        public Builder allowedCommonNames(String... allowedCommonNames) {
            return allowedCommonNames(List.of(allowedCommonNames));
        }

        /**
         * @param allowedDnsSans Allowed alternative dns names for authenticated client certificates
         * 
         * @return builder
         * 
         */
        public Builder allowedDnsSans(@Nullable Output<List<String>> allowedDnsSans) {
            $.allowedDnsSans = allowedDnsSans;
            return this;
        }

        /**
         * @param allowedDnsSans Allowed alternative dns names for authenticated client certificates
         * 
         * @return builder
         * 
         */
        public Builder allowedDnsSans(List<String> allowedDnsSans) {
            return allowedDnsSans(Output.of(allowedDnsSans));
        }

        /**
         * @param allowedDnsSans Allowed alternative dns names for authenticated client certificates
         * 
         * @return builder
         * 
         */
        public Builder allowedDnsSans(String... allowedDnsSans) {
            return allowedDnsSans(List.of(allowedDnsSans));
        }

        /**
         * @param allowedEmailSans Allowed emails for authenticated client certificates
         * 
         * @return builder
         * 
         */
        public Builder allowedEmailSans(@Nullable Output<List<String>> allowedEmailSans) {
            $.allowedEmailSans = allowedEmailSans;
            return this;
        }

        /**
         * @param allowedEmailSans Allowed emails for authenticated client certificates
         * 
         * @return builder
         * 
         */
        public Builder allowedEmailSans(List<String> allowedEmailSans) {
            return allowedEmailSans(Output.of(allowedEmailSans));
        }

        /**
         * @param allowedEmailSans Allowed emails for authenticated client certificates
         * 
         * @return builder
         * 
         */
        public Builder allowedEmailSans(String... allowedEmailSans) {
            return allowedEmailSans(List.of(allowedEmailSans));
        }

        /**
         * @param allowedNames DEPRECATED: Please use the individual `allowed_X_sans` parameters instead. Allowed subject names for authenticated client certificates
         * 
         * @return builder
         * 
         */
        public Builder allowedNames(@Nullable Output<List<String>> allowedNames) {
            $.allowedNames = allowedNames;
            return this;
        }

        /**
         * @param allowedNames DEPRECATED: Please use the individual `allowed_X_sans` parameters instead. Allowed subject names for authenticated client certificates
         * 
         * @return builder
         * 
         */
        public Builder allowedNames(List<String> allowedNames) {
            return allowedNames(Output.of(allowedNames));
        }

        /**
         * @param allowedNames DEPRECATED: Please use the individual `allowed_X_sans` parameters instead. Allowed subject names for authenticated client certificates
         * 
         * @return builder
         * 
         */
        public Builder allowedNames(String... allowedNames) {
            return allowedNames(List.of(allowedNames));
        }

        /**
         * @return builder
         * 
         * @deprecated
         * Use allowed_organizational_units
         * 
         */
        @Deprecated /* Use allowed_organizational_units */
        public Builder allowedOrganizationUnits(@Nullable Output<List<String>> allowedOrganizationUnits) {
            $.allowedOrganizationUnits = allowedOrganizationUnits;
            return this;
        }

        /**
         * @return builder
         * 
         * @deprecated
         * Use allowed_organizational_units
         * 
         */
        @Deprecated /* Use allowed_organizational_units */
        public Builder allowedOrganizationUnits(List<String> allowedOrganizationUnits) {
            return allowedOrganizationUnits(Output.of(allowedOrganizationUnits));
        }

        /**
         * @return builder
         * 
         * @deprecated
         * Use allowed_organizational_units
         * 
         */
        @Deprecated /* Use allowed_organizational_units */
        public Builder allowedOrganizationUnits(String... allowedOrganizationUnits) {
            return allowedOrganizationUnits(List.of(allowedOrganizationUnits));
        }

        /**
         * @param allowedOrganizationalUnits Allowed organization units for authenticated client certificates.
         * *In previous provider releases this field was incorrectly named `allowed_organization_units`, please update accordingly*
         * 
         * @return builder
         * 
         */
        public Builder allowedOrganizationalUnits(@Nullable Output<List<String>> allowedOrganizationalUnits) {
            $.allowedOrganizationalUnits = allowedOrganizationalUnits;
            return this;
        }

        /**
         * @param allowedOrganizationalUnits Allowed organization units for authenticated client certificates.
         * *In previous provider releases this field was incorrectly named `allowed_organization_units`, please update accordingly*
         * 
         * @return builder
         * 
         */
        public Builder allowedOrganizationalUnits(List<String> allowedOrganizationalUnits) {
            return allowedOrganizationalUnits(Output.of(allowedOrganizationalUnits));
        }

        /**
         * @param allowedOrganizationalUnits Allowed organization units for authenticated client certificates.
         * *In previous provider releases this field was incorrectly named `allowed_organization_units`, please update accordingly*
         * 
         * @return builder
         * 
         */
        public Builder allowedOrganizationalUnits(String... allowedOrganizationalUnits) {
            return allowedOrganizationalUnits(List.of(allowedOrganizationalUnits));
        }

        /**
         * @param allowedUriSans Allowed URIs for authenticated client certificates
         * 
         * @return builder
         * 
         */
        public Builder allowedUriSans(@Nullable Output<List<String>> allowedUriSans) {
            $.allowedUriSans = allowedUriSans;
            return this;
        }

        /**
         * @param allowedUriSans Allowed URIs for authenticated client certificates
         * 
         * @return builder
         * 
         */
        public Builder allowedUriSans(List<String> allowedUriSans) {
            return allowedUriSans(Output.of(allowedUriSans));
        }

        /**
         * @param allowedUriSans Allowed URIs for authenticated client certificates
         * 
         * @return builder
         * 
         */
        public Builder allowedUriSans(String... allowedUriSans) {
            return allowedUriSans(List.of(allowedUriSans));
        }

        /**
         * @param backend Path to the mounted Cert auth backend
         * 
         * @return builder
         * 
         */
        public Builder backend(@Nullable Output<String> backend) {
            $.backend = backend;
            return this;
        }

        /**
         * @param backend Path to the mounted Cert auth backend
         * 
         * @return builder
         * 
         */
        public Builder backend(String backend) {
            return backend(Output.of(backend));
        }

        /**
         * @param certificate CA certificate used to validate client certificates
         * 
         * @return builder
         * 
         */
        public Builder certificate(Output<String> certificate) {
            $.certificate = certificate;
            return this;
        }

        /**
         * @param certificate CA certificate used to validate client certificates
         * 
         * @return builder
         * 
         */
        public Builder certificate(String certificate) {
            return certificate(Output.of(certificate));
        }

        /**
         * @param displayName The name to display on tokens issued under this role.
         * 
         * @return builder
         * 
         */
        public Builder displayName(@Nullable Output<String> displayName) {
            $.displayName = displayName;
            return this;
        }

        /**
         * @param displayName The name to display on tokens issued under this role.
         * 
         * @return builder
         * 
         */
        public Builder displayName(String displayName) {
            return displayName(Output.of(displayName));
        }

        /**
         * @param name Name of the role
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name Name of the role
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param namespace The namespace to provision the resource in.
         * The value should not contain leading or trailing forward slashes.
         * The `namespace` is always relative to the provider&#39;s configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).
         * *Available only for Vault Enterprise*.
         * 
         * @return builder
         * 
         */
        public Builder namespace(@Nullable Output<String> namespace) {
            $.namespace = namespace;
            return this;
        }

        /**
         * @param namespace The namespace to provision the resource in.
         * The value should not contain leading or trailing forward slashes.
         * The `namespace` is always relative to the provider&#39;s configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).
         * *Available only for Vault Enterprise*.
         * 
         * @return builder
         * 
         */
        public Builder namespace(String namespace) {
            return namespace(Output.of(namespace));
        }

        /**
         * @param ocspCaCertificates Any additional CA certificates
         * needed to verify OCSP responses. Provided as base64 encoded PEM data.
         * Requires Vault version 1.13+.
         * 
         * @return builder
         * 
         */
        public Builder ocspCaCertificates(@Nullable Output<String> ocspCaCertificates) {
            $.ocspCaCertificates = ocspCaCertificates;
            return this;
        }

        /**
         * @param ocspCaCertificates Any additional CA certificates
         * needed to verify OCSP responses. Provided as base64 encoded PEM data.
         * Requires Vault version 1.13+.
         * 
         * @return builder
         * 
         */
        public Builder ocspCaCertificates(String ocspCaCertificates) {
            return ocspCaCertificates(Output.of(ocspCaCertificates));
        }

        /**
         * @param ocspEnabled If enabled, validate certificates&#39;
         * revocation status using OCSP. Requires Vault version 1.13+.
         * 
         * @return builder
         * 
         */
        public Builder ocspEnabled(@Nullable Output<Boolean> ocspEnabled) {
            $.ocspEnabled = ocspEnabled;
            return this;
        }

        /**
         * @param ocspEnabled If enabled, validate certificates&#39;
         * revocation status using OCSP. Requires Vault version 1.13+.
         * 
         * @return builder
         * 
         */
        public Builder ocspEnabled(Boolean ocspEnabled) {
            return ocspEnabled(Output.of(ocspEnabled));
        }

        /**
         * @param ocspFailOpen If true and an OCSP response cannot
         * be fetched or is of an unknown status, the login will proceed as if the
         * certificate has not been revoked.
         * Requires Vault version 1.13+.
         * 
         * @return builder
         * 
         */
        public Builder ocspFailOpen(@Nullable Output<Boolean> ocspFailOpen) {
            $.ocspFailOpen = ocspFailOpen;
            return this;
        }

        /**
         * @param ocspFailOpen If true and an OCSP response cannot
         * be fetched or is of an unknown status, the login will proceed as if the
         * certificate has not been revoked.
         * Requires Vault version 1.13+.
         * 
         * @return builder
         * 
         */
        public Builder ocspFailOpen(Boolean ocspFailOpen) {
            return ocspFailOpen(Output.of(ocspFailOpen));
        }

        /**
         * @param ocspQueryAllServers If set to true, rather than
         * accepting the first successful OCSP response, query all servers and consider
         * the certificate valid only if all servers agree.
         * Requires Vault version 1.13+.
         * 
         * @return builder
         * 
         */
        public Builder ocspQueryAllServers(@Nullable Output<Boolean> ocspQueryAllServers) {
            $.ocspQueryAllServers = ocspQueryAllServers;
            return this;
        }

        /**
         * @param ocspQueryAllServers If set to true, rather than
         * accepting the first successful OCSP response, query all servers and consider
         * the certificate valid only if all servers agree.
         * Requires Vault version 1.13+.
         * 
         * @return builder
         * 
         */
        public Builder ocspQueryAllServers(Boolean ocspQueryAllServers) {
            return ocspQueryAllServers(Output.of(ocspQueryAllServers));
        }

        /**
         * @param ocspServersOverrides A comma-separated list of OCSP
         * server addresses. If unset, the OCSP server is determined from the
         * AuthorityInformationAccess extension on the certificate being inspected.
         * Requires Vault version 1.13+.
         * 
         * @return builder
         * 
         */
        public Builder ocspServersOverrides(@Nullable Output<List<String>> ocspServersOverrides) {
            $.ocspServersOverrides = ocspServersOverrides;
            return this;
        }

        /**
         * @param ocspServersOverrides A comma-separated list of OCSP
         * server addresses. If unset, the OCSP server is determined from the
         * AuthorityInformationAccess extension on the certificate being inspected.
         * Requires Vault version 1.13+.
         * 
         * @return builder
         * 
         */
        public Builder ocspServersOverrides(List<String> ocspServersOverrides) {
            return ocspServersOverrides(Output.of(ocspServersOverrides));
        }

        /**
         * @param ocspServersOverrides A comma-separated list of OCSP
         * server addresses. If unset, the OCSP server is determined from the
         * AuthorityInformationAccess extension on the certificate being inspected.
         * Requires Vault version 1.13+.
         * 
         * @return builder
         * 
         */
        public Builder ocspServersOverrides(String... ocspServersOverrides) {
            return ocspServersOverrides(List.of(ocspServersOverrides));
        }

        /**
         * @param requiredExtensions TLS extensions required on
         * client certificates
         * 
         * @return builder
         * 
         */
        public Builder requiredExtensions(@Nullable Output<List<String>> requiredExtensions) {
            $.requiredExtensions = requiredExtensions;
            return this;
        }

        /**
         * @param requiredExtensions TLS extensions required on
         * client certificates
         * 
         * @return builder
         * 
         */
        public Builder requiredExtensions(List<String> requiredExtensions) {
            return requiredExtensions(Output.of(requiredExtensions));
        }

        /**
         * @param requiredExtensions TLS extensions required on
         * client certificates
         * 
         * @return builder
         * 
         */
        public Builder requiredExtensions(String... requiredExtensions) {
            return requiredExtensions(List.of(requiredExtensions));
        }

        /**
         * @param tokenBoundCidrs List of CIDR blocks; if set, specifies blocks of IP
         * addresses which can authenticate successfully, and ties the resulting token to these blocks
         * as well.
         * 
         * @return builder
         * 
         */
        public Builder tokenBoundCidrs(@Nullable Output<List<String>> tokenBoundCidrs) {
            $.tokenBoundCidrs = tokenBoundCidrs;
            return this;
        }

        /**
         * @param tokenBoundCidrs List of CIDR blocks; if set, specifies blocks of IP
         * addresses which can authenticate successfully, and ties the resulting token to these blocks
         * as well.
         * 
         * @return builder
         * 
         */
        public Builder tokenBoundCidrs(List<String> tokenBoundCidrs) {
            return tokenBoundCidrs(Output.of(tokenBoundCidrs));
        }

        /**
         * @param tokenBoundCidrs List of CIDR blocks; if set, specifies blocks of IP
         * addresses which can authenticate successfully, and ties the resulting token to these blocks
         * as well.
         * 
         * @return builder
         * 
         */
        public Builder tokenBoundCidrs(String... tokenBoundCidrs) {
            return tokenBoundCidrs(List.of(tokenBoundCidrs));
        }

        /**
         * @param tokenExplicitMaxTtl If set, will encode an
         * [explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)
         * onto the token in number of seconds. This is a hard cap even if `token_ttl` and
         * `token_max_ttl` would otherwise allow a renewal.
         * 
         * @return builder
         * 
         */
        public Builder tokenExplicitMaxTtl(@Nullable Output<Integer> tokenExplicitMaxTtl) {
            $.tokenExplicitMaxTtl = tokenExplicitMaxTtl;
            return this;
        }

        /**
         * @param tokenExplicitMaxTtl If set, will encode an
         * [explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)
         * onto the token in number of seconds. This is a hard cap even if `token_ttl` and
         * `token_max_ttl` would otherwise allow a renewal.
         * 
         * @return builder
         * 
         */
        public Builder tokenExplicitMaxTtl(Integer tokenExplicitMaxTtl) {
            return tokenExplicitMaxTtl(Output.of(tokenExplicitMaxTtl));
        }

        /**
         * @param tokenMaxTtl The maximum lifetime for generated tokens in number of seconds.
         * Its current value will be referenced at renewal time.
         * 
         * @return builder
         * 
         */
        public Builder tokenMaxTtl(@Nullable Output<Integer> tokenMaxTtl) {
            $.tokenMaxTtl = tokenMaxTtl;
            return this;
        }

        /**
         * @param tokenMaxTtl The maximum lifetime for generated tokens in number of seconds.
         * Its current value will be referenced at renewal time.
         * 
         * @return builder
         * 
         */
        public Builder tokenMaxTtl(Integer tokenMaxTtl) {
            return tokenMaxTtl(Output.of(tokenMaxTtl));
        }

        /**
         * @param tokenNoDefaultPolicy If set, the default policy will not be set on
         * generated tokens; otherwise it will be added to the policies set in token_policies.
         * 
         * @return builder
         * 
         */
        public Builder tokenNoDefaultPolicy(@Nullable Output<Boolean> tokenNoDefaultPolicy) {
            $.tokenNoDefaultPolicy = tokenNoDefaultPolicy;
            return this;
        }

        /**
         * @param tokenNoDefaultPolicy If set, the default policy will not be set on
         * generated tokens; otherwise it will be added to the policies set in token_policies.
         * 
         * @return builder
         * 
         */
        public Builder tokenNoDefaultPolicy(Boolean tokenNoDefaultPolicy) {
            return tokenNoDefaultPolicy(Output.of(tokenNoDefaultPolicy));
        }

        /**
         * @param tokenNumUses The [maximum number](https://www.vaultproject.io/api-docs/auth/cert#token_num_uses)
         * of times a generated token may be used (within its lifetime); 0 means unlimited.
         * 
         * @return builder
         * 
         */
        public Builder tokenNumUses(@Nullable Output<Integer> tokenNumUses) {
            $.tokenNumUses = tokenNumUses;
            return this;
        }

        /**
         * @param tokenNumUses The [maximum number](https://www.vaultproject.io/api-docs/auth/cert#token_num_uses)
         * of times a generated token may be used (within its lifetime); 0 means unlimited.
         * 
         * @return builder
         * 
         */
        public Builder tokenNumUses(Integer tokenNumUses) {
            return tokenNumUses(Output.of(tokenNumUses));
        }

        /**
         * @param tokenPeriod If set, indicates that the
         * token generated using this role should never expire. The token should be renewed within the
         * duration specified by this value. At each renewal, the token&#39;s TTL will be set to the
         * value of this field. Specified in seconds.
         * 
         * @return builder
         * 
         */
        public Builder tokenPeriod(@Nullable Output<Integer> tokenPeriod) {
            $.tokenPeriod = tokenPeriod;
            return this;
        }

        /**
         * @param tokenPeriod If set, indicates that the
         * token generated using this role should never expire. The token should be renewed within the
         * duration specified by this value. At each renewal, the token&#39;s TTL will be set to the
         * value of this field. Specified in seconds.
         * 
         * @return builder
         * 
         */
        public Builder tokenPeriod(Integer tokenPeriod) {
            return tokenPeriod(Output.of(tokenPeriod));
        }

        /**
         * @param tokenPolicies List of policies to encode onto generated tokens. Depending
         * on the auth method, this list may be supplemented by user/group/other values.
         * 
         * @return builder
         * 
         */
        public Builder tokenPolicies(@Nullable Output<List<String>> tokenPolicies) {
            $.tokenPolicies = tokenPolicies;
            return this;
        }

        /**
         * @param tokenPolicies List of policies to encode onto generated tokens. Depending
         * on the auth method, this list may be supplemented by user/group/other values.
         * 
         * @return builder
         * 
         */
        public Builder tokenPolicies(List<String> tokenPolicies) {
            return tokenPolicies(Output.of(tokenPolicies));
        }

        /**
         * @param tokenPolicies List of policies to encode onto generated tokens. Depending
         * on the auth method, this list may be supplemented by user/group/other values.
         * 
         * @return builder
         * 
         */
        public Builder tokenPolicies(String... tokenPolicies) {
            return tokenPolicies(List.of(tokenPolicies));
        }

        /**
         * @param tokenTtl The incremental lifetime for generated tokens in number of seconds.
         * Its current value will be referenced at renewal time.
         * 
         * @return builder
         * 
         */
        public Builder tokenTtl(@Nullable Output<Integer> tokenTtl) {
            $.tokenTtl = tokenTtl;
            return this;
        }

        /**
         * @param tokenTtl The incremental lifetime for generated tokens in number of seconds.
         * Its current value will be referenced at renewal time.
         * 
         * @return builder
         * 
         */
        public Builder tokenTtl(Integer tokenTtl) {
            return tokenTtl(Output.of(tokenTtl));
        }

        /**
         * @param tokenType The type of token that should be generated. Can be `service`,
         * `batch`, or `default` to use the mount&#39;s tuned default (which unless changed will be
         * `service` tokens). For token store roles, there are two additional possibilities:
         * `default-service` and `default-batch` which specify the type to return unless the client
         * requests a different type at generation time.
         * 
         * For more details on the usage of each argument consult the [Vault Cert API documentation](https://www.vaultproject.io/api-docs/auth/cert).
         * 
         * @return builder
         * 
         */
        public Builder tokenType(@Nullable Output<String> tokenType) {
            $.tokenType = tokenType;
            return this;
        }

        /**
         * @param tokenType The type of token that should be generated. Can be `service`,
         * `batch`, or `default` to use the mount&#39;s tuned default (which unless changed will be
         * `service` tokens). For token store roles, there are two additional possibilities:
         * `default-service` and `default-batch` which specify the type to return unless the client
         * requests a different type at generation time.
         * 
         * For more details on the usage of each argument consult the [Vault Cert API documentation](https://www.vaultproject.io/api-docs/auth/cert).
         * 
         * @return builder
         * 
         */
        public Builder tokenType(String tokenType) {
            return tokenType(Output.of(tokenType));
        }

        public CertAuthBackendRoleArgs build() {
            $.certificate = Objects.requireNonNull($.certificate, "expected parameter 'certificate' to be non-null");
            return $;
        }
    }

}
