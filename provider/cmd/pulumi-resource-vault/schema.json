{
    "name": "vault",
    "displayName": "HashiCorp Vault",
    "description": "A Pulumi package for creating and managing HashiCorp Vault cloud resources.",
    "keywords": [
        "pulumi",
        "vault"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`vault` Terraform Provider](https://github.com/hashicorp/terraform-provider-vault).",
    "repository": "https://github.com/pulumi/pulumi-vault",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "compatibility": "tfbridge20",
            "namespaces": {
                "ad": "AD",
                "alicloud": "AliCloud",
                "appRole": "AppRole",
                "aws": "Aws",
                "azure": "Azure",
                "consul": "Consul",
                "database": "Database",
                "gcp": "Gcp",
                "generic": "Generic",
                "github": "GitHub",
                "identity": "Identity",
                "index": "index",
                "jwt": "Jwt",
                "kmip": "Kmip",
                "kubernetes": "Kubernetes",
                "kv": "kv",
                "ldap": "Ldap",
                "managed": "Managed",
                "mongodbatlas": "MongoDBAtlas",
                "okta": "Okta",
                "pkiSecret": "PkiSecret",
                "rabbitMq": "RabbitMQ",
                "ssh": "Ssh",
                "terraformcloud": "TerraformCloud",
                "tokenauth": "TokenAuth",
                "transform": "Transform",
                "transit": "Transit",
                "vault": "Vault"
            },
            "packageReferences": {
                "Pulumi": "3.*"
            }
        },
        "go": {
            "generateExtraInputTypes": true,
            "generateResourceContainerTypes": true,
            "importBasePath": "github.com/pulumi/pulumi-vault/sdk/v5/go/vault"
        },
        "nodejs": {
            "compatibility": "tfbridge20",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^10.0.0"
            },
            "disableUnionOutputTypes": true,
            "packageDescription": "A Pulumi package for creating and managing HashiCorp Vault cloud resources.",
            "packageName": "",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/hashicorp/terraform-provider-vault)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-vault` repo](https://github.com/pulumi/pulumi-vault/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-vault` repo](https://github.com/hashicorp/terraform-provider-vault/issues).",
            "typescriptVersion": ""
        },
        "python": {
            "compatibility": "tfbridge20",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/hashicorp/terraform-provider-vault)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-vault` repo](https://github.com/pulumi/pulumi-vault/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-vault` repo](https://github.com/hashicorp/terraform-provider-vault/issues).",
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            }
        }
    },
    "config": {
        "variables": {
            "addAddressToEnv": {
                "type": "string",
                "description": "If true, adds the value of the `address` argument to the Terraform process environment.\n"
            },
            "address": {
                "type": "string",
                "description": "URL of the root of the target Vault server.\n"
            },
            "authLogin": {
                "$ref": "#/types/vault:config/authLogin:authLogin",
                "description": "Login to vault with an existing auth method using auth/\u003cmount\u003e/login\n"
            },
            "authLoginAws": {
                "$ref": "#/types/vault:config/authLoginAws:authLoginAws",
                "description": "Login to vault using the AWS method\n"
            },
            "authLoginAzure": {
                "$ref": "#/types/vault:config/authLoginAzure:authLoginAzure",
                "description": "Login to vault using the azure method\n"
            },
            "authLoginCert": {
                "$ref": "#/types/vault:config/authLoginCert:authLoginCert",
                "description": "Login to vault using the cert method\n"
            },
            "authLoginGcp": {
                "$ref": "#/types/vault:config/authLoginGcp:authLoginGcp",
                "description": "Login to vault using the gcp method\n"
            },
            "authLoginJwt": {
                "$ref": "#/types/vault:config/authLoginJwt:authLoginJwt",
                "description": "Login to vault using the jwt method\n"
            },
            "authLoginKerberos": {
                "$ref": "#/types/vault:config/authLoginKerberos:authLoginKerberos",
                "description": "Login to vault using the kerberos method\n"
            },
            "authLoginOci": {
                "$ref": "#/types/vault:config/authLoginOci:authLoginOci",
                "description": "Login to vault using the OCI method\n"
            },
            "authLoginOidc": {
                "$ref": "#/types/vault:config/authLoginOidc:authLoginOidc",
                "description": "Login to vault using the oidc method\n"
            },
            "authLoginRadius": {
                "$ref": "#/types/vault:config/authLoginRadius:authLoginRadius",
                "description": "Login to vault using the radius method\n"
            },
            "authLoginUserpass": {
                "$ref": "#/types/vault:config/authLoginUserpass:authLoginUserpass",
                "description": "Login to vault using the userpass method\n"
            },
            "caCertDir": {
                "type": "string",
                "description": "Path to directory containing CA certificate files to validate the server's certificate.\n"
            },
            "caCertFile": {
                "type": "string",
                "description": "Path to a CA certificate file to validate the server's certificate.\n"
            },
            "clientAuth": {
                "$ref": "#/types/vault:config/clientAuth:clientAuth",
                "description": "Client authentication credentials.\n"
            },
            "headers": {
                "type": "array",
                "items": {
                    "$ref": "#/types/vault:config/headers:headers"
                },
                "description": "The headers to send with each Vault request.\n"
            },
            "maxLeaseTtlSeconds": {
                "type": "integer",
                "description": "Maximum TTL for secret leases requested by this provider.\n",
                "default": 1200,
                "defaultInfo": {
                    "environment": [
                        "TERRAFORM_VAULT_MAX_TTL"
                    ]
                }
            },
            "maxRetries": {
                "type": "integer",
                "description": "Maximum number of retries when a 5xx error code is encountered.\n",
                "default": 2,
                "defaultInfo": {
                    "environment": [
                        "VAULT_MAX_RETRIES"
                    ]
                }
            },
            "maxRetriesCcc": {
                "type": "integer",
                "description": "Maximum number of retries for Client Controlled Consistency related operations\n"
            },
            "namespace": {
                "type": "string",
                "description": "The namespace to use. Available only for Vault Enterprise.\n"
            },
            "skipChildToken": {
                "type": "boolean",
                "description": "Set this to true to prevent the creation of ephemeral child token used by this provider.\n"
            },
            "skipGetVaultVersion": {
                "type": "boolean",
                "description": "Skip the dynamic fetching of the Vault server version.\n"
            },
            "skipTlsVerify": {
                "type": "boolean",
                "description": "Set this to true only if the target Vault server is an insecure development instance.\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_SKIP_VERIFY"
                    ]
                }
            },
            "tlsServerName": {
                "type": "string",
                "description": "Name to use as the SNI host when connecting via TLS.\n"
            },
            "token": {
                "type": "string",
                "description": "Token to use to authenticate to Vault.\n"
            },
            "tokenName": {
                "type": "string",
                "description": "Token name to use for creating the Vault child token.\n"
            },
            "vaultVersionOverride": {
                "type": "string",
                "description": "Override the Vault server version, which is normally determined dynamically from the target Vault server\n"
            }
        },
        "defaults": [
            "address",
            "token"
        ]
    },
    "types": {
        "vault:azure/BackendRoleAzureGroup:BackendRoleAzureGroup": {
            "properties": {
                "groupName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "objectId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "groupName"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "groupName",
                        "objectId"
                    ]
                }
            }
        },
        "vault:azure/BackendRoleAzureRole:BackendRoleAzureRole": {
            "properties": {
                "roleId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "scope": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "scope"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "roleId",
                        "roleName",
                        "scope"
                    ]
                }
            }
        },
        "vault:config/authLogin:authLogin": {
            "properties": {
                "method": {
                    "type": "string"
                },
                "namespace": {
                    "type": "string"
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "path": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "path"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vault:config/authLoginAws:authLoginAws": {
            "properties": {
                "awsAccessKeyId": {
                    "type": "string"
                },
                "awsIamEndpoint": {
                    "type": "string"
                },
                "awsProfile": {
                    "type": "string"
                },
                "awsRegion": {
                    "type": "string"
                },
                "awsRoleArn": {
                    "type": "string"
                },
                "awsRoleSessionName": {
                    "type": "string"
                },
                "awsSecretAccessKey": {
                    "type": "string"
                },
                "awsSessionToken": {
                    "type": "string"
                },
                "awsSharedCredentialsFile": {
                    "type": "string"
                },
                "awsStsEndpoint": {
                    "type": "string"
                },
                "awsWebIdentityTokenFile": {
                    "type": "string"
                },
                "headerValue": {
                    "type": "string"
                },
                "mount": {
                    "type": "string"
                },
                "namespace": {
                    "type": "string"
                },
                "role": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "role"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vault:config/authLoginAzure:authLoginAzure": {
            "properties": {
                "clientId": {
                    "type": "string"
                },
                "jwt": {
                    "type": "string"
                },
                "mount": {
                    "type": "string"
                },
                "namespace": {
                    "type": "string"
                },
                "resourceGroupName": {
                    "type": "string"
                },
                "role": {
                    "type": "string"
                },
                "scope": {
                    "type": "string"
                },
                "subscriptionId": {
                    "type": "string"
                },
                "tenantId": {
                    "type": "string"
                },
                "vmName": {
                    "type": "string"
                },
                "vmssName": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "resourceGroupName",
                "role",
                "subscriptionId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vault:config/authLoginCert:authLoginCert": {
            "properties": {
                "certFile": {
                    "type": "string"
                },
                "keyFile": {
                    "type": "string"
                },
                "mount": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "namespace": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "certFile",
                "keyFile"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vault:config/authLoginGcp:authLoginGcp": {
            "properties": {
                "credentials": {
                    "type": "string"
                },
                "jwt": {
                    "type": "string"
                },
                "mount": {
                    "type": "string"
                },
                "namespace": {
                    "type": "string"
                },
                "role": {
                    "type": "string"
                },
                "serviceAccount": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "role"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vault:config/authLoginJwt:authLoginJwt": {
            "properties": {
                "jwt": {
                    "type": "string"
                },
                "mount": {
                    "type": "string"
                },
                "namespace": {
                    "type": "string"
                },
                "role": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "jwt",
                "role"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vault:config/authLoginKerberos:authLoginKerberos": {
            "properties": {
                "disableFastNegotiation": {
                    "type": "boolean"
                },
                "keytabPath": {
                    "type": "string"
                },
                "krb5confPath": {
                    "type": "string"
                },
                "mount": {
                    "type": "string"
                },
                "namespace": {
                    "type": "string"
                },
                "realm": {
                    "type": "string"
                },
                "removeInstanceName": {
                    "type": "boolean"
                },
                "service": {
                    "type": "string"
                },
                "token": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "vault:config/authLoginOci:authLoginOci": {
            "properties": {
                "authType": {
                    "type": "string"
                },
                "mount": {
                    "type": "string"
                },
                "namespace": {
                    "type": "string"
                },
                "role": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "authType",
                "role"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vault:config/authLoginOidc:authLoginOidc": {
            "properties": {
                "callbackAddress": {
                    "type": "string"
                },
                "callbackListenerAddress": {
                    "type": "string"
                },
                "mount": {
                    "type": "string"
                },
                "namespace": {
                    "type": "string"
                },
                "role": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "role"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vault:config/authLoginRadius:authLoginRadius": {
            "properties": {
                "mount": {
                    "type": "string"
                },
                "namespace": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "password",
                "username"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vault:config/authLoginUserpass:authLoginUserpass": {
            "properties": {
                "mount": {
                    "type": "string"
                },
                "namespace": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                },
                "passwordFile": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "username"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vault:config/clientAuth:clientAuth": {
            "properties": {
                "certFile": {
                    "type": "string"
                },
                "keyFile": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "certFile",
                "keyFile"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vault:config/headers:headers": {
            "properties": {
                "name": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vault:database/SecretBackendConnectionCassandra:SecretBackendConnectionCassandra": {
            "properties": {
                "connectTimeout": {
                    "type": "integer",
                    "description": "The number of seconds to use as a connection\ntimeout.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Couchbase URIs to connect to. Must use `couchbases://` scheme if `tls` is `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Whether to skip verification of the server\ncertificate when using TLS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "pemBundle": {
                    "type": "string",
                    "description": "Concatenated PEM blocks configuring the certificate\nchain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "pemJson": {
                    "type": "string",
                    "description": "A JSON structure configuring the certificate chain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "port": {
                    "type": "integer",
                    "description": "The default port to connect to if no port is specified as\npart of the host.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "protocolVersion": {
                    "type": "integer",
                    "description": "The CQL protocol version to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tls": {
                    "type": "boolean",
                    "description": "Whether to use TLS when connecting to Redis.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionCouchbase:SecretBackendConnectionCouchbase": {
            "properties": {
                "base64Pem": {
                    "type": "string",
                    "description": "Required if `tls` is `true`. Specifies the certificate authority of the Couchbase server, as a PEM certificate that has been base64 encoded.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "bucketName": {
                    "type": "string",
                    "description": "Required for Couchbase versions prior to 6.5.0. This is only used to verify vault's connection to the server.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Couchbase URIs to connect to. Must use `couchbases://` scheme if `tls` is `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Whether to skip verification of the server\ncertificate when using TLS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "tls": {
                    "type": "boolean",
                    "description": "Whether to use TLS when connecting to Redis.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "hosts",
                "password",
                "username"
            ]
        },
        "vault:database/SecretBackendConnectionElasticsearch:SecretBackendConnectionElasticsearch": {
            "properties": {
                "caCert": {
                    "type": "string",
                    "description": "The path to a PEM-encoded CA cert file to use to verify the Elasticsearch server's identity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "caPath": {
                    "type": "string",
                    "description": "The path to a directory of PEM-encoded CA cert files to use to verify the Elasticsearch server's identity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientCert": {
                    "type": "string",
                    "description": "The path to the certificate for the Elasticsearch client to present for communication.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientKey": {
                    "type": "string",
                    "description": "The path to the key for the Elasticsearch client to use for communication.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "insecure": {
                    "type": "boolean",
                    "description": "Whether to disable certificate verification.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "tlsServerName": {
                    "type": "string",
                    "description": "This, if set, is used to set the SNI host when connecting via TLS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "url": {
                    "type": "string",
                    "description": "The URL for Elasticsearch's API. https requires certificate\nby trusted CA if used.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "password",
                "url",
                "username"
            ]
        },
        "vault:database/SecretBackendConnectionHana:SecretBackendConnectionHana": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "Specifies the Redshift DSN. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/redshift#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableEscaping": {
                    "type": "boolean",
                    "description": "Disable special character escaping in username and password.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum amount of time a connection may be reused.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionInfluxdb:SecretBackendConnectionInfluxdb": {
            "properties": {
                "connectTimeout": {
                    "type": "integer",
                    "description": "The number of seconds to use as a connection\ntimeout.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "description": "The host to connect to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Whether to skip verification of the server\ncertificate when using TLS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "pemBundle": {
                    "type": "string",
                    "description": "Concatenated PEM blocks configuring the certificate\nchain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "pemJson": {
                    "type": "string",
                    "description": "A JSON structure configuring the certificate chain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "port": {
                    "type": "integer",
                    "description": "The default port to connect to if no port is specified as\npart of the host.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tls": {
                    "type": "boolean",
                    "description": "Whether to use TLS when connecting to Redis.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "host",
                "password",
                "username"
            ]
        },
        "vault:database/SecretBackendConnectionMongodb:SecretBackendConnectionMongodb": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "Specifies the Redshift DSN. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/redshift#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum amount of time a connection may be reused.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionMongodbatlas:SecretBackendConnectionMongodbatlas": {
            "properties": {
                "privateKey": {
                    "type": "string",
                    "description": "The Private Programmatic API Key used to connect with MongoDB Atlas API.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "projectId": {
                    "type": "string",
                    "description": "The Project ID the Database User should be created within.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "publicKey": {
                    "type": "string",
                    "description": "The Public Programmatic API Key used to authenticate with the MongoDB Atlas API.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "privateKey",
                "projectId",
                "publicKey"
            ]
        },
        "vault:database/SecretBackendConnectionMssql:SecretBackendConnectionMssql": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "Specifies the Redshift DSN. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/redshift#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "containedDb": {
                    "type": "boolean",
                    "description": "For Vault v1.9+. Set to true when the target is a\nContained Database, e.g. AzureSQL.\nSee the [Vault\ndocs](https://www.vaultproject.io/api/secret/databases/mssql#contained_db)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableEscaping": {
                    "type": "boolean",
                    "description": "Disable special character escaping in username and password.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum amount of time a connection may be reused.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionMysql:SecretBackendConnectionMysql": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "Specifies the Redshift DSN. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/redshift#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum amount of time a connection may be reused.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "tlsCa": {
                    "type": "string",
                    "description": "x509 CA file for validating the certificate presented by the MySQL server. Must be PEM encoded.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tlsCertificateKey": {
                    "type": "string",
                    "description": "x509 certificate for connecting to the database. This must be a PEM encoded version of the private key and the certificate combined.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionMysqlAurora:SecretBackendConnectionMysqlAurora": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "Specifies the Redshift DSN. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/redshift#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum amount of time a connection may be reused.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionMysqlLegacy:SecretBackendConnectionMysqlLegacy": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "Specifies the Redshift DSN. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/redshift#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum amount of time a connection may be reused.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionMysqlRds:SecretBackendConnectionMysqlRds": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "Specifies the Redshift DSN. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/redshift#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum amount of time a connection may be reused.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionOracle:SecretBackendConnectionOracle": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "Specifies the Redshift DSN. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/redshift#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum amount of time a connection may be reused.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionPostgresql:SecretBackendConnectionPostgresql": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "Specifies the Redshift DSN. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/redshift#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableEscaping": {
                    "type": "boolean",
                    "description": "Disable special character escaping in username and password.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum amount of time a connection may be reused.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionRedis:SecretBackendConnectionRedis": {
            "properties": {
                "caCert": {
                    "type": "string",
                    "description": "The path to a PEM-encoded CA cert file to use to verify the Elasticsearch server's identity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "description": "The host to connect to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Whether to skip verification of the server\ncertificate when using TLS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "port": {
                    "type": "integer",
                    "description": "The default port to connect to if no port is specified as\npart of the host.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tls": {
                    "type": "boolean",
                    "description": "Whether to use TLS when connecting to Redis.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "host",
                "password",
                "username"
            ]
        },
        "vault:database/SecretBackendConnectionRedisElasticache:SecretBackendConnectionRedisElasticache": {
            "properties": {
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "region": {
                    "type": "string",
                    "description": "The region where the ElastiCache cluster is hosted. If omitted Vault tries to infer from the environment instead.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "url": {
                    "type": "string",
                    "description": "The URL for Elasticsearch's API. https requires certificate\nby trusted CA if used.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "url"
            ]
        },
        "vault:database/SecretBackendConnectionRedshift:SecretBackendConnectionRedshift": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "Specifies the Redshift DSN. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/redshift#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableEscaping": {
                    "type": "boolean",
                    "description": "Disable special character escaping in username and password.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum amount of time a connection may be reused.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionSnowflake:SecretBackendConnectionSnowflake": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "Specifies the Redshift DSN. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/redshift#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum amount of time a connection may be reused.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretsMountCassandra:SecretsMountCassandra": {
            "properties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of roles that are allowed to use this\nconnection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectTimeout": {
                    "type": "integer",
                    "description": "The number of seconds to use as a connection\ntimeout.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Couchbase URIs to connect to. Must use `couchbases://` scheme if `tls` is `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Whether to skip verification of the server\ncertificate when using TLS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The password to be used in the connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "pemBundle": {
                    "type": "string",
                    "description": "Concatenated PEM blocks configuring the certificate\nchain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "pemJson": {
                    "type": "string",
                    "description": "A JSON structure configuring the certificate chain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "pluginName": {
                    "type": "string",
                    "description": "Specifies the name of the plugin to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "port": {
                    "type": "integer",
                    "description": "The default port to connect to if no port is specified as\npart of the host.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "protocolVersion": {
                    "type": "integer",
                    "description": "The CQL protocol version to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rootRotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of database statements to be executed to rotate the root user's credentials.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tls": {
                    "type": "boolean",
                    "description": "Whether to use TLS when connecting to Redis.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The username to be used in the connection (the account admin level).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Whether the connection should be verified on\ninitial configuration or not.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "pluginName"
                    ]
                }
            }
        },
        "vault:database/SecretsMountCouchbase:SecretsMountCouchbase": {
            "properties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of roles that are allowed to use this\nconnection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "base64Pem": {
                    "type": "string",
                    "description": "Required if `tls` is `true`. Specifies the certificate authority of the Couchbase server, as a PEM certificate that has been base64 encoded.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "bucketName": {
                    "type": "string",
                    "description": "Required for Couchbase versions prior to 6.5.0. This is only used to verify vault's connection to the server.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Couchbase URIs to connect to. Must use `couchbases://` scheme if `tls` is `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Whether to skip verification of the server\ncertificate when using TLS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The password to be used in the connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "pluginName": {
                    "type": "string",
                    "description": "Specifies the name of the plugin to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rootRotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of database statements to be executed to rotate the root user's credentials.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tls": {
                    "type": "boolean",
                    "description": "Whether to use TLS when connecting to Redis.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The username to be used in the connection (the account admin level).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Whether the connection should be verified on\ninitial configuration or not.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "hosts",
                "name",
                "password",
                "username"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "hosts",
                        "name",
                        "password",
                        "pluginName",
                        "username"
                    ]
                }
            }
        },
        "vault:database/SecretsMountElasticsearch:SecretsMountElasticsearch": {
            "properties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of roles that are allowed to use this\nconnection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "caCert": {
                    "type": "string",
                    "description": "The contents of a PEM-encoded CA cert file to use to verify the Redis server's identity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "caPath": {
                    "type": "string",
                    "description": "The path to a directory of PEM-encoded CA cert files to use to verify the Elasticsearch server's identity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientCert": {
                    "type": "string",
                    "description": "The path to the certificate for the Elasticsearch client to present for communication.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientKey": {
                    "type": "string",
                    "description": "The path to the key for the Elasticsearch client to use for communication.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "insecure": {
                    "type": "boolean",
                    "description": "Whether to disable certificate verification.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The password to be used in the connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "pluginName": {
                    "type": "string",
                    "description": "Specifies the name of the plugin to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rootRotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of database statements to be executed to rotate the root user's credentials.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tlsServerName": {
                    "type": "string",
                    "description": "This, if set, is used to set the SNI host when connecting via TLS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "url": {
                    "type": "string",
                    "description": "The configuration endpoint for the ElastiCache cluster to connect to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The username to be used in the connection (the account admin level).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Whether the connection should be verified on\ninitial configuration or not.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "password",
                "url",
                "username"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "password",
                        "pluginName",
                        "url",
                        "username"
                    ]
                }
            }
        },
        "vault:database/SecretsMountHana:SecretsMountHana": {
            "properties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of roles that are allowed to use this\nconnection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information.  \nSee [Vault docs](https://www.vaultproject.io/api-docs/secret/databases/snowflake#sample-payload)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableEscaping": {
                    "type": "boolean",
                    "description": "Disable special character escaping in username and password.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The password to be used in the connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "pluginName": {
                    "type": "string",
                    "description": "Specifies the name of the plugin to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rootRotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of database statements to be executed to rotate the root user's credentials.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The username to be used in the connection (the account admin level).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Whether the connection should be verified on\ninitial configuration or not.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "pluginName"
                    ]
                }
            }
        },
        "vault:database/SecretsMountInfluxdb:SecretsMountInfluxdb": {
            "properties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of roles that are allowed to use this\nconnection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectTimeout": {
                    "type": "integer",
                    "description": "The number of seconds to use as a connection\ntimeout.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "description": "The host to connect to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Whether to skip verification of the server\ncertificate when using TLS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The password to be used in the connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "pemBundle": {
                    "type": "string",
                    "description": "Concatenated PEM blocks configuring the certificate\nchain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "pemJson": {
                    "type": "string",
                    "description": "A JSON structure configuring the certificate chain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "pluginName": {
                    "type": "string",
                    "description": "Specifies the name of the plugin to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "port": {
                    "type": "integer",
                    "description": "The default port to connect to if no port is specified as\npart of the host.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rootRotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of database statements to be executed to rotate the root user's credentials.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tls": {
                    "type": "boolean",
                    "description": "Whether to use TLS when connecting to Redis.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The username to be used in the connection (the account admin level).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Whether the connection should be verified on\ninitial configuration or not.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "host",
                "name",
                "password",
                "username"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "host",
                        "name",
                        "password",
                        "pluginName",
                        "username"
                    ]
                }
            }
        },
        "vault:database/SecretsMountMongodb:SecretsMountMongodb": {
            "properties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of roles that are allowed to use this\nconnection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information.  \nSee [Vault docs](https://www.vaultproject.io/api-docs/secret/databases/snowflake#sample-payload)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The password to be used in the connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "pluginName": {
                    "type": "string",
                    "description": "Specifies the name of the plugin to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rootRotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of database statements to be executed to rotate the root user's credentials.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The username to be used in the connection (the account admin level).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Whether the connection should be verified on\ninitial configuration or not.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "pluginName"
                    ]
                }
            }
        },
        "vault:database/SecretsMountMongodbatla:SecretsMountMongodbatla": {
            "properties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of roles that are allowed to use this\nconnection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pluginName": {
                    "type": "string",
                    "description": "Specifies the name of the plugin to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privateKey": {
                    "type": "string",
                    "description": "The Private Programmatic API Key used to connect with MongoDB Atlas API.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "projectId": {
                    "type": "string",
                    "description": "The Project ID the Database User should be created within.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "publicKey": {
                    "type": "string",
                    "description": "The Public Programmatic API Key used to authenticate with the MongoDB Atlas API.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rootRotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of database statements to be executed to rotate the root user's credentials.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Whether the connection should be verified on\ninitial configuration or not.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "privateKey",
                "projectId",
                "publicKey"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "pluginName",
                        "privateKey",
                        "projectId",
                        "publicKey"
                    ]
                }
            }
        },
        "vault:database/SecretsMountMssql:SecretsMountMssql": {
            "properties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of roles that are allowed to use this\nconnection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information.  \nSee [Vault docs](https://www.vaultproject.io/api-docs/secret/databases/snowflake#sample-payload)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "containedDb": {
                    "type": "boolean",
                    "description": "For Vault v1.9+. Set to true when the target is a\nContained Database, e.g. AzureSQL.\nSee [Vault docs](https://www.vaultproject.io/api/secret/databases/mssql#contained_db)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableEscaping": {
                    "type": "boolean",
                    "description": "Disable special character escaping in username and password.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The password to be used in the connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "pluginName": {
                    "type": "string",
                    "description": "Specifies the name of the plugin to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rootRotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of database statements to be executed to rotate the root user's credentials.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The username to be used in the connection (the account admin level).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Whether the connection should be verified on\ninitial configuration or not.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "pluginName"
                    ]
                }
            }
        },
        "vault:database/SecretsMountMysql:SecretsMountMysql": {
            "properties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of roles that are allowed to use this\nconnection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information.  \nSee [Vault docs](https://www.vaultproject.io/api-docs/secret/databases/snowflake#sample-payload)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The password to be used in the connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "pluginName": {
                    "type": "string",
                    "description": "Specifies the name of the plugin to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rootRotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of database statements to be executed to rotate the root user's credentials.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tlsCa": {
                    "type": "string",
                    "description": "x509 CA file for validating the certificate presented by the MySQL server. Must be PEM encoded.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tlsCertificateKey": {
                    "type": "string",
                    "description": "x509 certificate for connecting to the database. This must be a PEM encoded version of the private key and the certificate combined.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "The username to be used in the connection (the account admin level).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Whether the connection should be verified on\ninitial configuration or not.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "pluginName"
                    ]
                }
            }
        },
        "vault:database/SecretsMountMysqlAurora:SecretsMountMysqlAurora": {
            "properties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of roles that are allowed to use this\nconnection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information.  \nSee [Vault docs](https://www.vaultproject.io/api-docs/secret/databases/snowflake#sample-payload)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The password to be used in the connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "pluginName": {
                    "type": "string",
                    "description": "Specifies the name of the plugin to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rootRotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of database statements to be executed to rotate the root user's credentials.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The username to be used in the connection (the account admin level).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Whether the connection should be verified on\ninitial configuration or not.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "pluginName"
                    ]
                }
            }
        },
        "vault:database/SecretsMountMysqlLegacy:SecretsMountMysqlLegacy": {
            "properties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of roles that are allowed to use this\nconnection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information.  \nSee [Vault docs](https://www.vaultproject.io/api-docs/secret/databases/snowflake#sample-payload)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The password to be used in the connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "pluginName": {
                    "type": "string",
                    "description": "Specifies the name of the plugin to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rootRotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of database statements to be executed to rotate the root user's credentials.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The username to be used in the connection (the account admin level).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Whether the connection should be verified on\ninitial configuration or not.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "pluginName"
                    ]
                }
            }
        },
        "vault:database/SecretsMountMysqlRd:SecretsMountMysqlRd": {
            "properties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of roles that are allowed to use this\nconnection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information.  \nSee [Vault docs](https://www.vaultproject.io/api-docs/secret/databases/snowflake#sample-payload)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The password to be used in the connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "pluginName": {
                    "type": "string",
                    "description": "Specifies the name of the plugin to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rootRotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of database statements to be executed to rotate the root user's credentials.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The username to be used in the connection (the account admin level).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Whether the connection should be verified on\ninitial configuration or not.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "pluginName"
                    ]
                }
            }
        },
        "vault:database/SecretsMountOracle:SecretsMountOracle": {
            "properties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of roles that are allowed to use this\nconnection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information.  \nSee [Vault docs](https://www.vaultproject.io/api-docs/secret/databases/snowflake#sample-payload)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The password to be used in the connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "pluginName": {
                    "type": "string",
                    "description": "Specifies the name of the plugin to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rootRotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of database statements to be executed to rotate the root user's credentials.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The username to be used in the connection (the account admin level).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Whether the connection should be verified on\ninitial configuration or not.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "pluginName"
                    ]
                }
            }
        },
        "vault:database/SecretsMountPostgresql:SecretsMountPostgresql": {
            "properties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of roles that are allowed to use this\nconnection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information.  \nSee [Vault docs](https://www.vaultproject.io/api-docs/secret/databases/snowflake#sample-payload)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableEscaping": {
                    "type": "boolean",
                    "description": "Disable special character escaping in username and password.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The password to be used in the connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "pluginName": {
                    "type": "string",
                    "description": "Specifies the name of the plugin to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rootRotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of database statements to be executed to rotate the root user's credentials.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The username to be used in the connection (the account admin level).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Whether the connection should be verified on\ninitial configuration or not.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "pluginName"
                    ]
                }
            }
        },
        "vault:database/SecretsMountRedi:SecretsMountRedi": {
            "properties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of roles that are allowed to use this\nconnection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "caCert": {
                    "type": "string",
                    "description": "The contents of a PEM-encoded CA cert file to use to verify the Redis server's identity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "description": "The host to connect to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Whether to skip verification of the server\ncertificate when using TLS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The password to be used in the connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "pluginName": {
                    "type": "string",
                    "description": "Specifies the name of the plugin to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "port": {
                    "type": "integer",
                    "description": "The default port to connect to if no port is specified as\npart of the host.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rootRotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of database statements to be executed to rotate the root user's credentials.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tls": {
                    "type": "boolean",
                    "description": "Whether to use TLS when connecting to Redis.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The username to be used in the connection (the account admin level).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Whether the connection should be verified on\ninitial configuration or not.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "host",
                "name",
                "password",
                "username"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "host",
                        "name",
                        "password",
                        "pluginName",
                        "username"
                    ]
                }
            }
        },
        "vault:database/SecretsMountRedisElasticach:SecretsMountRedisElasticach": {
            "properties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of roles that are allowed to use this\nconnection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The password to be used in the connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "pluginName": {
                    "type": "string",
                    "description": "Specifies the name of the plugin to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "description": "The AWS region where the ElastiCache cluster is hosted.\nIf omitted the plugin tries to infer the region from the environment.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rootRotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of database statements to be executed to rotate the root user's credentials.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "url": {
                    "type": "string",
                    "description": "The configuration endpoint for the ElastiCache cluster to connect to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The username to be used in the connection (the account admin level).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Whether the connection should be verified on\ninitial configuration or not.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "url"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "pluginName",
                        "url"
                    ]
                }
            }
        },
        "vault:database/SecretsMountRedshift:SecretsMountRedshift": {
            "properties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of roles that are allowed to use this\nconnection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information.  \nSee [Vault docs](https://www.vaultproject.io/api-docs/secret/databases/snowflake#sample-payload)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableEscaping": {
                    "type": "boolean",
                    "description": "Disable special character escaping in username and password.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The password to be used in the connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "pluginName": {
                    "type": "string",
                    "description": "Specifies the name of the plugin to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rootRotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of database statements to be executed to rotate the root user's credentials.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The username to be used in the connection (the account admin level).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Whether the connection should be verified on\ninitial configuration or not.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "pluginName"
                    ]
                }
            }
        },
        "vault:database/SecretsMountSnowflake:SecretsMountSnowflake": {
            "properties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of roles that are allowed to use this\nconnection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information.  \nSee [Vault docs](https://www.vaultproject.io/api-docs/secret/databases/snowflake#sample-payload)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The password to be used in the connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "pluginName": {
                    "type": "string",
                    "description": "Specifies the name of the plugin to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rootRotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of database statements to be executed to rotate the root user's credentials.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The username to be used in the connection (the account admin level).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Whether the connection should be verified on\ninitial configuration or not.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "pluginName"
                    ]
                }
            }
        },
        "vault:gcp/AuthBackendCustomEndpoint:AuthBackendCustomEndpoint": {
            "properties": {
                "api": {
                    "type": "string",
                    "description": "Replaces the service endpoint used in API requests to `https://www.googleapis.com`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compute": {
                    "type": "string",
                    "description": "Replaces the service endpoint used in API requests to `https://compute.googleapis.com`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "crm": {
                    "type": "string",
                    "description": "Replaces the service endpoint used in API requests to `https://cloudresourcemanager.googleapis.com`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "iam": {
                    "type": "string",
                    "description": "Replaces the service endpoint used in API requests to `https://iam.googleapis.com`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:gcp/SecretRolesetBinding:SecretRolesetBinding": {
            "properties": {
                "resource": {
                    "type": "string",
                    "description": "Resource or resource path for which IAM policy information will be bound. The resource path may be specified in a few different [formats](https://www.vaultproject.io/docs/secrets/gcp/index.html#roleset-bindings).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of [GCP IAM roles](https://cloud.google.com/iam/docs/understanding-roles) for the resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "resource",
                "roles"
            ]
        },
        "vault:gcp/SecretStaticAccountBinding:SecretStaticAccountBinding": {
            "properties": {
                "resource": {
                    "type": "string",
                    "description": "Resource or resource path for which IAM policy information will be bound. The resource path may be specified in a few different [formats](https://www.vaultproject.io/docs/secrets/gcp/index.html#bindings).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of [GCP IAM roles](https://cloud.google.com/iam/docs/understanding-roles) for the resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "resource",
                "roles"
            ]
        },
        "vault:github/AuthBackendTune:AuthBackendTune": {
            "properties": {
                "allowedResponseHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of headers to whitelist and allowing\na plugin to include them in the response.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "auditNonHmacRequestKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will\nnot be HMAC'd by audit devices in the request data object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "auditNonHmacResponseKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will\nnot be HMAC'd by audit devices in the response data object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "defaultLeaseTtl": {
                    "type": "string",
                    "description": "Specifies the default time-to-live.\nIf set, this overrides the global default.\nMust be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "listingVisibility": {
                    "type": "string",
                    "description": "Specifies whether to show this mount in\nthe UI-specific listing endpoint. Valid values are \"unauth\" or \"hidden\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxLeaseTtl": {
                    "type": "string",
                    "description": "Specifies the maximum time-to-live.\nIf set, this overrides the global default.\nMust be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "passthroughRequestHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of headers to whitelist and\npass from the request to the backend.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tokenType": {
                    "type": "string",
                    "description": "Specifies the type of tokens that should be returned by\nthe mount. Valid values are \"default-service\", \"default-batch\", \"service\", \"batch\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:identity/getEntityAlias:getEntityAlias": {
            "properties": {
                "canonicalId": {
                    "type": "string",
                    "description": "Canonical ID of the Alias\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "creationTime": {
                    "type": "string",
                    "description": "Creation time of the Alias\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "ID of the alias\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lastUpdateTime": {
                    "type": "string",
                    "description": "Last update time of the alias\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mergedFromCanonicalIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of canonical IDs merged with this alias\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Arbitrary metadata\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "Authentication mount acccessor which this alias belongs to\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mountPath": {
                    "type": "string",
                    "description": "Authentication mount path which this alias belongs to\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mountType": {
                    "type": "string",
                    "description": "Authentication mount type which this alias belongs to\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of the alias\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "canonicalId",
                "creationTime",
                "id",
                "lastUpdateTime",
                "mergedFromCanonicalIds",
                "metadata",
                "mountAccessor",
                "mountPath",
                "mountType",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vault:index/AuthBackendTune:AuthBackendTune": {
            "properties": {
                "allowedResponseHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of headers to whitelist and allowing\na plugin to include them in the response.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "auditNonHmacRequestKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will\nnot be HMAC'd by audit devices in the request data object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "auditNonHmacResponseKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will\nnot be HMAC'd by audit devices in the response data object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "defaultLeaseTtl": {
                    "type": "string",
                    "description": "Specifies the default time-to-live.\nIf set, this overrides the global default.\nMust be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "listingVisibility": {
                    "type": "string",
                    "description": "Specifies whether to show this mount in\nthe UI-specific listing endpoint. Valid values are \"unauth\" or \"hidden\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxLeaseTtl": {
                    "type": "string",
                    "description": "Specifies the maximum time-to-live.\nIf set, this overrides the global default.\nMust be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "passthroughRequestHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of headers to whitelist and\npass from the request to the backend.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tokenType": {
                    "type": "string",
                    "description": "Specifies the type of tokens that should be returned by\nthe mount. Valid values are \"default-service\", \"default-batch\", \"service\", \"batch\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:index/ProviderAuthLogin:ProviderAuthLogin": {
            "properties": {
                "method": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "namespace": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "path"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": []
                }
            }
        },
        "vault:index/ProviderAuthLoginAws:ProviderAuthLoginAws": {
            "properties": {
                "awsAccessKeyId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "awsIamEndpoint": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "awsProfile": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "awsRegion": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "awsRoleArn": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "awsRoleSessionName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "awsSecretAccessKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "awsSessionToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "awsSharedCredentialsFile": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "awsStsEndpoint": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "awsWebIdentityTokenFile": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "headerValue": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mount": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "namespace": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "role": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "role"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": []
                }
            }
        },
        "vault:index/ProviderAuthLoginAzure:ProviderAuthLoginAzure": {
            "properties": {
                "clientId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "jwt": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mount": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "namespace": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "resourceGroupName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "role": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "scope": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "subscriptionId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tenantId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "vmName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "vmssName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "resourceGroupName",
                "role",
                "subscriptionId"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": []
                }
            }
        },
        "vault:index/ProviderAuthLoginCert:ProviderAuthLoginCert": {
            "properties": {
                "certFile": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyFile": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mount": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "namespace": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "certFile",
                "keyFile"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": []
                }
            }
        },
        "vault:index/ProviderAuthLoginGcp:ProviderAuthLoginGcp": {
            "properties": {
                "credentials": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "jwt": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mount": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "namespace": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "role": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serviceAccount": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "role"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": []
                }
            }
        },
        "vault:index/ProviderAuthLoginJwt:ProviderAuthLoginJwt": {
            "properties": {
                "jwt": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mount": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "namespace": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "role": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "jwt",
                "role"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": []
                }
            }
        },
        "vault:index/ProviderAuthLoginKerberos:ProviderAuthLoginKerberos": {
            "properties": {
                "disableFastNegotiation": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keytabPath": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "krb5confPath": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mount": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "namespace": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "realm": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "removeInstanceName": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "service": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "token": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:index/ProviderAuthLoginOci:ProviderAuthLoginOci": {
            "properties": {
                "authType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mount": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "namespace": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "role": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "authType",
                "role"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": []
                }
            }
        },
        "vault:index/ProviderAuthLoginOidc:ProviderAuthLoginOidc": {
            "properties": {
                "callbackAddress": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "callbackListenerAddress": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mount": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "namespace": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "role": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "role"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": []
                }
            }
        },
        "vault:index/ProviderAuthLoginRadius:ProviderAuthLoginRadius": {
            "properties": {
                "mount": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "namespace": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "password",
                "username"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": []
                }
            }
        },
        "vault:index/ProviderAuthLoginUserpass:ProviderAuthLoginUserpass": {
            "properties": {
                "mount": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "namespace": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "passwordFile": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "username"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": []
                }
            }
        },
        "vault:index/ProviderClientAuth:ProviderClientAuth": {
            "properties": {
                "certFile": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyFile": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "certFile",
                "keyFile"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": []
                }
            }
        },
        "vault:index/ProviderHeader:ProviderHeader": {
            "properties": {
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": []
                }
            }
        },
        "vault:index/getPolicyDocumentRule:getPolicyDocumentRule": {
            "properties": {
                "allowedParameters": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:index/getPolicyDocumentRuleAllowedParameter:getPolicyDocumentRuleAllowedParameter"
                    },
                    "description": "Whitelists a list of keys and values that are permitted on the given path. See Parameters below.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "capabilities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of capabilities that this rule apply to `path`. For example, [\"read\", \"write\"].\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "deniedParameters": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:index/getPolicyDocumentRuleDeniedParameter:getPolicyDocumentRuleDeniedParameter"
                    },
                    "description": "Blacklists a list of parameter and values. Any values specified here take precedence over `allowed_parameter`. See Parameters below.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "description": "Description of the rule. Will be added as a comment to rendered rule.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxWrappingTtl": {
                    "type": "string",
                    "description": "The maximum allowed TTL that clients can specify for a wrapped response.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minWrappingTtl": {
                    "type": "string",
                    "description": "The minimum allowed TTL that clients can specify for a wrapped response.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "description": "A path in Vault that this rule applies to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "requiredParameters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of parameters that must be specified.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "capabilities",
                "path"
            ]
        },
        "vault:index/getPolicyDocumentRuleAllowedParameter:getPolicyDocumentRuleAllowedParameter": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "name of permitted or denied parameter.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "list of values what are permitted or denied by policy rule.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "key",
                "values"
            ]
        },
        "vault:index/getPolicyDocumentRuleDeniedParameter:getPolicyDocumentRuleDeniedParameter": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "name of permitted or denied parameter.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "list of values what are permitted or denied by policy rule.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "key",
                "values"
            ]
        },
        "vault:jwt/AuthBackendTune:AuthBackendTune": {
            "properties": {
                "allowedResponseHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of headers to whitelist and allowing\na plugin to include them in the response.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "auditNonHmacRequestKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will\nnot be HMAC'd by audit devices in the request data object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "auditNonHmacResponseKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will\nnot be HMAC'd by audit devices in the response data object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "defaultLeaseTtl": {
                    "type": "string",
                    "description": "Specifies the default time-to-live.\nIf set, this overrides the global default.\nMust be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "listingVisibility": {
                    "type": "string",
                    "description": "Specifies whether to show this mount in\nthe UI-specific listing endpoint. Valid values are \"unauth\" or \"hidden\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxLeaseTtl": {
                    "type": "string",
                    "description": "Specifies the maximum time-to-live.\nIf set, this overrides the global default.\nMust be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "passthroughRequestHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of headers to whitelist and\npass from the request to the backend.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tokenType": {
                    "type": "string",
                    "description": "Specifies the type of tokens that should be returned by\nthe mount. Valid values are \"default-service\", \"default-batch\", \"service\", \"batch\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:kv/SecretV2CustomMetadata:SecretV2CustomMetadata": {
            "properties": {
                "casRequired": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A mapping whose keys are the top-level data keys returned from\nVault and whose values are the corresponding values. This map can only\nrepresent string data, so any non-string values returned from Vault are\nserialized as JSON.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "deleteVersionAfter": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxVersions": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:managed/KeysAw:KeysAw": {
            "properties": {
                "accessKey": {
                    "type": "string",
                    "description": "The AWS access key to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "allowGenerateKey": {
                    "type": "boolean",
                    "description": "If no existing key can be found in \nthe referenced backend, instructs Vault to generate a key within the backend.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "allowReplaceKey": {
                    "type": "boolean",
                    "description": "Controls the ability for Vault to replace through\ngeneration or importing a key into the configured backend even\nif a key is present, if set to `false` those operations are forbidden\nif a key exists.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "allowStoreKey": {
                    "type": "boolean",
                    "description": "Controls the ability for Vault to import a key to the\nconfigured backend, if `false`, those operations will be forbidden.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "anyMount": {
                    "type": "boolean",
                    "description": "If `true`, allows usage from any mount point within the\nnamespace.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "curve": {
                    "type": "string",
                    "description": "Supplies the curve value when using the `CKM_ECDSA` mechanism.\nRequired if `allow_generate_key` is `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoint": {
                    "type": "string",
                    "description": "Used to specify a custom AWS endpoint.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyBits": {
                    "type": "string",
                    "description": "Supplies the size in bits of the key when using `CKM_RSA_PKCS_PSS`,\n`CKM_RSA_PKCS_OAEP` or `CKM_RSA_PKCS` as a value for `mechanism`. Required if\n`allow_generate_key` is `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyType": {
                    "type": "string",
                    "description": "The type of key to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "kmsKey": {
                    "type": "string",
                    "description": "An identifier for the key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "A unique lowercase name that serves as identifying the key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "description": "The AWS region where the keys are stored (or will be stored).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "secretKey": {
                    "type": "string",
                    "description": "The AWS access key to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "uuid": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "accessKey",
                "keyBits",
                "keyType",
                "kmsKey",
                "name",
                "secretKey"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "accessKey",
                        "allowGenerateKey",
                        "allowReplaceKey",
                        "allowStoreKey",
                        "anyMount",
                        "keyBits",
                        "keyType",
                        "kmsKey",
                        "name",
                        "region",
                        "secretKey",
                        "uuid"
                    ]
                }
            }
        },
        "vault:managed/KeysAzure:KeysAzure": {
            "properties": {
                "allowGenerateKey": {
                    "type": "boolean",
                    "description": "If no existing key can be found in \nthe referenced backend, instructs Vault to generate a key within the backend.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "allowReplaceKey": {
                    "type": "boolean",
                    "description": "Controls the ability for Vault to replace through\ngeneration or importing a key into the configured backend even\nif a key is present, if set to `false` those operations are forbidden\nif a key exists.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "allowStoreKey": {
                    "type": "boolean",
                    "description": "Controls the ability for Vault to import a key to the\nconfigured backend, if `false`, those operations will be forbidden.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "anyMount": {
                    "type": "boolean",
                    "description": "If `true`, allows usage from any mount point within the\nnamespace.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientId": {
                    "type": "string",
                    "description": "The client id for credentials to query the Azure APIs.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client secret for credentials to query the Azure APIs.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "environment": {
                    "type": "string",
                    "description": "The Azure Cloud environment API endpoints to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyBits": {
                    "type": "string",
                    "description": "Supplies the size in bits of the key when using `CKM_RSA_PKCS_PSS`,\n`CKM_RSA_PKCS_OAEP` or `CKM_RSA_PKCS` as a value for `mechanism`. Required if\n`allow_generate_key` is `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyName": {
                    "type": "string",
                    "description": "The Key Vault key to use for encryption and decryption.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyType": {
                    "type": "string",
                    "description": "The type of key to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "A unique lowercase name that serves as identifying the key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "resource": {
                    "type": "string",
                    "description": "The Azure Key Vault resource's DNS Suffix to connect to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tenantId": {
                    "type": "string",
                    "description": "The tenant id for the Azure Active Directory organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "uuid": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "vaultName": {
                    "type": "string",
                    "description": "The Key Vault vault to use for encryption and decryption.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "clientId",
                "clientSecret",
                "keyName",
                "keyType",
                "name",
                "tenantId",
                "vaultName"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "allowGenerateKey",
                        "allowReplaceKey",
                        "allowStoreKey",
                        "anyMount",
                        "clientId",
                        "clientSecret",
                        "environment",
                        "keyName",
                        "keyType",
                        "name",
                        "resource",
                        "tenantId",
                        "uuid",
                        "vaultName"
                    ]
                }
            }
        },
        "vault:managed/KeysPkc:KeysPkc": {
            "properties": {
                "allowGenerateKey": {
                    "type": "boolean",
                    "description": "If no existing key can be found in \nthe referenced backend, instructs Vault to generate a key within the backend.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "allowReplaceKey": {
                    "type": "boolean",
                    "description": "Controls the ability for Vault to replace through\ngeneration or importing a key into the configured backend even\nif a key is present, if set to `false` those operations are forbidden\nif a key exists.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "allowStoreKey": {
                    "type": "boolean",
                    "description": "Controls the ability for Vault to import a key to the\nconfigured backend, if `false`, those operations will be forbidden.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "anyMount": {
                    "type": "boolean",
                    "description": "If `true`, allows usage from any mount point within the\nnamespace.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "curve": {
                    "type": "string",
                    "description": "Supplies the curve value when using the `CKM_ECDSA` mechanism.\nRequired if `allow_generate_key` is `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "forceRwSession": {
                    "type": "string",
                    "description": "Force all operations to open up a read-write session to\nthe HSM.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyBits": {
                    "type": "string",
                    "description": "Supplies the size in bits of the key when using `CKM_RSA_PKCS_PSS`,\n`CKM_RSA_PKCS_OAEP` or `CKM_RSA_PKCS` as a value for `mechanism`. Required if\n`allow_generate_key` is `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyId": {
                    "type": "string",
                    "description": "The id of a PKCS#11 key to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyLabel": {
                    "type": "string",
                    "description": "The label of the key to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "library": {
                    "type": "string",
                    "description": "The name of the kms_library stanza to use from Vault's config\nto lookup the local library path.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mechanism": {
                    "type": "string",
                    "description": "The encryption/decryption mechanism to use, specified as a\nhexadecimal (prefixed by 0x) string.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "A unique lowercase name that serves as identifying the key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pin": {
                    "type": "string",
                    "description": "The PIN for login.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "slot": {
                    "type": "string",
                    "description": "The slot number to use, specified as a string in a decimal format\n(e.g. `2305843009213693953`).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tokenLabel": {
                    "type": "string",
                    "description": "The slot token label to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "uuid": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "keyId",
                "keyLabel",
                "library",
                "mechanism",
                "name",
                "pin"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "allowGenerateKey",
                        "allowReplaceKey",
                        "allowStoreKey",
                        "anyMount",
                        "keyId",
                        "keyLabel",
                        "library",
                        "mechanism",
                        "name",
                        "pin",
                        "uuid"
                    ]
                }
            }
        },
        "vault:okta/AuthBackendGroup:AuthBackendGroup": {
            "properties": {
                "groupName": {
                    "type": "string",
                    "description": "Name of the group within the Okta\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Vault policies to associate with this user\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "groupName",
                "policies"
            ]
        },
        "vault:okta/AuthBackendUser:AuthBackendUser": {
            "properties": {
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Okta groups to associate with this user\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Vault policies to associate with this user\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "Name of the user within Okta\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "groups",
                "username"
            ]
        },
        "vault:pkiSecret/SecretBackendRolePolicyIdentifier:SecretBackendRolePolicyIdentifier": {
            "properties": {
                "cps": {
                    "type": "string",
                    "description": "The URL of the CPS for the policy identifier\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "notice": {
                    "type": "string",
                    "description": "A notice for the policy identifier\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oid": {
                    "type": "string",
                    "description": "The OID for the policy identifier\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "oid"
            ]
        },
        "vault:rabbitMq/SecretBackendRoleVhost:SecretBackendRoleVhost": {
            "properties": {
                "configure": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "read": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "write": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "configure",
                "host",
                "read",
                "write"
            ]
        },
        "vault:rabbitMq/SecretBackendRoleVhostTopic:SecretBackendRoleVhostTopic": {
            "properties": {
                "host": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "vhosts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:rabbitMq/SecretBackendRoleVhostTopicVhost:SecretBackendRoleVhostTopicVhost"
                    },
                    "description": "Specifies a map of virtual hosts to permissions.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "host"
            ]
        },
        "vault:rabbitMq/SecretBackendRoleVhostTopicVhost:SecretBackendRoleVhostTopicVhost": {
            "properties": {
                "read": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "topic": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "write": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "read",
                "topic",
                "write"
            ]
        },
        "vault:ssh/SecretBackendRoleAllowedUserKeyConfig:SecretBackendRoleAllowedUserKeyConfig": {
            "properties": {
                "lengths": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A list of allowed key lengths as integers. \nFor key types that do not support setting the length a value of `[0]` should be used.\nSetting multiple lengths is only supported on Vault 1.10+. For prior releases `length`\nmust be set to a single element list.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "The SSH public key type.  \n*Supported key types are:*\n`rsa`, `ecdsa`, `ec`, `dsa`, `ed25519`, `ssh-rsa`, `ssh-dss`, `ssh-ed25519`,\n`ecdsa-sha2-nistp256`, `ecdsa-sha2-nistp384`, `ecdsa-sha2-nistp521`\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "lengths",
                "type"
            ]
        }
    },
    "provider": {
        "description": "The provider type for the vault package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "addAddressToEnv": {
                "type": "string",
                "description": "If true, adds the value of the `address` argument to the Terraform process environment.\n"
            },
            "address": {
                "type": "string",
                "description": "URL of the root of the target Vault server.\n"
            },
            "authLogin": {
                "$ref": "#/types/vault:index/ProviderAuthLogin:ProviderAuthLogin",
                "description": "Login to vault with an existing auth method using auth/\u003cmount\u003e/login\n"
            },
            "authLoginAws": {
                "$ref": "#/types/vault:index/ProviderAuthLoginAws:ProviderAuthLoginAws",
                "description": "Login to vault using the AWS method\n"
            },
            "authLoginAzure": {
                "$ref": "#/types/vault:index/ProviderAuthLoginAzure:ProviderAuthLoginAzure",
                "description": "Login to vault using the azure method\n"
            },
            "authLoginCert": {
                "$ref": "#/types/vault:index/ProviderAuthLoginCert:ProviderAuthLoginCert",
                "description": "Login to vault using the cert method\n"
            },
            "authLoginGcp": {
                "$ref": "#/types/vault:index/ProviderAuthLoginGcp:ProviderAuthLoginGcp",
                "description": "Login to vault using the gcp method\n"
            },
            "authLoginJwt": {
                "$ref": "#/types/vault:index/ProviderAuthLoginJwt:ProviderAuthLoginJwt",
                "description": "Login to vault using the jwt method\n"
            },
            "authLoginKerberos": {
                "$ref": "#/types/vault:index/ProviderAuthLoginKerberos:ProviderAuthLoginKerberos",
                "description": "Login to vault using the kerberos method\n"
            },
            "authLoginOci": {
                "$ref": "#/types/vault:index/ProviderAuthLoginOci:ProviderAuthLoginOci",
                "description": "Login to vault using the OCI method\n"
            },
            "authLoginOidc": {
                "$ref": "#/types/vault:index/ProviderAuthLoginOidc:ProviderAuthLoginOidc",
                "description": "Login to vault using the oidc method\n"
            },
            "authLoginRadius": {
                "$ref": "#/types/vault:index/ProviderAuthLoginRadius:ProviderAuthLoginRadius",
                "description": "Login to vault using the radius method\n"
            },
            "authLoginUserpass": {
                "$ref": "#/types/vault:index/ProviderAuthLoginUserpass:ProviderAuthLoginUserpass",
                "description": "Login to vault using the userpass method\n"
            },
            "caCertDir": {
                "type": "string",
                "description": "Path to directory containing CA certificate files to validate the server's certificate.\n"
            },
            "caCertFile": {
                "type": "string",
                "description": "Path to a CA certificate file to validate the server's certificate.\n"
            },
            "clientAuth": {
                "$ref": "#/types/vault:index/ProviderClientAuth:ProviderClientAuth",
                "description": "Client authentication credentials.\n"
            },
            "headers": {
                "type": "array",
                "items": {
                    "$ref": "#/types/vault:index/ProviderHeader:ProviderHeader"
                },
                "description": "The headers to send with each Vault request.\n"
            },
            "maxLeaseTtlSeconds": {
                "type": "integer",
                "description": "Maximum TTL for secret leases requested by this provider.\n"
            },
            "maxRetries": {
                "type": "integer",
                "description": "Maximum number of retries when a 5xx error code is encountered.\n"
            },
            "maxRetriesCcc": {
                "type": "integer",
                "description": "Maximum number of retries for Client Controlled Consistency related operations\n"
            },
            "namespace": {
                "type": "string",
                "description": "The namespace to use. Available only for Vault Enterprise.\n"
            },
            "skipChildToken": {
                "type": "boolean",
                "description": "Set this to true to prevent the creation of ephemeral child token used by this provider.\n"
            },
            "skipGetVaultVersion": {
                "type": "boolean",
                "description": "Skip the dynamic fetching of the Vault server version.\n"
            },
            "skipTlsVerify": {
                "type": "boolean",
                "description": "Set this to true only if the target Vault server is an insecure development instance.\n"
            },
            "tlsServerName": {
                "type": "string",
                "description": "Name to use as the SNI host when connecting via TLS.\n"
            },
            "token": {
                "type": "string",
                "description": "Token to use to authenticate to Vault.\n"
            },
            "tokenName": {
                "type": "string",
                "description": "Token name to use for creating the Vault child token.\n"
            },
            "vaultVersionOverride": {
                "type": "string",
                "description": "Override the Vault server version, which is normally determined dynamically from the target Vault server\n"
            }
        },
        "required": [
            "address",
            "token"
        ],
        "inputProperties": {
            "addAddressToEnv": {
                "type": "string",
                "description": "If true, adds the value of the `address` argument to the Terraform process environment.\n"
            },
            "address": {
                "type": "string",
                "description": "URL of the root of the target Vault server.\n"
            },
            "authLogin": {
                "$ref": "#/types/vault:index/ProviderAuthLogin:ProviderAuthLogin",
                "description": "Login to vault with an existing auth method using auth/\u003cmount\u003e/login\n"
            },
            "authLoginAws": {
                "$ref": "#/types/vault:index/ProviderAuthLoginAws:ProviderAuthLoginAws",
                "description": "Login to vault using the AWS method\n"
            },
            "authLoginAzure": {
                "$ref": "#/types/vault:index/ProviderAuthLoginAzure:ProviderAuthLoginAzure",
                "description": "Login to vault using the azure method\n"
            },
            "authLoginCert": {
                "$ref": "#/types/vault:index/ProviderAuthLoginCert:ProviderAuthLoginCert",
                "description": "Login to vault using the cert method\n"
            },
            "authLoginGcp": {
                "$ref": "#/types/vault:index/ProviderAuthLoginGcp:ProviderAuthLoginGcp",
                "description": "Login to vault using the gcp method\n"
            },
            "authLoginJwt": {
                "$ref": "#/types/vault:index/ProviderAuthLoginJwt:ProviderAuthLoginJwt",
                "description": "Login to vault using the jwt method\n"
            },
            "authLoginKerberos": {
                "$ref": "#/types/vault:index/ProviderAuthLoginKerberos:ProviderAuthLoginKerberos",
                "description": "Login to vault using the kerberos method\n"
            },
            "authLoginOci": {
                "$ref": "#/types/vault:index/ProviderAuthLoginOci:ProviderAuthLoginOci",
                "description": "Login to vault using the OCI method\n"
            },
            "authLoginOidc": {
                "$ref": "#/types/vault:index/ProviderAuthLoginOidc:ProviderAuthLoginOidc",
                "description": "Login to vault using the oidc method\n"
            },
            "authLoginRadius": {
                "$ref": "#/types/vault:index/ProviderAuthLoginRadius:ProviderAuthLoginRadius",
                "description": "Login to vault using the radius method\n"
            },
            "authLoginUserpass": {
                "$ref": "#/types/vault:index/ProviderAuthLoginUserpass:ProviderAuthLoginUserpass",
                "description": "Login to vault using the userpass method\n"
            },
            "caCertDir": {
                "type": "string",
                "description": "Path to directory containing CA certificate files to validate the server's certificate.\n"
            },
            "caCertFile": {
                "type": "string",
                "description": "Path to a CA certificate file to validate the server's certificate.\n"
            },
            "clientAuth": {
                "$ref": "#/types/vault:index/ProviderClientAuth:ProviderClientAuth",
                "description": "Client authentication credentials.\n"
            },
            "headers": {
                "type": "array",
                "items": {
                    "$ref": "#/types/vault:index/ProviderHeader:ProviderHeader"
                },
                "description": "The headers to send with each Vault request.\n"
            },
            "maxLeaseTtlSeconds": {
                "type": "integer",
                "description": "Maximum TTL for secret leases requested by this provider.\n",
                "default": 1200,
                "defaultInfo": {
                    "environment": [
                        "TERRAFORM_VAULT_MAX_TTL"
                    ]
                }
            },
            "maxRetries": {
                "type": "integer",
                "description": "Maximum number of retries when a 5xx error code is encountered.\n",
                "default": 2,
                "defaultInfo": {
                    "environment": [
                        "VAULT_MAX_RETRIES"
                    ]
                }
            },
            "maxRetriesCcc": {
                "type": "integer",
                "description": "Maximum number of retries for Client Controlled Consistency related operations\n"
            },
            "namespace": {
                "type": "string",
                "description": "The namespace to use. Available only for Vault Enterprise.\n"
            },
            "skipChildToken": {
                "type": "boolean",
                "description": "Set this to true to prevent the creation of ephemeral child token used by this provider.\n"
            },
            "skipGetVaultVersion": {
                "type": "boolean",
                "description": "Skip the dynamic fetching of the Vault server version.\n"
            },
            "skipTlsVerify": {
                "type": "boolean",
                "description": "Set this to true only if the target Vault server is an insecure development instance.\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_SKIP_VERIFY"
                    ]
                }
            },
            "tlsServerName": {
                "type": "string",
                "description": "Name to use as the SNI host when connecting via TLS.\n"
            },
            "token": {
                "type": "string",
                "description": "Token to use to authenticate to Vault.\n"
            },
            "tokenName": {
                "type": "string",
                "description": "Token name to use for creating the Vault child token.\n"
            },
            "vaultVersionOverride": {
                "type": "string",
                "description": "Override the Vault server version, which is normally determined dynamically from the target Vault server\n"
            }
        },
        "requiredInputs": [
            "address",
            "token"
        ]
    },
    "resources": {
        "vault:ad/secretBackend:SecretBackend": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst config = new vault.ad.SecretBackend(\"config\", {\n    backend: \"ad\",\n    binddn: \"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\",\n    bindpass: \"SuperSecretPassw0rd\",\n    insecureTls: true,\n    url: \"ldaps://ad\",\n    userdn: \"CN=Users,DC=corp,DC=example,DC=net\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nconfig = vault.ad.SecretBackend(\"config\",\n    backend=\"ad\",\n    binddn=\"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\",\n    bindpass=\"SuperSecretPassw0rd\",\n    insecure_tls=True,\n    url=\"ldaps://ad\",\n    userdn=\"CN=Users,DC=corp,DC=example,DC=net\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Vault.AD.SecretBackend(\"config\", new()\n    {\n        Backend = \"ad\",\n        Binddn = \"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\",\n        Bindpass = \"SuperSecretPassw0rd\",\n        InsecureTls = true,\n        Url = \"ldaps://ad\",\n        Userdn = \"CN=Users,DC=corp,DC=example,DC=net\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/ad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := ad.NewSecretBackend(ctx, \"config\", \u0026ad.SecretBackendArgs{\n\t\t\tBackend:     pulumi.String(\"ad\"),\n\t\t\tBinddn:      pulumi.String(\"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\"),\n\t\t\tBindpass:    pulumi.String(\"SuperSecretPassw0rd\"),\n\t\t\tInsecureTls: pulumi.Bool(true),\n\t\t\tUrl:         pulumi.String(\"ldaps://ad\"),\n\t\t\tUserdn:      pulumi.String(\"CN=Users,DC=corp,DC=example,DC=net\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.ad.SecretBackend;\nimport com.pulumi.vault.ad.SecretBackendArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var config = new SecretBackend(\"config\", SecretBackendArgs.builder()        \n            .backend(\"ad\")\n            .binddn(\"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\")\n            .bindpass(\"SuperSecretPassw0rd\")\n            .insecureTls(\"true\")\n            .url(\"ldaps://ad\")\n            .userdn(\"CN=Users,DC=corp,DC=example,DC=net\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  config:\n    type: vault:ad:SecretBackend\n    properties:\n      backend: ad\n      binddn: CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\n      bindpass: SuperSecretPassw0rd\n      insecureTls: true\n      url: ldaps://ad\n      userdn: CN=Users,DC=corp,DC=example,DC=net\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAD secret backend can be imported using the `backend`, e.g.\n\n```sh\n $ pulumi import vault:ad/secretBackend:SecretBackend ad ad\n```\n\n ",
            "properties": {
                "anonymousGroupSearch": {
                    "type": "boolean",
                    "description": "Use anonymous binds when performing LDAP group searches\n(if true the initial credentials will still be used for the initial connection test).\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `ad`.\n"
                },
                "binddn": {
                    "type": "string",
                    "description": "Distinguished name of object to bind when performing user and group search.\n"
                },
                "bindpass": {
                    "type": "string",
                    "description": "Password to use along with binddn when performing user search.\n",
                    "secret": true
                },
                "caseSensitiveNames": {
                    "type": "boolean",
                    "description": "If set, user and group names assigned to policies within the\nbackend will be case sensitive. Otherwise, names will be normalized to lower case.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "CA certificate to use when verifying LDAP server certificate, must be\nx509 PEM encoded.\n"
                },
                "clientTlsCert": {
                    "type": "string",
                    "description": "Client certificate to provide to the LDAP server, must be x509 PEM encoded.\n",
                    "secret": true
                },
                "clientTlsKey": {
                    "type": "string",
                    "description": "Client certificate key to provide to the LDAP server, must be x509 PEM encoded.\n",
                    "secret": true
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Default lease duration for secrets in seconds.\n"
                },
                "denyNullBind": {
                    "type": "boolean",
                    "description": "Denies an unauthenticated LDAP bind request if the user's password is empty;\ndefaults to true.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the Active Directory backend.\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "discoverdn": {
                    "type": "boolean",
                    "description": "Use anonymous bind to discover the bind Distinguished Name of a user.\n"
                },
                "formatter": {
                    "type": "string",
                    "description": "**Deprecated** use `password_policy`. Text to insert the password into, ex. \"customPrefix{{PASSWORD}}customSuffix\".\n",
                    "deprecationMessage": "Formatter is deprecated and password_policy should be used with Vault \u003e= 1.5."
                },
                "groupattr": {
                    "type": "string",
                    "description": "LDAP attribute to follow on objects returned by \u003cgroupfilter\u003e in order to enumerate\nuser group membership. Examples: `cn` or `memberOf`, etc. Defaults to `cn`.\n"
                },
                "groupdn": {
                    "type": "string",
                    "description": "LDAP search base to use for group membership search (eg: ou=Groups,dc=example,dc=org).\n"
                },
                "groupfilter": {
                    "type": "string",
                    "description": "Go template for querying group membership of user (optional) The template can access\nthe following context variables: UserDN, Username. Defaults to `(|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}}))`\n"
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Skip LDAP server SSL Certificate verification. This is not recommended for production.\nDefaults to `false`.\n"
                },
                "lastRotationTolerance": {
                    "type": "integer",
                    "description": "The number of seconds after a Vault rotation where, if Active Directory\nshows a later rotation, it should be considered out-of-band\n"
                },
                "length": {
                    "type": "integer",
                    "description": "**Deprecated** use `password_policy`. The desired length of passwords that Vault generates.\n*Mutually exclusive with `password_policy` on vault-1.11+*\n",
                    "deprecationMessage": "Length is deprecated and password_policy should be used with Vault \u003e= 1.5."
                },
                "local": {
                    "type": "boolean",
                    "description": "Mark the secrets engine as local-only. Local engines are not replicated or removed by\nreplication.Tolerance duration to use when checking the last rotation time.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Maximum possible lease duration for secrets in seconds.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "In seconds, the maximum password time-to-live.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "passwordPolicy": {
                    "type": "string",
                    "description": "Name of the password policy to use to generate passwords.\n"
                },
                "requestTimeout": {
                    "type": "integer",
                    "description": "Timeout, in seconds, for the connection when making requests against the server\nbefore returning back an error.\n"
                },
                "starttls": {
                    "type": "boolean",
                    "description": "Issue a StartTLS command after establishing unencrypted connection.\n"
                },
                "tlsMaxVersion": {
                    "type": "string",
                    "description": "Maximum TLS version to use. Accepted values are `tls10`, `tls11`,\n`tls12` or `tls13`. Defaults to `tls12`.\n"
                },
                "tlsMinVersion": {
                    "type": "string",
                    "description": "Minimum TLS version to use. Accepted values are `tls10`, `tls11`,\n`tls12` or `tls13`. Defaults to `tls12`.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "In seconds, the default password time-to-live.\n"
                },
                "upndomain": {
                    "type": "string",
                    "description": "Enables userPrincipalDomain login with [username]@UPNDomain.\n"
                },
                "url": {
                    "type": "string",
                    "description": "LDAP URL to connect to. Multiple URLs can be specified by concatenating\nthem with commas; they will be tried in-order. Defaults to `ldap://127.0.0.1`.\n"
                },
                "usePre111GroupCnBehavior": {
                    "type": "boolean",
                    "description": "In Vault 1.1.1 a fix for handling group CN values of\ndifferent cases unfortunately introduced a regression that could cause previously defined groups\nto not be found due to a change in the resulting name. If set true, the pre-1.1.1 behavior for\nmatching group CNs will be used. This is only needed in some upgrade scenarios for backwards\ncompatibility. It is enabled by default if the config is upgraded but disabled by default on\nnew configurations.\n"
                },
                "useTokenGroups": {
                    "type": "boolean",
                    "description": "If true, use the Active Directory tokenGroups constructed attribute of the\nuser to find the group memberships. This will find all security groups including nested ones.\n"
                },
                "userattr": {
                    "type": "string",
                    "description": "Attribute used when searching users. Defaults to `cn`.\n"
                },
                "userdn": {
                    "type": "string",
                    "description": "LDAP domain to use for users (eg: ou=People,dc=example,dc=org)`.\n"
                }
            },
            "required": [
                "binddn",
                "bindpass",
                "defaultLeaseTtlSeconds",
                "formatter",
                "lastRotationTolerance",
                "length",
                "maxLeaseTtlSeconds",
                "maxTtl",
                "starttls",
                "tlsMaxVersion",
                "tlsMinVersion",
                "ttl",
                "upndomain",
                "usePre111GroupCnBehavior"
            ],
            "inputProperties": {
                "anonymousGroupSearch": {
                    "type": "boolean",
                    "description": "Use anonymous binds when performing LDAP group searches\n(if true the initial credentials will still be used for the initial connection test).\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `ad`.\n"
                },
                "binddn": {
                    "type": "string",
                    "description": "Distinguished name of object to bind when performing user and group search.\n"
                },
                "bindpass": {
                    "type": "string",
                    "description": "Password to use along with binddn when performing user search.\n",
                    "secret": true
                },
                "caseSensitiveNames": {
                    "type": "boolean",
                    "description": "If set, user and group names assigned to policies within the\nbackend will be case sensitive. Otherwise, names will be normalized to lower case.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "CA certificate to use when verifying LDAP server certificate, must be\nx509 PEM encoded.\n"
                },
                "clientTlsCert": {
                    "type": "string",
                    "description": "Client certificate to provide to the LDAP server, must be x509 PEM encoded.\n",
                    "secret": true
                },
                "clientTlsKey": {
                    "type": "string",
                    "description": "Client certificate key to provide to the LDAP server, must be x509 PEM encoded.\n",
                    "secret": true
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Default lease duration for secrets in seconds.\n"
                },
                "denyNullBind": {
                    "type": "boolean",
                    "description": "Denies an unauthenticated LDAP bind request if the user's password is empty;\ndefaults to true.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the Active Directory backend.\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "discoverdn": {
                    "type": "boolean",
                    "description": "Use anonymous bind to discover the bind Distinguished Name of a user.\n"
                },
                "formatter": {
                    "type": "string",
                    "description": "**Deprecated** use `password_policy`. Text to insert the password into, ex. \"customPrefix{{PASSWORD}}customSuffix\".\n",
                    "deprecationMessage": "Formatter is deprecated and password_policy should be used with Vault \u003e= 1.5."
                },
                "groupattr": {
                    "type": "string",
                    "description": "LDAP attribute to follow on objects returned by \u003cgroupfilter\u003e in order to enumerate\nuser group membership. Examples: `cn` or `memberOf`, etc. Defaults to `cn`.\n"
                },
                "groupdn": {
                    "type": "string",
                    "description": "LDAP search base to use for group membership search (eg: ou=Groups,dc=example,dc=org).\n"
                },
                "groupfilter": {
                    "type": "string",
                    "description": "Go template for querying group membership of user (optional) The template can access\nthe following context variables: UserDN, Username. Defaults to `(|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}}))`\n"
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Skip LDAP server SSL Certificate verification. This is not recommended for production.\nDefaults to `false`.\n"
                },
                "lastRotationTolerance": {
                    "type": "integer",
                    "description": "The number of seconds after a Vault rotation where, if Active Directory\nshows a later rotation, it should be considered out-of-band\n"
                },
                "length": {
                    "type": "integer",
                    "description": "**Deprecated** use `password_policy`. The desired length of passwords that Vault generates.\n*Mutually exclusive with `password_policy` on vault-1.11+*\n",
                    "deprecationMessage": "Length is deprecated and password_policy should be used with Vault \u003e= 1.5."
                },
                "local": {
                    "type": "boolean",
                    "description": "Mark the secrets engine as local-only. Local engines are not replicated or removed by\nreplication.Tolerance duration to use when checking the last rotation time.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Maximum possible lease duration for secrets in seconds.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "In seconds, the maximum password time-to-live.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "passwordPolicy": {
                    "type": "string",
                    "description": "Name of the password policy to use to generate passwords.\n"
                },
                "requestTimeout": {
                    "type": "integer",
                    "description": "Timeout, in seconds, for the connection when making requests against the server\nbefore returning back an error.\n"
                },
                "starttls": {
                    "type": "boolean",
                    "description": "Issue a StartTLS command after establishing unencrypted connection.\n"
                },
                "tlsMaxVersion": {
                    "type": "string",
                    "description": "Maximum TLS version to use. Accepted values are `tls10`, `tls11`,\n`tls12` or `tls13`. Defaults to `tls12`.\n"
                },
                "tlsMinVersion": {
                    "type": "string",
                    "description": "Minimum TLS version to use. Accepted values are `tls10`, `tls11`,\n`tls12` or `tls13`. Defaults to `tls12`.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "In seconds, the default password time-to-live.\n"
                },
                "upndomain": {
                    "type": "string",
                    "description": "Enables userPrincipalDomain login with [username]@UPNDomain.\n"
                },
                "url": {
                    "type": "string",
                    "description": "LDAP URL to connect to. Multiple URLs can be specified by concatenating\nthem with commas; they will be tried in-order. Defaults to `ldap://127.0.0.1`.\n"
                },
                "usePre111GroupCnBehavior": {
                    "type": "boolean",
                    "description": "In Vault 1.1.1 a fix for handling group CN values of\ndifferent cases unfortunately introduced a regression that could cause previously defined groups\nto not be found due to a change in the resulting name. If set true, the pre-1.1.1 behavior for\nmatching group CNs will be used. This is only needed in some upgrade scenarios for backwards\ncompatibility. It is enabled by default if the config is upgraded but disabled by default on\nnew configurations.\n"
                },
                "useTokenGroups": {
                    "type": "boolean",
                    "description": "If true, use the Active Directory tokenGroups constructed attribute of the\nuser to find the group memberships. This will find all security groups including nested ones.\n"
                },
                "userattr": {
                    "type": "string",
                    "description": "Attribute used when searching users. Defaults to `cn`.\n"
                },
                "userdn": {
                    "type": "string",
                    "description": "LDAP domain to use for users (eg: ou=People,dc=example,dc=org)`.\n"
                }
            },
            "requiredInputs": [
                "binddn",
                "bindpass"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackend resources.\n",
                "properties": {
                    "anonymousGroupSearch": {
                        "type": "boolean",
                        "description": "Use anonymous binds when performing LDAP group searches\n(if true the initial credentials will still be used for the initial connection test).\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `ad`.\n"
                    },
                    "binddn": {
                        "type": "string",
                        "description": "Distinguished name of object to bind when performing user and group search.\n"
                    },
                    "bindpass": {
                        "type": "string",
                        "description": "Password to use along with binddn when performing user search.\n",
                        "secret": true
                    },
                    "caseSensitiveNames": {
                        "type": "boolean",
                        "description": "If set, user and group names assigned to policies within the\nbackend will be case sensitive. Otherwise, names will be normalized to lower case.\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "CA certificate to use when verifying LDAP server certificate, must be\nx509 PEM encoded.\n"
                    },
                    "clientTlsCert": {
                        "type": "string",
                        "description": "Client certificate to provide to the LDAP server, must be x509 PEM encoded.\n",
                        "secret": true
                    },
                    "clientTlsKey": {
                        "type": "string",
                        "description": "Client certificate key to provide to the LDAP server, must be x509 PEM encoded.\n",
                        "secret": true
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "Default lease duration for secrets in seconds.\n"
                    },
                    "denyNullBind": {
                        "type": "boolean",
                        "description": "Denies an unauthenticated LDAP bind request if the user's password is empty;\ndefaults to true.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Human-friendly description of the mount for the Active Directory backend.\n"
                    },
                    "disableRemount": {
                        "type": "boolean",
                        "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                    },
                    "discoverdn": {
                        "type": "boolean",
                        "description": "Use anonymous bind to discover the bind Distinguished Name of a user.\n"
                    },
                    "formatter": {
                        "type": "string",
                        "description": "**Deprecated** use `password_policy`. Text to insert the password into, ex. \"customPrefix{{PASSWORD}}customSuffix\".\n",
                        "deprecationMessage": "Formatter is deprecated and password_policy should be used with Vault \u003e= 1.5."
                    },
                    "groupattr": {
                        "type": "string",
                        "description": "LDAP attribute to follow on objects returned by \u003cgroupfilter\u003e in order to enumerate\nuser group membership. Examples: `cn` or `memberOf`, etc. Defaults to `cn`.\n"
                    },
                    "groupdn": {
                        "type": "string",
                        "description": "LDAP search base to use for group membership search (eg: ou=Groups,dc=example,dc=org).\n"
                    },
                    "groupfilter": {
                        "type": "string",
                        "description": "Go template for querying group membership of user (optional) The template can access\nthe following context variables: UserDN, Username. Defaults to `(|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}}))`\n"
                    },
                    "insecureTls": {
                        "type": "boolean",
                        "description": "Skip LDAP server SSL Certificate verification. This is not recommended for production.\nDefaults to `false`.\n"
                    },
                    "lastRotationTolerance": {
                        "type": "integer",
                        "description": "The number of seconds after a Vault rotation where, if Active Directory\nshows a later rotation, it should be considered out-of-band\n"
                    },
                    "length": {
                        "type": "integer",
                        "description": "**Deprecated** use `password_policy`. The desired length of passwords that Vault generates.\n*Mutually exclusive with `password_policy` on vault-1.11+*\n",
                        "deprecationMessage": "Length is deprecated and password_policy should be used with Vault \u003e= 1.5."
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Mark the secrets engine as local-only. Local engines are not replicated or removed by\nreplication.Tolerance duration to use when checking the last rotation time.\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "Maximum possible lease duration for secrets in seconds.\n"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "In seconds, the maximum password time-to-live.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "passwordPolicy": {
                        "type": "string",
                        "description": "Name of the password policy to use to generate passwords.\n"
                    },
                    "requestTimeout": {
                        "type": "integer",
                        "description": "Timeout, in seconds, for the connection when making requests against the server\nbefore returning back an error.\n"
                    },
                    "starttls": {
                        "type": "boolean",
                        "description": "Issue a StartTLS command after establishing unencrypted connection.\n"
                    },
                    "tlsMaxVersion": {
                        "type": "string",
                        "description": "Maximum TLS version to use. Accepted values are `tls10`, `tls11`,\n`tls12` or `tls13`. Defaults to `tls12`.\n"
                    },
                    "tlsMinVersion": {
                        "type": "string",
                        "description": "Minimum TLS version to use. Accepted values are `tls10`, `tls11`,\n`tls12` or `tls13`. Defaults to `tls12`.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "In seconds, the default password time-to-live.\n"
                    },
                    "upndomain": {
                        "type": "string",
                        "description": "Enables userPrincipalDomain login with [username]@UPNDomain.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "LDAP URL to connect to. Multiple URLs can be specified by concatenating\nthem with commas; they will be tried in-order. Defaults to `ldap://127.0.0.1`.\n"
                    },
                    "usePre111GroupCnBehavior": {
                        "type": "boolean",
                        "description": "In Vault 1.1.1 a fix for handling group CN values of\ndifferent cases unfortunately introduced a regression that could cause previously defined groups\nto not be found due to a change in the resulting name. If set true, the pre-1.1.1 behavior for\nmatching group CNs will be used. This is only needed in some upgrade scenarios for backwards\ncompatibility. It is enabled by default if the config is upgraded but disabled by default on\nnew configurations.\n"
                    },
                    "useTokenGroups": {
                        "type": "boolean",
                        "description": "If true, use the Active Directory tokenGroups constructed attribute of the\nuser to find the group memberships. This will find all security groups including nested ones.\n"
                    },
                    "userattr": {
                        "type": "string",
                        "description": "Attribute used when searching users. Defaults to `cn`.\n"
                    },
                    "userdn": {
                        "type": "string",
                        "description": "LDAP domain to use for users (eg: ou=People,dc=example,dc=org)`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:ad/secretLibrary:SecretLibrary": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst config = new vault.ad.SecretBackend(\"config\", {\n    backend: \"ad\",\n    binddn: \"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\",\n    bindpass: \"SuperSecretPassw0rd\",\n    url: \"ldaps://ad\",\n    insecureTls: true,\n    userdn: \"CN=Users,DC=corp,DC=example,DC=net\",\n});\nconst qa = new vault.ad.SecretLibrary(\"qa\", {\n    backend: config.backend,\n    serviceAccountNames: [\n        \"Bob\",\n        \"Mary\",\n    ],\n    ttl: 60,\n    disableCheckInEnforcement: true,\n    maxTtl: 120,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nconfig = vault.ad.SecretBackend(\"config\",\n    backend=\"ad\",\n    binddn=\"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\",\n    bindpass=\"SuperSecretPassw0rd\",\n    url=\"ldaps://ad\",\n    insecure_tls=True,\n    userdn=\"CN=Users,DC=corp,DC=example,DC=net\")\nqa = vault.ad.SecretLibrary(\"qa\",\n    backend=config.backend,\n    service_account_names=[\n        \"Bob\",\n        \"Mary\",\n    ],\n    ttl=60,\n    disable_check_in_enforcement=True,\n    max_ttl=120)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Vault.AD.SecretBackend(\"config\", new()\n    {\n        Backend = \"ad\",\n        Binddn = \"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\",\n        Bindpass = \"SuperSecretPassw0rd\",\n        Url = \"ldaps://ad\",\n        InsecureTls = true,\n        Userdn = \"CN=Users,DC=corp,DC=example,DC=net\",\n    });\n\n    var qa = new Vault.AD.SecretLibrary(\"qa\", new()\n    {\n        Backend = config.Backend,\n        ServiceAccountNames = new[]\n        {\n            \"Bob\",\n            \"Mary\",\n        },\n        Ttl = 60,\n        DisableCheckInEnforcement = true,\n        MaxTtl = 120,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/ad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfig, err := ad.NewSecretBackend(ctx, \"config\", \u0026ad.SecretBackendArgs{\n\t\t\tBackend:     pulumi.String(\"ad\"),\n\t\t\tBinddn:      pulumi.String(\"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\"),\n\t\t\tBindpass:    pulumi.String(\"SuperSecretPassw0rd\"),\n\t\t\tUrl:         pulumi.String(\"ldaps://ad\"),\n\t\t\tInsecureTls: pulumi.Bool(true),\n\t\t\tUserdn:      pulumi.String(\"CN=Users,DC=corp,DC=example,DC=net\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ad.NewSecretLibrary(ctx, \"qa\", \u0026ad.SecretLibraryArgs{\n\t\t\tBackend: config.Backend,\n\t\t\tServiceAccountNames: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"Bob\"),\n\t\t\t\tpulumi.String(\"Mary\"),\n\t\t\t},\n\t\t\tTtl:                       pulumi.Int(60),\n\t\t\tDisableCheckInEnforcement: pulumi.Bool(true),\n\t\t\tMaxTtl:                    pulumi.Int(120),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.ad.SecretBackend;\nimport com.pulumi.vault.ad.SecretBackendArgs;\nimport com.pulumi.vault.ad.SecretLibrary;\nimport com.pulumi.vault.ad.SecretLibraryArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var config = new SecretBackend(\"config\", SecretBackendArgs.builder()        \n            .backend(\"ad\")\n            .binddn(\"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\")\n            .bindpass(\"SuperSecretPassw0rd\")\n            .url(\"ldaps://ad\")\n            .insecureTls(\"true\")\n            .userdn(\"CN=Users,DC=corp,DC=example,DC=net\")\n            .build());\n\n        var qa = new SecretLibrary(\"qa\", SecretLibraryArgs.builder()        \n            .backend(config.backend())\n            .serviceAccountNames(            \n                \"Bob\",\n                \"Mary\")\n            .ttl(60)\n            .disableCheckInEnforcement(true)\n            .maxTtl(120)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  config:\n    type: vault:ad:SecretBackend\n    properties:\n      backend: ad\n      binddn: CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\n      bindpass: SuperSecretPassw0rd\n      url: ldaps://ad\n      insecureTls: true\n      userdn: CN=Users,DC=corp,DC=example,DC=net\n  qa:\n    type: vault:ad:SecretLibrary\n    properties:\n      backend: ${config.backend}\n      serviceAccountNames:\n        - Bob\n        - Mary\n      ttl: 60\n      disableCheckInEnforcement: true\n      maxTtl: 120\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAD secret backend libraries can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:ad/secretLibrary:SecretLibrary role ad/library/bob\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path the AD secret backend is mounted at,\nwith no leading or trailing `/`s.\n"
                },
                "disableCheckInEnforcement": {
                    "type": "boolean",
                    "description": "Disable enforcing that service accounts must be checked in by the entity or client token that checked them out.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum password time-to-live in seconds. Defaults to the configuration\nmax_ttl if not provided.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this set of service accounts.\nMust be unique within the backend.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "serviceAccountNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the slice of service accounts mapped to this set.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The password time-to-live in seconds. Defaults to the configuration\nttl if not provided.\n"
                }
            },
            "required": [
                "backend",
                "maxTtl",
                "name",
                "serviceAccountNames",
                "ttl"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path the AD secret backend is mounted at,\nwith no leading or trailing `/`s.\n",
                    "willReplaceOnChanges": true
                },
                "disableCheckInEnforcement": {
                    "type": "boolean",
                    "description": "Disable enforcing that service accounts must be checked in by the entity or client token that checked them out.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum password time-to-live in seconds. Defaults to the configuration\nmax_ttl if not provided.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this set of service accounts.\nMust be unique within the backend.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "serviceAccountNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the slice of service accounts mapped to this set.\n",
                    "willReplaceOnChanges": true
                },
                "ttl": {
                    "type": "integer",
                    "description": "The password time-to-live in seconds. Defaults to the configuration\nttl if not provided.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "serviceAccountNames"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretLibrary resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the AD secret backend is mounted at,\nwith no leading or trailing `/`s.\n",
                        "willReplaceOnChanges": true
                    },
                    "disableCheckInEnforcement": {
                        "type": "boolean",
                        "description": "Disable enforcing that service accounts must be checked in by the entity or client token that checked them out.\n"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "The maximum password time-to-live in seconds. Defaults to the configuration\nmax_ttl if not provided.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name to identify this set of service accounts.\nMust be unique within the backend.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "serviceAccountNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the slice of service accounts mapped to this set.\n",
                        "willReplaceOnChanges": true
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "The password time-to-live in seconds. Defaults to the configuration\nttl if not provided.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:ad/secretRole:SecretRole": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst config = new vault.ad.SecretBackend(\"config\", {\n    backend: \"ad\",\n    binddn: \"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\",\n    bindpass: \"SuperSecretPassw0rd\",\n    url: \"ldaps://ad\",\n    insecureTls: true,\n    userdn: \"CN=Users,DC=corp,DC=example,DC=net\",\n});\nconst role = new vault.ad.SecretRole(\"role\", {\n    backend: config.backend,\n    role: \"bob\",\n    serviceAccountName: \"Bob\",\n    ttl: 60,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nconfig = vault.ad.SecretBackend(\"config\",\n    backend=\"ad\",\n    binddn=\"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\",\n    bindpass=\"SuperSecretPassw0rd\",\n    url=\"ldaps://ad\",\n    insecure_tls=True,\n    userdn=\"CN=Users,DC=corp,DC=example,DC=net\")\nrole = vault.ad.SecretRole(\"role\",\n    backend=config.backend,\n    role=\"bob\",\n    service_account_name=\"Bob\",\n    ttl=60)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Vault.AD.SecretBackend(\"config\", new()\n    {\n        Backend = \"ad\",\n        Binddn = \"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\",\n        Bindpass = \"SuperSecretPassw0rd\",\n        Url = \"ldaps://ad\",\n        InsecureTls = true,\n        Userdn = \"CN=Users,DC=corp,DC=example,DC=net\",\n    });\n\n    var role = new Vault.AD.SecretRole(\"role\", new()\n    {\n        Backend = config.Backend,\n        Role = \"bob\",\n        ServiceAccountName = \"Bob\",\n        Ttl = 60,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/ad\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfig, err := ad.NewSecretBackend(ctx, \"config\", \u0026ad.SecretBackendArgs{\n\t\t\tBackend:     pulumi.String(\"ad\"),\n\t\t\tBinddn:      pulumi.String(\"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\"),\n\t\t\tBindpass:    pulumi.String(\"SuperSecretPassw0rd\"),\n\t\t\tUrl:         pulumi.String(\"ldaps://ad\"),\n\t\t\tInsecureTls: pulumi.Bool(true),\n\t\t\tUserdn:      pulumi.String(\"CN=Users,DC=corp,DC=example,DC=net\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ad.NewSecretRole(ctx, \"role\", \u0026ad.SecretRoleArgs{\n\t\t\tBackend:            config.Backend,\n\t\t\tRole:               pulumi.String(\"bob\"),\n\t\t\tServiceAccountName: pulumi.String(\"Bob\"),\n\t\t\tTtl:                pulumi.Int(60),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.ad.SecretBackend;\nimport com.pulumi.vault.ad.SecretBackendArgs;\nimport com.pulumi.vault.ad.SecretRole;\nimport com.pulumi.vault.ad.SecretRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var config = new SecretBackend(\"config\", SecretBackendArgs.builder()        \n            .backend(\"ad\")\n            .binddn(\"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\")\n            .bindpass(\"SuperSecretPassw0rd\")\n            .url(\"ldaps://ad\")\n            .insecureTls(\"true\")\n            .userdn(\"CN=Users,DC=corp,DC=example,DC=net\")\n            .build());\n\n        var role = new SecretRole(\"role\", SecretRoleArgs.builder()        \n            .backend(config.backend())\n            .role(\"bob\")\n            .serviceAccountName(\"Bob\")\n            .ttl(60)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  config:\n    type: vault:ad:SecretBackend\n    properties:\n      backend: ad\n      binddn: CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\n      bindpass: SuperSecretPassw0rd\n      url: ldaps://ad\n      insecureTls: true\n      userdn: CN=Users,DC=corp,DC=example,DC=net\n  role:\n    type: vault:ad:SecretRole\n    properties:\n      backend: ${config.backend}\n      role: bob\n      serviceAccountName: Bob\n      ttl: 60\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAD secret backend roles can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:ad/secretRole:SecretRole role ad/roles/bob\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path the AD secret backend is mounted at,\nwith no leading or trailing `/`s.\n"
                },
                "lastVaultRotation": {
                    "type": "string",
                    "description": "Timestamp of the last password rotation by Vault.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "passwordLastSet": {
                    "type": "string",
                    "description": "Timestamp of the last password set by Vault.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n"
                },
                "serviceAccountName": {
                    "type": "string",
                    "description": "Specifies the name of the Active Directory service\naccount mapped to this role.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The password time-to-live in seconds. Defaults to the configuration\nttl if not provided.\n"
                }
            },
            "required": [
                "backend",
                "lastVaultRotation",
                "passwordLastSet",
                "role",
                "serviceAccountName"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path the AD secret backend is mounted at,\nwith no leading or trailing `/`s.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "role": {
                    "type": "string",
                    "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n",
                    "willReplaceOnChanges": true
                },
                "serviceAccountName": {
                    "type": "string",
                    "description": "Specifies the name of the Active Directory service\naccount mapped to this role.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The password time-to-live in seconds. Defaults to the configuration\nttl if not provided.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "role",
                "serviceAccountName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the AD secret backend is mounted at,\nwith no leading or trailing `/`s.\n",
                        "willReplaceOnChanges": true
                    },
                    "lastVaultRotation": {
                        "type": "string",
                        "description": "Timestamp of the last password rotation by Vault.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "passwordLastSet": {
                        "type": "string",
                        "description": "Timestamp of the last password set by Vault.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n",
                        "willReplaceOnChanges": true
                    },
                    "serviceAccountName": {
                        "type": "string",
                        "description": "Specifies the name of the Active Directory service\naccount mapped to this role.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "The password time-to-live in seconds. Defaults to the configuration\nttl if not provided.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:alicloud/authBackendRole:AuthBackendRole": {
            "description": "Provides a resource to create a role in an [AliCloud auth backend within Vault](https://www.vaultproject.io/docs/auth/alicloud.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst alicloudAuthBackend = new vault.AuthBackend(\"alicloudAuthBackend\", {\n    type: \"alicloud\",\n    path: \"alicloud\",\n});\nconst alicloudAuthBackendRole = new vault.alicloud.AuthBackendRole(\"alicloudAuthBackendRole\", {\n    backend: alicloudAuthBackend.path,\n    role: \"example\",\n    arn: \"acs:ram:123456:tf:role/foobar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nalicloud_auth_backend = vault.AuthBackend(\"alicloudAuthBackend\",\n    type=\"alicloud\",\n    path=\"alicloud\")\nalicloud_auth_backend_role = vault.alicloud.AuthBackendRole(\"alicloudAuthBackendRole\",\n    backend=alicloud_auth_backend.path,\n    role=\"example\",\n    arn=\"acs:ram:123456:tf:role/foobar\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var alicloudAuthBackend = new Vault.AuthBackend(\"alicloudAuthBackend\", new()\n    {\n        Type = \"alicloud\",\n        Path = \"alicloud\",\n    });\n\n    var alicloudAuthBackendRole = new Vault.AliCloud.AuthBackendRole(\"alicloudAuthBackendRole\", new()\n    {\n        Backend = alicloudAuthBackend.Path,\n        Role = \"example\",\n        Arn = \"acs:ram:123456:tf:role/foobar\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/alicloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\talicloudAuthBackend, err := vault.NewAuthBackend(ctx, \"alicloudAuthBackend\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"alicloud\"),\n\t\t\tPath: pulumi.String(\"alicloud\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = alicloud.NewAuthBackendRole(ctx, \"alicloudAuthBackendRole\", \u0026alicloud.AuthBackendRoleArgs{\n\t\t\tBackend: alicloudAuthBackend.Path,\n\t\t\tRole:    pulumi.String(\"example\"),\n\t\t\tArn:     pulumi.String(\"acs:ram:123456:tf:role/foobar\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.AuthBackend;\nimport com.pulumi.vault.AuthBackendArgs;\nimport com.pulumi.vault.alicloud.AuthBackendRole;\nimport com.pulumi.vault.alicloud.AuthBackendRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var alicloudAuthBackend = new AuthBackend(\"alicloudAuthBackend\", AuthBackendArgs.builder()        \n            .type(\"alicloud\")\n            .path(\"alicloud\")\n            .build());\n\n        var alicloudAuthBackendRole = new AuthBackendRole(\"alicloudAuthBackendRole\", AuthBackendRoleArgs.builder()        \n            .backend(alicloudAuthBackend.path())\n            .role(\"example\")\n            .arn(\"acs:ram:123456:tf:role/foobar\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  alicloudAuthBackend:\n    type: vault:AuthBackend\n    properties:\n      type: alicloud\n      path: alicloud\n  alicloudAuthBackendRole:\n    type: vault:alicloud:AuthBackendRole\n    properties:\n      backend: ${alicloudAuthBackend.path}\n      role: example\n      arn: acs:ram:123456:tf:role/foobar\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAlicloud authentication roles can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:alicloud/authBackendRole:AuthBackendRole my_role auth/alicloud/role/my_role\n```\n\n ",
            "properties": {
                "arn": {
                    "type": "string",
                    "description": "The role's arn.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Path to the mounted AliCloud auth backend.\nDefaults to `alicloud`\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the role. Must correspond with the name of\nthe role reflected in the arn.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The [maximum number](https://www.vaultproject.io/api-docs/auth/alicloud#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "required": [
                "arn",
                "role"
            ],
            "inputProperties": {
                "arn": {
                    "type": "string",
                    "description": "The role's arn.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Path to the mounted AliCloud auth backend.\nDefaults to `alicloud`\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "role": {
                    "type": "string",
                    "description": "Name of the role. Must correspond with the name of\nthe role reflected in the arn.\n",
                    "willReplaceOnChanges": true
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The [maximum number](https://www.vaultproject.io/api-docs/auth/alicloud#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "requiredInputs": [
                "arn",
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "arn": {
                        "type": "string",
                        "description": "The role's arn.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "Path to the mounted AliCloud auth backend.\nDefaults to `alicloud`\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "role": {
                        "type": "string",
                        "description": "Name of the role. Must correspond with the name of\nthe role reflected in the arn.\n",
                        "willReplaceOnChanges": true
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The [maximum number](https://www.vaultproject.io/api-docs/auth/alicloud#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:appRole/authBackendLogin:AuthBackendLogin": {
            "description": "Logs into Vault using the AppRole auth backend. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/approle) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst approle = new vault.AuthBackend(\"approle\", {type: \"approle\"});\nconst example = new vault.approle.AuthBackendRole(\"example\", {\n    backend: approle.path,\n    roleName: \"test-role\",\n    tokenPolicies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n});\nconst id = new vault.approle.AuthBackendRoleSecretId(\"id\", {\n    backend: approle.path,\n    roleName: example.roleName,\n});\nconst login = new vault.approle.AuthBackendLogin(\"login\", {\n    backend: approle.path,\n    roleId: example.roleId,\n    secretId: id.secretId,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\napprole = vault.AuthBackend(\"approle\", type=\"approle\")\nexample = vault.app_role.AuthBackendRole(\"example\",\n    backend=approle.path,\n    role_name=\"test-role\",\n    token_policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ])\nid = vault.app_role.AuthBackendRoleSecretId(\"id\",\n    backend=approle.path,\n    role_name=example.role_name)\nlogin = vault.app_role.AuthBackendLogin(\"login\",\n    backend=approle.path,\n    role_id=example.role_id,\n    secret_id=id.secret_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var approle = new Vault.AuthBackend(\"approle\", new()\n    {\n        Type = \"approle\",\n    });\n\n    var example = new Vault.AppRole.AuthBackendRole(\"example\", new()\n    {\n        Backend = approle.Path,\n        RoleName = \"test-role\",\n        TokenPolicies = new[]\n        {\n            \"default\",\n            \"dev\",\n            \"prod\",\n        },\n    });\n\n    var id = new Vault.AppRole.AuthBackendRoleSecretId(\"id\", new()\n    {\n        Backend = approle.Path,\n        RoleName = example.RoleName,\n    });\n\n    var login = new Vault.AppRole.AuthBackendLogin(\"login\", new()\n    {\n        Backend = approle.Path,\n        RoleId = example.RoleId,\n        SecretId = id.SecretId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/appRole\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tapprole, err := vault.NewAuthBackend(ctx, \"approle\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"approle\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texample, err := appRole.NewAuthBackendRole(ctx, \"example\", \u0026appRole.AuthBackendRoleArgs{\n\t\t\tBackend:  approle.Path,\n\t\t\tRoleName: pulumi.String(\"test-role\"),\n\t\t\tTokenPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tid, err := appRole.NewAuthBackendRoleSecretId(ctx, \"id\", \u0026appRole.AuthBackendRoleSecretIdArgs{\n\t\t\tBackend:  approle.Path,\n\t\t\tRoleName: example.RoleName,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = appRole.NewAuthBackendLogin(ctx, \"login\", \u0026appRole.AuthBackendLoginArgs{\n\t\t\tBackend:  approle.Path,\n\t\t\tRoleId:   example.RoleId,\n\t\t\tSecretId: id.SecretId,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.AuthBackend;\nimport com.pulumi.vault.AuthBackendArgs;\nimport com.pulumi.vault.appRole.AuthBackendRole;\nimport com.pulumi.vault.appRole.AuthBackendRoleArgs;\nimport com.pulumi.vault.appRole.AuthBackendRoleSecretId;\nimport com.pulumi.vault.appRole.AuthBackendRoleSecretIdArgs;\nimport com.pulumi.vault.appRole.AuthBackendLogin;\nimport com.pulumi.vault.appRole.AuthBackendLoginArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var approle = new AuthBackend(\"approle\", AuthBackendArgs.builder()        \n            .type(\"approle\")\n            .build());\n\n        var example = new AuthBackendRole(\"example\", AuthBackendRoleArgs.builder()        \n            .backend(approle.path())\n            .roleName(\"test-role\")\n            .tokenPolicies(            \n                \"default\",\n                \"dev\",\n                \"prod\")\n            .build());\n\n        var id = new AuthBackendRoleSecretId(\"id\", AuthBackendRoleSecretIdArgs.builder()        \n            .backend(approle.path())\n            .roleName(example.roleName())\n            .build());\n\n        var login = new AuthBackendLogin(\"login\", AuthBackendLoginArgs.builder()        \n            .backend(approle.path())\n            .roleId(example.roleId())\n            .secretId(id.secretId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  approle:\n    type: vault:AuthBackend\n    properties:\n      type: approle\n  example:\n    type: vault:appRole:AuthBackendRole\n    properties:\n      backend: ${approle.path}\n      roleName: test-role\n      tokenPolicies:\n        - default\n        - dev\n        - prod\n  id:\n    type: vault:appRole:AuthBackendRoleSecretId\n    properties:\n      backend: ${approle.path}\n      roleName: ${example.roleName}\n  login:\n    type: vault:appRole:AuthBackendLogin\n    properties:\n      backend: ${approle.path}\n      roleId: ${example.roleId}\n      secretId: ${id.secretId}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The accessor for the token.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique path of the Vault backend to log in with.\n"
                },
                "clientToken": {
                    "type": "string",
                    "description": "The Vault token created.\n"
                },
                "leaseDuration": {
                    "type": "integer",
                    "description": "How long the token is valid for, in seconds.\n"
                },
                "leaseStarted": {
                    "type": "string",
                    "description": "The date and time the lease started, in RFC 3339 format.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The metadata associated with the token.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of policies applied to the token.\n"
                },
                "renewable": {
                    "type": "boolean",
                    "description": "Whether the token is renewable or not.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "The ID of the role to log in with.\n"
                },
                "secretId": {
                    "type": "string",
                    "description": "The secret ID of the role to log in with. Required\nunless `bind_secret_id` is set to false on the role.\n"
                }
            },
            "required": [
                "accessor",
                "clientToken",
                "leaseDuration",
                "leaseStarted",
                "metadata",
                "policies",
                "renewable",
                "roleId"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The unique path of the Vault backend to log in with.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "roleId": {
                    "type": "string",
                    "description": "The ID of the role to log in with.\n",
                    "willReplaceOnChanges": true
                },
                "secretId": {
                    "type": "string",
                    "description": "The secret ID of the role to log in with. Required\nunless `bind_secret_id` is set to false on the role.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "roleId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendLogin resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The accessor for the token.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The unique path of the Vault backend to log in with.\n",
                        "willReplaceOnChanges": true
                    },
                    "clientToken": {
                        "type": "string",
                        "description": "The Vault token created.\n"
                    },
                    "leaseDuration": {
                        "type": "integer",
                        "description": "How long the token is valid for, in seconds.\n"
                    },
                    "leaseStarted": {
                        "type": "string",
                        "description": "The date and time the lease started, in RFC 3339 format.\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "The metadata associated with the token.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of policies applied to the token.\n"
                    },
                    "renewable": {
                        "type": "boolean",
                        "description": "Whether the token is renewable or not.\n"
                    },
                    "roleId": {
                        "type": "string",
                        "description": "The ID of the role to log in with.\n",
                        "willReplaceOnChanges": true
                    },
                    "secretId": {
                        "type": "string",
                        "description": "The secret ID of the role to log in with. Required\nunless `bind_secret_id` is set to false on the role.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:appRole/authBackendRole:AuthBackendRole": {
            "description": "Manages an AppRole auth backend role in a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/approle) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst approle = new vault.AuthBackend(\"approle\", {type: \"approle\"});\nconst example = new vault.approle.AuthBackendRole(\"example\", {\n    backend: approle.path,\n    roleName: \"test-role\",\n    tokenPolicies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\napprole = vault.AuthBackend(\"approle\", type=\"approle\")\nexample = vault.app_role.AuthBackendRole(\"example\",\n    backend=approle.path,\n    role_name=\"test-role\",\n    token_policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var approle = new Vault.AuthBackend(\"approle\", new()\n    {\n        Type = \"approle\",\n    });\n\n    var example = new Vault.AppRole.AuthBackendRole(\"example\", new()\n    {\n        Backend = approle.Path,\n        RoleName = \"test-role\",\n        TokenPolicies = new[]\n        {\n            \"default\",\n            \"dev\",\n            \"prod\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/appRole\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tapprole, err := vault.NewAuthBackend(ctx, \"approle\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"approle\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = appRole.NewAuthBackendRole(ctx, \"example\", \u0026appRole.AuthBackendRoleArgs{\n\t\t\tBackend:  approle.Path,\n\t\t\tRoleName: pulumi.String(\"test-role\"),\n\t\t\tTokenPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.AuthBackend;\nimport com.pulumi.vault.AuthBackendArgs;\nimport com.pulumi.vault.appRole.AuthBackendRole;\nimport com.pulumi.vault.appRole.AuthBackendRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var approle = new AuthBackend(\"approle\", AuthBackendArgs.builder()        \n            .type(\"approle\")\n            .build());\n\n        var example = new AuthBackendRole(\"example\", AuthBackendRoleArgs.builder()        \n            .backend(approle.path())\n            .roleName(\"test-role\")\n            .tokenPolicies(            \n                \"default\",\n                \"dev\",\n                \"prod\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  approle:\n    type: vault:AuthBackend\n    properties:\n      type: approle\n  example:\n    type: vault:appRole:AuthBackendRole\n    properties:\n      backend: ${approle.path}\n      roleName: test-role\n      tokenPolicies:\n        - default\n        - dev\n        - prod\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAppRole authentication backend roles can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:appRole/authBackendRole:AuthBackendRole example auth/approle/role/test-role\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of the auth backend to configure.\nDefaults to `approle`.\n"
                },
                "bindSecretId": {
                    "type": "boolean",
                    "description": "Whether or not to require `secret_id` to be\npresented when logging in using this AppRole. Defaults to `true`.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "The RoleID of this role. If not specified, one will be\nauto-generated.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "secretIdBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set,\nspecifies blocks of IP addresses which can perform the login operation.\n"
                },
                "secretIdNumUses": {
                    "type": "integer",
                    "description": "The number of times any particular SecretID\ncan be used to fetch a token from this AppRole, after which the SecretID will\nexpire. A value of zero will allow unlimited uses.\n"
                },
                "secretIdTtl": {
                    "type": "integer",
                    "description": "The number of seconds after which any SecretID\nexpires.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The [maximum number](https://www.vaultproject.io/api-docs/auth/approle#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "required": [
                "roleId",
                "roleName"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of the auth backend to configure.\nDefaults to `approle`.\n",
                    "willReplaceOnChanges": true
                },
                "bindSecretId": {
                    "type": "boolean",
                    "description": "Whether or not to require `secret_id` to be\npresented when logging in using this AppRole. Defaults to `true`.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "roleId": {
                    "type": "string",
                    "description": "The RoleID of this role. If not specified, one will be\nauto-generated.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role.\n",
                    "willReplaceOnChanges": true
                },
                "secretIdBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set,\nspecifies blocks of IP addresses which can perform the login operation.\n"
                },
                "secretIdNumUses": {
                    "type": "integer",
                    "description": "The number of times any particular SecretID\ncan be used to fetch a token from this AppRole, after which the SecretID will\nexpire. A value of zero will allow unlimited uses.\n"
                },
                "secretIdTtl": {
                    "type": "integer",
                    "description": "The number of seconds after which any SecretID\nexpires.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The [maximum number](https://www.vaultproject.io/api-docs/auth/approle#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "requiredInputs": [
                "roleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The unique name of the auth backend to configure.\nDefaults to `approle`.\n",
                        "willReplaceOnChanges": true
                    },
                    "bindSecretId": {
                        "type": "boolean",
                        "description": "Whether or not to require `secret_id` to be\npresented when logging in using this AppRole. Defaults to `true`.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "roleId": {
                        "type": "string",
                        "description": "The RoleID of this role. If not specified, one will be\nauto-generated.\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role.\n",
                        "willReplaceOnChanges": true
                    },
                    "secretIdBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set,\nspecifies blocks of IP addresses which can perform the login operation.\n"
                    },
                    "secretIdNumUses": {
                        "type": "integer",
                        "description": "The number of times any particular SecretID\ncan be used to fetch a token from this AppRole, after which the SecretID will\nexpire. A value of zero will allow unlimited uses.\n"
                    },
                    "secretIdTtl": {
                        "type": "integer",
                        "description": "The number of seconds after which any SecretID\nexpires.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The [maximum number](https://www.vaultproject.io/api-docs/auth/approle#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:appRole/authBackendRoleSecretId:AuthBackendRoleSecretId": {
            "description": "Manages an AppRole auth backend SecretID in a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/approle) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst approle = new vault.AuthBackend(\"approle\", {type: \"approle\"});\nconst example = new vault.approle.AuthBackendRole(\"example\", {\n    backend: approle.path,\n    roleName: \"test-role\",\n    tokenPolicies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n});\nconst id = new vault.approle.AuthBackendRoleSecretId(\"id\", {\n    backend: approle.path,\n    roleName: example.roleName,\n    metadata: JSON.stringify({\n        hello: \"world\",\n    }),\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_vault as vault\n\napprole = vault.AuthBackend(\"approle\", type=\"approle\")\nexample = vault.app_role.AuthBackendRole(\"example\",\n    backend=approle.path,\n    role_name=\"test-role\",\n    token_policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ])\nid = vault.app_role.AuthBackendRoleSecretId(\"id\",\n    backend=approle.path,\n    role_name=example.role_name,\n    metadata=json.dumps({\n        \"hello\": \"world\",\n    }))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var approle = new Vault.AuthBackend(\"approle\", new()\n    {\n        Type = \"approle\",\n    });\n\n    var example = new Vault.AppRole.AuthBackendRole(\"example\", new()\n    {\n        Backend = approle.Path,\n        RoleName = \"test-role\",\n        TokenPolicies = new[]\n        {\n            \"default\",\n            \"dev\",\n            \"prod\",\n        },\n    });\n\n    var id = new Vault.AppRole.AuthBackendRoleSecretId(\"id\", new()\n    {\n        Backend = approle.Path,\n        RoleName = example.RoleName,\n        Metadata = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"hello\"] = \"world\",\n        }),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/appRole\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tapprole, err := vault.NewAuthBackend(ctx, \"approle\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"approle\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texample, err := appRole.NewAuthBackendRole(ctx, \"example\", \u0026appRole.AuthBackendRoleArgs{\n\t\t\tBackend:  approle.Path,\n\t\t\tRoleName: pulumi.String(\"test-role\"),\n\t\t\tTokenPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"hello\": \"world\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\t_, err = appRole.NewAuthBackendRoleSecretId(ctx, \"id\", \u0026appRole.AuthBackendRoleSecretIdArgs{\n\t\t\tBackend:  approle.Path,\n\t\t\tRoleName: example.RoleName,\n\t\t\tMetadata: pulumi.String(json0),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.AuthBackend;\nimport com.pulumi.vault.AuthBackendArgs;\nimport com.pulumi.vault.appRole.AuthBackendRole;\nimport com.pulumi.vault.appRole.AuthBackendRoleArgs;\nimport com.pulumi.vault.appRole.AuthBackendRoleSecretId;\nimport com.pulumi.vault.appRole.AuthBackendRoleSecretIdArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var approle = new AuthBackend(\"approle\", AuthBackendArgs.builder()        \n            .type(\"approle\")\n            .build());\n\n        var example = new AuthBackendRole(\"example\", AuthBackendRoleArgs.builder()        \n            .backend(approle.path())\n            .roleName(\"test-role\")\n            .tokenPolicies(            \n                \"default\",\n                \"dev\",\n                \"prod\")\n            .build());\n\n        var id = new AuthBackendRoleSecretId(\"id\", AuthBackendRoleSecretIdArgs.builder()        \n            .backend(approle.path())\n            .roleName(example.roleName())\n            .metadata(serializeJson(\n                jsonObject(\n                    jsonProperty(\"hello\", \"world\")\n                )))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  approle:\n    type: vault:AuthBackend\n    properties:\n      type: approle\n  example:\n    type: vault:appRole:AuthBackendRole\n    properties:\n      backend: ${approle.path}\n      roleName: test-role\n      tokenPolicies:\n        - default\n        - dev\n        - prod\n  id:\n    type: vault:appRole:AuthBackendRoleSecretId\n    properties:\n      backend: ${approle.path}\n      roleName: ${example.roleName}\n      metadata:\n        Fn::ToJSON:\n          hello: world\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The unique ID for this SecretID that can be safely logged.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Unique name of the auth backend to configure.\n"
                },
                "cidrLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, specifies blocks of IP addresses which can\nperform the login operation using this SecretID.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "A JSON-encoded string containing metadata in\nkey-value pairs to be set on tokens issued with this SecretID.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role to create the SecretID for.\n"
                },
                "secretId": {
                    "type": "string",
                    "description": "The SecretID to be created. If set, uses \"Push\"\nmode.  Defaults to Vault auto-generating SecretIDs.\n",
                    "secret": true
                },
                "withWrappedAccessor": {
                    "type": "boolean",
                    "description": "Set to `true` to use the wrapped secret-id accessor as the resource ID.\nIf `false` (default value), a fresh secret ID will be regenerated whenever the wrapping token is expired or\ninvalidated through unwrapping.\n"
                },
                "wrappingAccessor": {
                    "type": "string",
                    "description": "The unique ID for the response-wrapped SecretID that can\nbe safely logged.\n"
                },
                "wrappingToken": {
                    "type": "string",
                    "description": "The token used to retrieve a response-wrapped SecretID.\n",
                    "secret": true
                },
                "wrappingTtl": {
                    "type": "string",
                    "description": "If set, the SecretID response will be\n[response-wrapped](https://www.vaultproject.io/docs/concepts/response-wrapping)\nand available for the duration specified. Only a single unwrapping of the\ntoken is allowed.\n"
                }
            },
            "required": [
                "accessor",
                "roleName",
                "secretId",
                "wrappingAccessor",
                "wrappingToken"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Unique name of the auth backend to configure.\n",
                    "willReplaceOnChanges": true
                },
                "cidrLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, specifies blocks of IP addresses which can\nperform the login operation using this SecretID.\n",
                    "willReplaceOnChanges": true
                },
                "metadata": {
                    "type": "string",
                    "description": "A JSON-encoded string containing metadata in\nkey-value pairs to be set on tokens issued with this SecretID.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role to create the SecretID for.\n",
                    "willReplaceOnChanges": true
                },
                "secretId": {
                    "type": "string",
                    "description": "The SecretID to be created. If set, uses \"Push\"\nmode.  Defaults to Vault auto-generating SecretIDs.\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                },
                "withWrappedAccessor": {
                    "type": "boolean",
                    "description": "Set to `true` to use the wrapped secret-id accessor as the resource ID.\nIf `false` (default value), a fresh secret ID will be regenerated whenever the wrapping token is expired or\ninvalidated through unwrapping.\n",
                    "willReplaceOnChanges": true
                },
                "wrappingTtl": {
                    "type": "string",
                    "description": "If set, the SecretID response will be\n[response-wrapped](https://www.vaultproject.io/docs/concepts/response-wrapping)\nand available for the duration specified. Only a single unwrapping of the\ntoken is allowed.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "roleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRoleSecretId resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The unique ID for this SecretID that can be safely logged.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "Unique name of the auth backend to configure.\n",
                        "willReplaceOnChanges": true
                    },
                    "cidrLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, specifies blocks of IP addresses which can\nperform the login operation using this SecretID.\n",
                        "willReplaceOnChanges": true
                    },
                    "metadata": {
                        "type": "string",
                        "description": "A JSON-encoded string containing metadata in\nkey-value pairs to be set on tokens issued with this SecretID.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role to create the SecretID for.\n",
                        "willReplaceOnChanges": true
                    },
                    "secretId": {
                        "type": "string",
                        "description": "The SecretID to be created. If set, uses \"Push\"\nmode.  Defaults to Vault auto-generating SecretIDs.\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "withWrappedAccessor": {
                        "type": "boolean",
                        "description": "Set to `true` to use the wrapped secret-id accessor as the resource ID.\nIf `false` (default value), a fresh secret ID will be regenerated whenever the wrapping token is expired or\ninvalidated through unwrapping.\n",
                        "willReplaceOnChanges": true
                    },
                    "wrappingAccessor": {
                        "type": "string",
                        "description": "The unique ID for the response-wrapped SecretID that can\nbe safely logged.\n"
                    },
                    "wrappingToken": {
                        "type": "string",
                        "description": "The token used to retrieve a response-wrapped SecretID.\n",
                        "secret": true
                    },
                    "wrappingTtl": {
                        "type": "string",
                        "description": "If set, the SecretID response will be\n[response-wrapped](https://www.vaultproject.io/docs/concepts/response-wrapping)\nand available for the duration specified. Only a single unwrapping of the\ntoken is allowed.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "vault:appRole/authBackendRoleSecretID:AuthBackendRoleSecretID"
                }
            ]
        },
        "vault:aws/authBackendCert:AuthBackendCert": {
            "description": "\n\n## Import\n\nAWS auth backend certificates can be imported using `auth/`, the `backend` path, `/config/certificate/`, and the `cert_name` e.g.\n\n```sh\n $ pulumi import vault:aws/authBackendCert:AuthBackendCert example auth/aws/config/certificate/my-cert\n```\n\n ",
            "properties": {
                "awsPublicCert": {
                    "type": "string",
                    "description": "The  Base64 encoded AWS Public key required to\nverify PKCS7 signature of the EC2 instance metadata. You can find this key in\nthe [AWS\ndocumentation](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-identity-documents.html).\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                },
                "certName": {
                    "type": "string",
                    "description": "The name of the certificate.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Either \"pkcs7\" or \"identity\", indicating the type of\ndocument which can be verified using the given certificate. Defaults to\n\"pkcs7\".\n"
                }
            },
            "required": [
                "awsPublicCert",
                "certName"
            ],
            "inputProperties": {
                "awsPublicCert": {
                    "type": "string",
                    "description": "The  Base64 encoded AWS Public key required to\nverify PKCS7 signature of the EC2 instance metadata. You can find this key in\nthe [AWS\ndocumentation](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-identity-documents.html).\n",
                    "willReplaceOnChanges": true
                },
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n",
                    "willReplaceOnChanges": true
                },
                "certName": {
                    "type": "string",
                    "description": "The name of the certificate.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "Either \"pkcs7\" or \"identity\", indicating the type of\ndocument which can be verified using the given certificate. Defaults to\n\"pkcs7\".\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "awsPublicCert",
                "certName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendCert resources.\n",
                "properties": {
                    "awsPublicCert": {
                        "type": "string",
                        "description": "The  Base64 encoded AWS Public key required to\nverify PKCS7 signature of the EC2 instance metadata. You can find this key in\nthe [AWS\ndocumentation](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-identity-documents.html).\n",
                        "willReplaceOnChanges": true
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n",
                        "willReplaceOnChanges": true
                    },
                    "certName": {
                        "type": "string",
                        "description": "The name of the certificate.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "Either \"pkcs7\" or \"identity\", indicating the type of\ndocument which can be verified using the given certificate. Defaults to\n\"pkcs7\".\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendClient:AuthBackendClient": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst exampleAuthBackend = new vault.AuthBackend(\"exampleAuthBackend\", {type: \"aws\"});\nconst exampleAuthBackendClient = new vault.aws.AuthBackendClient(\"exampleAuthBackendClient\", {\n    backend: exampleAuthBackend.path,\n    accessKey: \"INSERT_AWS_ACCESS_KEY\",\n    secretKey: \"INSERT_AWS_SECRET_KEY\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample_auth_backend = vault.AuthBackend(\"exampleAuthBackend\", type=\"aws\")\nexample_auth_backend_client = vault.aws.AuthBackendClient(\"exampleAuthBackendClient\",\n    backend=example_auth_backend.path,\n    access_key=\"INSERT_AWS_ACCESS_KEY\",\n    secret_key=\"INSERT_AWS_SECRET_KEY\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleAuthBackend = new Vault.AuthBackend(\"exampleAuthBackend\", new()\n    {\n        Type = \"aws\",\n    });\n\n    var exampleAuthBackendClient = new Vault.Aws.AuthBackendClient(\"exampleAuthBackendClient\", new()\n    {\n        Backend = exampleAuthBackend.Path,\n        AccessKey = \"INSERT_AWS_ACCESS_KEY\",\n        SecretKey = \"INSERT_AWS_SECRET_KEY\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/aws\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleAuthBackend, err := vault.NewAuthBackend(ctx, \"exampleAuthBackend\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"aws\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = aws.NewAuthBackendClient(ctx, \"exampleAuthBackendClient\", \u0026aws.AuthBackendClientArgs{\n\t\t\tBackend:   exampleAuthBackend.Path,\n\t\t\tAccessKey: pulumi.String(\"INSERT_AWS_ACCESS_KEY\"),\n\t\t\tSecretKey: pulumi.String(\"INSERT_AWS_SECRET_KEY\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.AuthBackend;\nimport com.pulumi.vault.AuthBackendArgs;\nimport com.pulumi.vault.aws.AuthBackendClient;\nimport com.pulumi.vault.aws.AuthBackendClientArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleAuthBackend = new AuthBackend(\"exampleAuthBackend\", AuthBackendArgs.builder()        \n            .type(\"aws\")\n            .build());\n\n        var exampleAuthBackendClient = new AuthBackendClient(\"exampleAuthBackendClient\", AuthBackendClientArgs.builder()        \n            .backend(exampleAuthBackend.path())\n            .accessKey(\"INSERT_AWS_ACCESS_KEY\")\n            .secretKey(\"INSERT_AWS_SECRET_KEY\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleAuthBackend:\n    type: vault:AuthBackend\n    properties:\n      type: aws\n  exampleAuthBackendClient:\n    type: vault:aws:AuthBackendClient\n    properties:\n      backend: ${exampleAuthBackend.path}\n      accessKey: INSERT_AWS_ACCESS_KEY\n      secretKey: INSERT_AWS_SECRET_KEY\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAWS auth backend clients can be imported using `auth/`, the `backend` path, and `/config/client` e.g.\n\n```sh\n $ pulumi import vault:aws/authBackendClient:AuthBackendClient example auth/aws/config/client\n```\n\n ",
            "properties": {
                "accessKey": {
                    "type": "string",
                    "description": "The AWS access key that Vault should use for the\nauth backend.\n",
                    "secret": true
                },
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                },
                "ec2Endpoint": {
                    "type": "string",
                    "description": "Override the URL Vault uses when making EC2 API\ncalls.\n"
                },
                "iamEndpoint": {
                    "type": "string",
                    "description": "Override the URL Vault uses when making IAM API\ncalls.\n"
                },
                "iamServerIdHeaderValue": {
                    "type": "string",
                    "description": "The value to require in the\n`X-Vault-AWS-IAM-Server-ID` header as part of `GetCallerIdentity` requests\nthat are used in the IAM auth method.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "secretKey": {
                    "type": "string",
                    "description": "The AWS secret key that Vault should use for the\nauth backend.\n",
                    "secret": true
                },
                "stsEndpoint": {
                    "type": "string",
                    "description": "Override the URL Vault uses when making STS API\ncalls.\n"
                },
                "stsRegion": {
                    "type": "string",
                    "description": "Override the default region when making STS API \ncalls. The `sts_endpoint` argument must be set when using `sts_region`.\n"
                }
            },
            "inputProperties": {
                "accessKey": {
                    "type": "string",
                    "description": "The AWS access key that Vault should use for the\nauth backend.\n",
                    "secret": true
                },
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n",
                    "willReplaceOnChanges": true
                },
                "ec2Endpoint": {
                    "type": "string",
                    "description": "Override the URL Vault uses when making EC2 API\ncalls.\n"
                },
                "iamEndpoint": {
                    "type": "string",
                    "description": "Override the URL Vault uses when making IAM API\ncalls.\n"
                },
                "iamServerIdHeaderValue": {
                    "type": "string",
                    "description": "The value to require in the\n`X-Vault-AWS-IAM-Server-ID` header as part of `GetCallerIdentity` requests\nthat are used in the IAM auth method.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "secretKey": {
                    "type": "string",
                    "description": "The AWS secret key that Vault should use for the\nauth backend.\n",
                    "secret": true
                },
                "stsEndpoint": {
                    "type": "string",
                    "description": "Override the URL Vault uses when making STS API\ncalls.\n"
                },
                "stsRegion": {
                    "type": "string",
                    "description": "Override the default region when making STS API \ncalls. The `sts_endpoint` argument must be set when using `sts_region`.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendClient resources.\n",
                "properties": {
                    "accessKey": {
                        "type": "string",
                        "description": "The AWS access key that Vault should use for the\nauth backend.\n",
                        "secret": true
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n",
                        "willReplaceOnChanges": true
                    },
                    "ec2Endpoint": {
                        "type": "string",
                        "description": "Override the URL Vault uses when making EC2 API\ncalls.\n"
                    },
                    "iamEndpoint": {
                        "type": "string",
                        "description": "Override the URL Vault uses when making IAM API\ncalls.\n"
                    },
                    "iamServerIdHeaderValue": {
                        "type": "string",
                        "description": "The value to require in the\n`X-Vault-AWS-IAM-Server-ID` header as part of `GetCallerIdentity` requests\nthat are used in the IAM auth method.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "secretKey": {
                        "type": "string",
                        "description": "The AWS secret key that Vault should use for the\nauth backend.\n",
                        "secret": true
                    },
                    "stsEndpoint": {
                        "type": "string",
                        "description": "Override the URL Vault uses when making STS API\ncalls.\n"
                    },
                    "stsRegion": {
                        "type": "string",
                        "description": "Override the default region when making STS API \ncalls. The `sts_endpoint` argument must be set when using `sts_region`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendConfigIdentity:AuthBackendConfigIdentity": {
            "description": "Manages an AWS auth backend identity configuration in a Vault server. This configuration defines how Vault interacts\nwith the identity store. See the [Vault documentation](https://www.vaultproject.io/docs/auth/aws.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst aws = new vault.AuthBackend(\"aws\", {type: \"aws\"});\nconst example = new vault.aws.AuthBackendConfigIdentity(\"example\", {\n    backend: aws.path,\n    iamAlias: \"full_arn\",\n    iamMetadatas: [\n        \"canonical_arn\",\n        \"account_id\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\naws = vault.AuthBackend(\"aws\", type=\"aws\")\nexample = vault.aws.AuthBackendConfigIdentity(\"example\",\n    backend=aws.path,\n    iam_alias=\"full_arn\",\n    iam_metadatas=[\n        \"canonical_arn\",\n        \"account_id\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var aws = new Vault.AuthBackend(\"aws\", new()\n    {\n        Type = \"aws\",\n    });\n\n    var example = new Vault.Aws.AuthBackendConfigIdentity(\"example\", new()\n    {\n        Backend = aws.Path,\n        IamAlias = \"full_arn\",\n        IamMetadatas = new[]\n        {\n            \"canonical_arn\",\n            \"account_id\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/aws\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\taws, err := vault.NewAuthBackend(ctx, \"aws\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"aws\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = aws.NewAuthBackendConfigIdentity(ctx, \"example\", \u0026aws.AuthBackendConfigIdentityArgs{\n\t\t\tBackend:  aws.Path,\n\t\t\tIamAlias: pulumi.String(\"full_arn\"),\n\t\t\tIamMetadatas: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"canonical_arn\"),\n\t\t\t\tpulumi.String(\"account_id\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.AuthBackend;\nimport com.pulumi.vault.AuthBackendArgs;\nimport com.pulumi.vault.aws.AuthBackendConfigIdentity;\nimport com.pulumi.vault.aws.AuthBackendConfigIdentityArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var aws = new AuthBackend(\"aws\", AuthBackendArgs.builder()        \n            .type(\"aws\")\n            .build());\n\n        var example = new AuthBackendConfigIdentity(\"example\", AuthBackendConfigIdentityArgs.builder()        \n            .backend(aws.path())\n            .iamAlias(\"full_arn\")\n            .iamMetadatas(            \n                \"canonical_arn\",\n                \"account_id\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  aws:\n    type: vault:AuthBackend\n    properties:\n      type: aws\n  example:\n    type: vault:aws:AuthBackendConfigIdentity\n    properties:\n      backend: ${aws.path}\n      iamAlias: full_arn\n      iamMetadatas:\n        - canonical_arn\n        - account_id\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAWS auth backend identity config can be imported using `auth/`, the `backend` path, and `/config/identity` e.g.\n\n```sh\n $ pulumi import vault:aws/authBackendConfigIdentity:AuthBackendConfigIdentity example auth/aws/config/identity\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Unique name of the auth backend to configure.\n"
                },
                "ec2Alias": {
                    "type": "string",
                    "description": "How to generate the identity alias when using the ec2 auth method. Valid choices are\n`role_id`, `instance_id`, and `image_id`. Defaults to `role_id`\n"
                },
                "ec2Metadatas": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The metadata to include on the token returned by the `login` endpoint. This metadata will be\nadded to both audit logs, and on the `ec2_alias`\n"
                },
                "iamAlias": {
                    "type": "string",
                    "description": "How to generate the identity alias when using the iam auth method. Valid choices are\n`role_id`, `unique_id`, and `full_arn`. Defaults to `role_id`\n"
                },
                "iamMetadatas": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The metadata to include on the token returned by the `login` endpoint. This metadata will be\nadded to both audit logs, and on the `iam_alias`\n"
                }
            },
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Unique name of the auth backend to configure.\n",
                    "willReplaceOnChanges": true
                },
                "ec2Alias": {
                    "type": "string",
                    "description": "How to generate the identity alias when using the ec2 auth method. Valid choices are\n`role_id`, `instance_id`, and `image_id`. Defaults to `role_id`\n"
                },
                "ec2Metadatas": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The metadata to include on the token returned by the `login` endpoint. This metadata will be\nadded to both audit logs, and on the `ec2_alias`\n"
                },
                "iamAlias": {
                    "type": "string",
                    "description": "How to generate the identity alias when using the iam auth method. Valid choices are\n`role_id`, `unique_id`, and `full_arn`. Defaults to `role_id`\n"
                },
                "iamMetadatas": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The metadata to include on the token returned by the `login` endpoint. This metadata will be\nadded to both audit logs, and on the `iam_alias`\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendConfigIdentity resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Unique name of the auth backend to configure.\n",
                        "willReplaceOnChanges": true
                    },
                    "ec2Alias": {
                        "type": "string",
                        "description": "How to generate the identity alias when using the ec2 auth method. Valid choices are\n`role_id`, `instance_id`, and `image_id`. Defaults to `role_id`\n"
                    },
                    "ec2Metadatas": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The metadata to include on the token returned by the `login` endpoint. This metadata will be\nadded to both audit logs, and on the `ec2_alias`\n"
                    },
                    "iamAlias": {
                        "type": "string",
                        "description": "How to generate the identity alias when using the iam auth method. Valid choices are\n`role_id`, `unique_id`, and `full_arn`. Defaults to `role_id`\n"
                    },
                    "iamMetadatas": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The metadata to include on the token returned by the `login` endpoint. This metadata will be\nadded to both audit logs, and on the `iam_alias`\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendIdentityWhitelist:AuthBackendIdentityWhitelist": {
            "description": "Configures the periodic tidying operation of the whitelisted identity entries.\n\nFor more information, see the\n[Vault docs](https://www.vaultproject.io/api-docs/auth/aws#configure-identity-whitelist-tidy-operation).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst exampleAuthBackend = new vault.AuthBackend(\"exampleAuthBackend\", {type: \"aws\"});\nconst exampleAuthBackendIdentityWhitelist = new vault.aws.AuthBackendIdentityWhitelist(\"exampleAuthBackendIdentityWhitelist\", {\n    backend: exampleAuthBackend.path,\n    safetyBuffer: 3600,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample_auth_backend = vault.AuthBackend(\"exampleAuthBackend\", type=\"aws\")\nexample_auth_backend_identity_whitelist = vault.aws.AuthBackendIdentityWhitelist(\"exampleAuthBackendIdentityWhitelist\",\n    backend=example_auth_backend.path,\n    safety_buffer=3600)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleAuthBackend = new Vault.AuthBackend(\"exampleAuthBackend\", new()\n    {\n        Type = \"aws\",\n    });\n\n    var exampleAuthBackendIdentityWhitelist = new Vault.Aws.AuthBackendIdentityWhitelist(\"exampleAuthBackendIdentityWhitelist\", new()\n    {\n        Backend = exampleAuthBackend.Path,\n        SafetyBuffer = 3600,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/aws\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleAuthBackend, err := vault.NewAuthBackend(ctx, \"exampleAuthBackend\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"aws\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = aws.NewAuthBackendIdentityWhitelist(ctx, \"exampleAuthBackendIdentityWhitelist\", \u0026aws.AuthBackendIdentityWhitelistArgs{\n\t\t\tBackend:      exampleAuthBackend.Path,\n\t\t\tSafetyBuffer: pulumi.Int(3600),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.AuthBackend;\nimport com.pulumi.vault.AuthBackendArgs;\nimport com.pulumi.vault.aws.AuthBackendIdentityWhitelist;\nimport com.pulumi.vault.aws.AuthBackendIdentityWhitelistArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleAuthBackend = new AuthBackend(\"exampleAuthBackend\", AuthBackendArgs.builder()        \n            .type(\"aws\")\n            .build());\n\n        var exampleAuthBackendIdentityWhitelist = new AuthBackendIdentityWhitelist(\"exampleAuthBackendIdentityWhitelist\", AuthBackendIdentityWhitelistArgs.builder()        \n            .backend(exampleAuthBackend.path())\n            .safetyBuffer(3600)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleAuthBackend:\n    type: vault:AuthBackend\n    properties:\n      type: aws\n  exampleAuthBackendIdentityWhitelist:\n    type: vault:aws:AuthBackendIdentityWhitelist\n    properties:\n      backend: ${exampleAuthBackend.path}\n      safetyBuffer: 3600\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAWS auth backend identity whitelists can be imported using `auth/`, the `backend` path, and `/config/tidy/identity-whitelist` e.g.\n\n```sh\n $ pulumi import vault:aws/authBackendIdentityWhitelist:AuthBackendIdentityWhitelist example auth/aws/config/tidy/identity-whitelist\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path of the AWS backend being configured.\n"
                },
                "disablePeriodicTidy": {
                    "type": "boolean",
                    "description": "If set to true, disables the periodic\ntidying of the identity-whitelist entries.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "safetyBuffer": {
                    "type": "integer",
                    "description": "The amount of extra time, in minutes, that must\nhave passed beyond the roletag expiration, before it is removed from the\nbackend storage.\n"
                }
            },
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path of the AWS backend being configured.\n",
                    "willReplaceOnChanges": true
                },
                "disablePeriodicTidy": {
                    "type": "boolean",
                    "description": "If set to true, disables the periodic\ntidying of the identity-whitelist entries.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "safetyBuffer": {
                    "type": "integer",
                    "description": "The amount of extra time, in minutes, that must\nhave passed beyond the roletag expiration, before it is removed from the\nbackend storage.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendIdentityWhitelist resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path of the AWS backend being configured.\n",
                        "willReplaceOnChanges": true
                    },
                    "disablePeriodicTidy": {
                        "type": "boolean",
                        "description": "If set to true, disables the periodic\ntidying of the identity-whitelist entries.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "safetyBuffer": {
                        "type": "integer",
                        "description": "The amount of extra time, in minutes, that must\nhave passed beyond the roletag expiration, before it is removed from the\nbackend storage.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendLogin:AuthBackendLogin": {
            "description": "Logs into a Vault server using an AWS auth backend. Login can be\naccomplished using a signed identity request from IAM or using ec2\ninstance metadata. For more information, see the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/aws.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.AuthBackend;\nimport com.pulumi.vault.AuthBackendArgs;\nimport com.pulumi.vault.aws.AuthBackendClient;\nimport com.pulumi.vault.aws.AuthBackendClientArgs;\nimport com.pulumi.vault.aws.AuthBackendRole;\nimport com.pulumi.vault.aws.AuthBackendRoleArgs;\nimport com.pulumi.vault.aws.AuthBackendLogin;\nimport com.pulumi.vault.aws.AuthBackendLoginArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var aws = new AuthBackend(\"aws\", AuthBackendArgs.builder()        \n            .type(\"aws\")\n            .path(\"aws\")\n            .build());\n\n        var exampleAuthBackendClient = new AuthBackendClient(\"exampleAuthBackendClient\", AuthBackendClientArgs.builder()        \n            .backend(aws.path())\n            .accessKey(\"123456789012\")\n            .secretKey(\"AWSSECRETKEYGOESHERE\")\n            .build());\n\n        var exampleAuthBackendRole = new AuthBackendRole(\"exampleAuthBackendRole\", AuthBackendRoleArgs.builder()        \n            .backend(aws.path())\n            .role(\"test-role\")\n            .authType(\"ec2\")\n            .boundAmiId(\"ami-8c1be5f6\")\n            .boundAccountId(\"123456789012\")\n            .boundVpcId(\"vpc-b61106d4\")\n            .boundSubnetId(\"vpc-133128f1\")\n            .boundIamInstanceProfileArns(\"arn:aws:iam::123456789012:instance-profile/MyProfile\")\n            .ttl(60)\n            .maxTtl(120)\n            .tokenPolicies(            \n                \"default\",\n                \"dev\",\n                \"prod\")\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(\"vault_aws_auth_backend_client.example\")\n                .build());\n\n        var exampleAuthBackendLogin = new AuthBackendLogin(\"exampleAuthBackendLogin\", AuthBackendLoginArgs.builder()        \n            .backend(vault_auth_backend.example().path())\n            .role(exampleAuthBackendRole.role())\n            .identity(\"BASE64ENCODEDIDENTITYDOCUMENT\")\n            .signature(\"BASE64ENCODEDSHA256IDENTITYDOCUMENTSIGNATURE\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  aws:\n    type: vault:AuthBackend\n    properties:\n      type: aws\n      path: aws\n  exampleAuthBackendClient:\n    type: vault:aws:AuthBackendClient\n    properties:\n      backend: ${aws.path}\n      accessKey: 123456789012\n      secretKey: AWSSECRETKEYGOESHERE\n  exampleAuthBackendRole:\n    type: vault:aws:AuthBackendRole\n    properties:\n      backend: ${aws.path}\n      role: test-role\n      authType: ec2\n      boundAmiId: ami-8c1be5f6\n      boundAccountId: 123456789012\n      boundVpcId: vpc-b61106d4\n      boundSubnetId: vpc-133128f1\n      boundIamInstanceProfileArns:\n        - arn:aws:iam::123456789012:instance-profile/MyProfile\n      ttl: 60\n      maxTtl: 120\n      tokenPolicies:\n        - default\n        - dev\n        - prod\n    options:\n      dependson:\n        - vault_aws_auth_backend_client.example\n  exampleAuthBackendLogin:\n    type: vault:aws:AuthBackendLogin\n    properties:\n      backend: ${vault_auth_backend.example.path}\n      role: ${exampleAuthBackendRole.role}\n      identity: BASE64ENCODEDIDENTITYDOCUMENT\n      signature: BASE64ENCODEDSHA256IDENTITYDOCUMENTSIGNATURE\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The token's accessor.\n"
                },
                "authType": {
                    "type": "string",
                    "description": "The authentication type used to generate this token.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique name of the AWS auth backend. Defaults to\n'aws'.\n"
                },
                "clientToken": {
                    "type": "string",
                    "description": "The token returned by Vault.\n",
                    "secret": true
                },
                "iamHttpRequestMethod": {
                    "type": "string",
                    "description": "The HTTP method used in the signed IAM\nrequest.\n"
                },
                "iamRequestBody": {
                    "type": "string",
                    "description": "The base64-encoded body of the signed\nrequest.\n"
                },
                "iamRequestHeaders": {
                    "type": "string",
                    "description": "The base64-encoded, JSON serialized\nrepresentation of the GetCallerIdentity HTTP request headers.\n"
                },
                "iamRequestUrl": {
                    "type": "string",
                    "description": "The base64-encoded HTTP URL used in the signed\nrequest.\n"
                },
                "identity": {
                    "type": "string",
                    "description": "The base64-encoded EC2 instance identity document to\nauthenticate with. Can be retrieved from the EC2 metadata server.\n"
                },
                "leaseDuration": {
                    "type": "integer",
                    "description": "The duration in seconds the token will be valid, relative\nto the time in `lease_start_time`.\n"
                },
                "leaseStartTime": {
                    "type": "string",
                    "description": "Time at which the lease was read, using the clock of the system where Terraform was running\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of information returned by the Vault server about the\nauthentication used to generate this token.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "nonce": {
                    "type": "string",
                    "description": "The unique nonce to be used for login requests. Can be\nset to a user-specified value, or will contain the server-generated value\nonce a token is issued. EC2 instances can only acquire a single token until\nthe whitelist is tidied again unless they keep track of this nonce.\n"
                },
                "pkcs7": {
                    "type": "string",
                    "description": "The PKCS#7 signature of the identity document to\nauthenticate with, with all newline characters removed. Can be retrieved from\nthe EC2 metadata server.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The Vault policies assigned to this token.\n"
                },
                "renewable": {
                    "type": "boolean",
                    "description": "Set to true if the token can be extended through renewal.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the AWS auth backend role to create tokens\nagainst.\n"
                },
                "signature": {
                    "type": "string",
                    "description": "The base64-encoded SHA256 RSA signature of the\ninstance identity document to authenticate with, with all newline characters\nremoved. Can be retrieved from the EC2 metadata server.\n"
                }
            },
            "required": [
                "accessor",
                "authType",
                "clientToken",
                "leaseDuration",
                "leaseStartTime",
                "metadata",
                "nonce",
                "policies",
                "renewable",
                "role"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of the AWS auth backend. Defaults to\n'aws'.\n",
                    "willReplaceOnChanges": true
                },
                "iamHttpRequestMethod": {
                    "type": "string",
                    "description": "The HTTP method used in the signed IAM\nrequest.\n",
                    "willReplaceOnChanges": true
                },
                "iamRequestBody": {
                    "type": "string",
                    "description": "The base64-encoded body of the signed\nrequest.\n",
                    "willReplaceOnChanges": true
                },
                "iamRequestHeaders": {
                    "type": "string",
                    "description": "The base64-encoded, JSON serialized\nrepresentation of the GetCallerIdentity HTTP request headers.\n",
                    "willReplaceOnChanges": true
                },
                "iamRequestUrl": {
                    "type": "string",
                    "description": "The base64-encoded HTTP URL used in the signed\nrequest.\n",
                    "willReplaceOnChanges": true
                },
                "identity": {
                    "type": "string",
                    "description": "The base64-encoded EC2 instance identity document to\nauthenticate with. Can be retrieved from the EC2 metadata server.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "nonce": {
                    "type": "string",
                    "description": "The unique nonce to be used for login requests. Can be\nset to a user-specified value, or will contain the server-generated value\nonce a token is issued. EC2 instances can only acquire a single token until\nthe whitelist is tidied again unless they keep track of this nonce.\n",
                    "willReplaceOnChanges": true
                },
                "pkcs7": {
                    "type": "string",
                    "description": "The PKCS#7 signature of the identity document to\nauthenticate with, with all newline characters removed. Can be retrieved from\nthe EC2 metadata server.\n",
                    "willReplaceOnChanges": true
                },
                "role": {
                    "type": "string",
                    "description": "The name of the AWS auth backend role to create tokens\nagainst.\n",
                    "willReplaceOnChanges": true
                },
                "signature": {
                    "type": "string",
                    "description": "The base64-encoded SHA256 RSA signature of the\ninstance identity document to authenticate with, with all newline characters\nremoved. Can be retrieved from the EC2 metadata server.\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendLogin resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The token's accessor.\n"
                    },
                    "authType": {
                        "type": "string",
                        "description": "The authentication type used to generate this token.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The unique name of the AWS auth backend. Defaults to\n'aws'.\n",
                        "willReplaceOnChanges": true
                    },
                    "clientToken": {
                        "type": "string",
                        "description": "The token returned by Vault.\n",
                        "secret": true
                    },
                    "iamHttpRequestMethod": {
                        "type": "string",
                        "description": "The HTTP method used in the signed IAM\nrequest.\n",
                        "willReplaceOnChanges": true
                    },
                    "iamRequestBody": {
                        "type": "string",
                        "description": "The base64-encoded body of the signed\nrequest.\n",
                        "willReplaceOnChanges": true
                    },
                    "iamRequestHeaders": {
                        "type": "string",
                        "description": "The base64-encoded, JSON serialized\nrepresentation of the GetCallerIdentity HTTP request headers.\n",
                        "willReplaceOnChanges": true
                    },
                    "iamRequestUrl": {
                        "type": "string",
                        "description": "The base64-encoded HTTP URL used in the signed\nrequest.\n",
                        "willReplaceOnChanges": true
                    },
                    "identity": {
                        "type": "string",
                        "description": "The base64-encoded EC2 instance identity document to\nauthenticate with. Can be retrieved from the EC2 metadata server.\n",
                        "willReplaceOnChanges": true
                    },
                    "leaseDuration": {
                        "type": "integer",
                        "description": "The duration in seconds the token will be valid, relative\nto the time in `lease_start_time`.\n"
                    },
                    "leaseStartTime": {
                        "type": "string",
                        "description": "Time at which the lease was read, using the clock of the system where Terraform was running\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A map of information returned by the Vault server about the\nauthentication used to generate this token.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "nonce": {
                        "type": "string",
                        "description": "The unique nonce to be used for login requests. Can be\nset to a user-specified value, or will contain the server-generated value\nonce a token is issued. EC2 instances can only acquire a single token until\nthe whitelist is tidied again unless they keep track of this nonce.\n",
                        "willReplaceOnChanges": true
                    },
                    "pkcs7": {
                        "type": "string",
                        "description": "The PKCS#7 signature of the identity document to\nauthenticate with, with all newline characters removed. Can be retrieved from\nthe EC2 metadata server.\n",
                        "willReplaceOnChanges": true
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The Vault policies assigned to this token.\n"
                    },
                    "renewable": {
                        "type": "boolean",
                        "description": "Set to true if the token can be extended through renewal.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the AWS auth backend role to create tokens\nagainst.\n",
                        "willReplaceOnChanges": true
                    },
                    "signature": {
                        "type": "string",
                        "description": "The base64-encoded SHA256 RSA signature of the\ninstance identity document to authenticate with, with all newline characters\nremoved. Can be retrieved from the EC2 metadata server.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendRole:AuthBackendRole": {
            "description": "Manages an AWS auth backend role in a Vault server. Roles constrain the\ninstances or principals that can perform the login operation against the\nbackend. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/aws.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst aws = new vault.AuthBackend(\"aws\", {type: \"aws\"});\nconst example = new vault.aws.AuthBackendRole(\"example\", {\n    backend: aws.path,\n    role: \"test-role\",\n    authType: \"iam\",\n    boundAmiIds: [\"ami-8c1be5f6\"],\n    boundAccountIds: [\"123456789012\"],\n    boundVpcIds: [\"vpc-b61106d4\"],\n    boundSubnetIds: [\"vpc-133128f1\"],\n    boundIamRoleArns: [\"arn:aws:iam::123456789012:role/MyRole\"],\n    boundIamInstanceProfileArns: [\"arn:aws:iam::123456789012:instance-profile/MyProfile\"],\n    inferredEntityType: \"ec2_instance\",\n    inferredAwsRegion: \"us-east-1\",\n    tokenTtl: 60,\n    tokenMaxTtl: 120,\n    tokenPolicies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\naws = vault.AuthBackend(\"aws\", type=\"aws\")\nexample = vault.aws.AuthBackendRole(\"example\",\n    backend=aws.path,\n    role=\"test-role\",\n    auth_type=\"iam\",\n    bound_ami_ids=[\"ami-8c1be5f6\"],\n    bound_account_ids=[\"123456789012\"],\n    bound_vpc_ids=[\"vpc-b61106d4\"],\n    bound_subnet_ids=[\"vpc-133128f1\"],\n    bound_iam_role_arns=[\"arn:aws:iam::123456789012:role/MyRole\"],\n    bound_iam_instance_profile_arns=[\"arn:aws:iam::123456789012:instance-profile/MyProfile\"],\n    inferred_entity_type=\"ec2_instance\",\n    inferred_aws_region=\"us-east-1\",\n    token_ttl=60,\n    token_max_ttl=120,\n    token_policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var aws = new Vault.AuthBackend(\"aws\", new()\n    {\n        Type = \"aws\",\n    });\n\n    var example = new Vault.Aws.AuthBackendRole(\"example\", new()\n    {\n        Backend = aws.Path,\n        Role = \"test-role\",\n        AuthType = \"iam\",\n        BoundAmiIds = new[]\n        {\n            \"ami-8c1be5f6\",\n        },\n        BoundAccountIds = new[]\n        {\n            \"123456789012\",\n        },\n        BoundVpcIds = new[]\n        {\n            \"vpc-b61106d4\",\n        },\n        BoundSubnetIds = new[]\n        {\n            \"vpc-133128f1\",\n        },\n        BoundIamRoleArns = new[]\n        {\n            \"arn:aws:iam::123456789012:role/MyRole\",\n        },\n        BoundIamInstanceProfileArns = new[]\n        {\n            \"arn:aws:iam::123456789012:instance-profile/MyProfile\",\n        },\n        InferredEntityType = \"ec2_instance\",\n        InferredAwsRegion = \"us-east-1\",\n        TokenTtl = 60,\n        TokenMaxTtl = 120,\n        TokenPolicies = new[]\n        {\n            \"default\",\n            \"dev\",\n            \"prod\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/aws\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\taws, err := vault.NewAuthBackend(ctx, \"aws\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"aws\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = aws.NewAuthBackendRole(ctx, \"example\", \u0026aws.AuthBackendRoleArgs{\n\t\t\tBackend:  aws.Path,\n\t\t\tRole:     pulumi.String(\"test-role\"),\n\t\t\tAuthType: pulumi.String(\"iam\"),\n\t\t\tBoundAmiIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"ami-8c1be5f6\"),\n\t\t\t},\n\t\t\tBoundAccountIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"123456789012\"),\n\t\t\t},\n\t\t\tBoundVpcIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vpc-b61106d4\"),\n\t\t\t},\n\t\t\tBoundSubnetIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vpc-133128f1\"),\n\t\t\t},\n\t\t\tBoundIamRoleArns: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"arn:aws:iam::123456789012:role/MyRole\"),\n\t\t\t},\n\t\t\tBoundIamInstanceProfileArns: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"arn:aws:iam::123456789012:instance-profile/MyProfile\"),\n\t\t\t},\n\t\t\tInferredEntityType: pulumi.String(\"ec2_instance\"),\n\t\t\tInferredAwsRegion:  pulumi.String(\"us-east-1\"),\n\t\t\tTokenTtl:           pulumi.Int(60),\n\t\t\tTokenMaxTtl:        pulumi.Int(120),\n\t\t\tTokenPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.AuthBackend;\nimport com.pulumi.vault.AuthBackendArgs;\nimport com.pulumi.vault.aws.AuthBackendRole;\nimport com.pulumi.vault.aws.AuthBackendRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var aws = new AuthBackend(\"aws\", AuthBackendArgs.builder()        \n            .type(\"aws\")\n            .build());\n\n        var example = new AuthBackendRole(\"example\", AuthBackendRoleArgs.builder()        \n            .backend(aws.path())\n            .role(\"test-role\")\n            .authType(\"iam\")\n            .boundAmiIds(\"ami-8c1be5f6\")\n            .boundAccountIds(\"123456789012\")\n            .boundVpcIds(\"vpc-b61106d4\")\n            .boundSubnetIds(\"vpc-133128f1\")\n            .boundIamRoleArns(\"arn:aws:iam::123456789012:role/MyRole\")\n            .boundIamInstanceProfileArns(\"arn:aws:iam::123456789012:instance-profile/MyProfile\")\n            .inferredEntityType(\"ec2_instance\")\n            .inferredAwsRegion(\"us-east-1\")\n            .tokenTtl(60)\n            .tokenMaxTtl(120)\n            .tokenPolicies(            \n                \"default\",\n                \"dev\",\n                \"prod\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  aws:\n    type: vault:AuthBackend\n    properties:\n      type: aws\n  example:\n    type: vault:aws:AuthBackendRole\n    properties:\n      backend: ${aws.path}\n      role: test-role\n      authType: iam\n      boundAmiIds:\n        - ami-8c1be5f6\n      boundAccountIds:\n        - 123456789012\n      boundVpcIds:\n        - vpc-b61106d4\n      boundSubnetIds:\n        - vpc-133128f1\n      boundIamRoleArns:\n        - arn:aws:iam::123456789012:role/MyRole\n      boundIamInstanceProfileArns:\n        - arn:aws:iam::123456789012:instance-profile/MyProfile\n      inferredEntityType: ec2_instance\n      inferredAwsRegion: us-east-1\n      tokenTtl: 60\n      tokenMaxTtl: 120\n      tokenPolicies:\n        - default\n        - dev\n        - prod\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAWS auth backend roles can be imported using `auth/`, the `backend` path, `/role/`, and the `role` name e.g.\n\n```sh\n $ pulumi import vault:aws/authBackendRole:AuthBackendRole example auth/aws/role/test-role\n```\n\n ",
            "properties": {
                "allowInstanceMigration": {
                    "type": "boolean",
                    "description": "If set to `true`, allows migration of\nthe underlying instance where the client resides.\n"
                },
                "authType": {
                    "type": "string",
                    "description": "The auth type permitted for this role. Valid choices\nare `ec2` and `iam`. Defaults to `iam`.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Unique name of the auth backend to configure.\n"
                },
                "boundAccountIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they should be using the\naccount ID specified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundAmiIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they should be using the AMI ID\nspecified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundEc2InstanceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Only EC2 instances that match this instance ID will be permitted to log in.\n"
                },
                "boundIamInstanceProfileArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on\nthe EC2 instances that can perform the login operation that they must be\nassociated with an IAM instance profile ARN which has a prefix that matches\nthe value specified by this field. The value is prefix-matched as though it\nwere a glob ending in `*`. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundIamPrincipalArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines the IAM principal that\nmust be authenticated when `auth_type` is set to `iam`. Wildcards are\nsupported at the end of the ARN.\n"
                },
                "boundIamRoleArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they must match the IAM\nrole ARN specified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that the region in their identity\ndocument must match the one specified by this field. `auth_type` must be set\nto `ec2` or `inferred_entity_type` must be set to `ec2_instance` to use this\nconstraint.\n"
                },
                "boundSubnetIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they be associated with\nthe subnet ID that matches the value specified by this field. `auth_type`\nmust be set to `ec2` or `inferred_entity_type` must be set to `ec2_instance`\nto use this constraint.\n"
                },
                "boundVpcIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they be associated with the VPC ID\nthat matches the value specified by this field. `auth_type` must be set to\n`ec2` or `inferred_entity_type` must be set to `ec2_instance` to use this\nconstraint.\n"
                },
                "disallowReauthentication": {
                    "type": "boolean",
                    "description": "IF set to `true`, only allows a\nsingle token to be granted per instance ID. This can only be set when\n`auth_type` is set to `ec2`.\n"
                },
                "inferredAwsRegion": {
                    "type": "string",
                    "description": "When `inferred_entity_type` is set, this\nis the region to search for the inferred entities. Required if\n`inferred_entity_type` is set. This only applies when `auth_type` is set to\n`iam`.\n"
                },
                "inferredEntityType": {
                    "type": "string",
                    "description": "If set, instructs Vault to turn on\ninferencing. The only valid value is `ec2_instance`, which instructs Vault to\ninfer that the role comes from an EC2 instance in an IAM instance profile.\nThis only applies when `auth_type` is set to `iam`.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "resolveAwsUniqueIds": {
                    "type": "boolean",
                    "description": "Only valid when\n`auth_type` is `iam`. If set to `true`, the `bound_iam_principal_arns` are\nresolved to [AWS Unique\nIDs](http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-unique-ids)\nfor the bound principal ARN. This field is ignored when a\n`bound_iam_principal_arn` ends in a wildcard. Resolving to unique IDs more\nclosely mimics the behavior of AWS services in that if an IAM user or role is\ndeleted and a new one is recreated with the same name, those new users or\nroles won't get access to roles in Vault that were permissioned to the prior\nprincipals of the same name. Defaults to `true`.\nOnce set to `true`, this cannot be changed to `false` without recreating the role.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "The Vault generated role ID.\n"
                },
                "roleTag": {
                    "type": "string",
                    "description": "If set, enable role tags for this role. The value set\nfor this field should be the key of the tag on the EC2 instance. `auth_type`\nmust be set to `ec2` or `inferred_entity_type` must be set to `ec2_instance`\nto use this constraint.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The [maximum number](https://www.vaultproject.io/api-docs/auth/aws#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "required": [
                "role",
                "roleId"
            ],
            "inputProperties": {
                "allowInstanceMigration": {
                    "type": "boolean",
                    "description": "If set to `true`, allows migration of\nthe underlying instance where the client resides.\n"
                },
                "authType": {
                    "type": "string",
                    "description": "The auth type permitted for this role. Valid choices\nare `ec2` and `iam`. Defaults to `iam`.\n",
                    "willReplaceOnChanges": true
                },
                "backend": {
                    "type": "string",
                    "description": "Unique name of the auth backend to configure.\n",
                    "willReplaceOnChanges": true
                },
                "boundAccountIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they should be using the\naccount ID specified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundAmiIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they should be using the AMI ID\nspecified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundEc2InstanceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Only EC2 instances that match this instance ID will be permitted to log in.\n"
                },
                "boundIamInstanceProfileArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on\nthe EC2 instances that can perform the login operation that they must be\nassociated with an IAM instance profile ARN which has a prefix that matches\nthe value specified by this field. The value is prefix-matched as though it\nwere a glob ending in `*`. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundIamPrincipalArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines the IAM principal that\nmust be authenticated when `auth_type` is set to `iam`. Wildcards are\nsupported at the end of the ARN.\n"
                },
                "boundIamRoleArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they must match the IAM\nrole ARN specified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that the region in their identity\ndocument must match the one specified by this field. `auth_type` must be set\nto `ec2` or `inferred_entity_type` must be set to `ec2_instance` to use this\nconstraint.\n"
                },
                "boundSubnetIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they be associated with\nthe subnet ID that matches the value specified by this field. `auth_type`\nmust be set to `ec2` or `inferred_entity_type` must be set to `ec2_instance`\nto use this constraint.\n"
                },
                "boundVpcIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they be associated with the VPC ID\nthat matches the value specified by this field. `auth_type` must be set to\n`ec2` or `inferred_entity_type` must be set to `ec2_instance` to use this\nconstraint.\n"
                },
                "disallowReauthentication": {
                    "type": "boolean",
                    "description": "IF set to `true`, only allows a\nsingle token to be granted per instance ID. This can only be set when\n`auth_type` is set to `ec2`.\n"
                },
                "inferredAwsRegion": {
                    "type": "string",
                    "description": "When `inferred_entity_type` is set, this\nis the region to search for the inferred entities. Required if\n`inferred_entity_type` is set. This only applies when `auth_type` is set to\n`iam`.\n"
                },
                "inferredEntityType": {
                    "type": "string",
                    "description": "If set, instructs Vault to turn on\ninferencing. The only valid value is `ec2_instance`, which instructs Vault to\ninfer that the role comes from an EC2 instance in an IAM instance profile.\nThis only applies when `auth_type` is set to `iam`.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "resolveAwsUniqueIds": {
                    "type": "boolean",
                    "description": "Only valid when\n`auth_type` is `iam`. If set to `true`, the `bound_iam_principal_arns` are\nresolved to [AWS Unique\nIDs](http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-unique-ids)\nfor the bound principal ARN. This field is ignored when a\n`bound_iam_principal_arn` ends in a wildcard. Resolving to unique IDs more\nclosely mimics the behavior of AWS services in that if an IAM user or role is\ndeleted and a new one is recreated with the same name, those new users or\nroles won't get access to roles in Vault that were permissioned to the prior\nprincipals of the same name. Defaults to `true`.\nOnce set to `true`, this cannot be changed to `false` without recreating the role.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role.\n",
                    "willReplaceOnChanges": true
                },
                "roleTag": {
                    "type": "string",
                    "description": "If set, enable role tags for this role. The value set\nfor this field should be the key of the tag on the EC2 instance. `auth_type`\nmust be set to `ec2` or `inferred_entity_type` must be set to `ec2_instance`\nto use this constraint.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The [maximum number](https://www.vaultproject.io/api-docs/auth/aws#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "requiredInputs": [
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "allowInstanceMigration": {
                        "type": "boolean",
                        "description": "If set to `true`, allows migration of\nthe underlying instance where the client resides.\n"
                    },
                    "authType": {
                        "type": "string",
                        "description": "The auth type permitted for this role. Valid choices\nare `ec2` and `iam`. Defaults to `iam`.\n",
                        "willReplaceOnChanges": true
                    },
                    "backend": {
                        "type": "string",
                        "description": "Unique name of the auth backend to configure.\n",
                        "willReplaceOnChanges": true
                    },
                    "boundAccountIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they should be using the\naccount ID specified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                    },
                    "boundAmiIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they should be using the AMI ID\nspecified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                    },
                    "boundEc2InstanceIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Only EC2 instances that match this instance ID will be permitted to log in.\n"
                    },
                    "boundIamInstanceProfileArns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on\nthe EC2 instances that can perform the login operation that they must be\nassociated with an IAM instance profile ARN which has a prefix that matches\nthe value specified by this field. The value is prefix-matched as though it\nwere a glob ending in `*`. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                    },
                    "boundIamPrincipalArns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines the IAM principal that\nmust be authenticated when `auth_type` is set to `iam`. Wildcards are\nsupported at the end of the ARN.\n"
                    },
                    "boundIamRoleArns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they must match the IAM\nrole ARN specified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                    },
                    "boundRegions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that the region in their identity\ndocument must match the one specified by this field. `auth_type` must be set\nto `ec2` or `inferred_entity_type` must be set to `ec2_instance` to use this\nconstraint.\n"
                    },
                    "boundSubnetIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they be associated with\nthe subnet ID that matches the value specified by this field. `auth_type`\nmust be set to `ec2` or `inferred_entity_type` must be set to `ec2_instance`\nto use this constraint.\n"
                    },
                    "boundVpcIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they be associated with the VPC ID\nthat matches the value specified by this field. `auth_type` must be set to\n`ec2` or `inferred_entity_type` must be set to `ec2_instance` to use this\nconstraint.\n"
                    },
                    "disallowReauthentication": {
                        "type": "boolean",
                        "description": "IF set to `true`, only allows a\nsingle token to be granted per instance ID. This can only be set when\n`auth_type` is set to `ec2`.\n"
                    },
                    "inferredAwsRegion": {
                        "type": "string",
                        "description": "When `inferred_entity_type` is set, this\nis the region to search for the inferred entities. Required if\n`inferred_entity_type` is set. This only applies when `auth_type` is set to\n`iam`.\n"
                    },
                    "inferredEntityType": {
                        "type": "string",
                        "description": "If set, instructs Vault to turn on\ninferencing. The only valid value is `ec2_instance`, which instructs Vault to\ninfer that the role comes from an EC2 instance in an IAM instance profile.\nThis only applies when `auth_type` is set to `iam`.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "resolveAwsUniqueIds": {
                        "type": "boolean",
                        "description": "Only valid when\n`auth_type` is `iam`. If set to `true`, the `bound_iam_principal_arns` are\nresolved to [AWS Unique\nIDs](http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-unique-ids)\nfor the bound principal ARN. This field is ignored when a\n`bound_iam_principal_arn` ends in a wildcard. Resolving to unique IDs more\nclosely mimics the behavior of AWS services in that if an IAM user or role is\ndeleted and a new one is recreated with the same name, those new users or\nroles won't get access to roles in Vault that were permissioned to the prior\nprincipals of the same name. Defaults to `true`.\nOnce set to `true`, this cannot be changed to `false` without recreating the role.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the role.\n",
                        "willReplaceOnChanges": true
                    },
                    "roleId": {
                        "type": "string",
                        "description": "The Vault generated role ID.\n"
                    },
                    "roleTag": {
                        "type": "string",
                        "description": "If set, enable role tags for this role. The value set\nfor this field should be the key of the tag on the EC2 instance. `auth_type`\nmust be set to `ec2` or `inferred_entity_type` must be set to `ec2_instance`\nto use this constraint.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The [maximum number](https://www.vaultproject.io/api-docs/auth/aws#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendRoleTag:AuthBackendRoleTag": {
            "description": "Reads role tag information from an AWS auth backend in Vault. \n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.AuthBackend;\nimport com.pulumi.vault.AuthBackendArgs;\nimport com.pulumi.vault.aws.AuthBackendRole;\nimport com.pulumi.vault.aws.AuthBackendRoleArgs;\nimport com.pulumi.vault.aws.AuthBackendRoleTag;\nimport com.pulumi.vault.aws.AuthBackendRoleTagArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var aws = new AuthBackend(\"aws\", AuthBackendArgs.builder()        \n            .path(\"%s\")\n            .type(\"aws\")\n            .build());\n\n        var role = new AuthBackendRole(\"role\", AuthBackendRoleArgs.builder()        \n            .backend(aws.path())\n            .role(\"%s\")\n            .authType(\"ec2\")\n            .boundAccountId(\"123456789012\")\n            .policies(            \n                \"dev\",\n                \"prod\",\n                \"qa\",\n                \"test\")\n            .roleTag(\"VaultRoleTag\")\n            .build());\n\n        var test = new AuthBackendRoleTag(\"test\", AuthBackendRoleTagArgs.builder()        \n            .backend(aws.path())\n            .role(role.role())\n            .policies(            \n                \"prod\",\n                \"dev\",\n                \"test\")\n            .maxTtl(\"1h\")\n            .instanceId(\"i-1234567\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  aws:\n    type: vault:AuthBackend\n    properties:\n      path: '%s'\n      type: aws\n  role:\n    type: vault:aws:AuthBackendRole\n    properties:\n      backend: ${aws.path}\n      role: '%s'\n      authType: ec2\n      boundAccountId: 123456789012\n      policies:\n        - dev\n        - prod\n        - qa\n        - test\n      roleTag: VaultRoleTag\n  test:\n    type: vault:aws:AuthBackendRoleTag\n    properties:\n      backend: ${aws.path}\n      role: ${role.role}\n      policies:\n        - prod\n        - dev\n        - test\n      maxTtl: 1h\n      instanceId: i-1234567\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "allowInstanceMigration": {
                    "type": "boolean",
                    "description": "If set, allows migration of the underlying instances where the client resides. Use with caution.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path to the AWS auth backend to\nread role tags from, with no leading or trailing `/`s. Defaults to \"aws\".\n"
                },
                "disallowReauthentication": {
                    "type": "boolean",
                    "description": "If set, only allows a single token to be granted per instance ID.\n"
                },
                "instanceId": {
                    "type": "string",
                    "description": "Instance ID for which this tag is intended for. If set, the created tag can only be used by the instance with the given ID.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "The maximum TTL of the tokens issued using this role.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The policies to be associated with the tag. Must be a subset of the policies associated with the role.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the AWS auth backend role to read\nrole tags from, with no leading or trailing `/`s.\n"
                },
                "tagKey": {
                    "type": "string",
                    "description": "The key of the role tag.\n"
                },
                "tagValue": {
                    "type": "string",
                    "description": "The value to set the role key.\n"
                }
            },
            "required": [
                "role",
                "tagKey",
                "tagValue"
            ],
            "inputProperties": {
                "allowInstanceMigration": {
                    "type": "boolean",
                    "description": "If set, allows migration of the underlying instances where the client resides. Use with caution.\n",
                    "willReplaceOnChanges": true
                },
                "backend": {
                    "type": "string",
                    "description": "The path to the AWS auth backend to\nread role tags from, with no leading or trailing `/`s. Defaults to \"aws\".\n",
                    "willReplaceOnChanges": true
                },
                "disallowReauthentication": {
                    "type": "boolean",
                    "description": "If set, only allows a single token to be granted per instance ID.\n",
                    "willReplaceOnChanges": true
                },
                "instanceId": {
                    "type": "string",
                    "description": "Instance ID for which this tag is intended for. If set, the created tag can only be used by the instance with the given ID.\n",
                    "willReplaceOnChanges": true
                },
                "maxTtl": {
                    "type": "string",
                    "description": "The maximum TTL of the tokens issued using this role.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The policies to be associated with the tag. Must be a subset of the policies associated with the role.\n",
                    "willReplaceOnChanges": true
                },
                "role": {
                    "type": "string",
                    "description": "The name of the AWS auth backend role to read\nrole tags from, with no leading or trailing `/`s.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRoleTag resources.\n",
                "properties": {
                    "allowInstanceMigration": {
                        "type": "boolean",
                        "description": "If set, allows migration of the underlying instances where the client resides. Use with caution.\n",
                        "willReplaceOnChanges": true
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path to the AWS auth backend to\nread role tags from, with no leading or trailing `/`s. Defaults to \"aws\".\n",
                        "willReplaceOnChanges": true
                    },
                    "disallowReauthentication": {
                        "type": "boolean",
                        "description": "If set, only allows a single token to be granted per instance ID.\n",
                        "willReplaceOnChanges": true
                    },
                    "instanceId": {
                        "type": "string",
                        "description": "Instance ID for which this tag is intended for. If set, the created tag can only be used by the instance with the given ID.\n",
                        "willReplaceOnChanges": true
                    },
                    "maxTtl": {
                        "type": "string",
                        "description": "The maximum TTL of the tokens issued using this role.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The policies to be associated with the tag. Must be a subset of the policies associated with the role.\n",
                        "willReplaceOnChanges": true
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the AWS auth backend role to read\nrole tags from, with no leading or trailing `/`s.\n",
                        "willReplaceOnChanges": true
                    },
                    "tagKey": {
                        "type": "string",
                        "description": "The key of the role tag.\n"
                    },
                    "tagValue": {
                        "type": "string",
                        "description": "The value to set the role key.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendRoletagBlacklist:AuthBackendRoletagBlacklist": {
            "description": "Configures the periodic tidying operation of the blacklisted role tag entries.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst exampleAuthBackend = new vault.AuthBackend(\"exampleAuthBackend\", {type: \"aws\"});\nconst exampleAuthBackendRoletagBlacklist = new vault.aws.AuthBackendRoletagBlacklist(\"exampleAuthBackendRoletagBlacklist\", {\n    backend: exampleAuthBackend.path,\n    safetyBuffer: 360,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample_auth_backend = vault.AuthBackend(\"exampleAuthBackend\", type=\"aws\")\nexample_auth_backend_roletag_blacklist = vault.aws.AuthBackendRoletagBlacklist(\"exampleAuthBackendRoletagBlacklist\",\n    backend=example_auth_backend.path,\n    safety_buffer=360)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleAuthBackend = new Vault.AuthBackend(\"exampleAuthBackend\", new()\n    {\n        Type = \"aws\",\n    });\n\n    var exampleAuthBackendRoletagBlacklist = new Vault.Aws.AuthBackendRoletagBlacklist(\"exampleAuthBackendRoletagBlacklist\", new()\n    {\n        Backend = exampleAuthBackend.Path,\n        SafetyBuffer = 360,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/aws\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleAuthBackend, err := vault.NewAuthBackend(ctx, \"exampleAuthBackend\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"aws\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = aws.NewAuthBackendRoletagBlacklist(ctx, \"exampleAuthBackendRoletagBlacklist\", \u0026aws.AuthBackendRoletagBlacklistArgs{\n\t\t\tBackend:      exampleAuthBackend.Path,\n\t\t\tSafetyBuffer: pulumi.Int(360),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.AuthBackend;\nimport com.pulumi.vault.AuthBackendArgs;\nimport com.pulumi.vault.aws.AuthBackendRoletagBlacklist;\nimport com.pulumi.vault.aws.AuthBackendRoletagBlacklistArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleAuthBackend = new AuthBackend(\"exampleAuthBackend\", AuthBackendArgs.builder()        \n            .type(\"aws\")\n            .build());\n\n        var exampleAuthBackendRoletagBlacklist = new AuthBackendRoletagBlacklist(\"exampleAuthBackendRoletagBlacklist\", AuthBackendRoletagBlacklistArgs.builder()        \n            .backend(exampleAuthBackend.path())\n            .safetyBuffer(360)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleAuthBackend:\n    type: vault:AuthBackend\n    properties:\n      type: aws\n  exampleAuthBackendRoletagBlacklist:\n    type: vault:aws:AuthBackendRoletagBlacklist\n    properties:\n      backend: ${exampleAuthBackend.path}\n      safetyBuffer: 360\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.\n"
                },
                "disablePeriodicTidy": {
                    "type": "boolean",
                    "description": "If set to true, disables the periodic\ntidying of the roletag blacklist entries. Defaults to false.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "safetyBuffer": {
                    "type": "integer",
                    "description": "The amount of extra time that must have passed\nbeyond the roletag expiration, before it is removed from the backend storage.\nDefaults to 259,200 seconds, or 72 hours.\n"
                }
            },
            "required": [
                "backend"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.\n",
                    "willReplaceOnChanges": true
                },
                "disablePeriodicTidy": {
                    "type": "boolean",
                    "description": "If set to true, disables the periodic\ntidying of the roletag blacklist entries. Defaults to false.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "safetyBuffer": {
                    "type": "integer",
                    "description": "The amount of extra time that must have passed\nbeyond the roletag expiration, before it is removed from the backend storage.\nDefaults to 259,200 seconds, or 72 hours.\n"
                }
            },
            "requiredInputs": [
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRoletagBlacklist resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the AWS auth backend being configured was\nmounted at.\n",
                        "willReplaceOnChanges": true
                    },
                    "disablePeriodicTidy": {
                        "type": "boolean",
                        "description": "If set to true, disables the periodic\ntidying of the roletag blacklist entries. Defaults to false.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "safetyBuffer": {
                        "type": "integer",
                        "description": "The amount of extra time that must have passed\nbeyond the roletag expiration, before it is removed from the backend storage.\nDefaults to 259,200 seconds, or 72 hours.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendStsRole:AuthBackendStsRole": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst aws = new vault.AuthBackend(\"aws\", {type: \"aws\"});\nconst role = new vault.aws.AuthBackendStsRole(\"role\", {\n    backend: aws.path,\n    accountId: \"1234567890\",\n    stsRole: \"arn:aws:iam::1234567890:role/my-role\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\naws = vault.AuthBackend(\"aws\", type=\"aws\")\nrole = vault.aws.AuthBackendStsRole(\"role\",\n    backend=aws.path,\n    account_id=\"1234567890\",\n    sts_role=\"arn:aws:iam::1234567890:role/my-role\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var aws = new Vault.AuthBackend(\"aws\", new()\n    {\n        Type = \"aws\",\n    });\n\n    var role = new Vault.Aws.AuthBackendStsRole(\"role\", new()\n    {\n        Backend = aws.Path,\n        AccountId = \"1234567890\",\n        StsRole = \"arn:aws:iam::1234567890:role/my-role\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/aws\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\taws, err := vault.NewAuthBackend(ctx, \"aws\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"aws\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = aws.NewAuthBackendStsRole(ctx, \"role\", \u0026aws.AuthBackendStsRoleArgs{\n\t\t\tBackend:   aws.Path,\n\t\t\tAccountId: pulumi.String(\"1234567890\"),\n\t\t\tStsRole:   pulumi.String(\"arn:aws:iam::1234567890:role/my-role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.AuthBackend;\nimport com.pulumi.vault.AuthBackendArgs;\nimport com.pulumi.vault.aws.AuthBackendStsRole;\nimport com.pulumi.vault.aws.AuthBackendStsRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var aws = new AuthBackend(\"aws\", AuthBackendArgs.builder()        \n            .type(\"aws\")\n            .build());\n\n        var role = new AuthBackendStsRole(\"role\", AuthBackendStsRoleArgs.builder()        \n            .backend(aws.path())\n            .accountId(\"1234567890\")\n            .stsRole(\"arn:aws:iam::1234567890:role/my-role\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  aws:\n    type: vault:AuthBackend\n    properties:\n      type: aws\n  role:\n    type: vault:aws:AuthBackendStsRole\n    properties:\n      backend: ${aws.path}\n      accountId: 1234567890\n      stsRole: arn:aws:iam::1234567890:role/my-role\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAWS auth backend STS roles can be imported using `auth/`, the `backend` path, `/config/sts/`, and the `account_id` e.g.\n\n```sh\n $ pulumi import vault:aws/authBackendStsRole:AuthBackendStsRole example auth/aws/config/sts/1234567890\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The AWS account ID to configure the STS role for.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "stsRole": {
                    "type": "string",
                    "description": "The STS role to assume when verifying requests made\nby EC2 instances in the account specified by `account_id`.\n"
                }
            },
            "required": [
                "accountId",
                "stsRole"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The AWS account ID to configure the STS role for.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "stsRole": {
                    "type": "string",
                    "description": "The STS role to assume when verifying requests made\nby EC2 instances in the account specified by `account_id`.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "stsRole"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendStsRole resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The AWS account ID to configure the STS role for.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "stsRole": {
                        "type": "string",
                        "description": "The STS role to assume when verifying requests made\nby EC2 instances in the account specified by `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/secretBackend:SecretBackend": {
            "description": "\n\n\n## Import\n\nAWS secret backends can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:aws/secretBackend:SecretBackend aws aws\n```\n\n ",
            "properties": {
                "accessKey": {
                    "type": "string",
                    "description": "The AWS Access Key ID this backend should use to\nissue new credentials. Vault uses the official AWS SDK to authenticate, and thus can also use standard AWS environment credentials, shared file credentials or IAM role/ECS task credentials.\n",
                    "secret": true
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials\nissued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "iamEndpoint": {
                    "type": "string",
                    "description": "Specifies a custom HTTP IAM endpoint to use.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `aws`.\n"
                },
                "region": {
                    "type": "string",
                    "description": "The AWS region for API calls. Defaults to `us-east-1`.\n"
                },
                "secretKey": {
                    "type": "string",
                    "description": "The AWS Secret Key this backend should use to\nissue new credentials. Vault uses the official AWS SDK to authenticate, and thus can also use standard AWS environment credentials, shared file credentials or IAM role/ECS task credentials.\n",
                    "secret": true
                },
                "stsEndpoint": {
                    "type": "string",
                    "description": "Specifies a custom HTTP STS endpoint to use.\n"
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "Template describing how dynamic usernames are generated. The username template is used to generate both IAM usernames (capped at 64 characters) and STS usernames (capped at 32 characters). If no template is provided the field defaults to the template:\n"
                }
            },
            "required": [
                "defaultLeaseTtlSeconds",
                "maxLeaseTtlSeconds",
                "region",
                "usernameTemplate"
            ],
            "inputProperties": {
                "accessKey": {
                    "type": "string",
                    "description": "The AWS Access Key ID this backend should use to\nissue new credentials. Vault uses the official AWS SDK to authenticate, and thus can also use standard AWS environment credentials, shared file credentials or IAM role/ECS task credentials.\n",
                    "secret": true
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials\nissued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "iamEndpoint": {
                    "type": "string",
                    "description": "Specifies a custom HTTP IAM endpoint to use.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `aws`.\n"
                },
                "region": {
                    "type": "string",
                    "description": "The AWS region for API calls. Defaults to `us-east-1`.\n"
                },
                "secretKey": {
                    "type": "string",
                    "description": "The AWS Secret Key this backend should use to\nissue new credentials. Vault uses the official AWS SDK to authenticate, and thus can also use standard AWS environment credentials, shared file credentials or IAM role/ECS task credentials.\n",
                    "secret": true
                },
                "stsEndpoint": {
                    "type": "string",
                    "description": "Specifies a custom HTTP STS endpoint to use.\n"
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "Template describing how dynamic usernames are generated. The username template is used to generate both IAM usernames (capped at 64 characters) and STS usernames (capped at 32 characters). If no template is provided the field defaults to the template:\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackend resources.\n",
                "properties": {
                    "accessKey": {
                        "type": "string",
                        "description": "The AWS Access Key ID this backend should use to\nissue new credentials. Vault uses the official AWS SDK to authenticate, and thus can also use standard AWS environment credentials, shared file credentials or IAM role/ECS task credentials.\n",
                        "secret": true
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The default TTL for credentials\nissued by this backend.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A human-friendly description for this backend.\n"
                    },
                    "disableRemount": {
                        "type": "boolean",
                        "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                    },
                    "iamEndpoint": {
                        "type": "string",
                        "description": "Specifies a custom HTTP IAM endpoint to use.\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `aws`.\n"
                    },
                    "region": {
                        "type": "string",
                        "description": "The AWS region for API calls. Defaults to `us-east-1`.\n"
                    },
                    "secretKey": {
                        "type": "string",
                        "description": "The AWS Secret Key this backend should use to\nissue new credentials. Vault uses the official AWS SDK to authenticate, and thus can also use standard AWS environment credentials, shared file credentials or IAM role/ECS task credentials.\n",
                        "secret": true
                    },
                    "stsEndpoint": {
                        "type": "string",
                        "description": "Specifies a custom HTTP STS endpoint to use.\n"
                    },
                    "usernameTemplate": {
                        "type": "string",
                        "description": "Template describing how dynamic usernames are generated. The username template is used to generate both IAM usernames (capped at 64 characters) and STS usernames (capped at 32 characters). If no template is provided the field defaults to the template:\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/secretBackendRole:SecretBackendRole": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst aws = new vault.aws.SecretBackend(\"aws\", {\n    accessKey: \"AKIA.....\",\n    secretKey: \"AWS secret key\",\n});\nconst role = new vault.aws.SecretBackendRole(\"role\", {\n    backend: aws.path,\n    credentialType: \"iam_user\",\n    policyDocument: `{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": \"iam:*\",\n      \"Resource\": \"*\"\n    }\n  ]\n}\n`,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\naws = vault.aws.SecretBackend(\"aws\",\n    access_key=\"AKIA.....\",\n    secret_key=\"AWS secret key\")\nrole = vault.aws.SecretBackendRole(\"role\",\n    backend=aws.path,\n    credential_type=\"iam_user\",\n    policy_document=\"\"\"{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": \"iam:*\",\n      \"Resource\": \"*\"\n    }\n  ]\n}\n\"\"\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var aws = new Vault.Aws.SecretBackend(\"aws\", new()\n    {\n        AccessKey = \"AKIA.....\",\n        SecretKey = \"AWS secret key\",\n    });\n\n    var role = new Vault.Aws.SecretBackendRole(\"role\", new()\n    {\n        Backend = aws.Path,\n        CredentialType = \"iam_user\",\n        PolicyDocument = @\"{\n  \"\"Version\"\": \"\"2012-10-17\"\",\n  \"\"Statement\"\": [\n    {\n      \"\"Effect\"\": \"\"Allow\"\",\n      \"\"Action\"\": \"\"iam:*\"\",\n      \"\"Resource\"\": \"\"*\"\"\n    }\n  ]\n}\n\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/aws\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\taws, err := aws.NewSecretBackend(ctx, \"aws\", \u0026aws.SecretBackendArgs{\n\t\t\tAccessKey: pulumi.String(\"AKIA.....\"),\n\t\t\tSecretKey: pulumi.String(\"AWS secret key\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = aws.NewSecretBackendRole(ctx, \"role\", \u0026aws.SecretBackendRoleArgs{\n\t\t\tBackend:        aws.Path,\n\t\t\tCredentialType: pulumi.String(\"iam_user\"),\n\t\t\tPolicyDocument: pulumi.String(\"{\\n  \\\"Version\\\": \\\"2012-10-17\\\",\\n  \\\"Statement\\\": [\\n    {\\n      \\\"Effect\\\": \\\"Allow\\\",\\n      \\\"Action\\\": \\\"iam:*\\\",\\n      \\\"Resource\\\": \\\"*\\\"\\n    }\\n  ]\\n}\\n\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.aws.SecretBackend;\nimport com.pulumi.vault.aws.SecretBackendArgs;\nimport com.pulumi.vault.aws.SecretBackendRole;\nimport com.pulumi.vault.aws.SecretBackendRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var aws = new SecretBackend(\"aws\", SecretBackendArgs.builder()        \n            .accessKey(\"AKIA.....\")\n            .secretKey(\"AWS secret key\")\n            .build());\n\n        var role = new SecretBackendRole(\"role\", SecretBackendRoleArgs.builder()        \n            .backend(aws.path())\n            .credentialType(\"iam_user\")\n            .policyDocument(\"\"\"\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": \"iam:*\",\n      \"Resource\": \"*\"\n    }\n  ]\n}\n            \"\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  aws:\n    type: vault:aws:SecretBackend\n    properties:\n      accessKey: AKIA.....\n      secretKey: AWS secret key\n  role:\n    type: vault:aws:SecretBackendRole\n    properties:\n      backend: ${aws.path}\n      credentialType: iam_user\n      policyDocument: |\n        {\n          \"Version\": \"2012-10-17\",\n          \"Statement\": [\n            {\n              \"Effect\": \"Allow\",\n              \"Action\": \"iam:*\",\n              \"Resource\": \"*\"\n            }\n          ]\n        }\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAWS secret backend roles can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:aws/secretBackendRole:SecretBackendRole role aws/roles/deploy\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path the AWS secret backend is mounted at,\nwith no leading or trailing `/`s.\n"
                },
                "credentialType": {
                    "type": "string",
                    "description": "Specifies the type of credential to be used when\nretrieving credentials from the role. Must be one of `iam_user`, `assumed_role`, or\n`federation_token`.\n"
                },
                "defaultStsTtl": {
                    "type": "integer",
                    "description": "The default TTL in seconds for STS credentials.\nWhen a TTL is not specified when STS credentials are requested,\nand a default TTL is specified on the role,\nthen this default TTL will be used. Valid only when `credential_type` is one of\n`assumed_role` or `federation_token`.\n"
                },
                "iamGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of IAM group names. IAM users generated\nagainst this vault role will be added to these IAM Groups. For a credential\ntype of `assumed_role` or `federation_token`, the policies sent to the\ncorresponding AWS call (sts:AssumeRole or sts:GetFederation) will be the\npolicies from each group in `iam_groups` combined with the `policy_document`\nand `policy_arns` parameters.\n"
                },
                "maxStsTtl": {
                    "type": "integer",
                    "description": "The max allowed TTL in seconds for STS credentials\n(credentials TTL are capped to `max_sts_ttl`). Valid only when `credential_type` is\none of `assumed_role` or `federation_token`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "permissionsBoundaryArn": {
                    "type": "string",
                    "description": "The ARN of the AWS Permissions \nBoundary to attach to IAM users created in the role. Valid only when\n`credential_type` is `iam_user`. If not specified, then no permissions boundary\npolicy will be attached.\n"
                },
                "policyArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies a list of AWS managed policy ARNs. The\nbehavior depends on the credential type. With `iam_user`, the policies will be\nattached to IAM users when they are requested. With `assumed_role` and\n`federation_token`, the policy ARNs will act as a filter on what the credentials\ncan do, similar to `policy_document`. When `credential_type` is `iam_user` or\n`federation_token`, at least one of `policy_document` or `policy_arns` must\nbe specified.\n"
                },
                "policyDocument": {
                    "type": "string",
                    "description": "The IAM policy document for the role. The\nbehavior depends on the credential type. With `iam_user`, the policy document\nwill be attached to the IAM user generated and augment the permissions the IAM\nuser has. With `assumed_role` and `federation_token`, the policy document will\nact as a filter on what the credentials can do, similar to `policy_arns`.\n"
                },
                "roleArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the ARNs of the AWS roles this Vault role\nis allowed to assume. Required when `credential_type` is `assumed_role` and\nprohibited otherwise.\n"
                },
                "userPath": {
                    "type": "string",
                    "description": "The path for the user name. Valid only when \n`credential_type` is `iam_user`. Default is `/`.\n"
                }
            },
            "required": [
                "backend",
                "credentialType",
                "defaultStsTtl",
                "maxStsTtl",
                "name"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path the AWS secret backend is mounted at,\nwith no leading or trailing `/`s.\n",
                    "willReplaceOnChanges": true
                },
                "credentialType": {
                    "type": "string",
                    "description": "Specifies the type of credential to be used when\nretrieving credentials from the role. Must be one of `iam_user`, `assumed_role`, or\n`federation_token`.\n"
                },
                "defaultStsTtl": {
                    "type": "integer",
                    "description": "The default TTL in seconds for STS credentials.\nWhen a TTL is not specified when STS credentials are requested,\nand a default TTL is specified on the role,\nthen this default TTL will be used. Valid only when `credential_type` is one of\n`assumed_role` or `federation_token`.\n"
                },
                "iamGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of IAM group names. IAM users generated\nagainst this vault role will be added to these IAM Groups. For a credential\ntype of `assumed_role` or `federation_token`, the policies sent to the\ncorresponding AWS call (sts:AssumeRole or sts:GetFederation) will be the\npolicies from each group in `iam_groups` combined with the `policy_document`\nand `policy_arns` parameters.\n"
                },
                "maxStsTtl": {
                    "type": "integer",
                    "description": "The max allowed TTL in seconds for STS credentials\n(credentials TTL are capped to `max_sts_ttl`). Valid only when `credential_type` is\none of `assumed_role` or `federation_token`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "permissionsBoundaryArn": {
                    "type": "string",
                    "description": "The ARN of the AWS Permissions \nBoundary to attach to IAM users created in the role. Valid only when\n`credential_type` is `iam_user`. If not specified, then no permissions boundary\npolicy will be attached.\n"
                },
                "policyArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies a list of AWS managed policy ARNs. The\nbehavior depends on the credential type. With `iam_user`, the policies will be\nattached to IAM users when they are requested. With `assumed_role` and\n`federation_token`, the policy ARNs will act as a filter on what the credentials\ncan do, similar to `policy_document`. When `credential_type` is `iam_user` or\n`federation_token`, at least one of `policy_document` or `policy_arns` must\nbe specified.\n"
                },
                "policyDocument": {
                    "type": "string",
                    "description": "The IAM policy document for the role. The\nbehavior depends on the credential type. With `iam_user`, the policy document\nwill be attached to the IAM user generated and augment the permissions the IAM\nuser has. With `assumed_role` and `federation_token`, the policy document will\nact as a filter on what the credentials can do, similar to `policy_arns`.\n"
                },
                "roleArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the ARNs of the AWS roles this Vault role\nis allowed to assume. Required when `credential_type` is `assumed_role` and\nprohibited otherwise.\n",
                    "willReplaceOnChanges": true
                },
                "userPath": {
                    "type": "string",
                    "description": "The path for the user name. Valid only when \n`credential_type` is `iam_user`. Default is `/`.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "credentialType"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the AWS secret backend is mounted at,\nwith no leading or trailing `/`s.\n",
                        "willReplaceOnChanges": true
                    },
                    "credentialType": {
                        "type": "string",
                        "description": "Specifies the type of credential to be used when\nretrieving credentials from the role. Must be one of `iam_user`, `assumed_role`, or\n`federation_token`.\n"
                    },
                    "defaultStsTtl": {
                        "type": "integer",
                        "description": "The default TTL in seconds for STS credentials.\nWhen a TTL is not specified when STS credentials are requested,\nand a default TTL is specified on the role,\nthen this default TTL will be used. Valid only when `credential_type` is one of\n`assumed_role` or `federation_token`.\n"
                    },
                    "iamGroups": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of IAM group names. IAM users generated\nagainst this vault role will be added to these IAM Groups. For a credential\ntype of `assumed_role` or `federation_token`, the policies sent to the\ncorresponding AWS call (sts:AssumeRole or sts:GetFederation) will be the\npolicies from each group in `iam_groups` combined with the `policy_document`\nand `policy_arns` parameters.\n"
                    },
                    "maxStsTtl": {
                        "type": "integer",
                        "description": "The max allowed TTL in seconds for STS credentials\n(credentials TTL are capped to `max_sts_ttl`). Valid only when `credential_type` is\none of `assumed_role` or `federation_token`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "permissionsBoundaryArn": {
                        "type": "string",
                        "description": "The ARN of the AWS Permissions \nBoundary to attach to IAM users created in the role. Valid only when\n`credential_type` is `iam_user`. If not specified, then no permissions boundary\npolicy will be attached.\n"
                    },
                    "policyArns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies a list of AWS managed policy ARNs. The\nbehavior depends on the credential type. With `iam_user`, the policies will be\nattached to IAM users when they are requested. With `assumed_role` and\n`federation_token`, the policy ARNs will act as a filter on what the credentials\ncan do, similar to `policy_document`. When `credential_type` is `iam_user` or\n`federation_token`, at least one of `policy_document` or `policy_arns` must\nbe specified.\n"
                    },
                    "policyDocument": {
                        "type": "string",
                        "description": "The IAM policy document for the role. The\nbehavior depends on the credential type. With `iam_user`, the policy document\nwill be attached to the IAM user generated and augment the permissions the IAM\nuser has. With `assumed_role` and `federation_token`, the policy document will\nact as a filter on what the credentials can do, similar to `policy_arns`.\n"
                    },
                    "roleArns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the ARNs of the AWS roles this Vault role\nis allowed to assume. Required when `credential_type` is `assumed_role` and\nprohibited otherwise.\n",
                        "willReplaceOnChanges": true
                    },
                    "userPath": {
                        "type": "string",
                        "description": "The path for the user name. Valid only when \n`credential_type` is `iam_user`. Default is `/`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:azure/authBackendConfig:AuthBackendConfig": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst exampleAuthBackend = new vault.AuthBackend(\"exampleAuthBackend\", {type: \"azure\"});\nconst exampleAuthBackendConfig = new vault.azure.AuthBackendConfig(\"exampleAuthBackendConfig\", {\n    backend: exampleAuthBackend.path,\n    tenantId: \"11111111-2222-3333-4444-555555555555\",\n    clientId: \"11111111-2222-3333-4444-555555555555\",\n    clientSecret: \"01234567890123456789\",\n    resource: \"https://vault.hashicorp.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample_auth_backend = vault.AuthBackend(\"exampleAuthBackend\", type=\"azure\")\nexample_auth_backend_config = vault.azure.AuthBackendConfig(\"exampleAuthBackendConfig\",\n    backend=example_auth_backend.path,\n    tenant_id=\"11111111-2222-3333-4444-555555555555\",\n    client_id=\"11111111-2222-3333-4444-555555555555\",\n    client_secret=\"01234567890123456789\",\n    resource=\"https://vault.hashicorp.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleAuthBackend = new Vault.AuthBackend(\"exampleAuthBackend\", new()\n    {\n        Type = \"azure\",\n    });\n\n    var exampleAuthBackendConfig = new Vault.Azure.AuthBackendConfig(\"exampleAuthBackendConfig\", new()\n    {\n        Backend = exampleAuthBackend.Path,\n        TenantId = \"11111111-2222-3333-4444-555555555555\",\n        ClientId = \"11111111-2222-3333-4444-555555555555\",\n        ClientSecret = \"01234567890123456789\",\n        Resource = \"https://vault.hashicorp.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/azure\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleAuthBackend, err := vault.NewAuthBackend(ctx, \"exampleAuthBackend\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"azure\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = azure.NewAuthBackendConfig(ctx, \"exampleAuthBackendConfig\", \u0026azure.AuthBackendConfigArgs{\n\t\t\tBackend:      exampleAuthBackend.Path,\n\t\t\tTenantId:     pulumi.String(\"11111111-2222-3333-4444-555555555555\"),\n\t\t\tClientId:     pulumi.String(\"11111111-2222-3333-4444-555555555555\"),\n\t\t\tClientSecret: pulumi.String(\"01234567890123456789\"),\n\t\t\tResource:     pulumi.String(\"https://vault.hashicorp.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.AuthBackend;\nimport com.pulumi.vault.AuthBackendArgs;\nimport com.pulumi.vault.azure.AuthBackendConfig;\nimport com.pulumi.vault.azure.AuthBackendConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleAuthBackend = new AuthBackend(\"exampleAuthBackend\", AuthBackendArgs.builder()        \n            .type(\"azure\")\n            .build());\n\n        var exampleAuthBackendConfig = new AuthBackendConfig(\"exampleAuthBackendConfig\", AuthBackendConfigArgs.builder()        \n            .backend(exampleAuthBackend.path())\n            .tenantId(\"11111111-2222-3333-4444-555555555555\")\n            .clientId(\"11111111-2222-3333-4444-555555555555\")\n            .clientSecret(\"01234567890123456789\")\n            .resource(\"https://vault.hashicorp.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleAuthBackend:\n    type: vault:AuthBackend\n    properties:\n      type: azure\n  exampleAuthBackendConfig:\n    type: vault:azure:AuthBackendConfig\n    properties:\n      backend: ${exampleAuthBackend.path}\n      tenantId: 11111111-2222-3333-4444-555555555555\n      clientId: 11111111-2222-3333-4444-555555555555\n      clientSecret: 01234567890123456789\n      resource: https://vault.hashicorp.com\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAzure auth backends can be imported using `auth/`, the `backend` path, and `/config` e.g.\n\n```sh\n $ pulumi import vault:azure/authBackendConfig:AuthBackendConfig example auth/azure/config\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path the Azure auth backend being configured was\nmounted at.  Defaults to `azure`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client id for credentials to query the Azure APIs.\nCurrently read permissions to query compute resources are required.\n",
                    "secret": true
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client secret for credentials to query the\nAzure APIs.\n",
                    "secret": true
                },
                "environment": {
                    "type": "string",
                    "description": "The Azure cloud environment. Valid values:\nAzurePublicCloud, AzureUSGovernmentCloud, AzureChinaCloud,\nAzureGermanCloud.  Defaults to `AzurePublicCloud`.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "resource": {
                    "type": "string",
                    "description": "The configured URL for the application registered in\nAzure Active Directory.\n"
                },
                "tenantId": {
                    "type": "string",
                    "description": "The tenant id for the Azure Active Directory\norganization.\n",
                    "secret": true
                }
            },
            "required": [
                "resource",
                "tenantId"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path the Azure auth backend being configured was\nmounted at.  Defaults to `azure`.\n",
                    "willReplaceOnChanges": true
                },
                "clientId": {
                    "type": "string",
                    "description": "The client id for credentials to query the Azure APIs.\nCurrently read permissions to query compute resources are required.\n",
                    "secret": true
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client secret for credentials to query the\nAzure APIs.\n",
                    "secret": true
                },
                "environment": {
                    "type": "string",
                    "description": "The Azure cloud environment. Valid values:\nAzurePublicCloud, AzureUSGovernmentCloud, AzureChinaCloud,\nAzureGermanCloud.  Defaults to `AzurePublicCloud`.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "resource": {
                    "type": "string",
                    "description": "The configured URL for the application registered in\nAzure Active Directory.\n"
                },
                "tenantId": {
                    "type": "string",
                    "description": "The tenant id for the Azure Active Directory\norganization.\n",
                    "secret": true
                }
            },
            "requiredInputs": [
                "resource",
                "tenantId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendConfig resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the Azure auth backend being configured was\nmounted at.  Defaults to `azure`.\n",
                        "willReplaceOnChanges": true
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client id for credentials to query the Azure APIs.\nCurrently read permissions to query compute resources are required.\n",
                        "secret": true
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "The client secret for credentials to query the\nAzure APIs.\n",
                        "secret": true
                    },
                    "environment": {
                        "type": "string",
                        "description": "The Azure cloud environment. Valid values:\nAzurePublicCloud, AzureUSGovernmentCloud, AzureChinaCloud,\nAzureGermanCloud.  Defaults to `AzurePublicCloud`.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "resource": {
                        "type": "string",
                        "description": "The configured URL for the application registered in\nAzure Active Directory.\n"
                    },
                    "tenantId": {
                        "type": "string",
                        "description": "The tenant id for the Azure Active Directory\norganization.\n",
                        "secret": true
                    }
                },
                "type": "object"
            }
        },
        "vault:azure/authBackendRole:AuthBackendRole": {
            "description": "Manages an Azure auth backend role in a Vault server. Roles constrain the\ninstances or principals that can perform the login operation against the\nbackend. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/azure.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst azure = new vault.AuthBackend(\"azure\", {type: \"azure\"});\nconst example = new vault.azure.AuthBackendRole(\"example\", {\n    backend: azure.path,\n    role: \"test-role\",\n    boundSubscriptionIds: [\"11111111-2222-3333-4444-555555555555\"],\n    boundResourceGroups: [\"123456789012\"],\n    tokenTtl: 60,\n    tokenMaxTtl: 120,\n    tokenPolicies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nazure = vault.AuthBackend(\"azure\", type=\"azure\")\nexample = vault.azure.AuthBackendRole(\"example\",\n    backend=azure.path,\n    role=\"test-role\",\n    bound_subscription_ids=[\"11111111-2222-3333-4444-555555555555\"],\n    bound_resource_groups=[\"123456789012\"],\n    token_ttl=60,\n    token_max_ttl=120,\n    token_policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var azure = new Vault.AuthBackend(\"azure\", new()\n    {\n        Type = \"azure\",\n    });\n\n    var example = new Vault.Azure.AuthBackendRole(\"example\", new()\n    {\n        Backend = azure.Path,\n        Role = \"test-role\",\n        BoundSubscriptionIds = new[]\n        {\n            \"11111111-2222-3333-4444-555555555555\",\n        },\n        BoundResourceGroups = new[]\n        {\n            \"123456789012\",\n        },\n        TokenTtl = 60,\n        TokenMaxTtl = 120,\n        TokenPolicies = new[]\n        {\n            \"default\",\n            \"dev\",\n            \"prod\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/azure\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tazure, err := vault.NewAuthBackend(ctx, \"azure\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"azure\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = azure.NewAuthBackendRole(ctx, \"example\", \u0026azure.AuthBackendRoleArgs{\n\t\t\tBackend: azure.Path,\n\t\t\tRole:    pulumi.String(\"test-role\"),\n\t\t\tBoundSubscriptionIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"11111111-2222-3333-4444-555555555555\"),\n\t\t\t},\n\t\t\tBoundResourceGroups: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"123456789012\"),\n\t\t\t},\n\t\t\tTokenTtl:    pulumi.Int(60),\n\t\t\tTokenMaxTtl: pulumi.Int(120),\n\t\t\tTokenPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.AuthBackend;\nimport com.pulumi.vault.AuthBackendArgs;\nimport com.pulumi.vault.azure.AuthBackendRole;\nimport com.pulumi.vault.azure.AuthBackendRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var azure = new AuthBackend(\"azure\", AuthBackendArgs.builder()        \n            .type(\"azure\")\n            .build());\n\n        var example = new AuthBackendRole(\"example\", AuthBackendRoleArgs.builder()        \n            .backend(azure.path())\n            .role(\"test-role\")\n            .boundSubscriptionIds(\"11111111-2222-3333-4444-555555555555\")\n            .boundResourceGroups(\"123456789012\")\n            .tokenTtl(60)\n            .tokenMaxTtl(120)\n            .tokenPolicies(            \n                \"default\",\n                \"dev\",\n                \"prod\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  azure:\n    type: vault:AuthBackend\n    properties:\n      type: azure\n  example:\n    type: vault:azure:AuthBackendRole\n    properties:\n      backend: ${azure.path}\n      role: test-role\n      boundSubscriptionIds:\n        - 11111111-2222-3333-4444-555555555555\n      boundResourceGroups:\n        - 123456789012\n      tokenTtl: 60\n      tokenMaxTtl: 120\n      tokenPolicies:\n        - default\n        - dev\n        - prod\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAzure auth backend roles can be imported using `auth/`, the `backend` path, `/role/`, and the `role` name e.g.\n\n```sh\n $ pulumi import vault:azure/authBackendRole:AuthBackendRole example auth/azure/role/test-role\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Unique name of the auth backend to configure.\n"
                },
                "boundGroupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the groups\nthat can perform the login operation that they should be using the group\nID specified by this field.\n"
                },
                "boundLocations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the virtual machines\nthat can perform the login operation that the location in their identity\ndocument must match the one specified by this field.\n"
                },
                "boundResourceGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the virtual\nmachines that can perform the login operation that they be associated with\nthe resource group that matches the value specified by this field.\n"
                },
                "boundScaleSets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the virtual\nmachines that can perform the login operation that they must match the scale set\nspecified by this field.\n"
                },
                "boundServicePrincipalIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the\nservice principals that can perform the login operation that they should be possess\nthe ids specified by this field.\n"
                },
                "boundSubscriptionIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the subscriptions\nthat can perform the login operation to ones which  matches the value specified by this\nfield.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The [maximum number](https://www.vaultproject.io/api-docs/azure#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "required": [
                "role"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Unique name of the auth backend to configure.\n",
                    "willReplaceOnChanges": true
                },
                "boundGroupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the groups\nthat can perform the login operation that they should be using the group\nID specified by this field.\n"
                },
                "boundLocations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the virtual machines\nthat can perform the login operation that the location in their identity\ndocument must match the one specified by this field.\n"
                },
                "boundResourceGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the virtual\nmachines that can perform the login operation that they be associated with\nthe resource group that matches the value specified by this field.\n"
                },
                "boundScaleSets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the virtual\nmachines that can perform the login operation that they must match the scale set\nspecified by this field.\n"
                },
                "boundServicePrincipalIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the\nservice principals that can perform the login operation that they should be possess\nthe ids specified by this field.\n"
                },
                "boundSubscriptionIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the subscriptions\nthat can perform the login operation to ones which  matches the value specified by this\nfield.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role.\n",
                    "willReplaceOnChanges": true
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The [maximum number](https://www.vaultproject.io/api-docs/azure#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "requiredInputs": [
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Unique name of the auth backend to configure.\n",
                        "willReplaceOnChanges": true
                    },
                    "boundGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the groups\nthat can perform the login operation that they should be using the group\nID specified by this field.\n"
                    },
                    "boundLocations": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the virtual machines\nthat can perform the login operation that the location in their identity\ndocument must match the one specified by this field.\n"
                    },
                    "boundResourceGroups": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the virtual\nmachines that can perform the login operation that they be associated with\nthe resource group that matches the value specified by this field.\n"
                    },
                    "boundScaleSets": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the virtual\nmachines that can perform the login operation that they must match the scale set\nspecified by this field.\n"
                    },
                    "boundServicePrincipalIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the\nservice principals that can perform the login operation that they should be possess\nthe ids specified by this field.\n"
                    },
                    "boundSubscriptionIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the subscriptions\nthat can perform the login operation to ones which  matches the value specified by this\nfield.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the role.\n",
                        "willReplaceOnChanges": true
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The [maximum number](https://www.vaultproject.io/api-docs/azure#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:azure/backend:Backend": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n### *Vault-1.9 And Above*\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst azure = new vault.azure.Backend(\"azure\", {\n    clientId: \"11111111-2222-3333-4444-333333333333\",\n    clientSecret: \"12345678901234567890\",\n    environment: \"AzurePublicCloud\",\n    subscriptionId: \"11111111-2222-3333-4444-111111111111\",\n    tenantId: \"11111111-2222-3333-4444-222222222222\",\n    useMicrosoftGraphApi: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nazure = vault.azure.Backend(\"azure\",\n    client_id=\"11111111-2222-3333-4444-333333333333\",\n    client_secret=\"12345678901234567890\",\n    environment=\"AzurePublicCloud\",\n    subscription_id=\"11111111-2222-3333-4444-111111111111\",\n    tenant_id=\"11111111-2222-3333-4444-222222222222\",\n    use_microsoft_graph_api=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var azure = new Vault.Azure.Backend(\"azure\", new()\n    {\n        ClientId = \"11111111-2222-3333-4444-333333333333\",\n        ClientSecret = \"12345678901234567890\",\n        Environment = \"AzurePublicCloud\",\n        SubscriptionId = \"11111111-2222-3333-4444-111111111111\",\n        TenantId = \"11111111-2222-3333-4444-222222222222\",\n        UseMicrosoftGraphApi = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/azure\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := azure.NewBackend(ctx, \"azure\", \u0026azure.BackendArgs{\n\t\t\tClientId:             pulumi.String(\"11111111-2222-3333-4444-333333333333\"),\n\t\t\tClientSecret:         pulumi.String(\"12345678901234567890\"),\n\t\t\tEnvironment:          pulumi.String(\"AzurePublicCloud\"),\n\t\t\tSubscriptionId:       pulumi.String(\"11111111-2222-3333-4444-111111111111\"),\n\t\t\tTenantId:             pulumi.String(\"11111111-2222-3333-4444-222222222222\"),\n\t\t\tUseMicrosoftGraphApi: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.azure.Backend;\nimport com.pulumi.vault.azure.BackendArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var azure = new Backend(\"azure\", BackendArgs.builder()        \n            .clientId(\"11111111-2222-3333-4444-333333333333\")\n            .clientSecret(\"12345678901234567890\")\n            .environment(\"AzurePublicCloud\")\n            .subscriptionId(\"11111111-2222-3333-4444-111111111111\")\n            .tenantId(\"11111111-2222-3333-4444-222222222222\")\n            .useMicrosoftGraphApi(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  azure:\n    type: vault:azure:Backend\n    properties:\n      clientId: 11111111-2222-3333-4444-333333333333\n      clientSecret: 12345678901234567890\n      environment: AzurePublicCloud\n      subscriptionId: 11111111-2222-3333-4444-111111111111\n      tenantId: 11111111-2222-3333-4444-222222222222\n      useMicrosoftGraphApi: true\n```\n\n{{% /example %}}\n{{% example %}}\n### *Vault-1.8 And Below*\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst azure = new vault.azure.Backend(\"azure\", {\n    clientId: \"11111111-2222-3333-4444-333333333333\",\n    clientSecret: \"12345678901234567890\",\n    environment: \"AzurePublicCloud\",\n    subscriptionId: \"11111111-2222-3333-4444-111111111111\",\n    tenantId: \"11111111-2222-3333-4444-222222222222\",\n    useMicrosoftGraphApi: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nazure = vault.azure.Backend(\"azure\",\n    client_id=\"11111111-2222-3333-4444-333333333333\",\n    client_secret=\"12345678901234567890\",\n    environment=\"AzurePublicCloud\",\n    subscription_id=\"11111111-2222-3333-4444-111111111111\",\n    tenant_id=\"11111111-2222-3333-4444-222222222222\",\n    use_microsoft_graph_api=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var azure = new Vault.Azure.Backend(\"azure\", new()\n    {\n        ClientId = \"11111111-2222-3333-4444-333333333333\",\n        ClientSecret = \"12345678901234567890\",\n        Environment = \"AzurePublicCloud\",\n        SubscriptionId = \"11111111-2222-3333-4444-111111111111\",\n        TenantId = \"11111111-2222-3333-4444-222222222222\",\n        UseMicrosoftGraphApi = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/azure\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := azure.NewBackend(ctx, \"azure\", \u0026azure.BackendArgs{\n\t\t\tClientId:             pulumi.String(\"11111111-2222-3333-4444-333333333333\"),\n\t\t\tClientSecret:         pulumi.String(\"12345678901234567890\"),\n\t\t\tEnvironment:          pulumi.String(\"AzurePublicCloud\"),\n\t\t\tSubscriptionId:       pulumi.String(\"11111111-2222-3333-4444-111111111111\"),\n\t\t\tTenantId:             pulumi.String(\"11111111-2222-3333-4444-222222222222\"),\n\t\t\tUseMicrosoftGraphApi: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.azure.Backend;\nimport com.pulumi.vault.azure.BackendArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var azure = new Backend(\"azure\", BackendArgs.builder()        \n            .clientId(\"11111111-2222-3333-4444-333333333333\")\n            .clientSecret(\"12345678901234567890\")\n            .environment(\"AzurePublicCloud\")\n            .subscriptionId(\"11111111-2222-3333-4444-111111111111\")\n            .tenantId(\"11111111-2222-3333-4444-222222222222\")\n            .useMicrosoftGraphApi(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  azure:\n    type: vault:azure:Backend\n    properties:\n      clientId: 11111111-2222-3333-4444-333333333333\n      clientSecret: 12345678901234567890\n      environment: AzurePublicCloud\n      subscriptionId: 11111111-2222-3333-4444-111111111111\n      tenantId: 11111111-2222-3333-4444-222222222222\n      useMicrosoftGraphApi: false\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "- The OAuth2 client id to connect to Azure.\n",
                    "secret": true
                },
                "clientSecret": {
                    "type": "string",
                    "description": "- The OAuth2 client secret to connect to Azure.\n",
                    "secret": true
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the backend.\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "environment": {
                    "type": "string",
                    "description": "- The Azure environment.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "path": {
                    "type": "string",
                    "description": "- The unique path this backend should be mounted at. Defaults to `azure`.\n"
                },
                "subscriptionId": {
                    "type": "string",
                    "description": "- The subscription id for the Azure Active Directory.\n",
                    "secret": true
                },
                "tenantId": {
                    "type": "string",
                    "description": "- The tenant id for the Azure Active Directory.\n",
                    "secret": true
                },
                "useMicrosoftGraphApi": {
                    "type": "boolean",
                    "description": "- Indicates whether the secrets engine should use \nthe Microsoft Graph API. This parameter has been deprecated and will be ignored in `vault-1.12+`.\nFor more information, please refer to the [Vault docs](https://developer.hashicorp.com/vault/api-docs/secret/azure#use_microsoft_graph_api)\n"
                }
            },
            "required": [
                "subscriptionId",
                "tenantId",
                "useMicrosoftGraphApi"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "- The OAuth2 client id to connect to Azure.\n",
                    "secret": true
                },
                "clientSecret": {
                    "type": "string",
                    "description": "- The OAuth2 client secret to connect to Azure.\n",
                    "secret": true
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the backend.\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "environment": {
                    "type": "string",
                    "description": "- The Azure environment.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "- The unique path this backend should be mounted at. Defaults to `azure`.\n"
                },
                "subscriptionId": {
                    "type": "string",
                    "description": "- The subscription id for the Azure Active Directory.\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                },
                "tenantId": {
                    "type": "string",
                    "description": "- The tenant id for the Azure Active Directory.\n",
                    "secret": true
                },
                "useMicrosoftGraphApi": {
                    "type": "boolean",
                    "description": "- Indicates whether the secrets engine should use \nthe Microsoft Graph API. This parameter has been deprecated and will be ignored in `vault-1.12+`.\nFor more information, please refer to the [Vault docs](https://developer.hashicorp.com/vault/api-docs/secret/azure#use_microsoft_graph_api)\n"
                }
            },
            "requiredInputs": [
                "subscriptionId",
                "tenantId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Backend resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "- The OAuth2 client id to connect to Azure.\n",
                        "secret": true
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "- The OAuth2 client secret to connect to Azure.\n",
                        "secret": true
                    },
                    "description": {
                        "type": "string",
                        "description": "Human-friendly description of the mount for the backend.\n"
                    },
                    "disableRemount": {
                        "type": "boolean",
                        "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                    },
                    "environment": {
                        "type": "string",
                        "description": "- The Azure environment.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "- The unique path this backend should be mounted at. Defaults to `azure`.\n"
                    },
                    "subscriptionId": {
                        "type": "string",
                        "description": "- The subscription id for the Azure Active Directory.\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "tenantId": {
                        "type": "string",
                        "description": "- The tenant id for the Azure Active Directory.\n",
                        "secret": true
                    },
                    "useMicrosoftGraphApi": {
                        "type": "boolean",
                        "description": "- Indicates whether the secrets engine should use \nthe Microsoft Graph API. This parameter has been deprecated and will be ignored in `vault-1.12+`.\nFor more information, please refer to the [Vault docs](https://developer.hashicorp.com/vault/api-docs/secret/azure#use_microsoft_graph_api)\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:azure/backendRole:BackendRole": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst azure = new vault.azure.Backend(\"azure\", {\n    subscriptionId: _var.subscription_id,\n    tenantId: _var.tenant_id,\n    clientSecret: _var.client_secret,\n    clientId: _var.client_id,\n});\nconst generatedRole = new vault.azure.BackendRole(\"generatedRole\", {\n    backend: azure.path,\n    role: \"generated_role\",\n    ttl: \"300\",\n    maxTtl: \"600\",\n    azureRoles: [{\n        roleName: \"Reader\",\n        scope: `/subscriptions/${_var.subscription_id}/resourceGroups/azure-vault-group`,\n    }],\n});\nconst existingObjectId = new vault.azure.BackendRole(\"existingObjectId\", {\n    backend: azure.path,\n    role: \"existing_object_id\",\n    applicationObjectId: \"11111111-2222-3333-4444-44444444444\",\n    ttl: \"300\",\n    maxTtl: \"600\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nazure = vault.azure.Backend(\"azure\",\n    subscription_id=var[\"subscription_id\"],\n    tenant_id=var[\"tenant_id\"],\n    client_secret=var[\"client_secret\"],\n    client_id=var[\"client_id\"])\ngenerated_role = vault.azure.BackendRole(\"generatedRole\",\n    backend=azure.path,\n    role=\"generated_role\",\n    ttl=\"300\",\n    max_ttl=\"600\",\n    azure_roles=[vault.azure.BackendRoleAzureRoleArgs(\n        role_name=\"Reader\",\n        scope=f\"/subscriptions/{var['subscription_id']}/resourceGroups/azure-vault-group\",\n    )])\nexisting_object_id = vault.azure.BackendRole(\"existingObjectId\",\n    backend=azure.path,\n    role=\"existing_object_id\",\n    application_object_id=\"11111111-2222-3333-4444-44444444444\",\n    ttl=\"300\",\n    max_ttl=\"600\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var azure = new Vault.Azure.Backend(\"azure\", new()\n    {\n        SubscriptionId = @var.Subscription_id,\n        TenantId = @var.Tenant_id,\n        ClientSecret = @var.Client_secret,\n        ClientId = @var.Client_id,\n    });\n\n    var generatedRole = new Vault.Azure.BackendRole(\"generatedRole\", new()\n    {\n        Backend = azure.Path,\n        Role = \"generated_role\",\n        Ttl = \"300\",\n        MaxTtl = \"600\",\n        AzureRoles = new[]\n        {\n            new Vault.Azure.Inputs.BackendRoleAzureRoleArgs\n            {\n                RoleName = \"Reader\",\n                Scope = $\"/subscriptions/{@var.Subscription_id}/resourceGroups/azure-vault-group\",\n            },\n        },\n    });\n\n    var existingObjectId = new Vault.Azure.BackendRole(\"existingObjectId\", new()\n    {\n        Backend = azure.Path,\n        Role = \"existing_object_id\",\n        ApplicationObjectId = \"11111111-2222-3333-4444-44444444444\",\n        Ttl = \"300\",\n        MaxTtl = \"600\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/azure\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tazure, err := azure.NewBackend(ctx, \"azure\", \u0026azure.BackendArgs{\n\t\t\tSubscriptionId: pulumi.Any(_var.Subscription_id),\n\t\t\tTenantId:       pulumi.Any(_var.Tenant_id),\n\t\t\tClientSecret:   pulumi.Any(_var.Client_secret),\n\t\t\tClientId:       pulumi.Any(_var.Client_id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = azure.NewBackendRole(ctx, \"generatedRole\", \u0026azure.BackendRoleArgs{\n\t\t\tBackend: azure.Path,\n\t\t\tRole:    pulumi.String(\"generated_role\"),\n\t\t\tTtl:     pulumi.String(\"300\"),\n\t\t\tMaxTtl:  pulumi.String(\"600\"),\n\t\t\tAzureRoles: azure.BackendRoleAzureRoleArray{\n\t\t\t\t\u0026azure.BackendRoleAzureRoleArgs{\n\t\t\t\t\tRoleName: pulumi.String(\"Reader\"),\n\t\t\t\t\tScope:    pulumi.String(fmt.Sprintf(\"/subscriptions/%v/resourceGroups/azure-vault-group\", _var.Subscription_id)),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = azure.NewBackendRole(ctx, \"existingObjectId\", \u0026azure.BackendRoleArgs{\n\t\t\tBackend:             azure.Path,\n\t\t\tRole:                pulumi.String(\"existing_object_id\"),\n\t\t\tApplicationObjectId: pulumi.String(\"11111111-2222-3333-4444-44444444444\"),\n\t\t\tTtl:                 pulumi.String(\"300\"),\n\t\t\tMaxTtl:              pulumi.String(\"600\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.azure.Backend;\nimport com.pulumi.vault.azure.BackendArgs;\nimport com.pulumi.vault.azure.BackendRole;\nimport com.pulumi.vault.azure.BackendRoleArgs;\nimport com.pulumi.vault.azure.inputs.BackendRoleAzureRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var azure = new Backend(\"azure\", BackendArgs.builder()        \n            .subscriptionId(var_.subscription_id())\n            .tenantId(var_.tenant_id())\n            .clientSecret(var_.client_secret())\n            .clientId(var_.client_id())\n            .build());\n\n        var generatedRole = new BackendRole(\"generatedRole\", BackendRoleArgs.builder()        \n            .backend(azure.path())\n            .role(\"generated_role\")\n            .ttl(300)\n            .maxTtl(600)\n            .azureRoles(BackendRoleAzureRoleArgs.builder()\n                .roleName(\"Reader\")\n                .scope(String.format(\"/subscriptions/%s/resourceGroups/azure-vault-group\", var_.subscription_id()))\n                .build())\n            .build());\n\n        var existingObjectId = new BackendRole(\"existingObjectId\", BackendRoleArgs.builder()        \n            .backend(azure.path())\n            .role(\"existing_object_id\")\n            .applicationObjectId(\"11111111-2222-3333-4444-44444444444\")\n            .ttl(300)\n            .maxTtl(600)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  azure:\n    type: vault:azure:Backend\n    properties:\n      subscriptionId: ${var.subscription_id}\n      tenantId: ${var.tenant_id}\n      clientSecret: ${var.client_secret}\n      clientId: ${var.client_id}\n  generatedRole:\n    type: vault:azure:BackendRole\n    properties:\n      backend: ${azure.path}\n      role: generated_role\n      ttl: 300\n      maxTtl: 600\n      azureRoles:\n        - roleName: Reader\n          scope: /subscriptions/${var.subscription_id}/resourceGroups/azure-vault-group\n  existingObjectId:\n    type: vault:azure:BackendRole\n    properties:\n      backend: ${azure.path}\n      role: existing_object_id\n      applicationObjectId: 11111111-2222-3333-4444-44444444444\n      ttl: 300\n      maxTtl: 600\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "applicationObjectId": {
                    "type": "string",
                    "description": "Application Object ID for an existing service principal that will\nbe used instead of creating dynamic service principals. If present, `azure_roles` will be ignored.\n"
                },
                "azureGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:azure/BackendRoleAzureGroup:BackendRoleAzureGroup"
                    },
                    "description": "List of Azure groups to be assigned to the generated service principal.\n"
                },
                "azureRoles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:azure/BackendRoleAzureRole:BackendRoleAzureRole"
                    },
                    "description": "List of Azure roles to be assigned to the generated service principal.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Path to the mounted Azure auth backend\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the backend.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Specifies the maximum TTL for service principals generated using this role. Accepts time\nsuffixed strings (\"1h\") or an integer number of seconds. Defaults to the system/engine max TTL time.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the Azure role\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Specifies the default TTL for service principals generated using this role.\nAccepts time suffixed strings (\"1h\") or an integer number of seconds. Defaults to the system/engine default TTL time.\n"
                }
            },
            "required": [
                "role"
            ],
            "inputProperties": {
                "applicationObjectId": {
                    "type": "string",
                    "description": "Application Object ID for an existing service principal that will\nbe used instead of creating dynamic service principals. If present, `azure_roles` will be ignored.\n"
                },
                "azureGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:azure/BackendRoleAzureGroup:BackendRoleAzureGroup"
                    },
                    "description": "List of Azure groups to be assigned to the generated service principal.\n"
                },
                "azureRoles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:azure/BackendRoleAzureRole:BackendRoleAzureRole"
                    },
                    "description": "List of Azure roles to be assigned to the generated service principal.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Path to the mounted Azure auth backend\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the backend.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Specifies the maximum TTL for service principals generated using this role. Accepts time\nsuffixed strings (\"1h\") or an integer number of seconds. Defaults to the system/engine max TTL time.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "role": {
                    "type": "string",
                    "description": "Name of the Azure role\n",
                    "willReplaceOnChanges": true
                },
                "ttl": {
                    "type": "string",
                    "description": "Specifies the default TTL for service principals generated using this role.\nAccepts time suffixed strings (\"1h\") or an integer number of seconds. Defaults to the system/engine default TTL time.\n"
                }
            },
            "requiredInputs": [
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering BackendRole resources.\n",
                "properties": {
                    "applicationObjectId": {
                        "type": "string",
                        "description": "Application Object ID for an existing service principal that will\nbe used instead of creating dynamic service principals. If present, `azure_roles` will be ignored.\n"
                    },
                    "azureGroups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:azure/BackendRoleAzureGroup:BackendRoleAzureGroup"
                        },
                        "description": "List of Azure groups to be assigned to the generated service principal.\n"
                    },
                    "azureRoles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:azure/BackendRoleAzureRole:BackendRoleAzureRole"
                        },
                        "description": "List of Azure roles to be assigned to the generated service principal.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "Path to the mounted Azure auth backend\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "Human-friendly description of the mount for the backend.\n"
                    },
                    "maxTtl": {
                        "type": "string",
                        "description": "Specifies the maximum TTL for service principals generated using this role. Accepts time\nsuffixed strings (\"1h\") or an integer number of seconds. Defaults to the system/engine max TTL time.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "role": {
                        "type": "string",
                        "description": "Name of the Azure role\n",
                        "willReplaceOnChanges": true
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Specifies the default TTL for service principals generated using this role.\nAccepts time suffixed strings (\"1h\") or an integer number of seconds. Defaults to the system/engine default TTL time.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:consul/secretBackend:SecretBackend": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n### Creating a standard backend resource:\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst test = new vault.consul.SecretBackend(\"test\", {\n    address: \"127.0.0.1:8500\",\n    description: \"Manages the Consul backend\",\n    path: \"consul\",\n    token: \"4240861b-ce3d-8530-115a-521ff070dd29\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntest = vault.consul.SecretBackend(\"test\",\n    address=\"127.0.0.1:8500\",\n    description=\"Manages the Consul backend\",\n    path=\"consul\",\n    token=\"4240861b-ce3d-8530-115a-521ff070dd29\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Vault.Consul.SecretBackend(\"test\", new()\n    {\n        Address = \"127.0.0.1:8500\",\n        Description = \"Manages the Consul backend\",\n        Path = \"consul\",\n        Token = \"4240861b-ce3d-8530-115a-521ff070dd29\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := consul.NewSecretBackend(ctx, \"test\", \u0026consul.SecretBackendArgs{\n\t\t\tAddress:     pulumi.String(\"127.0.0.1:8500\"),\n\t\t\tDescription: pulumi.String(\"Manages the Consul backend\"),\n\t\t\tPath:        pulumi.String(\"consul\"),\n\t\t\tToken:       pulumi.String(\"4240861b-ce3d-8530-115a-521ff070dd29\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.consul.SecretBackend;\nimport com.pulumi.vault.consul.SecretBackendArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new SecretBackend(\"test\", SecretBackendArgs.builder()        \n            .address(\"127.0.0.1:8500\")\n            .description(\"Manages the Consul backend\")\n            .path(\"consul\")\n            .token(\"4240861b-ce3d-8530-115a-521ff070dd29\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: vault:consul:SecretBackend\n    properties:\n      address: 127.0.0.1:8500\n      description: Manages the Consul backend\n      path: consul\n      token: 4240861b-ce3d-8530-115a-521ff070dd29\n```\n{{% /example %}}\n{{% example %}}\n### Creating a backend resource to bootstrap a new Consul instance:\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst test = new vault.consul.SecretBackend(\"test\", {\n    address: \"127.0.0.1:8500\",\n    bootstrap: true,\n    description: \"Bootstrap the Consul backend\",\n    path: \"consul\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntest = vault.consul.SecretBackend(\"test\",\n    address=\"127.0.0.1:8500\",\n    bootstrap=True,\n    description=\"Bootstrap the Consul backend\",\n    path=\"consul\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Vault.Consul.SecretBackend(\"test\", new()\n    {\n        Address = \"127.0.0.1:8500\",\n        Bootstrap = true,\n        Description = \"Bootstrap the Consul backend\",\n        Path = \"consul\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := consul.NewSecretBackend(ctx, \"test\", \u0026consul.SecretBackendArgs{\n\t\t\tAddress:     pulumi.String(\"127.0.0.1:8500\"),\n\t\t\tBootstrap:   pulumi.Bool(true),\n\t\t\tDescription: pulumi.String(\"Bootstrap the Consul backend\"),\n\t\t\tPath:        pulumi.String(\"consul\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.consul.SecretBackend;\nimport com.pulumi.vault.consul.SecretBackendArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new SecretBackend(\"test\", SecretBackendArgs.builder()        \n            .address(\"127.0.0.1:8500\")\n            .bootstrap(true)\n            .description(\"Bootstrap the Consul backend\")\n            .path(\"consul\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: vault:consul:SecretBackend\n    properties:\n      address: 127.0.0.1:8500\n      bootstrap: true\n      description: Bootstrap the Consul backend\n      path: consul\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nConsul secret backends can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:consul/secretBackend:SecretBackend example consul\n```\n\n ",
            "properties": {
                "address": {
                    "type": "string",
                    "description": "Specifies the address of the Consul instance, provided as \"host:port\" like \"127.0.0.1:8500\".\n"
                },
                "bootstrap": {
                    "type": "boolean",
                    "description": "Denotes that the resource is used to bootstrap the Consul ACL system.\n"
                },
                "caCert": {
                    "type": "string",
                    "description": "CA certificate to use when verifying Consul server certificate, must be x509 PEM encoded.\n"
                },
                "clientCert": {
                    "type": "string",
                    "description": "Client certificate used for Consul's TLS communication, must be x509 PEM encoded and if\nthis is set you need to also set client_key.\n",
                    "secret": true
                },
                "clientKey": {
                    "type": "string",
                    "description": "Client key used for Consul's TLS communication, must be x509 PEM encoded and if this is set\nyou need to also set client_cert.\n",
                    "secret": true
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials issued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the secret backend is local only.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique location this backend should be mounted at. Must not begin or end with a `/`. Defaults\nto `consul`.\n"
                },
                "scheme": {
                    "type": "string",
                    "description": "Specifies the URL scheme to use. Defaults to `http`.\n"
                },
                "token": {
                    "type": "string",
                    "description": "The Consul management token this backend should use to issue new tokens. This field is required\nwhen `bootstrap` is false.\n",
                    "secret": true
                }
            },
            "required": [
                "address"
            ],
            "inputProperties": {
                "address": {
                    "type": "string",
                    "description": "Specifies the address of the Consul instance, provided as \"host:port\" like \"127.0.0.1:8500\".\n"
                },
                "bootstrap": {
                    "type": "boolean",
                    "description": "Denotes that the resource is used to bootstrap the Consul ACL system.\n"
                },
                "caCert": {
                    "type": "string",
                    "description": "CA certificate to use when verifying Consul server certificate, must be x509 PEM encoded.\n"
                },
                "clientCert": {
                    "type": "string",
                    "description": "Client certificate used for Consul's TLS communication, must be x509 PEM encoded and if\nthis is set you need to also set client_key.\n",
                    "secret": true
                },
                "clientKey": {
                    "type": "string",
                    "description": "Client key used for Consul's TLS communication, must be x509 PEM encoded and if this is set\nyou need to also set client_cert.\n",
                    "secret": true
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials issued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the secret backend is local only.\n",
                    "willReplaceOnChanges": true
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "The unique location this backend should be mounted at. Must not begin or end with a `/`. Defaults\nto `consul`.\n"
                },
                "scheme": {
                    "type": "string",
                    "description": "Specifies the URL scheme to use. Defaults to `http`.\n"
                },
                "token": {
                    "type": "string",
                    "description": "The Consul management token this backend should use to issue new tokens. This field is required\nwhen `bootstrap` is false.\n",
                    "secret": true
                }
            },
            "requiredInputs": [
                "address"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackend resources.\n",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "Specifies the address of the Consul instance, provided as \"host:port\" like \"127.0.0.1:8500\".\n"
                    },
                    "bootstrap": {
                        "type": "boolean",
                        "description": "Denotes that the resource is used to bootstrap the Consul ACL system.\n"
                    },
                    "caCert": {
                        "type": "string",
                        "description": "CA certificate to use when verifying Consul server certificate, must be x509 PEM encoded.\n"
                    },
                    "clientCert": {
                        "type": "string",
                        "description": "Client certificate used for Consul's TLS communication, must be x509 PEM encoded and if\nthis is set you need to also set client_key.\n",
                        "secret": true
                    },
                    "clientKey": {
                        "type": "string",
                        "description": "Client key used for Consul's TLS communication, must be x509 PEM encoded and if this is set\nyou need to also set client_cert.\n",
                        "secret": true
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The default TTL for credentials issued by this backend.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A human-friendly description for this backend.\n"
                    },
                    "disableRemount": {
                        "type": "boolean",
                        "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Specifies if the secret backend is local only.\n",
                        "willReplaceOnChanges": true
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "The unique location this backend should be mounted at. Must not begin or end with a `/`. Defaults\nto `consul`.\n"
                    },
                    "scheme": {
                        "type": "string",
                        "description": "Specifies the URL scheme to use. Defaults to `http`.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "The Consul management token this backend should use to issue new tokens. This field is required\nwhen `bootstrap` is false.\n",
                        "secret": true
                    }
                },
                "type": "object"
            }
        },
        "vault:consul/secretBackendRole:SecretBackendRole": {
            "description": "Manages a Consul secrets role for a Consul secrets engine in Vault. Consul secret backends can then issue Consul tokens.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst test = new vault.consul.SecretBackend(\"test\", {\n    path: \"consul\",\n    description: \"Manages the Consul backend\",\n    address: \"127.0.0.1:8500\",\n    token: \"4240861b-ce3d-8530-115a-521ff070dd29\",\n});\nconst example = new vault.consul.SecretBackendRole(\"example\", {\n    backend: test.path,\n    consulPolicies: [\"example-policy\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntest = vault.consul.SecretBackend(\"test\",\n    path=\"consul\",\n    description=\"Manages the Consul backend\",\n    address=\"127.0.0.1:8500\",\n    token=\"4240861b-ce3d-8530-115a-521ff070dd29\")\nexample = vault.consul.SecretBackendRole(\"example\",\n    backend=test.path,\n    consul_policies=[\"example-policy\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Vault.Consul.SecretBackend(\"test\", new()\n    {\n        Path = \"consul\",\n        Description = \"Manages the Consul backend\",\n        Address = \"127.0.0.1:8500\",\n        Token = \"4240861b-ce3d-8530-115a-521ff070dd29\",\n    });\n\n    var example = new Vault.Consul.SecretBackendRole(\"example\", new()\n    {\n        Backend = test.Path,\n        ConsulPolicies = new[]\n        {\n            \"example-policy\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := consul.NewSecretBackend(ctx, \"test\", \u0026consul.SecretBackendArgs{\n\t\t\tPath:        pulumi.String(\"consul\"),\n\t\t\tDescription: pulumi.String(\"Manages the Consul backend\"),\n\t\t\tAddress:     pulumi.String(\"127.0.0.1:8500\"),\n\t\t\tToken:       pulumi.String(\"4240861b-ce3d-8530-115a-521ff070dd29\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = consul.NewSecretBackendRole(ctx, \"example\", \u0026consul.SecretBackendRoleArgs{\n\t\t\tBackend: test.Path,\n\t\t\tConsulPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"example-policy\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.consul.SecretBackend;\nimport com.pulumi.vault.consul.SecretBackendArgs;\nimport com.pulumi.vault.consul.SecretBackendRole;\nimport com.pulumi.vault.consul.SecretBackendRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new SecretBackend(\"test\", SecretBackendArgs.builder()        \n            .path(\"consul\")\n            .description(\"Manages the Consul backend\")\n            .address(\"127.0.0.1:8500\")\n            .token(\"4240861b-ce3d-8530-115a-521ff070dd29\")\n            .build());\n\n        var example = new SecretBackendRole(\"example\", SecretBackendRoleArgs.builder()        \n            .backend(test.path())\n            .consulPolicies(\"example-policy\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: vault:consul:SecretBackend\n    properties:\n      path: consul\n      description: Manages the Consul backend\n      address: 127.0.0.1:8500\n      token: 4240861b-ce3d-8530-115a-521ff070dd29\n  example:\n    type: vault:consul:SecretBackendRole\n    properties:\n      backend: ${test.path}\n      consulPolicies:\n        - example-policy\n```\n{{% /example %}}\n{{% /examples %}}\n## Note About Required Arguments\n\n*At least one* of the four arguments `consul_policies`, `consul_roles`, `service_identities`, or\n`node_identities` is required for a token. If desired, any combination of the four arguments up-to and\nincluding all four, is valid.\n\n\n## Import\n\nConsul secret backend roles can be imported using the `backend`, `/roles/`, and the `name` e.g.\n\n```sh\n $ pulumi import vault:consul/secretBackendRole:SecretBackendRole example consul/roles/my-role\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of an existing Consul secrets backend mount. Must not begin or end with a `/`. One of `path` or `backend` is required.\n"
                },
                "consulNamespace": {
                    "type": "string",
                    "description": "The Consul namespace that the token will be created in.\nApplicable for Vault 1.10+ and Consul 1.7+\".\n"
                },
                "consulPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "\u003csup\u003e\u003ca href=\"#note-about-required-arguments\"\u003eSEE NOTE\u003c/a\u003e\u003c/sup\u003e The list of Consul ACL policies to associate with these roles.\n"
                },
                "consulRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "\u003csup\u003e\u003ca href=\"#note-about-required-arguments\"\u003eSEE NOTE\u003c/a\u003e\u003c/sup\u003e Set of Consul roles to attach to the token.\nApplicable for Vault 1.10+ with Consul 1.5+.\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Indicates that the token should not be replicated globally and instead be local to the current datacenter.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "Maximum TTL for leases associated with this role, in seconds.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Consul secrets engine role to create.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "nodeIdentities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "\u003csup\u003e\u003ca href=\"#note-about-required-arguments\"\u003eSEE NOTE\u003c/a\u003e\u003c/sup\u003e Set of Consul node\nidentities to attach to the token. Applicable for Vault 1.11+ with Consul 1.8+.\n"
                },
                "partition": {
                    "type": "string",
                    "description": "The admin partition that the token will be created in.\nApplicable for Vault 1.10+ and Consul 1.11+\".\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of Consul ACL policies to associate with these roles.\n**NOTE:** The new parameter `consul_policies` should be used in favor of this. This parameter,\n`policies`, remains supported for legacy users, but Vault has deprecated this field.\n"
                },
                "serviceIdentities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "\u003csup\u003e\u003ca href=\"#note-about-required-arguments\"\u003eSEE NOTE\u003c/a\u003e\u003c/sup\u003e Set of Consul\nservice identities to attach to the token. Applicable for Vault 1.11+ with Consul 1.5+.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "Specifies the type of token to create when using this role. Valid values are \"client\" or \"management\".\n*Deprecated: Consul 1.11 and later removed the legacy ACL system which supported this field.*\n",
                    "deprecationMessage": "Consul 1.11 and later removed the legacy ACL system which supported this field."
                },
                "ttl": {
                    "type": "integer",
                    "description": "Specifies the TTL for this role.\n"
                }
            },
            "required": [
                "consulNamespace",
                "name",
                "partition"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of an existing Consul secrets backend mount. Must not begin or end with a `/`. One of `path` or `backend` is required.\n",
                    "willReplaceOnChanges": true
                },
                "consulNamespace": {
                    "type": "string",
                    "description": "The Consul namespace that the token will be created in.\nApplicable for Vault 1.10+ and Consul 1.7+\".\n"
                },
                "consulPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "\u003csup\u003e\u003ca href=\"#note-about-required-arguments\"\u003eSEE NOTE\u003c/a\u003e\u003c/sup\u003e The list of Consul ACL policies to associate with these roles.\n"
                },
                "consulRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "\u003csup\u003e\u003ca href=\"#note-about-required-arguments\"\u003eSEE NOTE\u003c/a\u003e\u003c/sup\u003e Set of Consul roles to attach to the token.\nApplicable for Vault 1.10+ with Consul 1.5+.\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Indicates that the token should not be replicated globally and instead be local to the current datacenter.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "Maximum TTL for leases associated with this role, in seconds.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Consul secrets engine role to create.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "nodeIdentities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "\u003csup\u003e\u003ca href=\"#note-about-required-arguments\"\u003eSEE NOTE\u003c/a\u003e\u003c/sup\u003e Set of Consul node\nidentities to attach to the token. Applicable for Vault 1.11+ with Consul 1.8+.\n"
                },
                "partition": {
                    "type": "string",
                    "description": "The admin partition that the token will be created in.\nApplicable for Vault 1.10+ and Consul 1.11+\".\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of Consul ACL policies to associate with these roles.\n**NOTE:** The new parameter `consul_policies` should be used in favor of this. This parameter,\n`policies`, remains supported for legacy users, but Vault has deprecated this field.\n"
                },
                "serviceIdentities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "\u003csup\u003e\u003ca href=\"#note-about-required-arguments\"\u003eSEE NOTE\u003c/a\u003e\u003c/sup\u003e Set of Consul\nservice identities to attach to the token. Applicable for Vault 1.11+ with Consul 1.5+.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "Specifies the type of token to create when using this role. Valid values are \"client\" or \"management\".\n*Deprecated: Consul 1.11 and later removed the legacy ACL system which supported this field.*\n",
                    "deprecationMessage": "Consul 1.11 and later removed the legacy ACL system which supported this field."
                },
                "ttl": {
                    "type": "integer",
                    "description": "Specifies the TTL for this role.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The unique name of an existing Consul secrets backend mount. Must not begin or end with a `/`. One of `path` or `backend` is required.\n",
                        "willReplaceOnChanges": true
                    },
                    "consulNamespace": {
                        "type": "string",
                        "description": "The Consul namespace that the token will be created in.\nApplicable for Vault 1.10+ and Consul 1.7+\".\n"
                    },
                    "consulPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "\u003csup\u003e\u003ca href=\"#note-about-required-arguments\"\u003eSEE NOTE\u003c/a\u003e\u003c/sup\u003e The list of Consul ACL policies to associate with these roles.\n"
                    },
                    "consulRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "\u003csup\u003e\u003ca href=\"#note-about-required-arguments\"\u003eSEE NOTE\u003c/a\u003e\u003c/sup\u003e Set of Consul roles to attach to the token.\nApplicable for Vault 1.10+ with Consul 1.5+.\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Indicates that the token should not be replicated globally and instead be local to the current datacenter.\n"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "Maximum TTL for leases associated with this role, in seconds.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Consul secrets engine role to create.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "nodeIdentities": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "\u003csup\u003e\u003ca href=\"#note-about-required-arguments\"\u003eSEE NOTE\u003c/a\u003e\u003c/sup\u003e Set of Consul node\nidentities to attach to the token. Applicable for Vault 1.11+ with Consul 1.8+.\n"
                    },
                    "partition": {
                        "type": "string",
                        "description": "The admin partition that the token will be created in.\nApplicable for Vault 1.10+ and Consul 1.11+\".\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of Consul ACL policies to associate with these roles.\n**NOTE:** The new parameter `consul_policies` should be used in favor of this. This parameter,\n`policies`, remains supported for legacy users, but Vault has deprecated this field.\n"
                    },
                    "serviceIdentities": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "\u003csup\u003e\u003ca href=\"#note-about-required-arguments\"\u003eSEE NOTE\u003c/a\u003e\u003c/sup\u003e Set of Consul\nservice identities to attach to the token. Applicable for Vault 1.11+ with Consul 1.5+.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "Specifies the type of token to create when using this role. Valid values are \"client\" or \"management\".\n*Deprecated: Consul 1.11 and later removed the legacy ACL system which supported this field.*\n",
                        "deprecationMessage": "Consul 1.11 and later removed the legacy ACL system which supported this field."
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "Specifies the TTL for this role.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:database/secretBackendConnection:SecretBackendConnection": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst db = new vault.Mount(\"db\", {\n    path: \"postgres\",\n    type: \"database\",\n});\nconst postgres = new vault.database.SecretBackendConnection(\"postgres\", {\n    backend: db.path,\n    allowedRoles: [\n        \"dev\",\n        \"prod\",\n    ],\n    postgresql: {\n        connectionUrl: \"postgres://username:password@host:port/database\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ndb = vault.Mount(\"db\",\n    path=\"postgres\",\n    type=\"database\")\npostgres = vault.database.SecretBackendConnection(\"postgres\",\n    backend=db.path,\n    allowed_roles=[\n        \"dev\",\n        \"prod\",\n    ],\n    postgresql=vault.database.SecretBackendConnectionPostgresqlArgs(\n        connection_url=\"postgres://username:password@host:port/database\",\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var db = new Vault.Mount(\"db\", new()\n    {\n        Path = \"postgres\",\n        Type = \"database\",\n    });\n\n    var postgres = new Vault.Database.SecretBackendConnection(\"postgres\", new()\n    {\n        Backend = db.Path,\n        AllowedRoles = new[]\n        {\n            \"dev\",\n            \"prod\",\n        },\n        Postgresql = new Vault.Database.Inputs.SecretBackendConnectionPostgresqlArgs\n        {\n            ConnectionUrl = \"postgres://username:password@host:port/database\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/database\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdb, err := vault.NewMount(ctx, \"db\", \u0026vault.MountArgs{\n\t\t\tPath: pulumi.String(\"postgres\"),\n\t\t\tType: pulumi.String(\"database\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = database.NewSecretBackendConnection(ctx, \"postgres\", \u0026database.SecretBackendConnectionArgs{\n\t\t\tBackend: db.Path,\n\t\t\tAllowedRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t\tPostgresql: \u0026database.SecretBackendConnectionPostgresqlArgs{\n\t\t\t\tConnectionUrl: pulumi.String(\"postgres://username:password@host:port/database\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Mount;\nimport com.pulumi.vault.MountArgs;\nimport com.pulumi.vault.database.SecretBackendConnection;\nimport com.pulumi.vault.database.SecretBackendConnectionArgs;\nimport com.pulumi.vault.database.inputs.SecretBackendConnectionPostgresqlArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var db = new Mount(\"db\", MountArgs.builder()        \n            .path(\"postgres\")\n            .type(\"database\")\n            .build());\n\n        var postgres = new SecretBackendConnection(\"postgres\", SecretBackendConnectionArgs.builder()        \n            .backend(db.path())\n            .allowedRoles(            \n                \"dev\",\n                \"prod\")\n            .postgresql(SecretBackendConnectionPostgresqlArgs.builder()\n                .connectionUrl(\"postgres://username:password@host:port/database\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  db:\n    type: vault:Mount\n    properties:\n      path: postgres\n      type: database\n  postgres:\n    type: vault:database:SecretBackendConnection\n    properties:\n      backend: ${db.path}\n      allowedRoles:\n        - dev\n        - prod\n      postgresql:\n        connectionUrl: postgres://username:password@host:port/database\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nDatabase secret backend connections can be imported using the `backend`, `/config/`, and the `name` e.g.\n\n```sh\n $ pulumi import vault:database/secretBackendConnection:SecretBackendConnection example postgres/config/postgres\n```\n\n ",
            "properties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of roles that are allowed to use this\nconnection.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique name of the Vault mount to configure.\n"
                },
                "cassandra": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionCassandra:SecretBackendConnectionCassandra",
                    "description": "A nested block containing configuration options for Cassandra connections.\n"
                },
                "couchbase": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionCouchbase:SecretBackendConnectionCouchbase",
                    "description": "A nested block containing configuration options for Couchbase connections.\n"
                },
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n"
                },
                "elasticsearch": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionElasticsearch:SecretBackendConnectionElasticsearch",
                    "description": "A nested block containing configuration options for Elasticsearch connections.\n"
                },
                "hana": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionHana:SecretBackendConnectionHana",
                    "description": "A nested block containing configuration options for SAP HanaDB connections.\n"
                },
                "influxdb": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionInfluxdb:SecretBackendConnectionInfluxdb",
                    "description": "A nested block containing configuration options for InfluxDB connections.\n"
                },
                "mongodb": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMongodb:SecretBackendConnectionMongodb",
                    "description": "A nested block containing configuration options for MongoDB connections.\n"
                },
                "mongodbatlas": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMongodbatlas:SecretBackendConnectionMongodbatlas",
                    "description": "A nested block containing configuration options for MongoDB Atlas connections.\n"
                },
                "mssql": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMssql:SecretBackendConnectionMssql",
                    "description": "A nested block containing configuration options for MSSQL connections.\n"
                },
                "mysql": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysql:SecretBackendConnectionMysql",
                    "description": "A nested block containing configuration options for MySQL connections.\n"
                },
                "mysqlAurora": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysqlAurora:SecretBackendConnectionMysqlAurora",
                    "description": "A nested block containing configuration options for Aurora MySQL connections.\n"
                },
                "mysqlLegacy": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysqlLegacy:SecretBackendConnectionMysqlLegacy",
                    "description": "A nested block containing configuration options for legacy MySQL connections.\n"
                },
                "mysqlRds": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysqlRds:SecretBackendConnectionMysqlRds",
                    "description": "A nested block containing configuration options for RDS MySQL connections.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to give the database connection.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n"
                },
                "oracle": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionOracle:SecretBackendConnectionOracle",
                    "description": "A nested block containing configuration options for Oracle connections.\n"
                },
                "pluginName": {
                    "type": "string",
                    "description": "Specifies the name of the plugin to use.\n"
                },
                "postgresql": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionPostgresql:SecretBackendConnectionPostgresql",
                    "description": "A nested block containing configuration options for PostgreSQL connections.\n"
                },
                "redis": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionRedis:SecretBackendConnectionRedis",
                    "description": "A nested block containing configuration options for Redis connections.\n"
                },
                "redisElasticache": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionRedisElasticache:SecretBackendConnectionRedisElasticache",
                    "description": "A nested block containing configuration options for Redis ElastiCache connections.\n"
                },
                "redshift": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionRedshift:SecretBackendConnectionRedshift",
                    "description": "Connection parameters for the redshift-database-plugin plugin.\n"
                },
                "rootRotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of database statements to be executed to rotate the root user's credentials.\n"
                },
                "snowflake": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionSnowflake:SecretBackendConnectionSnowflake",
                    "description": "A nested block containing configuration options for Snowflake connections.\n"
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Whether the connection should be verified on\ninitial configuration or not.\n"
                }
            },
            "required": [
                "backend",
                "name",
                "pluginName"
            ],
            "inputProperties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of roles that are allowed to use this\nconnection.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique name of the Vault mount to configure.\n",
                    "willReplaceOnChanges": true
                },
                "cassandra": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionCassandra:SecretBackendConnectionCassandra",
                    "description": "A nested block containing configuration options for Cassandra connections.\n"
                },
                "couchbase": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionCouchbase:SecretBackendConnectionCouchbase",
                    "description": "A nested block containing configuration options for Couchbase connections.\n"
                },
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n"
                },
                "elasticsearch": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionElasticsearch:SecretBackendConnectionElasticsearch",
                    "description": "A nested block containing configuration options for Elasticsearch connections.\n"
                },
                "hana": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionHana:SecretBackendConnectionHana",
                    "description": "A nested block containing configuration options for SAP HanaDB connections.\n"
                },
                "influxdb": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionInfluxdb:SecretBackendConnectionInfluxdb",
                    "description": "A nested block containing configuration options for InfluxDB connections.\n"
                },
                "mongodb": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMongodb:SecretBackendConnectionMongodb",
                    "description": "A nested block containing configuration options for MongoDB connections.\n"
                },
                "mongodbatlas": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMongodbatlas:SecretBackendConnectionMongodbatlas",
                    "description": "A nested block containing configuration options for MongoDB Atlas connections.\n"
                },
                "mssql": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMssql:SecretBackendConnectionMssql",
                    "description": "A nested block containing configuration options for MSSQL connections.\n"
                },
                "mysql": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysql:SecretBackendConnectionMysql",
                    "description": "A nested block containing configuration options for MySQL connections.\n"
                },
                "mysqlAurora": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysqlAurora:SecretBackendConnectionMysqlAurora",
                    "description": "A nested block containing configuration options for Aurora MySQL connections.\n"
                },
                "mysqlLegacy": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysqlLegacy:SecretBackendConnectionMysqlLegacy",
                    "description": "A nested block containing configuration options for legacy MySQL connections.\n"
                },
                "mysqlRds": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysqlRds:SecretBackendConnectionMysqlRds",
                    "description": "A nested block containing configuration options for RDS MySQL connections.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to give the database connection.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "oracle": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionOracle:SecretBackendConnectionOracle",
                    "description": "A nested block containing configuration options for Oracle connections.\n"
                },
                "pluginName": {
                    "type": "string",
                    "description": "Specifies the name of the plugin to use.\n"
                },
                "postgresql": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionPostgresql:SecretBackendConnectionPostgresql",
                    "description": "A nested block containing configuration options for PostgreSQL connections.\n"
                },
                "redis": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionRedis:SecretBackendConnectionRedis",
                    "description": "A nested block containing configuration options for Redis connections.\n"
                },
                "redisElasticache": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionRedisElasticache:SecretBackendConnectionRedisElasticache",
                    "description": "A nested block containing configuration options for Redis ElastiCache connections.\n"
                },
                "redshift": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionRedshift:SecretBackendConnectionRedshift",
                    "description": "Connection parameters for the redshift-database-plugin plugin.\n"
                },
                "rootRotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of database statements to be executed to rotate the root user's credentials.\n"
                },
                "snowflake": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionSnowflake:SecretBackendConnectionSnowflake",
                    "description": "A nested block containing configuration options for Snowflake connections.\n"
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Whether the connection should be verified on\ninitial configuration or not.\n"
                }
            },
            "requiredInputs": [
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendConnection resources.\n",
                "properties": {
                    "allowedRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of roles that are allowed to use this\nconnection.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The unique name of the Vault mount to configure.\n",
                        "willReplaceOnChanges": true
                    },
                    "cassandra": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionCassandra:SecretBackendConnectionCassandra",
                        "description": "A nested block containing configuration options for Cassandra connections.\n"
                    },
                    "couchbase": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionCouchbase:SecretBackendConnectionCouchbase",
                        "description": "A nested block containing configuration options for Couchbase connections.\n"
                    },
                    "data": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n"
                    },
                    "elasticsearch": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionElasticsearch:SecretBackendConnectionElasticsearch",
                        "description": "A nested block containing configuration options for Elasticsearch connections.\n"
                    },
                    "hana": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionHana:SecretBackendConnectionHana",
                        "description": "A nested block containing configuration options for SAP HanaDB connections.\n"
                    },
                    "influxdb": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionInfluxdb:SecretBackendConnectionInfluxdb",
                        "description": "A nested block containing configuration options for InfluxDB connections.\n"
                    },
                    "mongodb": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionMongodb:SecretBackendConnectionMongodb",
                        "description": "A nested block containing configuration options for MongoDB connections.\n"
                    },
                    "mongodbatlas": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionMongodbatlas:SecretBackendConnectionMongodbatlas",
                        "description": "A nested block containing configuration options for MongoDB Atlas connections.\n"
                    },
                    "mssql": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionMssql:SecretBackendConnectionMssql",
                        "description": "A nested block containing configuration options for MSSQL connections.\n"
                    },
                    "mysql": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionMysql:SecretBackendConnectionMysql",
                        "description": "A nested block containing configuration options for MySQL connections.\n"
                    },
                    "mysqlAurora": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionMysqlAurora:SecretBackendConnectionMysqlAurora",
                        "description": "A nested block containing configuration options for Aurora MySQL connections.\n"
                    },
                    "mysqlLegacy": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionMysqlLegacy:SecretBackendConnectionMysqlLegacy",
                        "description": "A nested block containing configuration options for legacy MySQL connections.\n"
                    },
                    "mysqlRds": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionMysqlRds:SecretBackendConnectionMysqlRds",
                        "description": "A nested block containing configuration options for RDS MySQL connections.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name to give the database connection.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "oracle": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionOracle:SecretBackendConnectionOracle",
                        "description": "A nested block containing configuration options for Oracle connections.\n"
                    },
                    "pluginName": {
                        "type": "string",
                        "description": "Specifies the name of the plugin to use.\n"
                    },
                    "postgresql": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionPostgresql:SecretBackendConnectionPostgresql",
                        "description": "A nested block containing configuration options for PostgreSQL connections.\n"
                    },
                    "redis": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionRedis:SecretBackendConnectionRedis",
                        "description": "A nested block containing configuration options for Redis connections.\n"
                    },
                    "redisElasticache": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionRedisElasticache:SecretBackendConnectionRedisElasticache",
                        "description": "A nested block containing configuration options for Redis ElastiCache connections.\n"
                    },
                    "redshift": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionRedshift:SecretBackendConnectionRedshift",
                        "description": "Connection parameters for the redshift-database-plugin plugin.\n"
                    },
                    "rootRotationStatements": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of database statements to be executed to rotate the root user's credentials.\n"
                    },
                    "snowflake": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionSnowflake:SecretBackendConnectionSnowflake",
                        "description": "A nested block containing configuration options for Snowflake connections.\n"
                    },
                    "verifyConnection": {
                        "type": "boolean",
                        "description": "Whether the connection should be verified on\ninitial configuration or not.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:database/secretBackendRole:SecretBackendRole": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst db = new vault.Mount(\"db\", {\n    path: \"postgres\",\n    type: \"database\",\n});\nconst postgres = new vault.database.SecretBackendConnection(\"postgres\", {\n    backend: db.path,\n    allowedRoles: [\n        \"dev\",\n        \"prod\",\n    ],\n    postgresql: {\n        connectionUrl: \"postgres://username:password@host:port/database\",\n    },\n});\nconst role = new vault.database.SecretBackendRole(\"role\", {\n    backend: db.path,\n    dbName: postgres.name,\n    creationStatements: [\"CREATE ROLE \\\"{{name}}\\\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}';\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ndb = vault.Mount(\"db\",\n    path=\"postgres\",\n    type=\"database\")\npostgres = vault.database.SecretBackendConnection(\"postgres\",\n    backend=db.path,\n    allowed_roles=[\n        \"dev\",\n        \"prod\",\n    ],\n    postgresql=vault.database.SecretBackendConnectionPostgresqlArgs(\n        connection_url=\"postgres://username:password@host:port/database\",\n    ))\nrole = vault.database.SecretBackendRole(\"role\",\n    backend=db.path,\n    db_name=postgres.name,\n    creation_statements=[\"CREATE ROLE \\\"{{name}}\\\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}';\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var db = new Vault.Mount(\"db\", new()\n    {\n        Path = \"postgres\",\n        Type = \"database\",\n    });\n\n    var postgres = new Vault.Database.SecretBackendConnection(\"postgres\", new()\n    {\n        Backend = db.Path,\n        AllowedRoles = new[]\n        {\n            \"dev\",\n            \"prod\",\n        },\n        Postgresql = new Vault.Database.Inputs.SecretBackendConnectionPostgresqlArgs\n        {\n            ConnectionUrl = \"postgres://username:password@host:port/database\",\n        },\n    });\n\n    var role = new Vault.Database.SecretBackendRole(\"role\", new()\n    {\n        Backend = db.Path,\n        DbName = postgres.Name,\n        CreationStatements = new[]\n        {\n            \"CREATE ROLE \\\"{{name}}\\\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}';\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/database\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdb, err := vault.NewMount(ctx, \"db\", \u0026vault.MountArgs{\n\t\t\tPath: pulumi.String(\"postgres\"),\n\t\t\tType: pulumi.String(\"database\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpostgres, err := database.NewSecretBackendConnection(ctx, \"postgres\", \u0026database.SecretBackendConnectionArgs{\n\t\t\tBackend: db.Path,\n\t\t\tAllowedRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t\tPostgresql: \u0026database.SecretBackendConnectionPostgresqlArgs{\n\t\t\t\tConnectionUrl: pulumi.String(\"postgres://username:password@host:port/database\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = database.NewSecretBackendRole(ctx, \"role\", \u0026database.SecretBackendRoleArgs{\n\t\t\tBackend: db.Path,\n\t\t\tDbName:  postgres.Name,\n\t\t\tCreationStatements: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"CREATE ROLE \\\"{{name}}\\\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}';\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Mount;\nimport com.pulumi.vault.MountArgs;\nimport com.pulumi.vault.database.SecretBackendConnection;\nimport com.pulumi.vault.database.SecretBackendConnectionArgs;\nimport com.pulumi.vault.database.inputs.SecretBackendConnectionPostgresqlArgs;\nimport com.pulumi.vault.database.SecretBackendRole;\nimport com.pulumi.vault.database.SecretBackendRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var db = new Mount(\"db\", MountArgs.builder()        \n            .path(\"postgres\")\n            .type(\"database\")\n            .build());\n\n        var postgres = new SecretBackendConnection(\"postgres\", SecretBackendConnectionArgs.builder()        \n            .backend(db.path())\n            .allowedRoles(            \n                \"dev\",\n                \"prod\")\n            .postgresql(SecretBackendConnectionPostgresqlArgs.builder()\n                .connectionUrl(\"postgres://username:password@host:port/database\")\n                .build())\n            .build());\n\n        var role = new SecretBackendRole(\"role\", SecretBackendRoleArgs.builder()        \n            .backend(db.path())\n            .dbName(postgres.name())\n            .creationStatements(\"CREATE ROLE \\\"{{name}}\\\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}';\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  db:\n    type: vault:Mount\n    properties:\n      path: postgres\n      type: database\n  postgres:\n    type: vault:database:SecretBackendConnection\n    properties:\n      backend: ${db.path}\n      allowedRoles:\n        - dev\n        - prod\n      postgresql:\n        connectionUrl: postgres://username:password@host:port/database\n  role:\n    type: vault:database:SecretBackendRole\n    properties:\n      backend: ${db.path}\n      dbName: ${postgres.name}\n      creationStatements:\n        - CREATE ROLE \"{{name}}\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}';\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nDatabase secret backend roles can be imported using the `backend`, `/roles/`, and the `name` e.g.\n\n```sh\n $ pulumi import vault:database/secretBackendRole:SecretBackendRole example postgres/roles/my-role\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of the Vault mount to configure.\n"
                },
                "creationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\ncreating a user.\n"
                },
                "dbName": {
                    "type": "string",
                    "description": "The unique name of the database connection to use for\nthe role.\n"
                },
                "defaultTtl": {
                    "type": "integer",
                    "description": "The default number of seconds for leases for this\nrole.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum number of seconds for leases for this\nrole.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to give the role.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n"
                },
                "renewStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\nrenewing a user.\n"
                },
                "revocationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\nrevoking a user.\n"
                },
                "rollbackStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\nrolling back creation due to an error.\n"
                }
            },
            "required": [
                "backend",
                "creationStatements",
                "dbName",
                "name"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of the Vault mount to configure.\n",
                    "willReplaceOnChanges": true
                },
                "creationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\ncreating a user.\n"
                },
                "dbName": {
                    "type": "string",
                    "description": "The unique name of the database connection to use for\nthe role.\n",
                    "willReplaceOnChanges": true
                },
                "defaultTtl": {
                    "type": "integer",
                    "description": "The default number of seconds for leases for this\nrole.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum number of seconds for leases for this\nrole.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to give the role.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "renewStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\nrenewing a user.\n"
                },
                "revocationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\nrevoking a user.\n"
                },
                "rollbackStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\nrolling back creation due to an error.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "creationStatements",
                "dbName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The unique name of the Vault mount to configure.\n",
                        "willReplaceOnChanges": true
                    },
                    "creationStatements": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The database statements to execute when\ncreating a user.\n"
                    },
                    "dbName": {
                        "type": "string",
                        "description": "The unique name of the database connection to use for\nthe role.\n",
                        "willReplaceOnChanges": true
                    },
                    "defaultTtl": {
                        "type": "integer",
                        "description": "The default number of seconds for leases for this\nrole.\n"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "The maximum number of seconds for leases for this\nrole.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name to give the role.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "renewStatements": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The database statements to execute when\nrenewing a user.\n"
                    },
                    "revocationStatements": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The database statements to execute when\nrevoking a user.\n"
                    },
                    "rollbackStatements": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The database statements to execute when\nrolling back creation due to an error.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:database/secretBackendStaticRole:SecretBackendStaticRole": {
            "description": "Creates a Database Secret Backend static role in Vault. Database secret backend\nstatic roles can be used to manage 1-to-1 mapping of a Vault Role to a user in a\ndatabase for the database.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst db = new vault.Mount(\"db\", {\n    path: \"postgres\",\n    type: \"database\",\n});\nconst postgres = new vault.database.SecretBackendConnection(\"postgres\", {\n    backend: db.path,\n    allowedRoles: [\"*\"],\n    postgresql: {\n        connectionUrl: \"postgres://username:password@host:port/database\",\n    },\n});\nconst staticRole = new vault.database.SecretBackendStaticRole(\"staticRole\", {\n    backend: db.path,\n    dbName: postgres.name,\n    username: \"example\",\n    rotationPeriod: 3600,\n    rotationStatements: [\"ALTER USER \\\"{{name}}\\\" WITH PASSWORD '{{password}}';\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ndb = vault.Mount(\"db\",\n    path=\"postgres\",\n    type=\"database\")\npostgres = vault.database.SecretBackendConnection(\"postgres\",\n    backend=db.path,\n    allowed_roles=[\"*\"],\n    postgresql=vault.database.SecretBackendConnectionPostgresqlArgs(\n        connection_url=\"postgres://username:password@host:port/database\",\n    ))\nstatic_role = vault.database.SecretBackendStaticRole(\"staticRole\",\n    backend=db.path,\n    db_name=postgres.name,\n    username=\"example\",\n    rotation_period=3600,\n    rotation_statements=[\"ALTER USER \\\"{{name}}\\\" WITH PASSWORD '{{password}}';\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var db = new Vault.Mount(\"db\", new()\n    {\n        Path = \"postgres\",\n        Type = \"database\",\n    });\n\n    var postgres = new Vault.Database.SecretBackendConnection(\"postgres\", new()\n    {\n        Backend = db.Path,\n        AllowedRoles = new[]\n        {\n            \"*\",\n        },\n        Postgresql = new Vault.Database.Inputs.SecretBackendConnectionPostgresqlArgs\n        {\n            ConnectionUrl = \"postgres://username:password@host:port/database\",\n        },\n    });\n\n    var staticRole = new Vault.Database.SecretBackendStaticRole(\"staticRole\", new()\n    {\n        Backend = db.Path,\n        DbName = postgres.Name,\n        Username = \"example\",\n        RotationPeriod = 3600,\n        RotationStatements = new[]\n        {\n            \"ALTER USER \\\"{{name}}\\\" WITH PASSWORD '{{password}}';\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/database\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdb, err := vault.NewMount(ctx, \"db\", \u0026vault.MountArgs{\n\t\t\tPath: pulumi.String(\"postgres\"),\n\t\t\tType: pulumi.String(\"database\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpostgres, err := database.NewSecretBackendConnection(ctx, \"postgres\", \u0026database.SecretBackendConnectionArgs{\n\t\t\tBackend: db.Path,\n\t\t\tAllowedRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"*\"),\n\t\t\t},\n\t\t\tPostgresql: \u0026database.SecretBackendConnectionPostgresqlArgs{\n\t\t\t\tConnectionUrl: pulumi.String(\"postgres://username:password@host:port/database\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = database.NewSecretBackendStaticRole(ctx, \"staticRole\", \u0026database.SecretBackendStaticRoleArgs{\n\t\t\tBackend:        db.Path,\n\t\t\tDbName:         postgres.Name,\n\t\t\tUsername:       pulumi.String(\"example\"),\n\t\t\tRotationPeriod: pulumi.Int(3600),\n\t\t\tRotationStatements: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"ALTER USER \\\"{{name}}\\\" WITH PASSWORD '{{password}}';\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Mount;\nimport com.pulumi.vault.MountArgs;\nimport com.pulumi.vault.database.SecretBackendConnection;\nimport com.pulumi.vault.database.SecretBackendConnectionArgs;\nimport com.pulumi.vault.database.inputs.SecretBackendConnectionPostgresqlArgs;\nimport com.pulumi.vault.database.SecretBackendStaticRole;\nimport com.pulumi.vault.database.SecretBackendStaticRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var db = new Mount(\"db\", MountArgs.builder()        \n            .path(\"postgres\")\n            .type(\"database\")\n            .build());\n\n        var postgres = new SecretBackendConnection(\"postgres\", SecretBackendConnectionArgs.builder()        \n            .backend(db.path())\n            .allowedRoles(\"*\")\n            .postgresql(SecretBackendConnectionPostgresqlArgs.builder()\n                .connectionUrl(\"postgres://username:password@host:port/database\")\n                .build())\n            .build());\n\n        var staticRole = new SecretBackendStaticRole(\"staticRole\", SecretBackendStaticRoleArgs.builder()        \n            .backend(db.path())\n            .dbName(postgres.name())\n            .username(\"example\")\n            .rotationPeriod(\"3600\")\n            .rotationStatements(\"ALTER USER \\\"{{name}}\\\" WITH PASSWORD '{{password}}';\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  db:\n    type: vault:Mount\n    properties:\n      path: postgres\n      type: database\n  postgres:\n    type: vault:database:SecretBackendConnection\n    properties:\n      backend: ${db.path}\n      allowedRoles:\n        - '*'\n      postgresql:\n        connectionUrl: postgres://username:password@host:port/database\n  staticRole:\n    type: vault:database:SecretBackendStaticRole\n    properties:\n      backend: ${db.path}\n      dbName: ${postgres.name}\n      username: example\n      rotationPeriod: 3600\n      rotationStatements:\n        - ALTER USER \"{{name}}\" WITH PASSWORD '{{password}}';\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nDatabase secret backend static roles can be imported using the `backend`, `/static-roles/`, and the `name` e.g.\n\n```sh\n $ pulumi import vault:database/secretBackendStaticRole:SecretBackendStaticRole example postgres/static-roles/my-role\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of the Vault mount to configure.\n"
                },
                "dbName": {
                    "type": "string",
                    "description": "The unique name of the database connection to use for the static role.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to give the static role.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n"
                },
                "rotationPeriod": {
                    "type": "integer",
                    "description": "The amount of time Vault should wait before rotating the password, in seconds.\n"
                },
                "rotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Database statements to execute to rotate the password for the configured database user.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The database username that this static role corresponds to.\n"
                }
            },
            "required": [
                "backend",
                "dbName",
                "name",
                "rotationPeriod",
                "username"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of the Vault mount to configure.\n",
                    "willReplaceOnChanges": true
                },
                "dbName": {
                    "type": "string",
                    "description": "The unique name of the database connection to use for the static role.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to give the static role.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "rotationPeriod": {
                    "type": "integer",
                    "description": "The amount of time Vault should wait before rotating the password, in seconds.\n"
                },
                "rotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Database statements to execute to rotate the password for the configured database user.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The database username that this static role corresponds to.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "backend",
                "dbName",
                "rotationPeriod",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendStaticRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The unique name of the Vault mount to configure.\n",
                        "willReplaceOnChanges": true
                    },
                    "dbName": {
                        "type": "string",
                        "description": "The unique name of the database connection to use for the static role.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name to give the static role.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "rotationPeriod": {
                        "type": "integer",
                        "description": "The amount of time Vault should wait before rotating the password, in seconds.\n"
                    },
                    "rotationStatements": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Database statements to execute to rotate the password for the configured database user.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "The database username that this static role corresponds to.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:database/secretsMount:SecretsMount": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst db = new vault.database.SecretsMount(\"db\", {\n    path: \"db\",\n    mssqls: [{\n        name: \"db1\",\n        username: \"sa\",\n        password: \"super_secret_1\",\n        connectionUrl: \"sqlserver://{{username}}:{{password}}@127.0.0.1:1433\",\n        allowedRoles: [\"dev1\"],\n    }],\n    postgresqls: [{\n        name: \"db2\",\n        username: \"postgres\",\n        password: \"super_secret_2\",\n        connectionUrl: \"postgresql://{{username}}:{{password}}@127.0.0.1:5432/postgres\",\n        verifyConnection: true,\n        allowedRoles: [\"dev2\"],\n    }],\n});\nconst dev1 = new vault.database.SecretBackendRole(\"dev1\", {\n    backend: db.path,\n    dbName: db.mssqls.apply(mssqls =\u003e mssqls?[0]?.name),\n    creationStatements: [\n        \"CREATE LOGIN [{{name}}] WITH PASSWORD = '{{password}}';\",\n        \"CREATE USER [{{name}}] FOR LOGIN [{{name}}];\",\n        \"GRANT SELECT ON SCHEMA::dbo TO [{{name}}];\",\n    ],\n});\nconst dev2 = new vault.database.SecretBackendRole(\"dev2\", {\n    backend: db.path,\n    dbName: db.postgresqls.apply(postgresqls =\u003e postgresqls?[0]?.name),\n    creationStatements: [\n        \"CREATE ROLE \\\"{{name}}\\\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}';\",\n        \"GRANT SELECT ON ALL TABLES IN SCHEMA public TO \\\"{{name}}\\\";\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ndb = vault.database.SecretsMount(\"db\",\n    path=\"db\",\n    mssqls=[vault.database.SecretsMountMssqlArgs(\n        name=\"db1\",\n        username=\"sa\",\n        password=\"super_secret_1\",\n        connection_url=\"sqlserver://{{username}}:{{password}}@127.0.0.1:1433\",\n        allowed_roles=[\"dev1\"],\n    )],\n    postgresqls=[vault.database.SecretsMountPostgresqlArgs(\n        name=\"db2\",\n        username=\"postgres\",\n        password=\"super_secret_2\",\n        connection_url=\"postgresql://{{username}}:{{password}}@127.0.0.1:5432/postgres\",\n        verify_connection=True,\n        allowed_roles=[\"dev2\"],\n    )])\ndev1 = vault.database.SecretBackendRole(\"dev1\",\n    backend=db.path,\n    db_name=db.mssqls[0].name,\n    creation_statements=[\n        \"CREATE LOGIN [{{name}}] WITH PASSWORD = '{{password}}';\",\n        \"CREATE USER [{{name}}] FOR LOGIN [{{name}}];\",\n        \"GRANT SELECT ON SCHEMA::dbo TO [{{name}}];\",\n    ])\ndev2 = vault.database.SecretBackendRole(\"dev2\",\n    backend=db.path,\n    db_name=db.postgresqls[0].name,\n    creation_statements=[\n        \"CREATE ROLE \\\"{{name}}\\\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}';\",\n        \"GRANT SELECT ON ALL TABLES IN SCHEMA public TO \\\"{{name}}\\\";\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var db = new Vault.Database.SecretsMount(\"db\", new()\n    {\n        Path = \"db\",\n        Mssqls = new[]\n        {\n            new Vault.Database.Inputs.SecretsMountMssqlArgs\n            {\n                Name = \"db1\",\n                Username = \"sa\",\n                Password = \"super_secret_1\",\n                ConnectionUrl = \"sqlserver://{{username}}:{{password}}@127.0.0.1:1433\",\n                AllowedRoles = new[]\n                {\n                    \"dev1\",\n                },\n            },\n        },\n        Postgresqls = new[]\n        {\n            new Vault.Database.Inputs.SecretsMountPostgresqlArgs\n            {\n                Name = \"db2\",\n                Username = \"postgres\",\n                Password = \"super_secret_2\",\n                ConnectionUrl = \"postgresql://{{username}}:{{password}}@127.0.0.1:5432/postgres\",\n                VerifyConnection = true,\n                AllowedRoles = new[]\n                {\n                    \"dev2\",\n                },\n            },\n        },\n    });\n\n    var dev1 = new Vault.Database.SecretBackendRole(\"dev1\", new()\n    {\n        Backend = db.Path,\n        DbName = db.Mssqls.Apply(mssqls =\u003e mssqls[0]?.Name),\n        CreationStatements = new[]\n        {\n            \"CREATE LOGIN [{{name}}] WITH PASSWORD = '{{password}}';\",\n            \"CREATE USER [{{name}}] FOR LOGIN [{{name}}];\",\n            \"GRANT SELECT ON SCHEMA::dbo TO [{{name}}];\",\n        },\n    });\n\n    var dev2 = new Vault.Database.SecretBackendRole(\"dev2\", new()\n    {\n        Backend = db.Path,\n        DbName = db.Postgresqls.Apply(postgresqls =\u003e postgresqls[0]?.Name),\n        CreationStatements = new[]\n        {\n            \"CREATE ROLE \\\"{{name}}\\\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}';\",\n            \"GRANT SELECT ON ALL TABLES IN SCHEMA public TO \\\"{{name}}\\\";\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/database\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdb, err := database.NewSecretsMount(ctx, \"db\", \u0026database.SecretsMountArgs{\n\t\t\tPath: pulumi.String(\"db\"),\n\t\t\tMssqls: database.SecretsMountMssqlArray{\n\t\t\t\t\u0026database.SecretsMountMssqlArgs{\n\t\t\t\t\tName:          pulumi.String(\"db1\"),\n\t\t\t\t\tUsername:      pulumi.String(\"sa\"),\n\t\t\t\t\tPassword:      pulumi.String(\"super_secret_1\"),\n\t\t\t\t\tConnectionUrl: pulumi.String(\"sqlserver://{{username}}:{{password}}@127.0.0.1:1433\"),\n\t\t\t\t\tAllowedRoles: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"dev1\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tPostgresqls: database.SecretsMountPostgresqlArray{\n\t\t\t\t\u0026database.SecretsMountPostgresqlArgs{\n\t\t\t\t\tName:             pulumi.String(\"db2\"),\n\t\t\t\t\tUsername:         pulumi.String(\"postgres\"),\n\t\t\t\t\tPassword:         pulumi.String(\"super_secret_2\"),\n\t\t\t\t\tConnectionUrl:    pulumi.String(\"postgresql://{{username}}:{{password}}@127.0.0.1:5432/postgres\"),\n\t\t\t\t\tVerifyConnection: pulumi.Bool(true),\n\t\t\t\t\tAllowedRoles: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"dev2\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = database.NewSecretBackendRole(ctx, \"dev1\", \u0026database.SecretBackendRoleArgs{\n\t\t\tBackend: db.Path,\n\t\t\tDbName: db.Mssqls.ApplyT(func(mssqls []database.SecretsMountMssql) (string, error) {\n\t\t\t\treturn mssqls[0].Name, nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t\tCreationStatements: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"CREATE LOGIN [{{name}}] WITH PASSWORD = '{{password}}';\"),\n\t\t\t\tpulumi.String(\"CREATE USER [{{name}}] FOR LOGIN [{{name}}];\"),\n\t\t\t\tpulumi.String(\"GRANT SELECT ON SCHEMA::dbo TO [{{name}}];\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = database.NewSecretBackendRole(ctx, \"dev2\", \u0026database.SecretBackendRoleArgs{\n\t\t\tBackend: db.Path,\n\t\t\tDbName: db.Postgresqls.ApplyT(func(postgresqls []database.SecretsMountPostgresql) (string, error) {\n\t\t\t\treturn postgresqls[0].Name, nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t\tCreationStatements: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"CREATE ROLE \\\"{{name}}\\\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}';\"),\n\t\t\t\tpulumi.String(\"GRANT SELECT ON ALL TABLES IN SCHEMA public TO \\\"{{name}}\\\";\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.database.SecretsMount;\nimport com.pulumi.vault.database.SecretsMountArgs;\nimport com.pulumi.vault.database.inputs.SecretsMountMssqlArgs;\nimport com.pulumi.vault.database.inputs.SecretsMountPostgresqlArgs;\nimport com.pulumi.vault.database.SecretBackendRole;\nimport com.pulumi.vault.database.SecretBackendRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var db = new SecretsMount(\"db\", SecretsMountArgs.builder()        \n            .path(\"db\")\n            .mssqls(SecretsMountMssqlArgs.builder()\n                .name(\"db1\")\n                .username(\"sa\")\n                .password(\"super_secret_1\")\n                .connectionUrl(\"sqlserver://{{username}}:{{password}}@127.0.0.1:1433\")\n                .allowedRoles(\"dev1\")\n                .build())\n            .postgresqls(SecretsMountPostgresqlArgs.builder()\n                .name(\"db2\")\n                .username(\"postgres\")\n                .password(\"super_secret_2\")\n                .connectionUrl(\"postgresql://{{username}}:{{password}}@127.0.0.1:5432/postgres\")\n                .verifyConnection(true)\n                .allowedRoles(\"dev2\")\n                .build())\n            .build());\n\n        var dev1 = new SecretBackendRole(\"dev1\", SecretBackendRoleArgs.builder()        \n            .backend(db.path())\n            .dbName(db.mssqls().applyValue(mssqls -\u003e mssqls[0].name()))\n            .creationStatements(            \n                \"CREATE LOGIN [{{name}}] WITH PASSWORD = '{{password}}';\",\n                \"CREATE USER [{{name}}] FOR LOGIN [{{name}}];\",\n                \"GRANT SELECT ON SCHEMA::dbo TO [{{name}}];\")\n            .build());\n\n        var dev2 = new SecretBackendRole(\"dev2\", SecretBackendRoleArgs.builder()        \n            .backend(db.path())\n            .dbName(db.postgresqls().applyValue(postgresqls -\u003e postgresqls[0].name()))\n            .creationStatements(            \n                \"CREATE ROLE \\\"{{name}}\\\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}';\",\n                \"GRANT SELECT ON ALL TABLES IN SCHEMA public TO \\\"{{name}}\\\";\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  db:\n    type: vault:database:SecretsMount\n    properties:\n      path: db\n      mssqls:\n        - name: db1\n          username: sa\n          password: super_secret_1\n          connectionUrl: sqlserver://{{username}}:{{password}}@127.0.0.1:1433\n          allowedRoles:\n            - dev1\n      postgresqls:\n        - name: db2\n          username: postgres\n          password: super_secret_2\n          connectionUrl: postgresql://{{username}}:{{password}}@127.0.0.1:5432/postgres\n          verifyConnection: true\n          allowedRoles:\n            - dev2\n  dev1:\n    type: vault:database:SecretBackendRole\n    properties:\n      backend: ${db.path}\n      dbName: ${db.mssqls[0].name}\n      creationStatements:\n        - CREATE LOGIN [{{name}}] WITH PASSWORD = '{{password}}';\n        - CREATE USER [{{name}}] FOR LOGIN [{{name}}];\n        - GRANT SELECT ON SCHEMA::dbo TO [{{name}}];\n  dev2:\n    type: vault:database:SecretBackendRole\n    properties:\n      backend: ${db.path}\n      dbName: ${db.postgresqls[0].name}\n      creationStatements:\n        - CREATE ROLE \"{{name}}\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}';\n        - GRANT SELECT ON ALL TABLES IN SCHEMA public TO \"{{name}}\";\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nDatabase secret backend connections can be imported using the `path` e.g.\n\n```sh\n $ pulumi import vault:database/secretsMount:SecretsMount db db\n```\n\n ",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "Accessor of the mount\n"
                },
                "allowedManagedKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of managed key registry entry names that the mount in question is allowed to access\n"
                },
                "auditNonHmacRequestKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the request data object.\n"
                },
                "auditNonHmacResponseKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the response data object.\n"
                },
                "cassandras": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountCassandra:SecretsMountCassandra"
                    },
                    "description": "A nested block containing configuration options for Cassandra connections.  \n*See Configuration Options for more info*\n"
                },
                "couchbases": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountCouchbase:SecretsMountCouchbase"
                    },
                    "description": "A nested block containing configuration options for Couchbase connections.  \n*See Configuration Options for more info*\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Default lease duration for tokens and secrets in seconds\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount\n"
                },
                "elasticsearches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountElasticsearch:SecretsMountElasticsearch"
                    },
                    "description": "A nested block containing configuration options for Elasticsearch connections.  \n*See Configuration Options for more info*\n"
                },
                "engineCount": {
                    "type": "integer",
                    "description": "The total number of database secrets engines configured.\n"
                },
                "externalEntropyAccess": {
                    "type": "boolean",
                    "description": "Boolean flag that can be explicitly set to true to enable the secrets engine to access Vault's external entropy source\n"
                },
                "hanas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountHana:SecretsMountHana"
                    },
                    "description": "A nested block containing configuration options for SAP HanaDB connections.  \n*See Configuration Options for more info*\n"
                },
                "influxdbs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountInfluxdb:SecretsMountInfluxdb"
                    },
                    "description": "A nested block containing configuration options for InfluxDB connections.  \n*See Configuration Options for more info*\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Boolean flag that can be explicitly set to true to enforce local mount in HA environment\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Maximum possible lease duration for tokens and secrets in seconds\n"
                },
                "mongodbatlas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountMongodbatla:SecretsMountMongodbatla"
                    },
                    "description": "A nested block containing configuration options for MongoDB Atlas connections.  \n*See Configuration Options for more info*\n"
                },
                "mongodbs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountMongodb:SecretsMountMongodb"
                    },
                    "description": "A nested block containing configuration options for MongoDB connections.  \n*See Configuration Options for more info*\n"
                },
                "mssqls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountMssql:SecretsMountMssql"
                    },
                    "description": "A nested block containing configuration options for MSSQL connections.  \n*See Configuration Options for more info*\n"
                },
                "mysqlAuroras": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountMysqlAurora:SecretsMountMysqlAurora"
                    },
                    "description": "A nested block containing configuration options for Aurora MySQL connections.  \n*See Configuration Options for more info*\n"
                },
                "mysqlLegacies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountMysqlLegacy:SecretsMountMysqlLegacy"
                    },
                    "description": "A nested block containing configuration options for legacy MySQL connections.  \n*See Configuration Options for more info*\n"
                },
                "mysqlRds": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountMysqlRd:SecretsMountMysqlRd"
                    },
                    "description": "A nested block containing configuration options for RDS MySQL connections.  \n*See Configuration Options for more info*\n"
                },
                "mysqls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountMysql:SecretsMountMysql"
                    },
                    "description": "A nested block containing configuration options for MySQL connections.  \n*See Configuration Options for more info*\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "Target namespace. (requires Enterprise)\n"
                },
                "options": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies mount type specific options that are passed to the backend\n"
                },
                "oracles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountOracle:SecretsMountOracle"
                    },
                    "description": "A nested block containing configuration options for Oracle connections.  \n*See Configuration Options for more info*\n"
                },
                "path": {
                    "type": "string",
                    "description": "Where the secret backend will be mounted\n"
                },
                "postgresqls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountPostgresql:SecretsMountPostgresql"
                    },
                    "description": "A nested block containing configuration options for PostgreSQL connections.  \n*See Configuration Options for more info*\n"
                },
                "redis": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountRedi:SecretsMountRedi"
                    },
                    "description": "A nested block containing configuration options for Redis connections.  \n*See Configuration Options for more info*\n"
                },
                "redisElasticaches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountRedisElasticach:SecretsMountRedisElasticach"
                    },
                    "description": "A nested block containing configuration options for Redis ElastiCache connections.  \n*See Configuration Options for more info*\n"
                },
                "redshifts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountRedshift:SecretsMountRedshift"
                    },
                    "description": "A nested block containing configuration options for AWS Redshift connections.  \n*See Configuration Options for more info*\n"
                },
                "sealWrap": {
                    "type": "boolean",
                    "description": "Boolean flag that can be explicitly set to true to enable seal wrapping for the mount, causing values stored by the mount to be wrapped by the seal's encryption capability\n"
                },
                "snowflakes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountSnowflake:SecretsMountSnowflake"
                    },
                    "description": "A nested block containing configuration options for Snowflake connections.  \n*See Configuration Options for more info*\n"
                }
            },
            "required": [
                "accessor",
                "auditNonHmacRequestKeys",
                "auditNonHmacResponseKeys",
                "defaultLeaseTtlSeconds",
                "engineCount",
                "maxLeaseTtlSeconds",
                "path",
                "sealWrap"
            ],
            "inputProperties": {
                "allowedManagedKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of managed key registry entry names that the mount in question is allowed to access\n",
                    "willReplaceOnChanges": true
                },
                "auditNonHmacRequestKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the request data object.\n"
                },
                "auditNonHmacResponseKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the response data object.\n"
                },
                "cassandras": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountCassandra:SecretsMountCassandra"
                    },
                    "description": "A nested block containing configuration options for Cassandra connections.  \n*See Configuration Options for more info*\n"
                },
                "couchbases": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountCouchbase:SecretsMountCouchbase"
                    },
                    "description": "A nested block containing configuration options for Couchbase connections.  \n*See Configuration Options for more info*\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Default lease duration for tokens and secrets in seconds\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount\n"
                },
                "elasticsearches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountElasticsearch:SecretsMountElasticsearch"
                    },
                    "description": "A nested block containing configuration options for Elasticsearch connections.  \n*See Configuration Options for more info*\n"
                },
                "externalEntropyAccess": {
                    "type": "boolean",
                    "description": "Boolean flag that can be explicitly set to true to enable the secrets engine to access Vault's external entropy source\n",
                    "willReplaceOnChanges": true
                },
                "hanas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountHana:SecretsMountHana"
                    },
                    "description": "A nested block containing configuration options for SAP HanaDB connections.  \n*See Configuration Options for more info*\n"
                },
                "influxdbs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountInfluxdb:SecretsMountInfluxdb"
                    },
                    "description": "A nested block containing configuration options for InfluxDB connections.  \n*See Configuration Options for more info*\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Boolean flag that can be explicitly set to true to enforce local mount in HA environment\n",
                    "willReplaceOnChanges": true
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Maximum possible lease duration for tokens and secrets in seconds\n"
                },
                "mongodbatlas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountMongodbatla:SecretsMountMongodbatla"
                    },
                    "description": "A nested block containing configuration options for MongoDB Atlas connections.  \n*See Configuration Options for more info*\n"
                },
                "mongodbs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountMongodb:SecretsMountMongodb"
                    },
                    "description": "A nested block containing configuration options for MongoDB connections.  \n*See Configuration Options for more info*\n"
                },
                "mssqls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountMssql:SecretsMountMssql"
                    },
                    "description": "A nested block containing configuration options for MSSQL connections.  \n*See Configuration Options for more info*\n"
                },
                "mysqlAuroras": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountMysqlAurora:SecretsMountMysqlAurora"
                    },
                    "description": "A nested block containing configuration options for Aurora MySQL connections.  \n*See Configuration Options for more info*\n"
                },
                "mysqlLegacies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountMysqlLegacy:SecretsMountMysqlLegacy"
                    },
                    "description": "A nested block containing configuration options for legacy MySQL connections.  \n*See Configuration Options for more info*\n"
                },
                "mysqlRds": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountMysqlRd:SecretsMountMysqlRd"
                    },
                    "description": "A nested block containing configuration options for RDS MySQL connections.  \n*See Configuration Options for more info*\n"
                },
                "mysqls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountMysql:SecretsMountMysql"
                    },
                    "description": "A nested block containing configuration options for MySQL connections.  \n*See Configuration Options for more info*\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "Target namespace. (requires Enterprise)\n",
                    "willReplaceOnChanges": true
                },
                "options": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies mount type specific options that are passed to the backend\n"
                },
                "oracles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountOracle:SecretsMountOracle"
                    },
                    "description": "A nested block containing configuration options for Oracle connections.  \n*See Configuration Options for more info*\n"
                },
                "path": {
                    "type": "string",
                    "description": "Where the secret backend will be mounted\n"
                },
                "postgresqls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountPostgresql:SecretsMountPostgresql"
                    },
                    "description": "A nested block containing configuration options for PostgreSQL connections.  \n*See Configuration Options for more info*\n"
                },
                "redis": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountRedi:SecretsMountRedi"
                    },
                    "description": "A nested block containing configuration options for Redis connections.  \n*See Configuration Options for more info*\n"
                },
                "redisElasticaches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountRedisElasticach:SecretsMountRedisElasticach"
                    },
                    "description": "A nested block containing configuration options for Redis ElastiCache connections.  \n*See Configuration Options for more info*\n"
                },
                "redshifts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountRedshift:SecretsMountRedshift"
                    },
                    "description": "A nested block containing configuration options for AWS Redshift connections.  \n*See Configuration Options for more info*\n"
                },
                "sealWrap": {
                    "type": "boolean",
                    "description": "Boolean flag that can be explicitly set to true to enable seal wrapping for the mount, causing values stored by the mount to be wrapped by the seal's encryption capability\n",
                    "willReplaceOnChanges": true
                },
                "snowflakes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:database/SecretsMountSnowflake:SecretsMountSnowflake"
                    },
                    "description": "A nested block containing configuration options for Snowflake connections.  \n*See Configuration Options for more info*\n"
                }
            },
            "requiredInputs": [
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretsMount resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "Accessor of the mount\n"
                    },
                    "allowedManagedKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of managed key registry entry names that the mount in question is allowed to access\n",
                        "willReplaceOnChanges": true
                    },
                    "auditNonHmacRequestKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the request data object.\n"
                    },
                    "auditNonHmacResponseKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the response data object.\n"
                    },
                    "cassandras": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:database/SecretsMountCassandra:SecretsMountCassandra"
                        },
                        "description": "A nested block containing configuration options for Cassandra connections.  \n*See Configuration Options for more info*\n"
                    },
                    "couchbases": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:database/SecretsMountCouchbase:SecretsMountCouchbase"
                        },
                        "description": "A nested block containing configuration options for Couchbase connections.  \n*See Configuration Options for more info*\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "Default lease duration for tokens and secrets in seconds\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Human-friendly description of the mount\n"
                    },
                    "elasticsearches": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:database/SecretsMountElasticsearch:SecretsMountElasticsearch"
                        },
                        "description": "A nested block containing configuration options for Elasticsearch connections.  \n*See Configuration Options for more info*\n"
                    },
                    "engineCount": {
                        "type": "integer",
                        "description": "The total number of database secrets engines configured.\n"
                    },
                    "externalEntropyAccess": {
                        "type": "boolean",
                        "description": "Boolean flag that can be explicitly set to true to enable the secrets engine to access Vault's external entropy source\n",
                        "willReplaceOnChanges": true
                    },
                    "hanas": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:database/SecretsMountHana:SecretsMountHana"
                        },
                        "description": "A nested block containing configuration options for SAP HanaDB connections.  \n*See Configuration Options for more info*\n"
                    },
                    "influxdbs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:database/SecretsMountInfluxdb:SecretsMountInfluxdb"
                        },
                        "description": "A nested block containing configuration options for InfluxDB connections.  \n*See Configuration Options for more info*\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Boolean flag that can be explicitly set to true to enforce local mount in HA environment\n",
                        "willReplaceOnChanges": true
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "Maximum possible lease duration for tokens and secrets in seconds\n"
                    },
                    "mongodbatlas": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:database/SecretsMountMongodbatla:SecretsMountMongodbatla"
                        },
                        "description": "A nested block containing configuration options for MongoDB Atlas connections.  \n*See Configuration Options for more info*\n"
                    },
                    "mongodbs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:database/SecretsMountMongodb:SecretsMountMongodb"
                        },
                        "description": "A nested block containing configuration options for MongoDB connections.  \n*See Configuration Options for more info*\n"
                    },
                    "mssqls": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:database/SecretsMountMssql:SecretsMountMssql"
                        },
                        "description": "A nested block containing configuration options for MSSQL connections.  \n*See Configuration Options for more info*\n"
                    },
                    "mysqlAuroras": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:database/SecretsMountMysqlAurora:SecretsMountMysqlAurora"
                        },
                        "description": "A nested block containing configuration options for Aurora MySQL connections.  \n*See Configuration Options for more info*\n"
                    },
                    "mysqlLegacies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:database/SecretsMountMysqlLegacy:SecretsMountMysqlLegacy"
                        },
                        "description": "A nested block containing configuration options for legacy MySQL connections.  \n*See Configuration Options for more info*\n"
                    },
                    "mysqlRds": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:database/SecretsMountMysqlRd:SecretsMountMysqlRd"
                        },
                        "description": "A nested block containing configuration options for RDS MySQL connections.  \n*See Configuration Options for more info*\n"
                    },
                    "mysqls": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:database/SecretsMountMysql:SecretsMountMysql"
                        },
                        "description": "A nested block containing configuration options for MySQL connections.  \n*See Configuration Options for more info*\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "Target namespace. (requires Enterprise)\n",
                        "willReplaceOnChanges": true
                    },
                    "options": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Specifies mount type specific options that are passed to the backend\n"
                    },
                    "oracles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:database/SecretsMountOracle:SecretsMountOracle"
                        },
                        "description": "A nested block containing configuration options for Oracle connections.  \n*See Configuration Options for more info*\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Where the secret backend will be mounted\n"
                    },
                    "postgresqls": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:database/SecretsMountPostgresql:SecretsMountPostgresql"
                        },
                        "description": "A nested block containing configuration options for PostgreSQL connections.  \n*See Configuration Options for more info*\n"
                    },
                    "redis": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:database/SecretsMountRedi:SecretsMountRedi"
                        },
                        "description": "A nested block containing configuration options for Redis connections.  \n*See Configuration Options for more info*\n"
                    },
                    "redisElasticaches": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:database/SecretsMountRedisElasticach:SecretsMountRedisElasticach"
                        },
                        "description": "A nested block containing configuration options for Redis ElastiCache connections.  \n*See Configuration Options for more info*\n"
                    },
                    "redshifts": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:database/SecretsMountRedshift:SecretsMountRedshift"
                        },
                        "description": "A nested block containing configuration options for AWS Redshift connections.  \n*See Configuration Options for more info*\n"
                    },
                    "sealWrap": {
                        "type": "boolean",
                        "description": "Boolean flag that can be explicitly set to true to enable seal wrapping for the mount, causing values stored by the mount to be wrapped by the seal's encryption capability\n",
                        "willReplaceOnChanges": true
                    },
                    "snowflakes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:database/SecretsMountSnowflake:SecretsMountSnowflake"
                        },
                        "description": "A nested block containing configuration options for Snowflake connections.  \n*See Configuration Options for more info*\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:gcp/authBackend:AuthBackend": {
            "description": "Provides a resource to configure the [GCP auth backend within Vault](https://www.vaultproject.io/docs/auth/gcp.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as fs from \"fs\";\nimport * as vault from \"@pulumi/vault\";\n\nconst gcp = new vault.gcp.AuthBackend(\"gcp\", {\n    credentials: fs.readFileSync(\"vault-gcp-credentials.json\"),\n    customEndpoint: {\n        api: \"www.googleapis.com\",\n        iam: \"iam.googleapis.com\",\n        crm: \"cloudresourcemanager.googleapis.com\",\n        compute: \"compute.googleapis.com\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ngcp = vault.gcp.AuthBackend(\"gcp\",\n    credentials=(lambda path: open(path).read())(\"vault-gcp-credentials.json\"),\n    custom_endpoint=vault.gcp.AuthBackendCustomEndpointArgs(\n        api=\"www.googleapis.com\",\n        iam=\"iam.googleapis.com\",\n        crm=\"cloudresourcemanager.googleapis.com\",\n        compute=\"compute.googleapis.com\",\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var gcp = new Vault.Gcp.AuthBackend(\"gcp\", new()\n    {\n        Credentials = File.ReadAllText(\"vault-gcp-credentials.json\"),\n        CustomEndpoint = new Vault.Gcp.Inputs.AuthBackendCustomEndpointArgs\n        {\n            Api = \"www.googleapis.com\",\n            Iam = \"iam.googleapis.com\",\n            Crm = \"cloudresourcemanager.googleapis.com\",\n            Compute = \"compute.googleapis.com\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/gcp\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gcp.NewAuthBackend(ctx, \"gcp\", \u0026gcp.AuthBackendArgs{\n\t\t\tCredentials: readFileOrPanic(\"vault-gcp-credentials.json\"),\n\t\t\tCustomEndpoint: \u0026gcp.AuthBackendCustomEndpointArgs{\n\t\t\t\tApi:     pulumi.String(\"www.googleapis.com\"),\n\t\t\t\tIam:     pulumi.String(\"iam.googleapis.com\"),\n\t\t\t\tCrm:     pulumi.String(\"cloudresourcemanager.googleapis.com\"),\n\t\t\t\tCompute: pulumi.String(\"compute.googleapis.com\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.gcp.AuthBackend;\nimport com.pulumi.vault.gcp.AuthBackendArgs;\nimport com.pulumi.vault.gcp.inputs.AuthBackendCustomEndpointArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var gcp = new AuthBackend(\"gcp\", AuthBackendArgs.builder()        \n            .credentials(Files.readString(Paths.get(\"vault-gcp-credentials.json\")))\n            .customEndpoint(AuthBackendCustomEndpointArgs.builder()\n                .api(\"www.googleapis.com\")\n                .iam(\"iam.googleapis.com\")\n                .crm(\"cloudresourcemanager.googleapis.com\")\n                .compute(\"compute.googleapis.com\")\n                .build())\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGCP authentication backends can be imported using the backend name, e.g.\n\n```sh\n $ pulumi import vault:gcp/authBackend:AuthBackend gcp gcp\n```\n\n ",
            "properties": {
                "clientEmail": {
                    "type": "string",
                    "description": "The clients email associated with the credentials\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The Client ID of the credentials\n"
                },
                "credentials": {
                    "type": "string",
                    "description": "A JSON string containing the contents of a GCP credentials file. If this value is empty, Vault will try to use Application Default Credentials from the machine on which the Vault server is running.\n",
                    "secret": true
                },
                "customEndpoint": {
                    "$ref": "#/types/vault:gcp/AuthBackendCustomEndpoint:AuthBackendCustomEndpoint",
                    "description": "Specifies overrides to\n[service endpoints](https://cloud.google.com/apis/design/glossary#api_service_endpoint)\nused when making API requests. This allows specific requests made during authentication\nto target alternative service endpoints for use in [Private Google Access](https://cloud.google.com/vpc/docs/configure-private-google-access)\nenvironments. Requires Vault 1.11+.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description of the auth method.\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the auth method is local only.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path to mount the auth method — this defaults to 'gcp'.\n"
                },
                "privateKeyId": {
                    "type": "string",
                    "description": "The ID of the private key from the credentials\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The GCP Project ID\n"
                }
            },
            "required": [
                "clientEmail",
                "clientId",
                "privateKeyId",
                "projectId"
            ],
            "inputProperties": {
                "clientEmail": {
                    "type": "string",
                    "description": "The clients email associated with the credentials\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The Client ID of the credentials\n"
                },
                "credentials": {
                    "type": "string",
                    "description": "A JSON string containing the contents of a GCP credentials file. If this value is empty, Vault will try to use Application Default Credentials from the machine on which the Vault server is running.\n",
                    "secret": true
                },
                "customEndpoint": {
                    "$ref": "#/types/vault:gcp/AuthBackendCustomEndpoint:AuthBackendCustomEndpoint",
                    "description": "Specifies overrides to\n[service endpoints](https://cloud.google.com/apis/design/glossary#api_service_endpoint)\nused when making API requests. This allows specific requests made during authentication\nto target alternative service endpoints for use in [Private Google Access](https://cloud.google.com/vpc/docs/configure-private-google-access)\nenvironments. Requires Vault 1.11+.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description of the auth method.\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the auth method is local only.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "The path to mount the auth method — this defaults to 'gcp'.\n"
                },
                "privateKeyId": {
                    "type": "string",
                    "description": "The ID of the private key from the credentials\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The GCP Project ID\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackend resources.\n",
                "properties": {
                    "clientEmail": {
                        "type": "string",
                        "description": "The clients email associated with the credentials\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The Client ID of the credentials\n"
                    },
                    "credentials": {
                        "type": "string",
                        "description": "A JSON string containing the contents of a GCP credentials file. If this value is empty, Vault will try to use Application Default Credentials from the machine on which the Vault server is running.\n",
                        "secret": true
                    },
                    "customEndpoint": {
                        "$ref": "#/types/vault:gcp/AuthBackendCustomEndpoint:AuthBackendCustomEndpoint",
                        "description": "Specifies overrides to\n[service endpoints](https://cloud.google.com/apis/design/glossary#api_service_endpoint)\nused when making API requests. This allows specific requests made during authentication\nto target alternative service endpoints for use in [Private Google Access](https://cloud.google.com/vpc/docs/configure-private-google-access)\nenvironments. Requires Vault 1.11+.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description of the auth method.\n"
                    },
                    "disableRemount": {
                        "type": "boolean",
                        "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Specifies if the auth method is local only.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "The path to mount the auth method — this defaults to 'gcp'.\n"
                    },
                    "privateKeyId": {
                        "type": "string",
                        "description": "The ID of the private key from the credentials\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The GCP Project ID\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:gcp/authBackendRole:AuthBackendRole": {
            "description": "Provides a resource to create a role in an [GCP auth backend within Vault](https://www.vaultproject.io/docs/auth/gcp.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst gcp = new vault.AuthBackend(\"gcp\", {\n    path: \"gcp\",\n    type: \"gcp\",\n});\nconst test = new vault.gcp.AuthBackendRole(\"test\", {\n    backend: gcp.path,\n    role: \"test\",\n    type: \"iam\",\n    boundServiceAccounts: [\"test\"],\n    boundProjects: [\"test\"],\n    tokenTtl: 300,\n    tokenMaxTtl: 600,\n    tokenPolicies: [\n        \"policy_a\",\n        \"policy_b\",\n    ],\n    addGroupAliases: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ngcp = vault.AuthBackend(\"gcp\",\n    path=\"gcp\",\n    type=\"gcp\")\ntest = vault.gcp.AuthBackendRole(\"test\",\n    backend=gcp.path,\n    role=\"test\",\n    type=\"iam\",\n    bound_service_accounts=[\"test\"],\n    bound_projects=[\"test\"],\n    token_ttl=300,\n    token_max_ttl=600,\n    token_policies=[\n        \"policy_a\",\n        \"policy_b\",\n    ],\n    add_group_aliases=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var gcp = new Vault.AuthBackend(\"gcp\", new()\n    {\n        Path = \"gcp\",\n        Type = \"gcp\",\n    });\n\n    var test = new Vault.Gcp.AuthBackendRole(\"test\", new()\n    {\n        Backend = gcp.Path,\n        Role = \"test\",\n        Type = \"iam\",\n        BoundServiceAccounts = new[]\n        {\n            \"test\",\n        },\n        BoundProjects = new[]\n        {\n            \"test\",\n        },\n        TokenTtl = 300,\n        TokenMaxTtl = 600,\n        TokenPolicies = new[]\n        {\n            \"policy_a\",\n            \"policy_b\",\n        },\n        AddGroupAliases = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/gcp\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tgcp, err := vault.NewAuthBackend(ctx, \"gcp\", \u0026vault.AuthBackendArgs{\n\t\t\tPath: pulumi.String(\"gcp\"),\n\t\t\tType: pulumi.String(\"gcp\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gcp.NewAuthBackendRole(ctx, \"test\", \u0026gcp.AuthBackendRoleArgs{\n\t\t\tBackend: gcp.Path,\n\t\t\tRole:    pulumi.String(\"test\"),\n\t\t\tType:    pulumi.String(\"iam\"),\n\t\t\tBoundServiceAccounts: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tBoundProjects: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tTokenTtl:    pulumi.Int(300),\n\t\t\tTokenMaxTtl: pulumi.Int(600),\n\t\t\tTokenPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"policy_a\"),\n\t\t\t\tpulumi.String(\"policy_b\"),\n\t\t\t},\n\t\t\tAddGroupAliases: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.AuthBackend;\nimport com.pulumi.vault.AuthBackendArgs;\nimport com.pulumi.vault.gcp.AuthBackendRole;\nimport com.pulumi.vault.gcp.AuthBackendRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var gcp = new AuthBackend(\"gcp\", AuthBackendArgs.builder()        \n            .path(\"gcp\")\n            .type(\"gcp\")\n            .build());\n\n        var test = new AuthBackendRole(\"test\", AuthBackendRoleArgs.builder()        \n            .backend(gcp.path())\n            .role(\"test\")\n            .type(\"iam\")\n            .boundServiceAccounts(\"test\")\n            .boundProjects(\"test\")\n            .tokenTtl(300)\n            .tokenMaxTtl(600)\n            .tokenPolicies(            \n                \"policy_a\",\n                \"policy_b\")\n            .addGroupAliases(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  gcp:\n    type: vault:AuthBackend\n    properties:\n      path: gcp\n      type: gcp\n  test:\n    type: vault:gcp:AuthBackendRole\n    properties:\n      backend: ${gcp.path}\n      role: test\n      type: iam\n      boundServiceAccounts:\n        - test\n      boundProjects:\n        - test\n      tokenTtl: 300\n      tokenMaxTtl: 600\n      tokenPolicies:\n        - policy_a\n        - policy_b\n      addGroupAliases: true\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGCP authentication roles can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:gcp/authBackendRole:AuthBackendRole my_role auth/gcp/role/my_role\n```\n\n ",
            "properties": {
                "addGroupAliases": {
                    "type": "boolean"
                },
                "allowGceInference": {
                    "type": "boolean",
                    "description": "A flag to determine if this role should allow GCE instances to authenticate by inferring service accounts from the GCE identity metadata token.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Path to the mounted GCP auth backend\n"
                },
                "boundInstanceGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The instance groups that an authorized instance must belong to in order to be authenticated. If specified, either `bound_zones` or `bound_regions` must be set too.\n"
                },
                "boundLabels": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A comma-separated list of GCP labels formatted as `\"key:value\"` strings that must be set on authorized GCE instances. Because GCP labels are not currently ACL'd, we recommend that this be used in conjunction with other restrictions.\n"
                },
                "boundProjects": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "GCP Projects that the role exists within\n"
                },
                "boundRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of regions that a GCE instance must belong to in order to be authenticated. If bound_instance_groups is provided, it is assumed to be a regional group and the group must belong to this region. If bound_zones are provided, this attribute is ignored.\n"
                },
                "boundServiceAccounts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "GCP Service Accounts allowed to issue tokens under this role. (Note: **Required** if role is `iam`)\n"
                },
                "boundZones": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of zones that a GCE instance must belong to in order to be authenticated. If bound_instance_groups is provided, it is assumed to be a zonal group and the group must belong to this zone.\n"
                },
                "maxJwtExp": {
                    "type": "string",
                    "description": "The number of seconds past the time of authentication that the login param JWT must expire within. For example, if a user attempts to login with a token that expires within an hour and this is set to 15 minutes, Vault will return an error prompting the user to create a new signed JWT with a shorter `exp`. The GCE metadata tokens currently do not allow the `exp` claim to be customized.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the GCP role\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The [maximum number](https://www.vaultproject.io/api-docs/gcp#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of GCP authentication role (either `gce` or `iam`)\n"
                }
            },
            "required": [
                "addGroupAliases",
                "allowGceInference",
                "boundInstanceGroups",
                "boundLabels",
                "boundRegions",
                "boundServiceAccounts",
                "boundZones",
                "maxJwtExp",
                "role",
                "type"
            ],
            "inputProperties": {
                "addGroupAliases": {
                    "type": "boolean"
                },
                "allowGceInference": {
                    "type": "boolean",
                    "description": "A flag to determine if this role should allow GCE instances to authenticate by inferring service accounts from the GCE identity metadata token.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Path to the mounted GCP auth backend\n",
                    "willReplaceOnChanges": true
                },
                "boundInstanceGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The instance groups that an authorized instance must belong to in order to be authenticated. If specified, either `bound_zones` or `bound_regions` must be set too.\n"
                },
                "boundLabels": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A comma-separated list of GCP labels formatted as `\"key:value\"` strings that must be set on authorized GCE instances. Because GCP labels are not currently ACL'd, we recommend that this be used in conjunction with other restrictions.\n"
                },
                "boundProjects": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "GCP Projects that the role exists within\n",
                    "willReplaceOnChanges": true
                },
                "boundRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of regions that a GCE instance must belong to in order to be authenticated. If bound_instance_groups is provided, it is assumed to be a regional group and the group must belong to this region. If bound_zones are provided, this attribute is ignored.\n"
                },
                "boundServiceAccounts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "GCP Service Accounts allowed to issue tokens under this role. (Note: **Required** if role is `iam`)\n"
                },
                "boundZones": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of zones that a GCE instance must belong to in order to be authenticated. If bound_instance_groups is provided, it is assumed to be a zonal group and the group must belong to this zone.\n"
                },
                "maxJwtExp": {
                    "type": "string",
                    "description": "The number of seconds past the time of authentication that the login param JWT must expire within. For example, if a user attempts to login with a token that expires within an hour and this is set to 15 minutes, Vault will return an error prompting the user to create a new signed JWT with a shorter `exp`. The GCE metadata tokens currently do not allow the `exp` claim to be customized.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "role": {
                    "type": "string",
                    "description": "Name of the GCP role\n",
                    "willReplaceOnChanges": true
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The [maximum number](https://www.vaultproject.io/api-docs/gcp#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of GCP authentication role (either `gce` or `iam`)\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "role",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "addGroupAliases": {
                        "type": "boolean"
                    },
                    "allowGceInference": {
                        "type": "boolean",
                        "description": "A flag to determine if this role should allow GCE instances to authenticate by inferring service accounts from the GCE identity metadata token.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "Path to the mounted GCP auth backend\n",
                        "willReplaceOnChanges": true
                    },
                    "boundInstanceGroups": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The instance groups that an authorized instance must belong to in order to be authenticated. If specified, either `bound_zones` or `bound_regions` must be set too.\n"
                    },
                    "boundLabels": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A comma-separated list of GCP labels formatted as `\"key:value\"` strings that must be set on authorized GCE instances. Because GCP labels are not currently ACL'd, we recommend that this be used in conjunction with other restrictions.\n"
                    },
                    "boundProjects": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "GCP Projects that the role exists within\n",
                        "willReplaceOnChanges": true
                    },
                    "boundRegions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of regions that a GCE instance must belong to in order to be authenticated. If bound_instance_groups is provided, it is assumed to be a regional group and the group must belong to this region. If bound_zones are provided, this attribute is ignored.\n"
                    },
                    "boundServiceAccounts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "GCP Service Accounts allowed to issue tokens under this role. (Note: **Required** if role is `iam`)\n"
                    },
                    "boundZones": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of zones that a GCE instance must belong to in order to be authenticated. If bound_instance_groups is provided, it is assumed to be a zonal group and the group must belong to this zone.\n"
                    },
                    "maxJwtExp": {
                        "type": "string",
                        "description": "The number of seconds past the time of authentication that the login param JWT must expire within. For example, if a user attempts to login with a token that expires within an hour and this is set to 15 minutes, Vault will return an error prompting the user to create a new signed JWT with a shorter `exp`. The GCE metadata tokens currently do not allow the `exp` claim to be customized.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "role": {
                        "type": "string",
                        "description": "Name of the GCP role\n",
                        "willReplaceOnChanges": true
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The [maximum number](https://www.vaultproject.io/api-docs/gcp#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of GCP authentication role (either `gce` or `iam`)\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:gcp/secretBackend:SecretBackend": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as fs from \"fs\";\nimport * as vault from \"@pulumi/vault\";\n\nconst gcp = new vault.gcp.SecretBackend(\"gcp\", {credentials: fs.readFileSync(\"credentials.json\")});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ngcp = vault.gcp.SecretBackend(\"gcp\", credentials=(lambda path: open(path).read())(\"credentials.json\"))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var gcp = new Vault.Gcp.SecretBackend(\"gcp\", new()\n    {\n        Credentials = File.ReadAllText(\"credentials.json\"),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/gcp\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gcp.NewSecretBackend(ctx, \"gcp\", \u0026gcp.SecretBackendArgs{\n\t\t\tCredentials: readFileOrPanic(\"credentials.json\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.gcp.SecretBackend;\nimport com.pulumi.vault.gcp.SecretBackendArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var gcp = new SecretBackend(\"gcp\", SecretBackendArgs.builder()        \n            .credentials(Files.readString(Paths.get(\"credentials.json\")))\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "credentials": {
                    "type": "string",
                    "description": "The GCP service account credentials in JSON format.\n",
                    "secret": true
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials\nissued by this backend. Defaults to '0'.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Boolean flag that can be explicitly set to true to enforce local mount in HA environment\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend. Defaults to '0'.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `gcp`.\n"
                }
            },
            "inputProperties": {
                "credentials": {
                    "type": "string",
                    "description": "The GCP service account credentials in JSON format.\n",
                    "secret": true
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials\nissued by this backend. Defaults to '0'.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Boolean flag that can be explicitly set to true to enforce local mount in HA environment\n",
                    "willReplaceOnChanges": true
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend. Defaults to '0'.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `gcp`.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackend resources.\n",
                "properties": {
                    "credentials": {
                        "type": "string",
                        "description": "The GCP service account credentials in JSON format.\n",
                        "secret": true
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The default TTL for credentials\nissued by this backend. Defaults to '0'.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A human-friendly description for this backend.\n"
                    },
                    "disableRemount": {
                        "type": "boolean",
                        "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Boolean flag that can be explicitly set to true to enforce local mount in HA environment\n",
                        "willReplaceOnChanges": true
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The maximum TTL that can be requested\nfor credentials issued by this backend. Defaults to '0'.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `gcp`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:gcp/secretImpersonatedAccount:SecretImpersonatedAccount": {
            "description": "Creates a Impersonated Account in the [GCP Secrets Engine](https://www.vaultproject.io/docs/secrets/gcp/index.html) for Vault.\n\nEach [impersonated account](https://www.vaultproject.io/docs/secrets/gcp/index.html#impersonated-accounts) is tied to a separately managed\nService Account.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as fs from \"fs\";\nimport * as gcp from \"@pulumi/gcp\";\nimport * as vault from \"@pulumi/vault\";\n\nconst _this = new gcp.serviceaccount.Account(\"this\", {accountId: \"my-awesome-account\"});\nconst gcp = new vault.gcp.SecretBackend(\"gcp\", {\n    path: \"gcp\",\n    credentials: fs.readFileSync(\"credentials.json\"),\n});\nconst impersonatedAccount = new vault.gcp.SecretImpersonatedAccount(\"impersonatedAccount\", {\n    backend: gcp.path,\n    impersonatedAccount: \"this\",\n    serviceAccountEmail: _this.email,\n    tokenScopes: [\"https://www.googleapis.com/auth/cloud-platform\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\nimport pulumi_vault as vault\n\nthis = gcp.service_account.Account(\"this\", account_id=\"my-awesome-account\")\ngcp = vault.gcp.SecretBackend(\"gcp\",\n    path=\"gcp\",\n    credentials=(lambda path: open(path).read())(\"credentials.json\"))\nimpersonated_account = vault.gcp.SecretImpersonatedAccount(\"impersonatedAccount\",\n    backend=gcp.path,\n    impersonated_account=\"this\",\n    service_account_email=this.email,\n    token_scopes=[\"https://www.googleapis.com/auth/cloud-platform\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @this = new Gcp.ServiceAccount.Account(\"this\", new()\n    {\n        AccountId = \"my-awesome-account\",\n    });\n\n    var gcp = new Vault.Gcp.SecretBackend(\"gcp\", new()\n    {\n        Path = \"gcp\",\n        Credentials = File.ReadAllText(\"credentials.json\"),\n    });\n\n    var impersonatedAccount = new Vault.Gcp.SecretImpersonatedAccount(\"impersonatedAccount\", new()\n    {\n        Backend = gcp.Path,\n        ImpersonatedAccount = \"this\",\n        ServiceAccountEmail = @this.Email,\n        TokenScopes = new[]\n        {\n            \"https://www.googleapis.com/auth/cloud-platform\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-gcp/sdk/v5/go/gcp/serviceAccount\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/gcp\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tthis, err := serviceAccount.NewAccount(ctx, \"this\", \u0026serviceAccount.AccountArgs{\n\t\t\tAccountId: pulumi.String(\"my-awesome-account\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgcp, err := gcp.NewSecretBackend(ctx, \"gcp\", \u0026gcp.SecretBackendArgs{\n\t\t\tPath:        pulumi.String(\"gcp\"),\n\t\t\tCredentials: readFileOrPanic(\"credentials.json\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gcp.NewSecretImpersonatedAccount(ctx, \"impersonatedAccount\", \u0026gcp.SecretImpersonatedAccountArgs{\n\t\t\tBackend:             gcp.Path,\n\t\t\tImpersonatedAccount: pulumi.String(\"this\"),\n\t\t\tServiceAccountEmail: this.Email,\n\t\t\tTokenScopes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"https://www.googleapis.com/auth/cloud-platform\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.serviceAccount.Account;\nimport com.pulumi.gcp.serviceAccount.AccountArgs;\nimport com.pulumi.vault.gcp.SecretBackend;\nimport com.pulumi.vault.gcp.SecretBackendArgs;\nimport com.pulumi.vault.gcp.SecretImpersonatedAccount;\nimport com.pulumi.vault.gcp.SecretImpersonatedAccountArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var this_ = new Account(\"this\", AccountArgs.builder()        \n            .accountId(\"my-awesome-account\")\n            .build());\n\n        var gcp = new SecretBackend(\"gcp\", SecretBackendArgs.builder()        \n            .path(\"gcp\")\n            .credentials(Files.readString(Paths.get(\"credentials.json\")))\n            .build());\n\n        var impersonatedAccount = new SecretImpersonatedAccount(\"impersonatedAccount\", SecretImpersonatedAccountArgs.builder()        \n            .backend(gcp.path())\n            .impersonatedAccount(\"this\")\n            .serviceAccountEmail(this_.email())\n            .tokenScopes(\"https://www.googleapis.com/auth/cloud-platform\")\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nA impersonated account can be imported using its Vault Path. For example, referencing the example above,\n\n```sh\n $ pulumi import vault:gcp/secretImpersonatedAccount:SecretImpersonatedAccount impersonated_account gcp/impersonated-account/project_viewer\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the GCP Secrets Engine is mounted\n"
                },
                "impersonatedAccount": {
                    "type": "string",
                    "description": "Name of the Impersonated Account to create\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "Target namespace. (requires Enterprise)\n"
                },
                "serviceAccountEmail": {
                    "type": "string",
                    "description": "Email of the GCP service account to impersonate.\n"
                },
                "serviceAccountProject": {
                    "type": "string",
                    "description": "Project the service account belongs to.\n"
                },
                "tokenScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of OAuth scopes to assign to access tokens generated under this impersonated account.\n"
                }
            },
            "required": [
                "backend",
                "impersonatedAccount",
                "serviceAccountEmail",
                "serviceAccountProject"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the GCP Secrets Engine is mounted\n",
                    "willReplaceOnChanges": true
                },
                "impersonatedAccount": {
                    "type": "string",
                    "description": "Name of the Impersonated Account to create\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "Target namespace. (requires Enterprise)\n",
                    "willReplaceOnChanges": true
                },
                "serviceAccountEmail": {
                    "type": "string",
                    "description": "Email of the GCP service account to impersonate.\n",
                    "willReplaceOnChanges": true
                },
                "tokenScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of OAuth scopes to assign to access tokens generated under this impersonated account.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "impersonatedAccount",
                "serviceAccountEmail"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretImpersonatedAccount resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Path where the GCP Secrets Engine is mounted\n",
                        "willReplaceOnChanges": true
                    },
                    "impersonatedAccount": {
                        "type": "string",
                        "description": "Name of the Impersonated Account to create\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "Target namespace. (requires Enterprise)\n",
                        "willReplaceOnChanges": true
                    },
                    "serviceAccountEmail": {
                        "type": "string",
                        "description": "Email of the GCP service account to impersonate.\n",
                        "willReplaceOnChanges": true
                    },
                    "serviceAccountProject": {
                        "type": "string",
                        "description": "Project the service account belongs to.\n"
                    },
                    "tokenScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of OAuth scopes to assign to access tokens generated under this impersonated account.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:gcp/secretRoleset:SecretRoleset": {
            "description": "Creates a Roleset in the [GCP Secrets Engine](https://www.vaultproject.io/docs/secrets/gcp/index.html) for Vault.\n\nEach Roleset is [tied](https://www.vaultproject.io/docs/secrets/gcp/index.html#service-accounts-are-tied-to-rolesets) to a Service Account, and can have one or more [bindings](https://www.vaultproject.io/docs/secrets/gcp/index.html#roleset-bindings) associated with it.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as fs from \"fs\";\nimport * as vault from \"@pulumi/vault\";\n\nconst project = \"my-awesome-project\";\nconst gcp = new vault.gcp.SecretBackend(\"gcp\", {\n    path: \"gcp\",\n    credentials: fs.readFileSync(\"credentials.json\"),\n});\nconst roleset = new vault.gcp.SecretRoleset(\"roleset\", {\n    backend: gcp.path,\n    roleset: \"project_viewer\",\n    secretType: \"access_token\",\n    project: project,\n    tokenScopes: [\"https://www.googleapis.com/auth/cloud-platform\"],\n    bindings: [{\n        resource: `//cloudresourcemanager.googleapis.com/projects/${project}`,\n        roles: [\"roles/viewer\"],\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nproject = \"my-awesome-project\"\ngcp = vault.gcp.SecretBackend(\"gcp\",\n    path=\"gcp\",\n    credentials=(lambda path: open(path).read())(\"credentials.json\"))\nroleset = vault.gcp.SecretRoleset(\"roleset\",\n    backend=gcp.path,\n    roleset=\"project_viewer\",\n    secret_type=\"access_token\",\n    project=project,\n    token_scopes=[\"https://www.googleapis.com/auth/cloud-platform\"],\n    bindings=[vault.gcp.SecretRolesetBindingArgs(\n        resource=f\"//cloudresourcemanager.googleapis.com/projects/{project}\",\n        roles=[\"roles/viewer\"],\n    )])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var project = \"my-awesome-project\";\n\n    var gcp = new Vault.Gcp.SecretBackend(\"gcp\", new()\n    {\n        Path = \"gcp\",\n        Credentials = File.ReadAllText(\"credentials.json\"),\n    });\n\n    var roleset = new Vault.Gcp.SecretRoleset(\"roleset\", new()\n    {\n        Backend = gcp.Path,\n        Roleset = \"project_viewer\",\n        SecretType = \"access_token\",\n        Project = project,\n        TokenScopes = new[]\n        {\n            \"https://www.googleapis.com/auth/cloud-platform\",\n        },\n        Bindings = new[]\n        {\n            new Vault.Gcp.Inputs.SecretRolesetBindingArgs\n            {\n                Resource = $\"//cloudresourcemanager.googleapis.com/projects/{project}\",\n                Roles = new[]\n                {\n                    \"roles/viewer\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/gcp\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tproject := \"my-awesome-project\"\n\t\tgcp, err := gcp.NewSecretBackend(ctx, \"gcp\", \u0026gcp.SecretBackendArgs{\n\t\t\tPath:        pulumi.String(\"gcp\"),\n\t\t\tCredentials: readFileOrPanic(\"credentials.json\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gcp.NewSecretRoleset(ctx, \"roleset\", \u0026gcp.SecretRolesetArgs{\n\t\t\tBackend:    gcp.Path,\n\t\t\tRoleset:    pulumi.String(\"project_viewer\"),\n\t\t\tSecretType: pulumi.String(\"access_token\"),\n\t\t\tProject:    pulumi.String(project),\n\t\t\tTokenScopes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"https://www.googleapis.com/auth/cloud-platform\"),\n\t\t\t},\n\t\t\tBindings: gcp.SecretRolesetBindingArray{\n\t\t\t\t\u0026gcp.SecretRolesetBindingArgs{\n\t\t\t\t\tResource: pulumi.String(fmt.Sprintf(\"//cloudresourcemanager.googleapis.com/projects/%v\", project)),\n\t\t\t\t\tRoles: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"roles/viewer\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.gcp.SecretBackend;\nimport com.pulumi.vault.gcp.SecretBackendArgs;\nimport com.pulumi.vault.gcp.SecretRoleset;\nimport com.pulumi.vault.gcp.SecretRolesetArgs;\nimport com.pulumi.vault.gcp.inputs.SecretRolesetBindingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var project = \"my-awesome-project\";\n\n        var gcp = new SecretBackend(\"gcp\", SecretBackendArgs.builder()        \n            .path(\"gcp\")\n            .credentials(Files.readString(Paths.get(\"credentials.json\")))\n            .build());\n\n        var roleset = new SecretRoleset(\"roleset\", SecretRolesetArgs.builder()        \n            .backend(gcp.path())\n            .roleset(\"project_viewer\")\n            .secretType(\"access_token\")\n            .project(project)\n            .tokenScopes(\"https://www.googleapis.com/auth/cloud-platform\")\n            .bindings(SecretRolesetBindingArgs.builder()\n                .resource(String.format(\"//cloudresourcemanager.googleapis.com/projects/%s\", project))\n                .roles(\"roles/viewer\")\n                .build())\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nA roleset can be imported using its Vault Path. For example, referencing the example above,\n\n```sh\n $ pulumi import vault:gcp/secretRoleset:SecretRoleset roleset gcp/roleset/project_viewer\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the GCP Secrets Engine is mounted\n"
                },
                "bindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:gcp/SecretRolesetBinding:SecretRolesetBinding"
                    },
                    "description": "Bindings to create for this roleset. This can be specified multiple times for multiple bindings. Structure is documented below.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "project": {
                    "type": "string",
                    "description": "Name of the GCP project that this roleset's service account will belong to.\n"
                },
                "roleset": {
                    "type": "string",
                    "description": "Name of the Roleset to create\n"
                },
                "secretType": {
                    "type": "string",
                    "description": "Type of secret generated for this role set. Accepted values: `access_token`, `service_account_key`. Defaults to `access_token`.\n"
                },
                "serviceAccountEmail": {
                    "type": "string",
                    "description": "Email of the service account created by Vault for this Roleset\n"
                },
                "tokenScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of OAuth scopes to assign to `access_token` secrets generated under this role set (`access_token` role sets only).\n"
                }
            },
            "required": [
                "backend",
                "bindings",
                "project",
                "roleset",
                "secretType",
                "serviceAccountEmail"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the GCP Secrets Engine is mounted\n",
                    "willReplaceOnChanges": true
                },
                "bindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:gcp/SecretRolesetBinding:SecretRolesetBinding"
                    },
                    "description": "Bindings to create for this roleset. This can be specified multiple times for multiple bindings. Structure is documented below.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "project": {
                    "type": "string",
                    "description": "Name of the GCP project that this roleset's service account will belong to.\n",
                    "willReplaceOnChanges": true
                },
                "roleset": {
                    "type": "string",
                    "description": "Name of the Roleset to create\n",
                    "willReplaceOnChanges": true
                },
                "secretType": {
                    "type": "string",
                    "description": "Type of secret generated for this role set. Accepted values: `access_token`, `service_account_key`. Defaults to `access_token`.\n",
                    "willReplaceOnChanges": true
                },
                "tokenScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of OAuth scopes to assign to `access_token` secrets generated under this role set (`access_token` role sets only).\n"
                }
            },
            "requiredInputs": [
                "backend",
                "bindings",
                "project",
                "roleset"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretRoleset resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Path where the GCP Secrets Engine is mounted\n",
                        "willReplaceOnChanges": true
                    },
                    "bindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:gcp/SecretRolesetBinding:SecretRolesetBinding"
                        },
                        "description": "Bindings to create for this roleset. This can be specified multiple times for multiple bindings. Structure is documented below.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "project": {
                        "type": "string",
                        "description": "Name of the GCP project that this roleset's service account will belong to.\n",
                        "willReplaceOnChanges": true
                    },
                    "roleset": {
                        "type": "string",
                        "description": "Name of the Roleset to create\n",
                        "willReplaceOnChanges": true
                    },
                    "secretType": {
                        "type": "string",
                        "description": "Type of secret generated for this role set. Accepted values: `access_token`, `service_account_key`. Defaults to `access_token`.\n",
                        "willReplaceOnChanges": true
                    },
                    "serviceAccountEmail": {
                        "type": "string",
                        "description": "Email of the service account created by Vault for this Roleset\n"
                    },
                    "tokenScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of OAuth scopes to assign to `access_token` secrets generated under this role set (`access_token` role sets only).\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:gcp/secretStaticAccount:SecretStaticAccount": {
            "description": "Creates a Static Account in the [GCP Secrets Engine](https://www.vaultproject.io/docs/secrets/gcp/index.html) for Vault.\n\nEach [static account](https://www.vaultproject.io/docs/secrets/gcp/index.html#static-accounts) is tied to a separately managed\nService Account, and can have one or more [bindings](https://www.vaultproject.io/docs/secrets/gcp/index.html#bindings) associated with it.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as fs from \"fs\";\nimport * as gcp from \"@pulumi/gcp\";\nimport * as vault from \"@pulumi/vault\";\n\nconst _this = new gcp.serviceaccount.Account(\"this\", {accountId: \"my-awesome-account\"});\nconst gcp = new vault.gcp.SecretBackend(\"gcp\", {\n    path: \"gcp\",\n    credentials: fs.readFileSync(\"credentials.json\"),\n});\nconst staticAccount = new vault.gcp.SecretStaticAccount(\"staticAccount\", {\n    backend: gcp.path,\n    staticAccount: \"project_viewer\",\n    secretType: \"access_token\",\n    tokenScopes: [\"https://www.googleapis.com/auth/cloud-platform\"],\n    serviceAccountEmail: _this.email,\n    bindings: [{\n        resource: pulumi.interpolate`//cloudresourcemanager.googleapis.com/projects/${_this.project}`,\n        roles: [\"roles/viewer\"],\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\nimport pulumi_vault as vault\n\nthis = gcp.service_account.Account(\"this\", account_id=\"my-awesome-account\")\ngcp = vault.gcp.SecretBackend(\"gcp\",\n    path=\"gcp\",\n    credentials=(lambda path: open(path).read())(\"credentials.json\"))\nstatic_account = vault.gcp.SecretStaticAccount(\"staticAccount\",\n    backend=gcp.path,\n    static_account=\"project_viewer\",\n    secret_type=\"access_token\",\n    token_scopes=[\"https://www.googleapis.com/auth/cloud-platform\"],\n    service_account_email=this.email,\n    bindings=[vault.gcp.SecretStaticAccountBindingArgs(\n        resource=this.project.apply(lambda project: f\"//cloudresourcemanager.googleapis.com/projects/{project}\"),\n        roles=[\"roles/viewer\"],\n    )])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @this = new Gcp.ServiceAccount.Account(\"this\", new()\n    {\n        AccountId = \"my-awesome-account\",\n    });\n\n    var gcp = new Vault.Gcp.SecretBackend(\"gcp\", new()\n    {\n        Path = \"gcp\",\n        Credentials = File.ReadAllText(\"credentials.json\"),\n    });\n\n    var staticAccount = new Vault.Gcp.SecretStaticAccount(\"staticAccount\", new()\n    {\n        Backend = gcp.Path,\n        StaticAccount = \"project_viewer\",\n        SecretType = \"access_token\",\n        TokenScopes = new[]\n        {\n            \"https://www.googleapis.com/auth/cloud-platform\",\n        },\n        ServiceAccountEmail = @this.Email,\n        Bindings = new[]\n        {\n            new Vault.Gcp.Inputs.SecretStaticAccountBindingArgs\n            {\n                Resource = @this.Project.Apply(project =\u003e $\"//cloudresourcemanager.googleapis.com/projects/{project}\"),\n                Roles = new[]\n                {\n                    \"roles/viewer\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-gcp/sdk/v5/go/gcp/serviceAccount\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/gcp\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tthis, err := serviceAccount.NewAccount(ctx, \"this\", \u0026serviceAccount.AccountArgs{\n\t\t\tAccountId: pulumi.String(\"my-awesome-account\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgcp, err := gcp.NewSecretBackend(ctx, \"gcp\", \u0026gcp.SecretBackendArgs{\n\t\t\tPath:        pulumi.String(\"gcp\"),\n\t\t\tCredentials: readFileOrPanic(\"credentials.json\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gcp.NewSecretStaticAccount(ctx, \"staticAccount\", \u0026gcp.SecretStaticAccountArgs{\n\t\t\tBackend:       gcp.Path,\n\t\t\tStaticAccount: pulumi.String(\"project_viewer\"),\n\t\t\tSecretType:    pulumi.String(\"access_token\"),\n\t\t\tTokenScopes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"https://www.googleapis.com/auth/cloud-platform\"),\n\t\t\t},\n\t\t\tServiceAccountEmail: this.Email,\n\t\t\tBindings: gcp.SecretStaticAccountBindingArray{\n\t\t\t\t\u0026gcp.SecretStaticAccountBindingArgs{\n\t\t\t\t\tResource: this.Project.ApplyT(func(project string) (string, error) {\n\t\t\t\t\t\treturn fmt.Sprintf(\"//cloudresourcemanager.googleapis.com/projects/%v\", project), nil\n\t\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t\t\tRoles: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"roles/viewer\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.serviceAccount.Account;\nimport com.pulumi.gcp.serviceAccount.AccountArgs;\nimport com.pulumi.vault.gcp.SecretBackend;\nimport com.pulumi.vault.gcp.SecretBackendArgs;\nimport com.pulumi.vault.gcp.SecretStaticAccount;\nimport com.pulumi.vault.gcp.SecretStaticAccountArgs;\nimport com.pulumi.vault.gcp.inputs.SecretStaticAccountBindingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var this_ = new Account(\"this\", AccountArgs.builder()        \n            .accountId(\"my-awesome-account\")\n            .build());\n\n        var gcp = new SecretBackend(\"gcp\", SecretBackendArgs.builder()        \n            .path(\"gcp\")\n            .credentials(Files.readString(Paths.get(\"credentials.json\")))\n            .build());\n\n        var staticAccount = new SecretStaticAccount(\"staticAccount\", SecretStaticAccountArgs.builder()        \n            .backend(gcp.path())\n            .staticAccount(\"project_viewer\")\n            .secretType(\"access_token\")\n            .tokenScopes(\"https://www.googleapis.com/auth/cloud-platform\")\n            .serviceAccountEmail(this_.email())\n            .bindings(SecretStaticAccountBindingArgs.builder()\n                .resource(this_.project().applyValue(project -\u003e String.format(\"//cloudresourcemanager.googleapis.com/projects/%s\", project)))\n                .roles(\"roles/viewer\")\n                .build())\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nA static account can be imported using its Vault Path. For example, referencing the example above,\n\n```sh\n $ pulumi import vault:gcp/secretStaticAccount:SecretStaticAccount static_account gcp/static-account/project_viewer\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the GCP Secrets Engine is mounted\n"
                },
                "bindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:gcp/SecretStaticAccountBinding:SecretStaticAccountBinding"
                    },
                    "description": "Bindings to create for this static account. This can be specified multiple times for multiple bindings. Structure is documented below.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "secretType": {
                    "type": "string",
                    "description": "Type of secret generated for this static account. Accepted values: `access_token`, `service_account_key`. Defaults to `access_token`.\n"
                },
                "serviceAccountEmail": {
                    "type": "string",
                    "description": "Email of the GCP service account to manage.\n"
                },
                "serviceAccountProject": {
                    "type": "string",
                    "description": "Project the service account belongs to.\n"
                },
                "staticAccount": {
                    "type": "string",
                    "description": "Name of the Static Account to create\n"
                },
                "tokenScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of OAuth scopes to assign to `access_token` secrets generated under this static account (`access_token` static accounts only).\n"
                }
            },
            "required": [
                "backend",
                "secretType",
                "serviceAccountEmail",
                "serviceAccountProject",
                "staticAccount"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the GCP Secrets Engine is mounted\n",
                    "willReplaceOnChanges": true
                },
                "bindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:gcp/SecretStaticAccountBinding:SecretStaticAccountBinding"
                    },
                    "description": "Bindings to create for this static account. This can be specified multiple times for multiple bindings. Structure is documented below.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "secretType": {
                    "type": "string",
                    "description": "Type of secret generated for this static account. Accepted values: `access_token`, `service_account_key`. Defaults to `access_token`.\n",
                    "willReplaceOnChanges": true
                },
                "serviceAccountEmail": {
                    "type": "string",
                    "description": "Email of the GCP service account to manage.\n",
                    "willReplaceOnChanges": true
                },
                "staticAccount": {
                    "type": "string",
                    "description": "Name of the Static Account to create\n",
                    "willReplaceOnChanges": true
                },
                "tokenScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of OAuth scopes to assign to `access_token` secrets generated under this static account (`access_token` static accounts only).\n"
                }
            },
            "requiredInputs": [
                "backend",
                "serviceAccountEmail",
                "staticAccount"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretStaticAccount resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Path where the GCP Secrets Engine is mounted\n",
                        "willReplaceOnChanges": true
                    },
                    "bindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:gcp/SecretStaticAccountBinding:SecretStaticAccountBinding"
                        },
                        "description": "Bindings to create for this static account. This can be specified multiple times for multiple bindings. Structure is documented below.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "secretType": {
                        "type": "string",
                        "description": "Type of secret generated for this static account. Accepted values: `access_token`, `service_account_key`. Defaults to `access_token`.\n",
                        "willReplaceOnChanges": true
                    },
                    "serviceAccountEmail": {
                        "type": "string",
                        "description": "Email of the GCP service account to manage.\n",
                        "willReplaceOnChanges": true
                    },
                    "serviceAccountProject": {
                        "type": "string",
                        "description": "Project the service account belongs to.\n"
                    },
                    "staticAccount": {
                        "type": "string",
                        "description": "Name of the Static Account to create\n",
                        "willReplaceOnChanges": true
                    },
                    "tokenScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of OAuth scopes to assign to `access_token` secrets generated under this static account (`access_token` static accounts only).\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:generic/endpoint:Endpoint": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst userpass = new vault.AuthBackend(\"userpass\", {type: \"userpass\"});\nconst u1 = new vault.generic.Endpoint(\"u1\", {\n    path: \"auth/userpass/users/u1\",\n    ignoreAbsentFields: true,\n    dataJson: `{\n  \"policies\": [\"p1\"],\n  \"password\": \"changeme\"\n}\n`,\n}, {\n    dependsOn: [userpass],\n});\nconst u1Token = new vault.generic.Endpoint(\"u1Token\", {\n    path: \"auth/userpass/login/u1\",\n    disableRead: true,\n    disableDelete: true,\n    dataJson: `{\n  \"password\": \"changeme\"\n}\n`,\n}, {\n    dependsOn: [u1],\n});\nconst u1Entity = new vault.generic.Endpoint(\"u1Entity\", {\n    disableRead: true,\n    disableDelete: true,\n    path: \"identity/lookup/entity\",\n    ignoreAbsentFields: true,\n    writeFields: [\"id\"],\n    dataJson: `{\n  \"alias_name\": \"u1\",\n  \"alias_mount_accessor\": vault_auth_backend.userpass.accessor\n}\n`,\n}, {\n    dependsOn: [u1Token],\n});\nexport const u1Id = u1Entity.writeData.id;\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var userpass = new Vault.AuthBackend(\"userpass\", new()\n    {\n        Type = \"userpass\",\n    });\n\n    var u1 = new Vault.Generic.Endpoint(\"u1\", new()\n    {\n        Path = \"auth/userpass/users/u1\",\n        IgnoreAbsentFields = true,\n        DataJson = @\"{\n  \"\"policies\"\": [\"\"p1\"\"],\n  \"\"password\"\": \"\"changeme\"\"\n}\n\",\n    }, new CustomResourceOptions\n    {\n        DependsOn = new[]\n        {\n            userpass,\n        },\n    });\n\n    var u1Token = new Vault.Generic.Endpoint(\"u1Token\", new()\n    {\n        Path = \"auth/userpass/login/u1\",\n        DisableRead = true,\n        DisableDelete = true,\n        DataJson = @\"{\n  \"\"password\"\": \"\"changeme\"\"\n}\n\",\n    }, new CustomResourceOptions\n    {\n        DependsOn = new[]\n        {\n            u1,\n        },\n    });\n\n    var u1Entity = new Vault.Generic.Endpoint(\"u1Entity\", new()\n    {\n        DisableRead = true,\n        DisableDelete = true,\n        Path = \"identity/lookup/entity\",\n        IgnoreAbsentFields = true,\n        WriteFields = new[]\n        {\n            \"id\",\n        },\n        DataJson = @\"{\n  \"\"alias_name\"\": \"\"u1\"\",\n  \"\"alias_mount_accessor\"\": vault_auth_backend.userpass.accessor\n}\n\",\n    }, new CustomResourceOptions\n    {\n        DependsOn = new[]\n        {\n            u1Token,\n        },\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"u1Id\"] = u1Entity.WriteData.Apply(writeData =\u003e writeData.Id),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/generic\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tuserpass, err := vault.NewAuthBackend(ctx, \"userpass\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"userpass\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tu1, err := generic.NewEndpoint(ctx, \"u1\", \u0026generic.EndpointArgs{\n\t\t\tPath:               pulumi.String(\"auth/userpass/users/u1\"),\n\t\t\tIgnoreAbsentFields: pulumi.Bool(true),\n\t\t\tDataJson:           pulumi.String(\"{\\n  \\\"policies\\\": [\\\"p1\\\"],\\n  \\\"password\\\": \\\"changeme\\\"\\n}\\n\"),\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\tuserpass,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tu1Token, err := generic.NewEndpoint(ctx, \"u1Token\", \u0026generic.EndpointArgs{\n\t\t\tPath:          pulumi.String(\"auth/userpass/login/u1\"),\n\t\t\tDisableRead:   pulumi.Bool(true),\n\t\t\tDisableDelete: pulumi.Bool(true),\n\t\t\tDataJson:      pulumi.String(\"{\\n  \\\"password\\\": \\\"changeme\\\"\\n}\\n\"),\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\tu1,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tu1Entity, err := generic.NewEndpoint(ctx, \"u1Entity\", \u0026generic.EndpointArgs{\n\t\t\tDisableRead:        pulumi.Bool(true),\n\t\t\tDisableDelete:      pulumi.Bool(true),\n\t\t\tPath:               pulumi.String(\"identity/lookup/entity\"),\n\t\t\tIgnoreAbsentFields: pulumi.Bool(true),\n\t\t\tWriteFields: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"id\"),\n\t\t\t},\n\t\t\tDataJson: pulumi.String(\"{\\n  \\\"alias_name\\\": \\\"u1\\\",\\n  \\\"alias_mount_accessor\\\": vault_auth_backend.userpass.accessor\\n}\\n\"),\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\tu1Token,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"u1Id\", u1Entity.WriteData.ApplyT(func(writeData map[string]string) (string, error) {\n\t\t\treturn writeData.Id, nil\n\t\t}).(pulumi.StringOutput))\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.AuthBackend;\nimport com.pulumi.vault.AuthBackendArgs;\nimport com.pulumi.vault.generic.Endpoint;\nimport com.pulumi.vault.generic.EndpointArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var userpass = new AuthBackend(\"userpass\", AuthBackendArgs.builder()        \n            .type(\"userpass\")\n            .build());\n\n        var u1 = new Endpoint(\"u1\", EndpointArgs.builder()        \n            .path(\"auth/userpass/users/u1\")\n            .ignoreAbsentFields(true)\n            .dataJson(\"\"\"\n{\n  \"policies\": [\"p1\"],\n  \"password\": \"changeme\"\n}\n            \"\"\")\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(userpass)\n                .build());\n\n        var u1Token = new Endpoint(\"u1Token\", EndpointArgs.builder()        \n            .path(\"auth/userpass/login/u1\")\n            .disableRead(true)\n            .disableDelete(true)\n            .dataJson(\"\"\"\n{\n  \"password\": \"changeme\"\n}\n            \"\"\")\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(u1)\n                .build());\n\n        var u1Entity = new Endpoint(\"u1Entity\", EndpointArgs.builder()        \n            .disableRead(true)\n            .disableDelete(true)\n            .path(\"identity/lookup/entity\")\n            .ignoreAbsentFields(true)\n            .writeFields(\"id\")\n            .dataJson(\"\"\"\n{\n  \"alias_name\": \"u1\",\n  \"alias_mount_accessor\": vault_auth_backend.userpass.accessor\n}\n            \"\"\")\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(u1Token)\n                .build());\n\n        ctx.export(\"u1Id\", u1Entity.writeData().applyValue(writeData -\u003e writeData.id()));\n    }\n}\n```\n```yaml\nresources:\n  userpass:\n    type: vault:AuthBackend\n    properties:\n      type: userpass\n  u1:\n    type: vault:generic:Endpoint\n    properties:\n      path: auth/userpass/users/u1\n      ignoreAbsentFields: true\n      dataJson: |\n        {\n          \"policies\": [\"p1\"],\n          \"password\": \"changeme\"\n        }\n    options:\n      dependson:\n        - ${userpass}\n  u1Token:\n    type: vault:generic:Endpoint\n    properties:\n      path: auth/userpass/login/u1\n      disableRead: true\n      disableDelete: true\n      dataJson: |\n        {\n          \"password\": \"changeme\"\n        }\n    options:\n      dependson:\n        - ${u1}\n  u1Entity:\n    type: vault:generic:Endpoint\n    properties:\n      disableRead: true\n      disableDelete: true\n      path: identity/lookup/entity\n      ignoreAbsentFields: true\n      writeFields:\n        - id\n      dataJson: |\n        {\n          \"alias_name\": \"u1\",\n          \"alias_mount_accessor\": vault_auth_backend.userpass.accessor\n        }\n    options:\n      dependson:\n        - ${u1Token}\noutputs:\n  u1Id: ${u1Entity.writeData.id}\n```\n{{% /example %}}\n{{% /examples %}}\n## Required Vault Capabilities\n\nUse of this resource requires the `create` or `update` capability\n(depending on whether the resource already exists) on the given path. If\n`disable_delete` is false, the `delete` capbility is also required. If\n`disable_delete` is false, the `read` capbility is required.\n\n\n## Import\n\nImport is not supported for this resource. ",
            "properties": {
                "dataJson": {
                    "type": "string",
                    "description": "String containing a JSON-encoded object that will be\nwritten to the given path as the secret data.\n",
                    "secret": true
                },
                "disableDelete": {
                    "type": "boolean",
                    "description": "Don't attempt to delete the path from Vault if true\n"
                },
                "disableRead": {
                    "type": "boolean",
                    "description": "True/false. Set this to true if your vault\nauthentication is not able to read the data or if the endpoint does\nnot support the `GET` method. Setting this to `true` will break drift\ndetection. You should set this to `true` for endpoints that are\nwrite-only. Defaults to false.\n"
                },
                "ignoreAbsentFields": {
                    "type": "boolean",
                    "description": "When reading, disregard fields not present in data_json\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The full logical path at which to write the given\ndata. Consult each backend's documentation to see which endpoints\nsupport the `PUT` methods and to determine whether they also support\n`DELETE` and `GET`.\n"
                },
                "writeData": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of strings returned by write operation\n"
                },
                "writeDataJson": {
                    "type": "string",
                    "description": "JSON data returned by write operation\n"
                },
                "writeFields": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Top-level fields returned by write to persist in state\n"
                }
            },
            "required": [
                "dataJson",
                "path",
                "writeData",
                "writeDataJson"
            ],
            "inputProperties": {
                "dataJson": {
                    "type": "string",
                    "description": "String containing a JSON-encoded object that will be\nwritten to the given path as the secret data.\n",
                    "secret": true
                },
                "disableDelete": {
                    "type": "boolean",
                    "description": "Don't attempt to delete the path from Vault if true\n"
                },
                "disableRead": {
                    "type": "boolean",
                    "description": "True/false. Set this to true if your vault\nauthentication is not able to read the data or if the endpoint does\nnot support the `GET` method. Setting this to `true` will break drift\ndetection. You should set this to `true` for endpoints that are\nwrite-only. Defaults to false.\n"
                },
                "ignoreAbsentFields": {
                    "type": "boolean",
                    "description": "When reading, disregard fields not present in data_json\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "The full logical path at which to write the given\ndata. Consult each backend's documentation to see which endpoints\nsupport the `PUT` methods and to determine whether they also support\n`DELETE` and `GET`.\n",
                    "willReplaceOnChanges": true
                },
                "writeFields": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Top-level fields returned by write to persist in state\n"
                }
            },
            "requiredInputs": [
                "dataJson",
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Endpoint resources.\n",
                "properties": {
                    "dataJson": {
                        "type": "string",
                        "description": "String containing a JSON-encoded object that will be\nwritten to the given path as the secret data.\n",
                        "secret": true
                    },
                    "disableDelete": {
                        "type": "boolean",
                        "description": "Don't attempt to delete the path from Vault if true\n"
                    },
                    "disableRead": {
                        "type": "boolean",
                        "description": "True/false. Set this to true if your vault\nauthentication is not able to read the data or if the endpoint does\nnot support the `GET` method. Setting this to `true` will break drift\ndetection. You should set this to `true` for endpoints that are\nwrite-only. Defaults to false.\n"
                    },
                    "ignoreAbsentFields": {
                        "type": "boolean",
                        "description": "When reading, disregard fields not present in data_json\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "The full logical path at which to write the given\ndata. Consult each backend's documentation to see which endpoints\nsupport the `PUT` methods and to determine whether they also support\n`DELETE` and `GET`.\n",
                        "willReplaceOnChanges": true
                    },
                    "writeData": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of strings returned by write operation\n"
                    },
                    "writeDataJson": {
                        "type": "string",
                        "description": "JSON data returned by write operation\n"
                    },
                    "writeFields": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Top-level fields returned by write to persist in state\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:generic/secret:Secret": {
            "description": "\n\n\n## Import\n\nGeneric secrets can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:generic/secret:Secret example secret/foo\n```\n\n ",
            "properties": {
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A mapping whose keys are the top-level data keys returned from\nVault and whose values are the corresponding values. This map can only\nrepresent string data, so any non-string values returned from Vault are\nserialized as JSON.\n",
                    "secret": true
                },
                "dataJson": {
                    "type": "string",
                    "description": "String containing a JSON-encoded object that will be\nwritten as the secret data at the given path.\n",
                    "secret": true
                },
                "deleteAllVersions": {
                    "type": "boolean",
                    "description": "true/false.  Only applicable for kv-v2 stores.\nIf set to `true`, permanently deletes all versions for\nthe specified key. The default behavior is to only delete the latest version of the\nsecret.\n"
                },
                "disableRead": {
                    "type": "boolean",
                    "description": "true/false. Set this to true if your vault\nauthentication is not able to read the data. Setting this to `true` will\nbreak drift detection. Defaults to false.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The full logical path at which to write the given data.\nTo write data into the \"generic\" secret backend mounted in Vault by default,\nthis should be prefixed with `secret/`. Writing to other backends with this\nresource is possible; consult each backend's documentation to see which\nendpoints support the `PUT` and `DELETE` methods.\n"
                }
            },
            "required": [
                "data",
                "dataJson",
                "path"
            ],
            "inputProperties": {
                "dataJson": {
                    "type": "string",
                    "description": "String containing a JSON-encoded object that will be\nwritten as the secret data at the given path.\n",
                    "secret": true
                },
                "deleteAllVersions": {
                    "type": "boolean",
                    "description": "true/false.  Only applicable for kv-v2 stores.\nIf set to `true`, permanently deletes all versions for\nthe specified key. The default behavior is to only delete the latest version of the\nsecret.\n"
                },
                "disableRead": {
                    "type": "boolean",
                    "description": "true/false. Set this to true if your vault\nauthentication is not able to read the data. Setting this to `true` will\nbreak drift detection. Defaults to false.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "The full logical path at which to write the given data.\nTo write data into the \"generic\" secret backend mounted in Vault by default,\nthis should be prefixed with `secret/`. Writing to other backends with this\nresource is possible; consult each backend's documentation to see which\nendpoints support the `PUT` and `DELETE` methods.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "dataJson",
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Secret resources.\n",
                "properties": {
                    "data": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A mapping whose keys are the top-level data keys returned from\nVault and whose values are the corresponding values. This map can only\nrepresent string data, so any non-string values returned from Vault are\nserialized as JSON.\n",
                        "secret": true
                    },
                    "dataJson": {
                        "type": "string",
                        "description": "String containing a JSON-encoded object that will be\nwritten as the secret data at the given path.\n",
                        "secret": true
                    },
                    "deleteAllVersions": {
                        "type": "boolean",
                        "description": "true/false.  Only applicable for kv-v2 stores.\nIf set to `true`, permanently deletes all versions for\nthe specified key. The default behavior is to only delete the latest version of the\nsecret.\n"
                    },
                    "disableRead": {
                        "type": "boolean",
                        "description": "true/false. Set this to true if your vault\nauthentication is not able to read the data. Setting this to `true` will\nbreak drift detection. Defaults to false.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "The full logical path at which to write the given data.\nTo write data into the \"generic\" secret backend mounted in Vault by default,\nthis should be prefixed with `secret/`. Writing to other backends with this\nresource is possible; consult each backend's documentation to see which\nendpoints support the `PUT` and `DELETE` methods.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:github/authBackend:AuthBackend": {
            "description": "Manages a GitHub Auth mount in a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/github/) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.github.AuthBackend(\"example\", {\n    organization: \"myorg\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.github.AuthBackend(\"example\", organization=\"myorg\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Vault.GitHub.AuthBackend(\"example\", new()\n    {\n        Organization = \"myorg\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/github\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := github.NewAuthBackend(ctx, \"example\", \u0026github.AuthBackendArgs{\n\t\t\tOrganization: pulumi.String(\"myorg\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.github.AuthBackend;\nimport com.pulumi.vault.github.AuthBackendArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new AuthBackend(\"example\", AuthBackendArgs.builder()        \n            .organization(\"myorg\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: vault:github:AuthBackend\n    properties:\n      organization: myorg\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitHub authentication mounts can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:github/authBackend:AuthBackend example github\n```\n\n ",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The mount accessor related to the auth mount. It is useful for integration with [Identity Secrets Engine](https://www.vaultproject.io/docs/secrets/identity/index.html).\n"
                },
                "baseUrl": {
                    "type": "string",
                    "description": "The API endpoint to use. Useful if you\nare running GitHub Enterprise or an API-compatible authentication server.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Specifies the description of the mount.\nThis overrides the current stored value, if any.\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization configured users must be part of.\n"
                },
                "organizationId": {
                    "type": "integer",
                    "description": "The ID of the organization users must be part of.\nVault will attempt to fetch and set this value if it is not provided. (Vault 1.10+)\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path where the auth backend is mounted. Defaults to `auth/github`\nif not specified.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Optional) List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "(Optional) If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "(Optional) The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "(Optional) If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "(Optional) The [maximum number](https://www.vaultproject.io/api-docs/github#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "(Optional) If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Optional) List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "(Optional) The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "Specifies the type of tokens that should be returned by\nthe mount. Valid values are \"default-service\", \"default-batch\", \"service\", \"batch\".\n"
                },
                "tune": {
                    "$ref": "#/types/vault:github/AuthBackendTune:AuthBackendTune",
                    "description": "Extra configuration block. Structure is documented below.\n"
                }
            },
            "required": [
                "accessor",
                "organization",
                "organizationId",
                "tune"
            ],
            "inputProperties": {
                "baseUrl": {
                    "type": "string",
                    "description": "The API endpoint to use. Useful if you\nare running GitHub Enterprise or an API-compatible authentication server.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Specifies the description of the mount.\nThis overrides the current stored value, if any.\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "organization": {
                    "type": "string",
                    "description": "The organization configured users must be part of.\n"
                },
                "organizationId": {
                    "type": "integer",
                    "description": "The ID of the organization users must be part of.\nVault will attempt to fetch and set this value if it is not provided. (Vault 1.10+)\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path where the auth backend is mounted. Defaults to `auth/github`\nif not specified.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Optional) List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "(Optional) If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "(Optional) The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "(Optional) If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "(Optional) The [maximum number](https://www.vaultproject.io/api-docs/github#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "(Optional) If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Optional) List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "(Optional) The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "Specifies the type of tokens that should be returned by\nthe mount. Valid values are \"default-service\", \"default-batch\", \"service\", \"batch\".\n"
                },
                "tune": {
                    "$ref": "#/types/vault:github/AuthBackendTune:AuthBackendTune",
                    "description": "Extra configuration block. Structure is documented below.\n"
                }
            },
            "requiredInputs": [
                "organization"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackend resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The mount accessor related to the auth mount. It is useful for integration with [Identity Secrets Engine](https://www.vaultproject.io/docs/secrets/identity/index.html).\n"
                    },
                    "baseUrl": {
                        "type": "string",
                        "description": "The API endpoint to use. Useful if you\nare running GitHub Enterprise or an API-compatible authentication server.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Specifies the description of the mount.\nThis overrides the current stored value, if any.\n"
                    },
                    "disableRemount": {
                        "type": "boolean",
                        "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "organization": {
                        "type": "string",
                        "description": "The organization configured users must be part of.\n"
                    },
                    "organizationId": {
                        "type": "integer",
                        "description": "The ID of the organization users must be part of.\nVault will attempt to fetch and set this value if it is not provided. (Vault 1.10+)\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Path where the auth backend is mounted. Defaults to `auth/github`\nif not specified.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(Optional) List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "(Optional) If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "(Optional) The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "(Optional) If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "(Optional) The [maximum number](https://www.vaultproject.io/api-docs/github#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "(Optional) If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(Optional) List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "(Optional) The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "Specifies the type of tokens that should be returned by\nthe mount. Valid values are \"default-service\", \"default-batch\", \"service\", \"batch\".\n"
                    },
                    "tune": {
                        "$ref": "#/types/vault:github/AuthBackendTune:AuthBackendTune",
                        "description": "Extra configuration block. Structure is documented below.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:github/team:Team": {
            "description": "Manages policy mappings for Github Teams authenticated via Github. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/github/) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.github.AuthBackend(\"example\", {organization: \"myorg\"});\nconst tfDevs = new vault.github.Team(\"tfDevs\", {\n    backend: example.id,\n    team: \"terraform-developers\",\n    policies: [\n        \"developer\",\n        \"read-only\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.github.AuthBackend(\"example\", organization=\"myorg\")\ntf_devs = vault.github.Team(\"tfDevs\",\n    backend=example.id,\n    team=\"terraform-developers\",\n    policies=[\n        \"developer\",\n        \"read-only\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Vault.GitHub.AuthBackend(\"example\", new()\n    {\n        Organization = \"myorg\",\n    });\n\n    var tfDevs = new Vault.GitHub.Team(\"tfDevs\", new()\n    {\n        Backend = example.Id,\n        TeamCity = \"terraform-developers\",\n        Policies = new[]\n        {\n            \"developer\",\n            \"read-only\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/github\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := github.NewAuthBackend(ctx, \"example\", \u0026github.AuthBackendArgs{\n\t\t\tOrganization: pulumi.String(\"myorg\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = github.NewTeam(ctx, \"tfDevs\", \u0026github.TeamArgs{\n\t\t\tBackend: example.ID(),\n\t\t\tTeam:    pulumi.String(\"terraform-developers\"),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"developer\"),\n\t\t\t\tpulumi.String(\"read-only\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.github.AuthBackend;\nimport com.pulumi.vault.github.AuthBackendArgs;\nimport com.pulumi.vault.github.Team;\nimport com.pulumi.vault.github.TeamArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new AuthBackend(\"example\", AuthBackendArgs.builder()        \n            .organization(\"myorg\")\n            .build());\n\n        var tfDevs = new Team(\"tfDevs\", TeamArgs.builder()        \n            .backend(example.id())\n            .team(\"terraform-developers\")\n            .policies(            \n                \"developer\",\n                \"read-only\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: vault:github:AuthBackend\n    properties:\n      organization: myorg\n  tfDevs:\n    type: vault:github:Team\n    properties:\n      backend: ${example.id}\n      team: terraform-developers\n      policies:\n        - developer\n        - read-only\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGithub team mappings can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:github/team:Team tf_devs auth/github/map/teams/terraform-developers\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the github auth backend is mounted. Defaults to `github`\nif not specified.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings specifying the policies to be set on tokens\nissued using this role.\n"
                },
                "team": {
                    "type": "string",
                    "description": "GitHub team name in \"slugified\" format.\n",
                    "language": {
                        "csharp": {
                            "name": "TeamCity"
                        }
                    }
                }
            },
            "required": [
                "team"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the github auth backend is mounted. Defaults to `github`\nif not specified.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings specifying the policies to be set on tokens\nissued using this role.\n"
                },
                "team": {
                    "type": "string",
                    "description": "GitHub team name in \"slugified\" format.\n",
                    "language": {
                        "csharp": {
                            "name": "TeamCity"
                        }
                    },
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "team"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Team resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Path where the github auth backend is mounted. Defaults to `github`\nif not specified.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of strings specifying the policies to be set on tokens\nissued using this role.\n"
                    },
                    "team": {
                        "type": "string",
                        "description": "GitHub team name in \"slugified\" format.\n",
                        "language": {
                            "csharp": {
                                "name": "TeamCity"
                            }
                        },
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:github/user:User": {
            "description": "Manages policy mappings for Github Users authenticated via Github. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/github/) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.github.AuthBackend(\"example\", {organization: \"myorg\"});\nconst tfUser = new vault.github.User(\"tfUser\", {\n    backend: example.id,\n    user: \"john.doe\",\n    policies: [\n        \"developer\",\n        \"read-only\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.github.AuthBackend(\"example\", organization=\"myorg\")\ntf_user = vault.github.User(\"tfUser\",\n    backend=example.id,\n    user=\"john.doe\",\n    policies=[\n        \"developer\",\n        \"read-only\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Vault.GitHub.AuthBackend(\"example\", new()\n    {\n        Organization = \"myorg\",\n    });\n\n    var tfUser = new Vault.GitHub.User(\"tfUser\", new()\n    {\n        Backend = example.Id,\n        UserName = \"john.doe\",\n        Policies = new[]\n        {\n            \"developer\",\n            \"read-only\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/github\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := github.NewAuthBackend(ctx, \"example\", \u0026github.AuthBackendArgs{\n\t\t\tOrganization: pulumi.String(\"myorg\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = github.NewUser(ctx, \"tfUser\", \u0026github.UserArgs{\n\t\t\tBackend: example.ID(),\n\t\t\tUser:    pulumi.String(\"john.doe\"),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"developer\"),\n\t\t\t\tpulumi.String(\"read-only\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.github.AuthBackend;\nimport com.pulumi.vault.github.AuthBackendArgs;\nimport com.pulumi.vault.github.User;\nimport com.pulumi.vault.github.UserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new AuthBackend(\"example\", AuthBackendArgs.builder()        \n            .organization(\"myorg\")\n            .build());\n\n        var tfUser = new User(\"tfUser\", UserArgs.builder()        \n            .backend(example.id())\n            .user(\"john.doe\")\n            .policies(            \n                \"developer\",\n                \"read-only\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: vault:github:AuthBackend\n    properties:\n      organization: myorg\n  tfUser:\n    type: vault:github:User\n    properties:\n      backend: ${example.id}\n      user: john.doe\n      policies:\n        - developer\n        - read-only\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGithub user mappings can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:github/user:User tf_user auth/github/map/users/john.doe\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the github auth backend is mounted. Defaults to `github`\nif not specified.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings specifying the policies to be set on tokens issued\nusing this role.\n"
                },
                "user": {
                    "type": "string",
                    "description": "GitHub user name.\n",
                    "language": {
                        "csharp": {
                            "name": "UserName"
                        }
                    }
                }
            },
            "required": [
                "user"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the github auth backend is mounted. Defaults to `github`\nif not specified.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings specifying the policies to be set on tokens issued\nusing this role.\n"
                },
                "user": {
                    "type": "string",
                    "description": "GitHub user name.\n",
                    "language": {
                        "csharp": {
                            "name": "UserName"
                        }
                    },
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "user"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering User resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Path where the github auth backend is mounted. Defaults to `github`\nif not specified.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of strings specifying the policies to be set on tokens issued\nusing this role.\n"
                    },
                    "user": {
                        "type": "string",
                        "description": "GitHub user name.\n",
                        "language": {
                            "csharp": {
                                "name": "UserName"
                            }
                        },
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/entity:Entity": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst test = new vault.identity.Entity(\"test\", {\n    metadata: {\n        foo: \"bar\",\n    },\n    policies: [\"test\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntest = vault.identity.Entity(\"test\",\n    metadata={\n        \"foo\": \"bar\",\n    },\n    policies=[\"test\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Vault.Identity.Entity(\"test\", new()\n    {\n        Metadata = \n        {\n            { \"foo\", \"bar\" },\n        },\n        Policies = new[]\n        {\n            \"test\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := identity.NewEntity(ctx, \"test\", \u0026identity.EntityArgs{\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"foo\": pulumi.String(\"bar\"),\n\t\t\t},\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.Entity;\nimport com.pulumi.vault.identity.EntityArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new Entity(\"test\", EntityArgs.builder()        \n            .metadata(Map.of(\"foo\", \"bar\"))\n            .policies(\"test\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: vault:identity:Entity\n    properties:\n      metadata:\n        foo: bar\n      policies:\n        - test\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nIdentity entity can be imported using the `id`, e.g.\n\n```sh\n $ pulumi import vault:identity/entity:Entity test \"ae6f8ued-0f1a-9f6b-2915-1a2be20dc053\"\n```\n\n ",
            "properties": {
                "disabled": {
                    "type": "boolean",
                    "description": "True/false Is this entity currently disabled. Defaults to `false`\n"
                },
                "externalPolicies": {
                    "type": "boolean",
                    "description": "`false` by default. If set to `true`, this resource will ignore any policies return from Vault or specified in the resource. You can use `vault.identity.EntityPolicies` to manage policies for this entity in a decoupled manner.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A Map of additional metadata to associate with the user.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the identity entity to create.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of policies to apply to the entity.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "disabled": {
                    "type": "boolean",
                    "description": "True/false Is this entity currently disabled. Defaults to `false`\n"
                },
                "externalPolicies": {
                    "type": "boolean",
                    "description": "`false` by default. If set to `true`, this resource will ignore any policies return from Vault or specified in the resource. You can use `vault.identity.EntityPolicies` to manage policies for this entity in a decoupled manner.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A Map of additional metadata to associate with the user.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the identity entity to create.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of policies to apply to the entity.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Entity resources.\n",
                "properties": {
                    "disabled": {
                        "type": "boolean",
                        "description": "True/false Is this entity currently disabled. Defaults to `false`\n"
                    },
                    "externalPolicies": {
                        "type": "boolean",
                        "description": "`false` by default. If set to `true`, this resource will ignore any policies return from Vault or specified in the resource. You can use `vault.identity.EntityPolicies` to manage policies for this entity in a decoupled manner.\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A Map of additional metadata to associate with the user.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the identity entity to create.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of policies to apply to the entity.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/entityAlias:EntityAlias": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst test = new vault.identity.EntityAlias(\"test\", {\n    canonicalId: \"49877D63-07AD-4B85-BDA8-B61626C477E8\",\n    mountAccessor: \"token_1f2bd5\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntest = vault.identity.EntityAlias(\"test\",\n    canonical_id=\"49877D63-07AD-4B85-BDA8-B61626C477E8\",\n    mount_accessor=\"token_1f2bd5\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Vault.Identity.EntityAlias(\"test\", new()\n    {\n        CanonicalId = \"49877D63-07AD-4B85-BDA8-B61626C477E8\",\n        MountAccessor = \"token_1f2bd5\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := identity.NewEntityAlias(ctx, \"test\", \u0026identity.EntityAliasArgs{\n\t\t\tCanonicalId:   pulumi.String(\"49877D63-07AD-4B85-BDA8-B61626C477E8\"),\n\t\t\tMountAccessor: pulumi.String(\"token_1f2bd5\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.EntityAlias;\nimport com.pulumi.vault.identity.EntityAliasArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new EntityAlias(\"test\", EntityAliasArgs.builder()        \n            .canonicalId(\"49877D63-07AD-4B85-BDA8-B61626C477E8\")\n            .mountAccessor(\"token_1f2bd5\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: vault:identity:EntityAlias\n    properties:\n      canonicalId: 49877D63-07AD-4B85-BDA8-B61626C477E8\n      mountAccessor: token_1f2bd5\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nIdentity entity alias can be imported using the `id`, e.g.\n\n```sh\n $ pulumi import vault:identity/entityAlias:EntityAlias test \"3856fb4d-3c91-dcaf-2401-68f446796bfb\"\n```\n\n ",
            "properties": {
                "canonicalId": {
                    "type": "string",
                    "description": "Entity ID to which this alias belongs to.\n"
                },
                "customMetadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Custom metadata to be associated with this alias.\n"
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "Accessor of the mount to which the alias should belong to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the alias. Name should be the identifier of the client in the authentication source. For example, if the alias belongs to userpass backend, the name should be a valid username within userpass backend. If alias belongs to GitHub, it should be the GitHub username.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                }
            },
            "required": [
                "canonicalId",
                "mountAccessor",
                "name"
            ],
            "inputProperties": {
                "canonicalId": {
                    "type": "string",
                    "description": "Entity ID to which this alias belongs to.\n"
                },
                "customMetadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Custom metadata to be associated with this alias.\n"
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "Accessor of the mount to which the alias should belong to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the alias. Name should be the identifier of the client in the authentication source. For example, if the alias belongs to userpass backend, the name should be a valid username within userpass backend. If alias belongs to GitHub, it should be the GitHub username.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "canonicalId",
                "mountAccessor"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EntityAlias resources.\n",
                "properties": {
                    "canonicalId": {
                        "type": "string",
                        "description": "Entity ID to which this alias belongs to.\n"
                    },
                    "customMetadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Custom metadata to be associated with this alias.\n"
                    },
                    "mountAccessor": {
                        "type": "string",
                        "description": "Accessor of the mount to which the alias should belong to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the alias. Name should be the identifier of the client in the authentication source. For example, if the alias belongs to userpass backend, the name should be a valid username within userpass backend. If alias belongs to GitHub, it should be the GitHub username.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/entityPolicies:EntityPolicies": {
            "description": "Manages policies for an Identity Entity for Vault. The [Identity secrets engine](https://www.vaultproject.io/docs/secrets/identity/index.html) is the identity management solution for Vault.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Exclusive Policies\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst entity = new vault.identity.Entity(\"entity\", {externalPolicies: true});\nconst policies = new vault.identity.EntityPolicies(\"policies\", {\n    policies: [\n        \"default\",\n        \"test\",\n    ],\n    exclusive: true,\n    entityId: entity.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nentity = vault.identity.Entity(\"entity\", external_policies=True)\npolicies = vault.identity.EntityPolicies(\"policies\",\n    policies=[\n        \"default\",\n        \"test\",\n    ],\n    exclusive=True,\n    entity_id=entity.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var entity = new Vault.Identity.Entity(\"entity\", new()\n    {\n        ExternalPolicies = true,\n    });\n\n    var policies = new Vault.Identity.EntityPolicies(\"policies\", new()\n    {\n        Policies = new[]\n        {\n            \"default\",\n            \"test\",\n        },\n        Exclusive = true,\n        EntityId = entity.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tentity, err := identity.NewEntity(ctx, \"entity\", \u0026identity.EntityArgs{\n\t\t\tExternalPolicies: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewEntityPolicies(ctx, \"policies\", \u0026identity.EntityPoliciesArgs{\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tExclusive: pulumi.Bool(true),\n\t\t\tEntityId:  entity.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.Entity;\nimport com.pulumi.vault.identity.EntityArgs;\nimport com.pulumi.vault.identity.EntityPolicies;\nimport com.pulumi.vault.identity.EntityPoliciesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var entity = new Entity(\"entity\", EntityArgs.builder()        \n            .externalPolicies(true)\n            .build());\n\n        var policies = new EntityPolicies(\"policies\", EntityPoliciesArgs.builder()        \n            .policies(            \n                \"default\",\n                \"test\")\n            .exclusive(true)\n            .entityId(entity.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  entity:\n    type: vault:identity:Entity\n    properties:\n      externalPolicies: true\n  policies:\n    type: vault:identity:EntityPolicies\n    properties:\n      policies:\n        - default\n        - test\n      exclusive: true\n      entityId: ${entity.id}\n```\n{{% /example %}}\n{{% example %}}\n### Non-exclusive Policies\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst entity = new vault.identity.Entity(\"entity\", {externalPolicies: true});\nconst _default = new vault.identity.EntityPolicies(\"default\", {\n    policies: [\n        \"default\",\n        \"test\",\n    ],\n    exclusive: false,\n    entityId: entity.id,\n});\nconst others = new vault.identity.EntityPolicies(\"others\", {\n    policies: [\"others\"],\n    exclusive: false,\n    entityId: entity.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nentity = vault.identity.Entity(\"entity\", external_policies=True)\ndefault = vault.identity.EntityPolicies(\"default\",\n    policies=[\n        \"default\",\n        \"test\",\n    ],\n    exclusive=False,\n    entity_id=entity.id)\nothers = vault.identity.EntityPolicies(\"others\",\n    policies=[\"others\"],\n    exclusive=False,\n    entity_id=entity.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var entity = new Vault.Identity.Entity(\"entity\", new()\n    {\n        ExternalPolicies = true,\n    });\n\n    var @default = new Vault.Identity.EntityPolicies(\"default\", new()\n    {\n        Policies = new[]\n        {\n            \"default\",\n            \"test\",\n        },\n        Exclusive = false,\n        EntityId = entity.Id,\n    });\n\n    var others = new Vault.Identity.EntityPolicies(\"others\", new()\n    {\n        Policies = new[]\n        {\n            \"others\",\n        },\n        Exclusive = false,\n        EntityId = entity.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tentity, err := identity.NewEntity(ctx, \"entity\", \u0026identity.EntityArgs{\n\t\t\tExternalPolicies: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewEntityPolicies(ctx, \"default\", \u0026identity.EntityPoliciesArgs{\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tExclusive: pulumi.Bool(false),\n\t\t\tEntityId:  entity.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewEntityPolicies(ctx, \"others\", \u0026identity.EntityPoliciesArgs{\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"others\"),\n\t\t\t},\n\t\t\tExclusive: pulumi.Bool(false),\n\t\t\tEntityId:  entity.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.Entity;\nimport com.pulumi.vault.identity.EntityArgs;\nimport com.pulumi.vault.identity.EntityPolicies;\nimport com.pulumi.vault.identity.EntityPoliciesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var entity = new Entity(\"entity\", EntityArgs.builder()        \n            .externalPolicies(true)\n            .build());\n\n        var default_ = new EntityPolicies(\"default\", EntityPoliciesArgs.builder()        \n            .policies(            \n                \"default\",\n                \"test\")\n            .exclusive(false)\n            .entityId(entity.id())\n            .build());\n\n        var others = new EntityPolicies(\"others\", EntityPoliciesArgs.builder()        \n            .policies(\"others\")\n            .exclusive(false)\n            .entityId(entity.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  entity:\n    type: vault:identity:Entity\n    properties:\n      externalPolicies: true\n  default:\n    type: vault:identity:EntityPolicies\n    properties:\n      policies:\n        - default\n        - test\n      exclusive: false\n      entityId: ${entity.id}\n  others:\n    type: vault:identity:EntityPolicies\n    properties:\n      policies:\n        - others\n      exclusive: false\n      entityId: ${entity.id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "entityId": {
                    "type": "string",
                    "description": "Entity ID to assign policies to.\n"
                },
                "entityName": {
                    "type": "string",
                    "description": "The name of the entity that are assigned the policies.\n"
                },
                "exclusive": {
                    "type": "boolean",
                    "description": "Defaults to `true`.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to assign to the entity\n"
                }
            },
            "required": [
                "entityId",
                "entityName",
                "policies"
            ],
            "inputProperties": {
                "entityId": {
                    "type": "string",
                    "description": "Entity ID to assign policies to.\n"
                },
                "exclusive": {
                    "type": "boolean",
                    "description": "Defaults to `true`.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to assign to the entity\n"
                }
            },
            "requiredInputs": [
                "entityId",
                "policies"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EntityPolicies resources.\n",
                "properties": {
                    "entityId": {
                        "type": "string",
                        "description": "Entity ID to assign policies to.\n"
                    },
                    "entityName": {
                        "type": "string",
                        "description": "The name of the entity that are assigned the policies.\n"
                    },
                    "exclusive": {
                        "type": "boolean",
                        "description": "Defaults to `true`.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to assign to the entity\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/group:Group": {
            "description": "Creates an Identity Group for Vault. The [Identity secrets engine](https://www.vaultproject.io/docs/secrets/identity/index.html) is the identity management solution for Vault.\n\nA group can contain multiple entities as its members. A group can also have subgroups. Policies set on the group is granted to all members of the group. During request time, when the token's entity ID is being evaluated for the policies that it has access to; along with the policies on the entity itself, policies that are inherited due to group memberships are also granted.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Internal Group\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst internal = new vault.identity.Group(\"internal\", {\n    metadata: {\n        version: \"2\",\n    },\n    policies: [\n        \"dev\",\n        \"test\",\n    ],\n    type: \"internal\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ninternal = vault.identity.Group(\"internal\",\n    metadata={\n        \"version\": \"2\",\n    },\n    policies=[\n        \"dev\",\n        \"test\",\n    ],\n    type=\"internal\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @internal = new Vault.Identity.Group(\"internal\", new()\n    {\n        Metadata = \n        {\n            { \"version\", \"2\" },\n        },\n        Policies = new[]\n        {\n            \"dev\",\n            \"test\",\n        },\n        Type = \"internal\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := identity.NewGroup(ctx, \"internal\", \u0026identity.GroupArgs{\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"version\": pulumi.String(\"2\"),\n\t\t\t},\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"internal\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.Group;\nimport com.pulumi.vault.identity.GroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var internal = new Group(\"internal\", GroupArgs.builder()        \n            .metadata(Map.of(\"version\", \"2\"))\n            .policies(            \n                \"dev\",\n                \"test\")\n            .type(\"internal\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  internal:\n    type: vault:identity:Group\n    properties:\n      metadata:\n        version: 2\n      policies:\n        - dev\n        - test\n      type: internal\n```\n{{% /example %}}\n{{% example %}}\n### External Group\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst group = new vault.identity.Group(\"group\", {\n    metadata: {\n        version: \"1\",\n    },\n    policies: [\"test\"],\n    type: \"external\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ngroup = vault.identity.Group(\"group\",\n    metadata={\n        \"version\": \"1\",\n    },\n    policies=[\"test\"],\n    type=\"external\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @group = new Vault.Identity.Group(\"group\", new()\n    {\n        Metadata = \n        {\n            { \"version\", \"1\" },\n        },\n        Policies = new[]\n        {\n            \"test\",\n        },\n        Type = \"external\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := identity.NewGroup(ctx, \"group\", \u0026identity.GroupArgs{\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"version\": pulumi.String(\"1\"),\n\t\t\t},\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"external\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.Group;\nimport com.pulumi.vault.identity.GroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var group = new Group(\"group\", GroupArgs.builder()        \n            .metadata(Map.of(\"version\", \"1\"))\n            .policies(\"test\")\n            .type(\"external\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  group:\n    type: vault:identity:Group\n    properties:\n      metadata:\n        version: 1\n      policies:\n        - test\n      type: external\n```\n{{% /example %}}\n{{% /examples %}}\n## Caveats\n\nIt's important to note that Vault identity groups names are *case-insensitive*. For example the following resources would be equivalent.\nApplying this configuration would result in the provider failing to create one of the identity groups, since the resources share the same `name`.\n\nThis sort of pattern should be avoided:\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst internalIdentityGroup = new vault.identity.Group(\"internal\", {\n    metadata: {\n        version: \"2\",\n    },\n    policies: [\n        \"dev\",\n        \"test\",\n    ],\n    type: \"internal\",\n});\nconst internalGroup = new vault.identity.Group(\"Internal\", {\n    metadata: {\n        version: \"2\",\n    },\n    policies: [\n        \"dev\",\n        \"test\",\n    ],\n    type: \"internal\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ninternal_identity_group_group = vault.identity.Group(\"internalIdentity/groupGroup\",\n    metadata={\n        \"version\": \"2\",\n    },\n    policies=[\n        \"dev\",\n        \"test\",\n    ],\n    type=\"internal\")\ninternal_group = vault.identity.Group(\"internalGroup\",\n    metadata={\n        \"version\": \"2\",\n    },\n    policies=[\n        \"dev\",\n        \"test\",\n    ],\n    type=\"internal\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var internalIdentity_groupGroup = new Vault.Identity.Group(\"internalIdentity/groupGroup\", new()\n    {\n        Metadata = \n        {\n            { \"version\", \"2\" },\n        },\n        Policies = new[]\n        {\n            \"dev\",\n            \"test\",\n        },\n        Type = \"internal\",\n    });\n\n    var internalGroup = new Vault.Identity.Group(\"internalGroup\", new()\n    {\n        Metadata = \n        {\n            { \"version\", \"2\" },\n        },\n        Policies = new[]\n        {\n            \"dev\",\n            \"test\",\n        },\n        Type = \"internal\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := identity.NewGroup(ctx, \"internalIdentity/groupGroup\", \u0026identity.GroupArgs{\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"version\": pulumi.String(\"2\"),\n\t\t\t},\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"internal\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewGroup(ctx, \"internalGroup\", \u0026identity.GroupArgs{\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"version\": pulumi.String(\"2\"),\n\t\t\t},\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"internal\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.Group;\nimport com.pulumi.vault.identity.GroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var internalIdentity_groupGroup = new Group(\"internalIdentity/groupGroup\", GroupArgs.builder()        \n            .metadata(Map.of(\"version\", \"2\"))\n            .policies(            \n                \"dev\",\n                \"test\")\n            .type(\"internal\")\n            .build());\n\n        var internalGroup = new Group(\"internalGroup\", GroupArgs.builder()        \n            .metadata(Map.of(\"version\", \"2\"))\n            .policies(            \n                \"dev\",\n                \"test\")\n            .type(\"internal\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  internalIdentity/groupGroup:\n    type: vault:identity:Group\n    properties:\n      metadata:\n        version: 2\n      policies:\n        - dev\n        - test\n      type: internal\n  internalGroup:\n    type: vault:identity:Group\n    properties:\n      metadata:\n        version: 2\n      policies:\n        - dev\n        - test\n      type: internal\n```\n\n\n## Import\n\nIdentity group can be imported using the `id`, e.g.\n\n```sh\n $ pulumi import vault:identity/group:Group test 'fcbf1efb-2b69-4209-bed8-811e3475dad3'\n```\n\n ",
            "properties": {
                "externalMemberEntityIds": {
                    "type": "boolean",
                    "description": "`false` by default. If set to `true`, this resource will ignore any Entity IDs\nreturned from Vault or specified in the resource. You can use\n`vault.identity.GroupMemberEntityIds` to manage Entity IDs for this group in a\ndecoupled manner.\n"
                },
                "externalMemberGroupIds": {
                    "type": "boolean",
                    "description": "`false` by default. If set to `true`, this resource will ignore any Group IDs\nreturned from Vault or specified in the resource. You can use\n`vault.identity.GroupMemberGroupIds` to manage Group IDs for this group in a\ndecoupled manner.\n"
                },
                "externalPolicies": {
                    "type": "boolean",
                    "description": "`false` by default. If set to `true`, this resource will ignore any policies returned from\nVault or specified in the resource. You can use `vault.identity.GroupPolicies` to manage\npolicies for this group in a decoupled manner.\n"
                },
                "memberEntityIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of Entity IDs to be assigned as group members. Not allowed on `external` groups.\n"
                },
                "memberGroupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of Group IDs to be assigned as group members. Not allowed on `external` groups.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A Map of additional metadata to associate with the group.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the identity group to create.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of policies to apply to the group.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the group, internal or external. Defaults to `internal`.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "externalMemberEntityIds": {
                    "type": "boolean",
                    "description": "`false` by default. If set to `true`, this resource will ignore any Entity IDs\nreturned from Vault or specified in the resource. You can use\n`vault.identity.GroupMemberEntityIds` to manage Entity IDs for this group in a\ndecoupled manner.\n"
                },
                "externalMemberGroupIds": {
                    "type": "boolean",
                    "description": "`false` by default. If set to `true`, this resource will ignore any Group IDs\nreturned from Vault or specified in the resource. You can use\n`vault.identity.GroupMemberGroupIds` to manage Group IDs for this group in a\ndecoupled manner.\n"
                },
                "externalPolicies": {
                    "type": "boolean",
                    "description": "`false` by default. If set to `true`, this resource will ignore any policies returned from\nVault or specified in the resource. You can use `vault.identity.GroupPolicies` to manage\npolicies for this group in a decoupled manner.\n"
                },
                "memberEntityIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of Entity IDs to be assigned as group members. Not allowed on `external` groups.\n"
                },
                "memberGroupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of Group IDs to be assigned as group members. Not allowed on `external` groups.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A Map of additional metadata to associate with the group.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the identity group to create.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of policies to apply to the group.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the group, internal or external. Defaults to `internal`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Group resources.\n",
                "properties": {
                    "externalMemberEntityIds": {
                        "type": "boolean",
                        "description": "`false` by default. If set to `true`, this resource will ignore any Entity IDs\nreturned from Vault or specified in the resource. You can use\n`vault.identity.GroupMemberEntityIds` to manage Entity IDs for this group in a\ndecoupled manner.\n"
                    },
                    "externalMemberGroupIds": {
                        "type": "boolean",
                        "description": "`false` by default. If set to `true`, this resource will ignore any Group IDs\nreturned from Vault or specified in the resource. You can use\n`vault.identity.GroupMemberGroupIds` to manage Group IDs for this group in a\ndecoupled manner.\n"
                    },
                    "externalPolicies": {
                        "type": "boolean",
                        "description": "`false` by default. If set to `true`, this resource will ignore any policies returned from\nVault or specified in the resource. You can use `vault.identity.GroupPolicies` to manage\npolicies for this group in a decoupled manner.\n"
                    },
                    "memberEntityIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of Entity IDs to be assigned as group members. Not allowed on `external` groups.\n"
                    },
                    "memberGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of Group IDs to be assigned as group members. Not allowed on `external` groups.\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A Map of additional metadata to associate with the group.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the identity group to create.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of policies to apply to the group.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of the group, internal or external. Defaults to `internal`.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/groupAlias:GroupAlias": {
            "description": "Creates an Identity Group Alias for Vault. The [Identity secrets engine](https://www.vaultproject.io/docs/secrets/identity/index.html) is the identity management solution for Vault.\n\nGroup aliases allows entity membership in external groups to be managed semi-automatically. External group serves as a mapping to a group that is outside of the identity store. External groups can have one (and only one) alias. This alias should map to a notion of group that is outside of the identity store. For example, groups in LDAP, and teams in GitHub. A username in LDAP, belonging to a group in LDAP, can get its entity ID added as a member of a group in Vault automatically during logins and token renewals. This works only if the group in Vault is an external group and has an alias that maps to the group in LDAP. If the user is removed from the group in LDAP, that change gets reflected in Vault only upon the subsequent login or renewal operation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst group = new vault.identity.Group(\"group\", {\n    type: \"external\",\n    policies: [\"test\"],\n});\nconst github = new vault.AuthBackend(\"github\", {\n    type: \"github\",\n    path: \"github\",\n});\nconst group_alias = new vault.identity.GroupAlias(\"group-alias\", {\n    name: \"Github_Team_Slug\",\n    mountAccessor: github.accessor,\n    canonicalId: group.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ngroup = vault.identity.Group(\"group\",\n    type=\"external\",\n    policies=[\"test\"])\ngithub = vault.AuthBackend(\"github\",\n    type=\"github\",\n    path=\"github\")\ngroup_alias = vault.identity.GroupAlias(\"group-alias\",\n    name=\"Github_Team_Slug\",\n    mount_accessor=github.accessor,\n    canonical_id=group.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @group = new Vault.Identity.Group(\"group\", new()\n    {\n        Type = \"external\",\n        Policies = new[]\n        {\n            \"test\",\n        },\n    });\n\n    var github = new Vault.AuthBackend(\"github\", new()\n    {\n        Type = \"github\",\n        Path = \"github\",\n    });\n\n    var group_alias = new Vault.Identity.GroupAlias(\"group-alias\", new()\n    {\n        Name = \"Github_Team_Slug\",\n        MountAccessor = github.Accessor,\n        CanonicalId = @group.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tgroup, err := identity.NewGroup(ctx, \"group\", \u0026identity.GroupArgs{\n\t\t\tType: pulumi.String(\"external\"),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgithub, err := vault.NewAuthBackend(ctx, \"github\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"github\"),\n\t\t\tPath: pulumi.String(\"github\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewGroupAlias(ctx, \"group-alias\", \u0026identity.GroupAliasArgs{\n\t\t\tName:          pulumi.String(\"Github_Team_Slug\"),\n\t\t\tMountAccessor: github.Accessor,\n\t\t\tCanonicalId:   group.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.Group;\nimport com.pulumi.vault.identity.GroupArgs;\nimport com.pulumi.vault.AuthBackend;\nimport com.pulumi.vault.AuthBackendArgs;\nimport com.pulumi.vault.identity.GroupAlias;\nimport com.pulumi.vault.identity.GroupAliasArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var group = new Group(\"group\", GroupArgs.builder()        \n            .type(\"external\")\n            .policies(\"test\")\n            .build());\n\n        var github = new AuthBackend(\"github\", AuthBackendArgs.builder()        \n            .type(\"github\")\n            .path(\"github\")\n            .build());\n\n        var group_alias = new GroupAlias(\"group-alias\", GroupAliasArgs.builder()        \n            .name(\"Github_Team_Slug\")\n            .mountAccessor(github.accessor())\n            .canonicalId(group.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  group:\n    type: vault:identity:Group\n    properties:\n      type: external\n      policies:\n        - test\n  github:\n    type: vault:AuthBackend\n    properties:\n      type: github\n      path: github\n  group-alias:\n    type: vault:identity:GroupAlias\n    properties:\n      name: Github_Team_Slug\n      mountAccessor: ${github.accessor}\n      canonicalId: ${group.id}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nThe group alias can be imported with the group alias `id`, for example\n\n```sh\n $ pulumi import vault:identity/groupAlias:GroupAlias group-alias id\n```\n\n Group aliases can also be imported using the UUID of the alias record, e.g.\n\n```sh\n $ pulumi import vault:identity/groupAlias:GroupAlias alias_name 63104e20-88e4-11eb-8d04-cf7ac9d60157\n```\n\n ",
            "properties": {
                "canonicalId": {
                    "type": "string",
                    "description": "ID of the group to which this is an alias.\n"
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "Mount accessor of the authentication backend to which this alias belongs to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the group alias to create.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                }
            },
            "required": [
                "canonicalId",
                "mountAccessor",
                "name"
            ],
            "inputProperties": {
                "canonicalId": {
                    "type": "string",
                    "description": "ID of the group to which this is an alias.\n"
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "Mount accessor of the authentication backend to which this alias belongs to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the group alias to create.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "canonicalId",
                "mountAccessor",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupAlias resources.\n",
                "properties": {
                    "canonicalId": {
                        "type": "string",
                        "description": "ID of the group to which this is an alias.\n"
                    },
                    "mountAccessor": {
                        "type": "string",
                        "description": "Mount accessor of the authentication backend to which this alias belongs to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the group alias to create.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/groupMemberEntityIds:GroupMemberEntityIds": {
            "description": "Manages member entities for an Identity Group for Vault. The [Identity secrets engine](https://www.vaultproject.io/docs/secrets/identity/index.html) is the identity management solution for Vault.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Exclusive Member Entities\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst internal = new vault.identity.Group(\"internal\", {\n    type: \"internal\",\n    externalMemberEntityIds: true,\n    metadata: {\n        version: \"2\",\n    },\n});\nconst user = new vault.identity.Entity(\"user\", {});\nconst members = new vault.identity.GroupMemberEntityIds(\"members\", {\n    exclusive: true,\n    memberEntityIds: [user.id],\n    groupId: internal.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ninternal = vault.identity.Group(\"internal\",\n    type=\"internal\",\n    external_member_entity_ids=True,\n    metadata={\n        \"version\": \"2\",\n    })\nuser = vault.identity.Entity(\"user\")\nmembers = vault.identity.GroupMemberEntityIds(\"members\",\n    exclusive=True,\n    member_entity_ids=[user.id],\n    group_id=internal.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @internal = new Vault.Identity.Group(\"internal\", new()\n    {\n        Type = \"internal\",\n        ExternalMemberEntityIds = true,\n        Metadata = \n        {\n            { \"version\", \"2\" },\n        },\n    });\n\n    var user = new Vault.Identity.Entity(\"user\");\n\n    var members = new Vault.Identity.GroupMemberEntityIds(\"members\", new()\n    {\n        Exclusive = true,\n        MemberEntityIds = new[]\n        {\n            user.Id,\n        },\n        GroupId = @internal.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tinternal, err := identity.NewGroup(ctx, \"internal\", \u0026identity.GroupArgs{\n\t\t\tType:                    pulumi.String(\"internal\"),\n\t\t\tExternalMemberEntityIds: pulumi.Bool(true),\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"version\": pulumi.String(\"2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tuser, err := identity.NewEntity(ctx, \"user\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewGroupMemberEntityIds(ctx, \"members\", \u0026identity.GroupMemberEntityIdsArgs{\n\t\t\tExclusive: pulumi.Bool(true),\n\t\t\tMemberEntityIds: pulumi.StringArray{\n\t\t\t\tuser.ID(),\n\t\t\t},\n\t\t\tGroupId: internal.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.Group;\nimport com.pulumi.vault.identity.GroupArgs;\nimport com.pulumi.vault.identity.Entity;\nimport com.pulumi.vault.identity.GroupMemberEntityIds;\nimport com.pulumi.vault.identity.GroupMemberEntityIdsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var internal = new Group(\"internal\", GroupArgs.builder()        \n            .type(\"internal\")\n            .externalMemberEntityIds(true)\n            .metadata(Map.of(\"version\", \"2\"))\n            .build());\n\n        var user = new Entity(\"user\");\n\n        var members = new GroupMemberEntityIds(\"members\", GroupMemberEntityIdsArgs.builder()        \n            .exclusive(true)\n            .memberEntityIds(user.id())\n            .groupId(internal.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  internal:\n    type: vault:identity:Group\n    properties:\n      type: internal\n      externalMemberEntityIds: true\n      metadata:\n        version: 2\n  user:\n    type: vault:identity:Entity\n  members:\n    type: vault:identity:GroupMemberEntityIds\n    properties:\n      exclusive: true\n      memberEntityIds:\n        - ${user.id}\n      groupId: ${internal.id}\n```\n{{% /example %}}\n{{% example %}}\n### Non-exclusive Member Entities\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst internal = new vault.identity.Group(\"internal\", {\n    type: \"internal\",\n    externalMemberEntityIds: true,\n    metadata: {\n        version: \"2\",\n    },\n});\nconst testUser = new vault.identity.Entity(\"testUser\", {});\nconst secondTestUser = new vault.identity.Entity(\"secondTestUser\", {});\nconst devUser = new vault.identity.Entity(\"devUser\", {});\nconst test = new vault.identity.GroupMemberEntityIds(\"test\", {\n    memberEntityIds: [\n        testUser.id,\n        secondTestUser.id,\n    ],\n    exclusive: false,\n    groupId: internal.id,\n});\nconst others = new vault.identity.GroupMemberEntityIds(\"others\", {\n    memberEntityIds: [devUser.id],\n    exclusive: false,\n    groupId: internal.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ninternal = vault.identity.Group(\"internal\",\n    type=\"internal\",\n    external_member_entity_ids=True,\n    metadata={\n        \"version\": \"2\",\n    })\ntest_user = vault.identity.Entity(\"testUser\")\nsecond_test_user = vault.identity.Entity(\"secondTestUser\")\ndev_user = vault.identity.Entity(\"devUser\")\ntest = vault.identity.GroupMemberEntityIds(\"test\",\n    member_entity_ids=[\n        test_user.id,\n        second_test_user.id,\n    ],\n    exclusive=False,\n    group_id=internal.id)\nothers = vault.identity.GroupMemberEntityIds(\"others\",\n    member_entity_ids=[dev_user.id],\n    exclusive=False,\n    group_id=internal.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @internal = new Vault.Identity.Group(\"internal\", new()\n    {\n        Type = \"internal\",\n        ExternalMemberEntityIds = true,\n        Metadata = \n        {\n            { \"version\", \"2\" },\n        },\n    });\n\n    var testUser = new Vault.Identity.Entity(\"testUser\");\n\n    var secondTestUser = new Vault.Identity.Entity(\"secondTestUser\");\n\n    var devUser = new Vault.Identity.Entity(\"devUser\");\n\n    var test = new Vault.Identity.GroupMemberEntityIds(\"test\", new()\n    {\n        MemberEntityIds = new[]\n        {\n            testUser.Id,\n            secondTestUser.Id,\n        },\n        Exclusive = false,\n        GroupId = @internal.Id,\n    });\n\n    var others = new Vault.Identity.GroupMemberEntityIds(\"others\", new()\n    {\n        MemberEntityIds = new[]\n        {\n            devUser.Id,\n        },\n        Exclusive = false,\n        GroupId = @internal.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tinternal, err := identity.NewGroup(ctx, \"internal\", \u0026identity.GroupArgs{\n\t\t\tType:                    pulumi.String(\"internal\"),\n\t\t\tExternalMemberEntityIds: pulumi.Bool(true),\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"version\": pulumi.String(\"2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestUser, err := identity.NewEntity(ctx, \"testUser\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsecondTestUser, err := identity.NewEntity(ctx, \"secondTestUser\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdevUser, err := identity.NewEntity(ctx, \"devUser\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewGroupMemberEntityIds(ctx, \"test\", \u0026identity.GroupMemberEntityIdsArgs{\n\t\t\tMemberEntityIds: pulumi.StringArray{\n\t\t\t\ttestUser.ID(),\n\t\t\t\tsecondTestUser.ID(),\n\t\t\t},\n\t\t\tExclusive: pulumi.Bool(false),\n\t\t\tGroupId:   internal.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewGroupMemberEntityIds(ctx, \"others\", \u0026identity.GroupMemberEntityIdsArgs{\n\t\t\tMemberEntityIds: pulumi.StringArray{\n\t\t\t\tdevUser.ID(),\n\t\t\t},\n\t\t\tExclusive: pulumi.Bool(false),\n\t\t\tGroupId:   internal.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.Group;\nimport com.pulumi.vault.identity.GroupArgs;\nimport com.pulumi.vault.identity.Entity;\nimport com.pulumi.vault.identity.GroupMemberEntityIds;\nimport com.pulumi.vault.identity.GroupMemberEntityIdsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var internal = new Group(\"internal\", GroupArgs.builder()        \n            .type(\"internal\")\n            .externalMemberEntityIds(true)\n            .metadata(Map.of(\"version\", \"2\"))\n            .build());\n\n        var testUser = new Entity(\"testUser\");\n\n        var secondTestUser = new Entity(\"secondTestUser\");\n\n        var devUser = new Entity(\"devUser\");\n\n        var test = new GroupMemberEntityIds(\"test\", GroupMemberEntityIdsArgs.builder()        \n            .memberEntityIds(            \n                testUser.id(),\n                secondTestUser.id())\n            .exclusive(false)\n            .groupId(internal.id())\n            .build());\n\n        var others = new GroupMemberEntityIds(\"others\", GroupMemberEntityIdsArgs.builder()        \n            .memberEntityIds(devUser.id())\n            .exclusive(false)\n            .groupId(internal.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  internal:\n    type: vault:identity:Group\n    properties:\n      type: internal\n      externalMemberEntityIds: true\n      metadata:\n        version: 2\n  testUser:\n    type: vault:identity:Entity\n  secondTestUser:\n    type: vault:identity:Entity\n  devUser:\n    type: vault:identity:Entity\n  test:\n    type: vault:identity:GroupMemberEntityIds\n    properties:\n      memberEntityIds:\n        - ${testUser.id}\n        - ${secondTestUser.id}\n      exclusive: false\n      groupId: ${internal.id}\n  others:\n    type: vault:identity:GroupMemberEntityIds\n    properties:\n      memberEntityIds:\n        - ${devUser.id}\n      exclusive: false\n      groupId: ${internal.id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "exclusive": {
                    "type": "boolean",
                    "description": "Defaults to `true`.\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "Group ID to assign member entities to.\n"
                },
                "groupName": {
                    "type": "string",
                    "description": "The name of the group that are assigned the member entities.  \n*Deprecated: The value for group_name may not always be accurate*\n*use* `data.vault_identity_group.*.group_name`, *or* `vault_identity_group.*.group_name` *instead.*\n",
                    "deprecationMessage": "The value for group_name may not always be accurate, \nuse \"data.vault_identity_group.*.group_name\", \"vault_identity_group.*.group_name\" instead"
                },
                "memberEntityIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of member entities that belong to the group\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                }
            },
            "required": [
                "groupId",
                "groupName"
            ],
            "inputProperties": {
                "exclusive": {
                    "type": "boolean",
                    "description": "Defaults to `true`.\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "Group ID to assign member entities to.\n",
                    "willReplaceOnChanges": true
                },
                "memberEntityIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of member entities that belong to the group\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "groupId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupMemberEntityIds resources.\n",
                "properties": {
                    "exclusive": {
                        "type": "boolean",
                        "description": "Defaults to `true`.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "Group ID to assign member entities to.\n",
                        "willReplaceOnChanges": true
                    },
                    "groupName": {
                        "type": "string",
                        "description": "The name of the group that are assigned the member entities.  \n*Deprecated: The value for group_name may not always be accurate*\n*use* `data.vault_identity_group.*.group_name`, *or* `vault_identity_group.*.group_name` *instead.*\n",
                        "deprecationMessage": "The value for group_name may not always be accurate, \nuse \"data.vault_identity_group.*.group_name\", \"vault_identity_group.*.group_name\" instead"
                    },
                    "memberEntityIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of member entities that belong to the group\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/groupMemberGroupIds:GroupMemberGroupIds": {
            "description": "Manages member groups for an Identity Group for Vault. The\n[Identity secrets engine](https://www.vaultproject.io/docs/secrets/identity/index.html)\nis the identity management solution for Vault.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Exclusive Member Groups\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst internal = new vault.identity.Group(\"internal\", {\n    type: \"internal\",\n    externalMemberGroupIds: true,\n    metadata: {\n        version: \"2\",\n    },\n});\nconst users = new vault.identity.Group(\"users\", {metadata: {\n    version: \"2\",\n}});\nconst members = new vault.identity.GroupMemberGroupIds(\"members\", {\n    exclusive: true,\n    memberGroupIds: [users.id],\n    groupId: internal.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ninternal = vault.identity.Group(\"internal\",\n    type=\"internal\",\n    external_member_group_ids=True,\n    metadata={\n        \"version\": \"2\",\n    })\nusers = vault.identity.Group(\"users\", metadata={\n    \"version\": \"2\",\n})\nmembers = vault.identity.GroupMemberGroupIds(\"members\",\n    exclusive=True,\n    member_group_ids=[users.id],\n    group_id=internal.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @internal = new Vault.Identity.Group(\"internal\", new()\n    {\n        Type = \"internal\",\n        ExternalMemberGroupIds = true,\n        Metadata = \n        {\n            { \"version\", \"2\" },\n        },\n    });\n\n    var users = new Vault.Identity.Group(\"users\", new()\n    {\n        Metadata = \n        {\n            { \"version\", \"2\" },\n        },\n    });\n\n    var members = new Vault.Identity.GroupMemberGroupIds(\"members\", new()\n    {\n        Exclusive = true,\n        MemberGroupIds = new[]\n        {\n            users.Id,\n        },\n        GroupId = @internal.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tinternal, err := identity.NewGroup(ctx, \"internal\", \u0026identity.GroupArgs{\n\t\t\tType:                   pulumi.String(\"internal\"),\n\t\t\tExternalMemberGroupIds: pulumi.Bool(true),\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"version\": pulumi.String(\"2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tusers, err := identity.NewGroup(ctx, \"users\", \u0026identity.GroupArgs{\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"version\": pulumi.String(\"2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewGroupMemberGroupIds(ctx, \"members\", \u0026identity.GroupMemberGroupIdsArgs{\n\t\t\tExclusive: pulumi.Bool(true),\n\t\t\tMemberGroupIds: pulumi.StringArray{\n\t\t\t\tusers.ID(),\n\t\t\t},\n\t\t\tGroupId: internal.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.Group;\nimport com.pulumi.vault.identity.GroupArgs;\nimport com.pulumi.vault.identity.GroupMemberGroupIds;\nimport com.pulumi.vault.identity.GroupMemberGroupIdsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var internal = new Group(\"internal\", GroupArgs.builder()        \n            .type(\"internal\")\n            .externalMemberGroupIds(true)\n            .metadata(Map.of(\"version\", \"2\"))\n            .build());\n\n        var users = new Group(\"users\", GroupArgs.builder()        \n            .metadata(Map.of(\"version\", \"2\"))\n            .build());\n\n        var members = new GroupMemberGroupIds(\"members\", GroupMemberGroupIdsArgs.builder()        \n            .exclusive(true)\n            .memberGroupIds(users.id())\n            .groupId(internal.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  internal:\n    type: vault:identity:Group\n    properties:\n      type: internal\n      externalMemberGroupIds: true\n      metadata:\n        version: 2\n  users:\n    type: vault:identity:Group\n    properties:\n      metadata:\n        version: 2\n  members:\n    type: vault:identity:GroupMemberGroupIds\n    properties:\n      exclusive: true\n      memberGroupIds:\n        - ${users.id}\n      groupId: ${internal.id}\n```\n{{% /example %}}\n{{% example %}}\n### Non-Exclusive Member Groups\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst internal = new vault.identity.Group(\"internal\", {\n    type: \"internal\",\n    externalMemberGroupIds: true,\n    metadata: {\n        version: \"2\",\n    },\n});\nconst users = new vault.identity.Group(\"users\", {metadata: {\n    version: \"2\",\n}});\nconst members = new vault.identity.GroupMemberGroupIds(\"members\", {\n    exclusive: false,\n    memberGroupIds: [users.id],\n    groupId: internal.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ninternal = vault.identity.Group(\"internal\",\n    type=\"internal\",\n    external_member_group_ids=True,\n    metadata={\n        \"version\": \"2\",\n    })\nusers = vault.identity.Group(\"users\", metadata={\n    \"version\": \"2\",\n})\nmembers = vault.identity.GroupMemberGroupIds(\"members\",\n    exclusive=False,\n    member_group_ids=[users.id],\n    group_id=internal.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @internal = new Vault.Identity.Group(\"internal\", new()\n    {\n        Type = \"internal\",\n        ExternalMemberGroupIds = true,\n        Metadata = \n        {\n            { \"version\", \"2\" },\n        },\n    });\n\n    var users = new Vault.Identity.Group(\"users\", new()\n    {\n        Metadata = \n        {\n            { \"version\", \"2\" },\n        },\n    });\n\n    var members = new Vault.Identity.GroupMemberGroupIds(\"members\", new()\n    {\n        Exclusive = false,\n        MemberGroupIds = new[]\n        {\n            users.Id,\n        },\n        GroupId = @internal.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tinternal, err := identity.NewGroup(ctx, \"internal\", \u0026identity.GroupArgs{\n\t\t\tType:                   pulumi.String(\"internal\"),\n\t\t\tExternalMemberGroupIds: pulumi.Bool(true),\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"version\": pulumi.String(\"2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tusers, err := identity.NewGroup(ctx, \"users\", \u0026identity.GroupArgs{\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"version\": pulumi.String(\"2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewGroupMemberGroupIds(ctx, \"members\", \u0026identity.GroupMemberGroupIdsArgs{\n\t\t\tExclusive: pulumi.Bool(false),\n\t\t\tMemberGroupIds: pulumi.StringArray{\n\t\t\t\tusers.ID(),\n\t\t\t},\n\t\t\tGroupId: internal.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.Group;\nimport com.pulumi.vault.identity.GroupArgs;\nimport com.pulumi.vault.identity.GroupMemberGroupIds;\nimport com.pulumi.vault.identity.GroupMemberGroupIdsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var internal = new Group(\"internal\", GroupArgs.builder()        \n            .type(\"internal\")\n            .externalMemberGroupIds(true)\n            .metadata(Map.of(\"version\", \"2\"))\n            .build());\n\n        var users = new Group(\"users\", GroupArgs.builder()        \n            .metadata(Map.of(\"version\", \"2\"))\n            .build());\n\n        var members = new GroupMemberGroupIds(\"members\", GroupMemberGroupIdsArgs.builder()        \n            .exclusive(false)\n            .memberGroupIds(users.id())\n            .groupId(internal.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  internal:\n    type: vault:identity:Group\n    properties:\n      type: internal\n      externalMemberGroupIds: true\n      metadata:\n        version: 2\n  users:\n    type: vault:identity:Group\n    properties:\n      metadata:\n        version: 2\n  members:\n    type: vault:identity:GroupMemberGroupIds\n    properties:\n      exclusive: false\n      memberGroupIds:\n        - ${users.id}\n      groupId: ${internal.id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "exclusive": {
                    "type": "boolean",
                    "description": "Defaults to `true`.\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "Group ID to assign member entities to.\n"
                },
                "memberGroupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of member groups that belong to the group\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                }
            },
            "required": [
                "groupId"
            ],
            "inputProperties": {
                "exclusive": {
                    "type": "boolean",
                    "description": "Defaults to `true`.\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "Group ID to assign member entities to.\n",
                    "willReplaceOnChanges": true
                },
                "memberGroupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of member groups that belong to the group\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "groupId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupMemberGroupIds resources.\n",
                "properties": {
                    "exclusive": {
                        "type": "boolean",
                        "description": "Defaults to `true`.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "Group ID to assign member entities to.\n",
                        "willReplaceOnChanges": true
                    },
                    "memberGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of member groups that belong to the group\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/groupPolicies:GroupPolicies": {
            "description": "Manages policies for an Identity Group for Vault. The [Identity secrets engine](https://www.vaultproject.io/docs/secrets/identity/index.html) is the identity management solution for Vault.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Exclusive Policies\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst internal = new vault.identity.Group(\"internal\", {\n    type: \"internal\",\n    externalPolicies: true,\n    metadata: {\n        version: \"2\",\n    },\n});\nconst policies = new vault.identity.GroupPolicies(\"policies\", {\n    policies: [\n        \"default\",\n        \"test\",\n    ],\n    exclusive: true,\n    groupId: internal.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ninternal = vault.identity.Group(\"internal\",\n    type=\"internal\",\n    external_policies=True,\n    metadata={\n        \"version\": \"2\",\n    })\npolicies = vault.identity.GroupPolicies(\"policies\",\n    policies=[\n        \"default\",\n        \"test\",\n    ],\n    exclusive=True,\n    group_id=internal.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @internal = new Vault.Identity.Group(\"internal\", new()\n    {\n        Type = \"internal\",\n        ExternalPolicies = true,\n        Metadata = \n        {\n            { \"version\", \"2\" },\n        },\n    });\n\n    var policies = new Vault.Identity.GroupPolicies(\"policies\", new()\n    {\n        Policies = new[]\n        {\n            \"default\",\n            \"test\",\n        },\n        Exclusive = true,\n        GroupId = @internal.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tinternal, err := identity.NewGroup(ctx, \"internal\", \u0026identity.GroupArgs{\n\t\t\tType:             pulumi.String(\"internal\"),\n\t\t\tExternalPolicies: pulumi.Bool(true),\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"version\": pulumi.String(\"2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewGroupPolicies(ctx, \"policies\", \u0026identity.GroupPoliciesArgs{\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tExclusive: pulumi.Bool(true),\n\t\t\tGroupId:   internal.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.Group;\nimport com.pulumi.vault.identity.GroupArgs;\nimport com.pulumi.vault.identity.GroupPolicies;\nimport com.pulumi.vault.identity.GroupPoliciesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var internal = new Group(\"internal\", GroupArgs.builder()        \n            .type(\"internal\")\n            .externalPolicies(true)\n            .metadata(Map.of(\"version\", \"2\"))\n            .build());\n\n        var policies = new GroupPolicies(\"policies\", GroupPoliciesArgs.builder()        \n            .policies(            \n                \"default\",\n                \"test\")\n            .exclusive(true)\n            .groupId(internal.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  internal:\n    type: vault:identity:Group\n    properties:\n      type: internal\n      externalPolicies: true\n      metadata:\n        version: 2\n  policies:\n    type: vault:identity:GroupPolicies\n    properties:\n      policies:\n        - default\n        - test\n      exclusive: true\n      groupId: ${internal.id}\n```\n{{% /example %}}\n{{% example %}}\n### Non-exclusive Policies\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst internal = new vault.identity.Group(\"internal\", {\n    type: \"internal\",\n    externalPolicies: true,\n    metadata: {\n        version: \"2\",\n    },\n});\nconst _default = new vault.identity.GroupPolicies(\"default\", {\n    policies: [\n        \"default\",\n        \"test\",\n    ],\n    exclusive: false,\n    groupId: internal.id,\n});\nconst others = new vault.identity.GroupPolicies(\"others\", {\n    policies: [\"others\"],\n    exclusive: false,\n    groupId: internal.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ninternal = vault.identity.Group(\"internal\",\n    type=\"internal\",\n    external_policies=True,\n    metadata={\n        \"version\": \"2\",\n    })\ndefault = vault.identity.GroupPolicies(\"default\",\n    policies=[\n        \"default\",\n        \"test\",\n    ],\n    exclusive=False,\n    group_id=internal.id)\nothers = vault.identity.GroupPolicies(\"others\",\n    policies=[\"others\"],\n    exclusive=False,\n    group_id=internal.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @internal = new Vault.Identity.Group(\"internal\", new()\n    {\n        Type = \"internal\",\n        ExternalPolicies = true,\n        Metadata = \n        {\n            { \"version\", \"2\" },\n        },\n    });\n\n    var @default = new Vault.Identity.GroupPolicies(\"default\", new()\n    {\n        Policies = new[]\n        {\n            \"default\",\n            \"test\",\n        },\n        Exclusive = false,\n        GroupId = @internal.Id,\n    });\n\n    var others = new Vault.Identity.GroupPolicies(\"others\", new()\n    {\n        Policies = new[]\n        {\n            \"others\",\n        },\n        Exclusive = false,\n        GroupId = @internal.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tinternal, err := identity.NewGroup(ctx, \"internal\", \u0026identity.GroupArgs{\n\t\t\tType:             pulumi.String(\"internal\"),\n\t\t\tExternalPolicies: pulumi.Bool(true),\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"version\": pulumi.String(\"2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewGroupPolicies(ctx, \"default\", \u0026identity.GroupPoliciesArgs{\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tExclusive: pulumi.Bool(false),\n\t\t\tGroupId:   internal.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewGroupPolicies(ctx, \"others\", \u0026identity.GroupPoliciesArgs{\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"others\"),\n\t\t\t},\n\t\t\tExclusive: pulumi.Bool(false),\n\t\t\tGroupId:   internal.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.Group;\nimport com.pulumi.vault.identity.GroupArgs;\nimport com.pulumi.vault.identity.GroupPolicies;\nimport com.pulumi.vault.identity.GroupPoliciesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var internal = new Group(\"internal\", GroupArgs.builder()        \n            .type(\"internal\")\n            .externalPolicies(true)\n            .metadata(Map.of(\"version\", \"2\"))\n            .build());\n\n        var default_ = new GroupPolicies(\"default\", GroupPoliciesArgs.builder()        \n            .policies(            \n                \"default\",\n                \"test\")\n            .exclusive(false)\n            .groupId(internal.id())\n            .build());\n\n        var others = new GroupPolicies(\"others\", GroupPoliciesArgs.builder()        \n            .policies(\"others\")\n            .exclusive(false)\n            .groupId(internal.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  internal:\n    type: vault:identity:Group\n    properties:\n      type: internal\n      externalPolicies: true\n      metadata:\n        version: 2\n  default:\n    type: vault:identity:GroupPolicies\n    properties:\n      policies:\n        - default\n        - test\n      exclusive: false\n      groupId: ${internal.id}\n  others:\n    type: vault:identity:GroupPolicies\n    properties:\n      policies:\n        - others\n      exclusive: false\n      groupId: ${internal.id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "exclusive": {
                    "type": "boolean",
                    "description": "Defaults to `true`.\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "Group ID to assign policies to.\n"
                },
                "groupName": {
                    "type": "string",
                    "description": "The name of the group that are assigned the policies.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to assign to the group\n"
                }
            },
            "required": [
                "groupId",
                "groupName",
                "policies"
            ],
            "inputProperties": {
                "exclusive": {
                    "type": "boolean",
                    "description": "Defaults to `true`.\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "Group ID to assign policies to.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to assign to the group\n"
                }
            },
            "requiredInputs": [
                "groupId",
                "policies"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupPolicies resources.\n",
                "properties": {
                    "exclusive": {
                        "type": "boolean",
                        "description": "Defaults to `true`.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "Group ID to assign policies to.\n"
                    },
                    "groupName": {
                        "type": "string",
                        "description": "The name of the group that are assigned the policies.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to assign to the group\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/mfaDuo:MfaDuo": {
            "description": "Resource for configuring the duo MFA method.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.identity.MfaDuo(\"example\", {\n    apiHostname: \"api-xxxxxxxx.duosecurity.com\",\n    integrationKey: \"secret-int-key\",\n    secretKey: \"secret-key\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.identity.MfaDuo(\"example\",\n    api_hostname=\"api-xxxxxxxx.duosecurity.com\",\n    integration_key=\"secret-int-key\",\n    secret_key=\"secret-key\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Vault.Identity.MfaDuo(\"example\", new()\n    {\n        ApiHostname = \"api-xxxxxxxx.duosecurity.com\",\n        IntegrationKey = \"secret-int-key\",\n        SecretKey = \"secret-key\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := identity.NewMfaDuo(ctx, \"example\", \u0026identity.MfaDuoArgs{\n\t\t\tApiHostname:    pulumi.String(\"api-xxxxxxxx.duosecurity.com\"),\n\t\t\tIntegrationKey: pulumi.String(\"secret-int-key\"),\n\t\t\tSecretKey:      pulumi.String(\"secret-key\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.MfaDuo;\nimport com.pulumi.vault.identity.MfaDuoArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new MfaDuo(\"example\", MfaDuoArgs.builder()        \n            .apiHostname(\"api-xxxxxxxx.duosecurity.com\")\n            .integrationKey(\"secret-int-key\")\n            .secretKey(\"secret-key\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: vault:identity:MfaDuo\n    properties:\n      apiHostname: api-xxxxxxxx.duosecurity.com\n      integrationKey: secret-int-key\n      secretKey: secret-key\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nResource can be imported using its `uuid` field, e.g.\n\n```sh\n $ pulumi import vault:identity/mfaDuo:MfaDuo example 0d89c36a-4ff5-4d70-8749-bb6a5598aeec\n```\n\n ",
            "properties": {
                "apiHostname": {
                    "type": "string",
                    "description": "API hostname for Duo\n"
                },
                "integrationKey": {
                    "type": "string",
                    "description": "Integration key for Duo\n",
                    "secret": true
                },
                "methodId": {
                    "type": "string",
                    "description": "Method ID.\n"
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "Mount accessor.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Method name.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "Target namespace. (requires Enterprise)\n"
                },
                "namespaceId": {
                    "type": "string",
                    "description": "Method's namespace ID.\n"
                },
                "namespacePath": {
                    "type": "string",
                    "description": "Method's namespace path.\n"
                },
                "pushInfo": {
                    "type": "string",
                    "description": "Push information for Duo.\n"
                },
                "secretKey": {
                    "type": "string",
                    "description": "Secret key for Duo\n",
                    "secret": true
                },
                "type": {
                    "type": "string",
                    "description": "MFA type.\n"
                },
                "usePasscode": {
                    "type": "boolean",
                    "description": "Require passcode upon MFA validation.\n"
                },
                "usernameFormat": {
                    "type": "string",
                    "description": "A template string for mapping Identity names to MFA methods.\n"
                },
                "uuid": {
                    "type": "string",
                    "description": "Resource UUID.\n"
                }
            },
            "required": [
                "apiHostname",
                "integrationKey",
                "methodId",
                "mountAccessor",
                "name",
                "namespaceId",
                "namespacePath",
                "secretKey",
                "type",
                "uuid"
            ],
            "inputProperties": {
                "apiHostname": {
                    "type": "string",
                    "description": "API hostname for Duo\n"
                },
                "integrationKey": {
                    "type": "string",
                    "description": "Integration key for Duo\n",
                    "secret": true
                },
                "namespace": {
                    "type": "string",
                    "description": "Target namespace. (requires Enterprise)\n",
                    "willReplaceOnChanges": true
                },
                "pushInfo": {
                    "type": "string",
                    "description": "Push information for Duo.\n"
                },
                "secretKey": {
                    "type": "string",
                    "description": "Secret key for Duo\n",
                    "secret": true
                },
                "usePasscode": {
                    "type": "boolean",
                    "description": "Require passcode upon MFA validation.\n"
                },
                "usernameFormat": {
                    "type": "string",
                    "description": "A template string for mapping Identity names to MFA methods.\n"
                }
            },
            "requiredInputs": [
                "apiHostname",
                "integrationKey",
                "secretKey"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MfaDuo resources.\n",
                "properties": {
                    "apiHostname": {
                        "type": "string",
                        "description": "API hostname for Duo\n"
                    },
                    "integrationKey": {
                        "type": "string",
                        "description": "Integration key for Duo\n",
                        "secret": true
                    },
                    "methodId": {
                        "type": "string",
                        "description": "Method ID.\n"
                    },
                    "mountAccessor": {
                        "type": "string",
                        "description": "Mount accessor.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Method name.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "Target namespace. (requires Enterprise)\n",
                        "willReplaceOnChanges": true
                    },
                    "namespaceId": {
                        "type": "string",
                        "description": "Method's namespace ID.\n"
                    },
                    "namespacePath": {
                        "type": "string",
                        "description": "Method's namespace path.\n"
                    },
                    "pushInfo": {
                        "type": "string",
                        "description": "Push information for Duo.\n"
                    },
                    "secretKey": {
                        "type": "string",
                        "description": "Secret key for Duo\n",
                        "secret": true
                    },
                    "type": {
                        "type": "string",
                        "description": "MFA type.\n"
                    },
                    "usePasscode": {
                        "type": "boolean",
                        "description": "Require passcode upon MFA validation.\n"
                    },
                    "usernameFormat": {
                        "type": "string",
                        "description": "A template string for mapping Identity names to MFA methods.\n"
                    },
                    "uuid": {
                        "type": "string",
                        "description": "Resource UUID.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/mfaLoginEnforcement:MfaLoginEnforcement": {
            "description": "Resource for configuring MFA login-enforcement\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst exampleMfaDuo = new vault.identity.MfaDuo(\"exampleMfaDuo\", {\n    secretKey: \"secret-key\",\n    integrationKey: \"int-key\",\n    apiHostname: \"foo.baz\",\n    pushInfo: \"push-info\",\n});\nconst exampleMfaLoginEnforcement = new vault.identity.MfaLoginEnforcement(\"exampleMfaLoginEnforcement\", {mfaMethodIds: [exampleMfaDuo.methodId]});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample_mfa_duo = vault.identity.MfaDuo(\"exampleMfaDuo\",\n    secret_key=\"secret-key\",\n    integration_key=\"int-key\",\n    api_hostname=\"foo.baz\",\n    push_info=\"push-info\")\nexample_mfa_login_enforcement = vault.identity.MfaLoginEnforcement(\"exampleMfaLoginEnforcement\", mfa_method_ids=[example_mfa_duo.method_id])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleMfaDuo = new Vault.Identity.MfaDuo(\"exampleMfaDuo\", new()\n    {\n        SecretKey = \"secret-key\",\n        IntegrationKey = \"int-key\",\n        ApiHostname = \"foo.baz\",\n        PushInfo = \"push-info\",\n    });\n\n    var exampleMfaLoginEnforcement = new Vault.Identity.MfaLoginEnforcement(\"exampleMfaLoginEnforcement\", new()\n    {\n        MfaMethodIds = new[]\n        {\n            exampleMfaDuo.MethodId,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleMfaDuo, err := identity.NewMfaDuo(ctx, \"exampleMfaDuo\", \u0026identity.MfaDuoArgs{\n\t\t\tSecretKey:      pulumi.String(\"secret-key\"),\n\t\t\tIntegrationKey: pulumi.String(\"int-key\"),\n\t\t\tApiHostname:    pulumi.String(\"foo.baz\"),\n\t\t\tPushInfo:       pulumi.String(\"push-info\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewMfaLoginEnforcement(ctx, \"exampleMfaLoginEnforcement\", \u0026identity.MfaLoginEnforcementArgs{\n\t\t\tMfaMethodIds: pulumi.StringArray{\n\t\t\t\texampleMfaDuo.MethodId,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.MfaDuo;\nimport com.pulumi.vault.identity.MfaDuoArgs;\nimport com.pulumi.vault.identity.MfaLoginEnforcement;\nimport com.pulumi.vault.identity.MfaLoginEnforcementArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleMfaDuo = new MfaDuo(\"exampleMfaDuo\", MfaDuoArgs.builder()        \n            .secretKey(\"secret-key\")\n            .integrationKey(\"int-key\")\n            .apiHostname(\"foo.baz\")\n            .pushInfo(\"push-info\")\n            .build());\n\n        var exampleMfaLoginEnforcement = new MfaLoginEnforcement(\"exampleMfaLoginEnforcement\", MfaLoginEnforcementArgs.builder()        \n            .mfaMethodIds(exampleMfaDuo.methodId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleMfaDuo:\n    type: vault:identity:MfaDuo\n    properties:\n      secretKey: secret-key\n      integrationKey: int-key\n      apiHostname: foo.baz\n      pushInfo: push-info\n  exampleMfaLoginEnforcement:\n    type: vault:identity:MfaLoginEnforcement\n    properties:\n      mfaMethodIds:\n        - ${exampleMfaDuo.methodId}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nResource can be imported using its `name` field, e.g.\n\n```sh\n $ pulumi import vault:identity/mfaLoginEnforcement:MfaLoginEnforcement example default\n```\n\n ",
            "properties": {
                "authMethodAccessors": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of auth method accessor IDs.\n"
                },
                "authMethodTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of auth method types.\n"
                },
                "identityEntityIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of identity entity IDs.\n"
                },
                "identityGroupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of identity group IDs.\n"
                },
                "mfaMethodIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of MFA method UUIDs.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Login enforcement name.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "Target namespace. (requires Enterprise)\n"
                },
                "namespaceId": {
                    "type": "string",
                    "description": "Method's namespace ID.\n"
                },
                "namespacePath": {
                    "type": "string",
                    "description": "Method's namespace path.\n"
                },
                "uuid": {
                    "type": "string",
                    "description": "Resource UUID.\n"
                }
            },
            "required": [
                "mfaMethodIds",
                "name",
                "namespaceId",
                "namespacePath",
                "uuid"
            ],
            "inputProperties": {
                "authMethodAccessors": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of auth method accessor IDs.\n"
                },
                "authMethodTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of auth method types.\n"
                },
                "identityEntityIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of identity entity IDs.\n"
                },
                "identityGroupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of identity group IDs.\n"
                },
                "mfaMethodIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of MFA method UUIDs.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Login enforcement name.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "Target namespace. (requires Enterprise)\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "mfaMethodIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MfaLoginEnforcement resources.\n",
                "properties": {
                    "authMethodAccessors": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of auth method accessor IDs.\n"
                    },
                    "authMethodTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of auth method types.\n"
                    },
                    "identityEntityIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of identity entity IDs.\n"
                    },
                    "identityGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of identity group IDs.\n"
                    },
                    "mfaMethodIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of MFA method UUIDs.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Login enforcement name.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "Target namespace. (requires Enterprise)\n",
                        "willReplaceOnChanges": true
                    },
                    "namespaceId": {
                        "type": "string",
                        "description": "Method's namespace ID.\n"
                    },
                    "namespacePath": {
                        "type": "string",
                        "description": "Method's namespace path.\n"
                    },
                    "uuid": {
                        "type": "string",
                        "description": "Resource UUID.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/mfaOkta:MfaOkta": {
            "description": "Resource for configuring the okta MFA method.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.identity.MfaOkta(\"example\", {\n    apiToken: \"token1\",\n    baseUrl: \"qux.baz.com\",\n    orgName: \"org1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.identity.MfaOkta(\"example\",\n    api_token=\"token1\",\n    base_url=\"qux.baz.com\",\n    org_name=\"org1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Vault.Identity.MfaOkta(\"example\", new()\n    {\n        ApiToken = \"token1\",\n        BaseUrl = \"qux.baz.com\",\n        OrgName = \"org1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := identity.NewMfaOkta(ctx, \"example\", \u0026identity.MfaOktaArgs{\n\t\t\tApiToken: pulumi.String(\"token1\"),\n\t\t\tBaseUrl:  pulumi.String(\"qux.baz.com\"),\n\t\t\tOrgName:  pulumi.String(\"org1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.MfaOkta;\nimport com.pulumi.vault.identity.MfaOktaArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new MfaOkta(\"example\", MfaOktaArgs.builder()        \n            .apiToken(\"token1\")\n            .baseUrl(\"qux.baz.com\")\n            .orgName(\"org1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: vault:identity:MfaOkta\n    properties:\n      apiToken: token1\n      baseUrl: qux.baz.com\n      orgName: org1\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nResource can be imported using its `uuid` field, e.g.\n\n```sh\n $ pulumi import vault:identity/mfaOkta:MfaOkta example 0d89c36a-4ff5-4d70-8749-bb6a5598aeec\n```\n\n ",
            "properties": {
                "apiToken": {
                    "type": "string",
                    "description": "Okta API token.\n",
                    "secret": true
                },
                "baseUrl": {
                    "type": "string",
                    "description": "The base domain to use for API requests.\n"
                },
                "methodId": {
                    "type": "string",
                    "description": "Method ID.\n"
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "Mount accessor.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Method name.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "Target namespace. (requires Enterprise)\n"
                },
                "namespaceId": {
                    "type": "string",
                    "description": "Method's namespace ID.\n"
                },
                "namespacePath": {
                    "type": "string",
                    "description": "Method's namespace path.\n"
                },
                "orgName": {
                    "type": "string",
                    "description": "Name of the organization to be used in the Okta API.\n"
                },
                "primaryEmail": {
                    "type": "boolean",
                    "description": "Only match the primary email for the account.\n"
                },
                "type": {
                    "type": "string",
                    "description": "MFA type.\n"
                },
                "usernameFormat": {
                    "type": "string",
                    "description": "A template string for mapping Identity names to MFA methods.\n"
                },
                "uuid": {
                    "type": "string",
                    "description": "Resource UUID.\n"
                }
            },
            "required": [
                "apiToken",
                "methodId",
                "mountAccessor",
                "name",
                "namespaceId",
                "namespacePath",
                "orgName",
                "type",
                "uuid"
            ],
            "inputProperties": {
                "apiToken": {
                    "type": "string",
                    "description": "Okta API token.\n",
                    "secret": true
                },
                "baseUrl": {
                    "type": "string",
                    "description": "The base domain to use for API requests.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "Target namespace. (requires Enterprise)\n",
                    "willReplaceOnChanges": true
                },
                "orgName": {
                    "type": "string",
                    "description": "Name of the organization to be used in the Okta API.\n"
                },
                "primaryEmail": {
                    "type": "boolean",
                    "description": "Only match the primary email for the account.\n"
                },
                "usernameFormat": {
                    "type": "string",
                    "description": "A template string for mapping Identity names to MFA methods.\n"
                }
            },
            "requiredInputs": [
                "apiToken",
                "orgName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MfaOkta resources.\n",
                "properties": {
                    "apiToken": {
                        "type": "string",
                        "description": "Okta API token.\n",
                        "secret": true
                    },
                    "baseUrl": {
                        "type": "string",
                        "description": "The base domain to use for API requests.\n"
                    },
                    "methodId": {
                        "type": "string",
                        "description": "Method ID.\n"
                    },
                    "mountAccessor": {
                        "type": "string",
                        "description": "Mount accessor.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Method name.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "Target namespace. (requires Enterprise)\n",
                        "willReplaceOnChanges": true
                    },
                    "namespaceId": {
                        "type": "string",
                        "description": "Method's namespace ID.\n"
                    },
                    "namespacePath": {
                        "type": "string",
                        "description": "Method's namespace path.\n"
                    },
                    "orgName": {
                        "type": "string",
                        "description": "Name of the organization to be used in the Okta API.\n"
                    },
                    "primaryEmail": {
                        "type": "boolean",
                        "description": "Only match the primary email for the account.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "MFA type.\n"
                    },
                    "usernameFormat": {
                        "type": "string",
                        "description": "A template string for mapping Identity names to MFA methods.\n"
                    },
                    "uuid": {
                        "type": "string",
                        "description": "Resource UUID.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/mfaPingid:MfaPingid": {
            "description": "Resource for configuring the pingid MFA method.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.identity.MfaDuo(\"example\", {\n    settingsFileBase64: \"CnVzZV9iYXNlNjR[...]HBtCg==\",\n});\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.MfaDuo;\nimport com.pulumi.vault.identity.MfaDuoArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new MfaDuo(\"example\", MfaDuoArgs.builder()        \n            .settingsFileBase64(\"CnVzZV9iYXNlNjR[...]HBtCg==\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: vault:identity:MfaDuo\n    properties:\n      settingsFileBase64: CnVzZV9iYXNlNjR[...]HBtCg==\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nResource can be imported using its `uuid` field, e.g.\n\n```sh\n $ pulumi import vault:identity/mfaPingid:MfaPingid example 0d89c36a-4ff5-4d70-8749-bb6a5598aeec\n```\n\n ",
            "properties": {
                "adminUrl": {
                    "type": "string",
                    "description": "The admin URL, derived from \"settings_file_base64\"\n"
                },
                "authenticatorUrl": {
                    "type": "string",
                    "description": "A unique identifier of the organization, derived from \"settings_file_base64\"\n"
                },
                "idpUrl": {
                    "type": "string",
                    "description": "The IDP URL, derived from \"settings_file_base64\"\n"
                },
                "methodId": {
                    "type": "string",
                    "description": "Method ID.\n"
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "Mount accessor.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Method name.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "Target namespace. (requires Enterprise)\n"
                },
                "namespaceId": {
                    "type": "string",
                    "description": "Method's namespace ID.\n"
                },
                "namespacePath": {
                    "type": "string",
                    "description": "Method's namespace path.\n"
                },
                "orgAlias": {
                    "type": "string",
                    "description": "The name of the PingID client organization, derived from \"settings_file_base64\"\n"
                },
                "settingsFileBase64": {
                    "type": "string",
                    "description": "A base64-encoded third-party settings contents as retrieved from PingID's configuration page.\n"
                },
                "type": {
                    "type": "string",
                    "description": "MFA type.\n"
                },
                "useSignature": {
                    "type": "boolean",
                    "description": "Use signature value, derived from \"settings_file_base64\"\n"
                },
                "usernameFormat": {
                    "type": "string",
                    "description": "A template string for mapping Identity names to MFA methods.\n"
                },
                "uuid": {
                    "type": "string",
                    "description": "Resource UUID.\n"
                }
            },
            "required": [
                "adminUrl",
                "authenticatorUrl",
                "idpUrl",
                "methodId",
                "mountAccessor",
                "name",
                "namespaceId",
                "namespacePath",
                "orgAlias",
                "settingsFileBase64",
                "type",
                "useSignature",
                "uuid"
            ],
            "inputProperties": {
                "namespace": {
                    "type": "string",
                    "description": "Target namespace. (requires Enterprise)\n",
                    "willReplaceOnChanges": true
                },
                "settingsFileBase64": {
                    "type": "string",
                    "description": "A base64-encoded third-party settings contents as retrieved from PingID's configuration page.\n"
                },
                "usernameFormat": {
                    "type": "string",
                    "description": "A template string for mapping Identity names to MFA methods.\n"
                }
            },
            "requiredInputs": [
                "settingsFileBase64"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MfaPingid resources.\n",
                "properties": {
                    "adminUrl": {
                        "type": "string",
                        "description": "The admin URL, derived from \"settings_file_base64\"\n",
                        "willReplaceOnChanges": true
                    },
                    "authenticatorUrl": {
                        "type": "string",
                        "description": "A unique identifier of the organization, derived from \"settings_file_base64\"\n",
                        "willReplaceOnChanges": true
                    },
                    "idpUrl": {
                        "type": "string",
                        "description": "The IDP URL, derived from \"settings_file_base64\"\n",
                        "willReplaceOnChanges": true
                    },
                    "methodId": {
                        "type": "string",
                        "description": "Method ID.\n"
                    },
                    "mountAccessor": {
                        "type": "string",
                        "description": "Mount accessor.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Method name.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "Target namespace. (requires Enterprise)\n",
                        "willReplaceOnChanges": true
                    },
                    "namespaceId": {
                        "type": "string",
                        "description": "Method's namespace ID.\n"
                    },
                    "namespacePath": {
                        "type": "string",
                        "description": "Method's namespace path.\n"
                    },
                    "orgAlias": {
                        "type": "string",
                        "description": "The name of the PingID client organization, derived from \"settings_file_base64\"\n",
                        "willReplaceOnChanges": true
                    },
                    "settingsFileBase64": {
                        "type": "string",
                        "description": "A base64-encoded third-party settings contents as retrieved from PingID's configuration page.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "MFA type.\n"
                    },
                    "useSignature": {
                        "type": "boolean",
                        "description": "Use signature value, derived from \"settings_file_base64\"\n",
                        "willReplaceOnChanges": true
                    },
                    "usernameFormat": {
                        "type": "string",
                        "description": "A template string for mapping Identity names to MFA methods.\n"
                    },
                    "uuid": {
                        "type": "string",
                        "description": "Resource UUID.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/mfaTotp:MfaTotp": {
            "description": "Resource for configuring the totp MFA method.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.identity.MfaTotp(\"example\", {\n    issuer: \"issuer1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.identity.MfaTotp(\"example\", issuer=\"issuer1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Vault.Identity.MfaTotp(\"example\", new()\n    {\n        Issuer = \"issuer1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := identity.NewMfaTotp(ctx, \"example\", \u0026identity.MfaTotpArgs{\n\t\t\tIssuer: pulumi.String(\"issuer1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.MfaTotp;\nimport com.pulumi.vault.identity.MfaTotpArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new MfaTotp(\"example\", MfaTotpArgs.builder()        \n            .issuer(\"issuer1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: vault:identity:MfaTotp\n    properties:\n      issuer: issuer1\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nResource can be imported using its `uuid` field, e.g.\n\n```sh\n $ pulumi import vault:identity/mfaTotp:MfaTotp example 0d89c36a-4ff5-4d70-8749-bb6a5598aeec\n```\n\n ",
            "properties": {
                "algorithm": {
                    "type": "string",
                    "description": "Specifies the hashing algorithm used to generate the TOTP code. Options include SHA1, SHA256, SHA512.\n"
                },
                "digits": {
                    "type": "integer",
                    "description": "The number of digits in the generated TOTP token. This value can either be 6 or 8\n"
                },
                "issuer": {
                    "type": "string",
                    "description": "The name of the key's issuing organization.\n"
                },
                "keySize": {
                    "type": "integer",
                    "description": "Specifies the size in bytes of the generated key.\n"
                },
                "maxValidationAttempts": {
                    "type": "integer",
                    "description": "The maximum number of consecutive failed validation attempts allowed.\n"
                },
                "methodId": {
                    "type": "string",
                    "description": "Method ID.\n"
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "Mount accessor.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Method name.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "Target namespace. (requires Enterprise)\n"
                },
                "namespaceId": {
                    "type": "string",
                    "description": "Method's namespace ID.\n"
                },
                "namespacePath": {
                    "type": "string",
                    "description": "Method's namespace path.\n"
                },
                "period": {
                    "type": "integer",
                    "description": "The length of time in seconds used to generate a counter for the TOTP token calculation.\n"
                },
                "qrSize": {
                    "type": "integer",
                    "description": "The pixel size of the generated square QR code.\n"
                },
                "skew": {
                    "type": "integer",
                    "description": "The number of delay periods that are allowed when validating a TOTP token. This value can either be 0 or 1.\n"
                },
                "type": {
                    "type": "string",
                    "description": "MFA type.\n"
                },
                "uuid": {
                    "type": "string",
                    "description": "Resource UUID.\n"
                }
            },
            "required": [
                "issuer",
                "methodId",
                "mountAccessor",
                "name",
                "namespaceId",
                "namespacePath",
                "qrSize",
                "type",
                "uuid"
            ],
            "inputProperties": {
                "algorithm": {
                    "type": "string",
                    "description": "Specifies the hashing algorithm used to generate the TOTP code. Options include SHA1, SHA256, SHA512.\n"
                },
                "digits": {
                    "type": "integer",
                    "description": "The number of digits in the generated TOTP token. This value can either be 6 or 8\n"
                },
                "issuer": {
                    "type": "string",
                    "description": "The name of the key's issuing organization.\n"
                },
                "keySize": {
                    "type": "integer",
                    "description": "Specifies the size in bytes of the generated key.\n"
                },
                "maxValidationAttempts": {
                    "type": "integer",
                    "description": "The maximum number of consecutive failed validation attempts allowed.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "Target namespace. (requires Enterprise)\n",
                    "willReplaceOnChanges": true
                },
                "period": {
                    "type": "integer",
                    "description": "The length of time in seconds used to generate a counter for the TOTP token calculation.\n"
                },
                "qrSize": {
                    "type": "integer",
                    "description": "The pixel size of the generated square QR code.\n"
                },
                "skew": {
                    "type": "integer",
                    "description": "The number of delay periods that are allowed when validating a TOTP token. This value can either be 0 or 1.\n"
                }
            },
            "requiredInputs": [
                "issuer"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MfaTotp resources.\n",
                "properties": {
                    "algorithm": {
                        "type": "string",
                        "description": "Specifies the hashing algorithm used to generate the TOTP code. Options include SHA1, SHA256, SHA512.\n"
                    },
                    "digits": {
                        "type": "integer",
                        "description": "The number of digits in the generated TOTP token. This value can either be 6 or 8\n"
                    },
                    "issuer": {
                        "type": "string",
                        "description": "The name of the key's issuing organization.\n"
                    },
                    "keySize": {
                        "type": "integer",
                        "description": "Specifies the size in bytes of the generated key.\n"
                    },
                    "maxValidationAttempts": {
                        "type": "integer",
                        "description": "The maximum number of consecutive failed validation attempts allowed.\n"
                    },
                    "methodId": {
                        "type": "string",
                        "description": "Method ID.\n"
                    },
                    "mountAccessor": {
                        "type": "string",
                        "description": "Mount accessor.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Method name.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "Target namespace. (requires Enterprise)\n",
                        "willReplaceOnChanges": true
                    },
                    "namespaceId": {
                        "type": "string",
                        "description": "Method's namespace ID.\n"
                    },
                    "namespacePath": {
                        "type": "string",
                        "description": "Method's namespace path.\n"
                    },
                    "period": {
                        "type": "integer",
                        "description": "The length of time in seconds used to generate a counter for the TOTP token calculation.\n"
                    },
                    "qrSize": {
                        "type": "integer",
                        "description": "The pixel size of the generated square QR code.\n"
                    },
                    "skew": {
                        "type": "integer",
                        "description": "The number of delay periods that are allowed when validating a TOTP token. This value can either be 0 or 1.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "MFA type.\n"
                    },
                    "uuid": {
                        "type": "string",
                        "description": "Resource UUID.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/oidc:Oidc": {
            "description": "Configure the [Identity Tokens Backend](https://www.vaultproject.io/docs/secrets/identity/index.html#identity-tokens).\n\nThe Identity secrets engine is the identity management solution for Vault. It internally maintains\nthe clients who are recognized by Vault.\n\n\u003e **NOTE:** Each Vault server may only have one Identity Tokens Backend configuration. Multiple configurations of the resource against the same Vault server will cause a perpetual difference.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst server = new vault.identity.Oidc(\"server\", {\n    issuer: \"https://www.acme.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nserver = vault.identity.Oidc(\"server\", issuer=\"https://www.acme.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var server = new Vault.Identity.Oidc(\"server\", new()\n    {\n        Issuer = \"https://www.acme.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := identity.NewOidc(ctx, \"server\", \u0026identity.OidcArgs{\n\t\t\tIssuer: pulumi.String(\"https://www.acme.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.Oidc;\nimport com.pulumi.vault.identity.OidcArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var server = new Oidc(\"server\", OidcArgs.builder()        \n            .issuer(\"https://www.acme.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  server:\n    type: vault:identity:Oidc\n    properties:\n      issuer: https://www.acme.com\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "issuer": {
                    "type": "string",
                    "description": "Issuer URL to be used in the iss claim of the token. If not set, Vault's\n`api_addr` will be used. The issuer is a case sensitive URL using the https scheme that contains\nscheme, host, and optionally, port number and path components, but no query or fragment\ncomponents.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                }
            },
            "required": [
                "issuer"
            ],
            "inputProperties": {
                "issuer": {
                    "type": "string",
                    "description": "Issuer URL to be used in the iss claim of the token. If not set, Vault's\n`api_addr` will be used. The issuer is a case sensitive URL using the https scheme that contains\nscheme, host, and optionally, port number and path components, but no query or fragment\ncomponents.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Oidc resources.\n",
                "properties": {
                    "issuer": {
                        "type": "string",
                        "description": "Issuer URL to be used in the iss claim of the token. If not set, Vault's\n`api_addr` will be used. The issuer is a case sensitive URL using the https scheme that contains\nscheme, host, and optionally, port number and path components, but no query or fragment\ncomponents.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/oidcAssignment:OidcAssignment": {
            "description": "Manages OIDC Assignments in a Vault server. See the [Vault documentation](https://www.vaultproject.io/api-docs/secret/identity/oidc-provider#create-or-update-an-assignment)\nfor more information.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst internal = new vault.identity.Group(\"internal\", {\n    type: \"internal\",\n    policies: [\n        \"dev\",\n        \"test\",\n    ],\n});\nconst test = new vault.identity.Entity(\"test\", {policies: [\"test\"]});\nconst _default = new vault.identity.OidcAssignment(\"default\", {\n    entityIds: [test.id],\n    groupIds: [internal.id],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ninternal = vault.identity.Group(\"internal\",\n    type=\"internal\",\n    policies=[\n        \"dev\",\n        \"test\",\n    ])\ntest = vault.identity.Entity(\"test\", policies=[\"test\"])\ndefault = vault.identity.OidcAssignment(\"default\",\n    entity_ids=[test.id],\n    group_ids=[internal.id])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @internal = new Vault.Identity.Group(\"internal\", new()\n    {\n        Type = \"internal\",\n        Policies = new[]\n        {\n            \"dev\",\n            \"test\",\n        },\n    });\n\n    var test = new Vault.Identity.Entity(\"test\", new()\n    {\n        Policies = new[]\n        {\n            \"test\",\n        },\n    });\n\n    var @default = new Vault.Identity.OidcAssignment(\"default\", new()\n    {\n        EntityIds = new[]\n        {\n            test.Id,\n        },\n        GroupIds = new[]\n        {\n            @internal.Id,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tinternal, err := identity.NewGroup(ctx, \"internal\", \u0026identity.GroupArgs{\n\t\t\tType: pulumi.String(\"internal\"),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttest, err := identity.NewEntity(ctx, \"test\", \u0026identity.EntityArgs{\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewOidcAssignment(ctx, \"default\", \u0026identity.OidcAssignmentArgs{\n\t\t\tEntityIds: pulumi.StringArray{\n\t\t\t\ttest.ID(),\n\t\t\t},\n\t\t\tGroupIds: pulumi.StringArray{\n\t\t\t\tinternal.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.Group;\nimport com.pulumi.vault.identity.GroupArgs;\nimport com.pulumi.vault.identity.Entity;\nimport com.pulumi.vault.identity.EntityArgs;\nimport com.pulumi.vault.identity.OidcAssignment;\nimport com.pulumi.vault.identity.OidcAssignmentArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var internal = new Group(\"internal\", GroupArgs.builder()        \n            .type(\"internal\")\n            .policies(            \n                \"dev\",\n                \"test\")\n            .build());\n\n        var test = new Entity(\"test\", EntityArgs.builder()        \n            .policies(\"test\")\n            .build());\n\n        var default_ = new OidcAssignment(\"default\", OidcAssignmentArgs.builder()        \n            .entityIds(test.id())\n            .groupIds(internal.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  internal:\n    type: vault:identity:Group\n    properties:\n      type: internal\n      policies:\n        - dev\n        - test\n  test:\n    type: vault:identity:Entity\n    properties:\n      policies:\n        - test\n  default:\n    type: vault:identity:OidcAssignment\n    properties:\n      entityIds:\n        - ${test.id}\n      groupIds:\n        - ${internal.id}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nOIDC Assignments can be imported using the `name`, e.g.\n\n```sh\n $ pulumi import vault:identity/oidcAssignment:OidcAssignment default assignment\n```\n\n ",
            "properties": {
                "entityIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Vault entity IDs.\n"
                },
                "groupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Vault group IDs.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the assignment.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "entityIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Vault entity IDs.\n"
                },
                "groupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Vault group IDs.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the assignment.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OidcAssignment resources.\n",
                "properties": {
                    "entityIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A set of Vault entity IDs.\n"
                    },
                    "groupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A set of Vault group IDs.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the assignment.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/oidcClient:OidcClient": {
            "description": "Manages OIDC Clients in a Vault server. See the [Vault documentation](https://www.vaultproject.io/api-docs/secret/identity/oidc-provider#create-or-update-an-assignment)\nfor more information.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst testOidcAssignment = new vault.identity.OidcAssignment(\"testOidcAssignment\", {\n    entityIds: [\"ascbascas-2231a-sdfaa\"],\n    groupIds: [\"sajkdsad-32414-sfsada\"],\n});\nconst testOidcClient = new vault.identity.OidcClient(\"testOidcClient\", {\n    redirectUris: [\n        \"http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\",\n        \"http://127.0.0.1:8251/callback\",\n        \"http://127.0.0.1:8080/callback\",\n    ],\n    assignments: [testOidcAssignment.name],\n    idTokenTtl: 2400,\n    accessTokenTtl: 7200,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntest_oidc_assignment = vault.identity.OidcAssignment(\"testOidcAssignment\",\n    entity_ids=[\"ascbascas-2231a-sdfaa\"],\n    group_ids=[\"sajkdsad-32414-sfsada\"])\ntest_oidc_client = vault.identity.OidcClient(\"testOidcClient\",\n    redirect_uris=[\n        \"http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\",\n        \"http://127.0.0.1:8251/callback\",\n        \"http://127.0.0.1:8080/callback\",\n    ],\n    assignments=[test_oidc_assignment.name],\n    id_token_ttl=2400,\n    access_token_ttl=7200)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testOidcAssignment = new Vault.Identity.OidcAssignment(\"testOidcAssignment\", new()\n    {\n        EntityIds = new[]\n        {\n            \"ascbascas-2231a-sdfaa\",\n        },\n        GroupIds = new[]\n        {\n            \"sajkdsad-32414-sfsada\",\n        },\n    });\n\n    var testOidcClient = new Vault.Identity.OidcClient(\"testOidcClient\", new()\n    {\n        RedirectUris = new[]\n        {\n            \"http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\",\n            \"http://127.0.0.1:8251/callback\",\n            \"http://127.0.0.1:8080/callback\",\n        },\n        Assignments = new[]\n        {\n            testOidcAssignment.Name,\n        },\n        IdTokenTtl = 2400,\n        AccessTokenTtl = 7200,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestOidcAssignment, err := identity.NewOidcAssignment(ctx, \"testOidcAssignment\", \u0026identity.OidcAssignmentArgs{\n\t\t\tEntityIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"ascbascas-2231a-sdfaa\"),\n\t\t\t},\n\t\t\tGroupIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"sajkdsad-32414-sfsada\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewOidcClient(ctx, \"testOidcClient\", \u0026identity.OidcClientArgs{\n\t\t\tRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\"),\n\t\t\t\tpulumi.String(\"http://127.0.0.1:8251/callback\"),\n\t\t\t\tpulumi.String(\"http://127.0.0.1:8080/callback\"),\n\t\t\t},\n\t\t\tAssignments: pulumi.StringArray{\n\t\t\t\ttestOidcAssignment.Name,\n\t\t\t},\n\t\t\tIdTokenTtl:     pulumi.Int(2400),\n\t\t\tAccessTokenTtl: pulumi.Int(7200),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.OidcAssignment;\nimport com.pulumi.vault.identity.OidcAssignmentArgs;\nimport com.pulumi.vault.identity.OidcClient;\nimport com.pulumi.vault.identity.OidcClientArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testOidcAssignment = new OidcAssignment(\"testOidcAssignment\", OidcAssignmentArgs.builder()        \n            .entityIds(\"ascbascas-2231a-sdfaa\")\n            .groupIds(\"sajkdsad-32414-sfsada\")\n            .build());\n\n        var testOidcClient = new OidcClient(\"testOidcClient\", OidcClientArgs.builder()        \n            .redirectUris(            \n                \"http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\",\n                \"http://127.0.0.1:8251/callback\",\n                \"http://127.0.0.1:8080/callback\")\n            .assignments(testOidcAssignment.name())\n            .idTokenTtl(2400)\n            .accessTokenTtl(7200)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testOidcAssignment:\n    type: vault:identity:OidcAssignment\n    properties:\n      entityIds:\n        - ascbascas-2231a-sdfaa\n      groupIds:\n        - sajkdsad-32414-sfsada\n  testOidcClient:\n    type: vault:identity:OidcClient\n    properties:\n      redirectUris:\n        - http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\n        - http://127.0.0.1:8251/callback\n        - http://127.0.0.1:8080/callback\n      assignments:\n        - ${testOidcAssignment.name}\n      idTokenTtl: 2400\n      accessTokenTtl: 7200\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nOIDC Clients can be imported using the `name`, e.g.\n\n```sh\n $ pulumi import vault:identity/oidcClient:OidcClient test my-app\n```\n\n ",
            "properties": {
                "accessTokenTtl": {
                    "type": "integer",
                    "description": "The time-to-live for access tokens obtained by the client.\n"
                },
                "assignments": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of assignment resources associated with the client.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The Client ID from Vault.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The Client Secret from Vault.\n",
                    "secret": true
                },
                "clientType": {
                    "type": "string",
                    "description": "The client type based on its ability to maintain confidentiality of credentials.\nThe following client types are supported: `confidential`, `public`. Defaults to `confidential`.\n"
                },
                "idTokenTtl": {
                    "type": "integer",
                    "description": "The time-to-live for ID tokens obtained by the client. \nThe value should be less than the `verification_ttl` on the key.\n"
                },
                "key": {
                    "type": "string",
                    "description": "A reference to a named key resource in Vault.\nThis cannot be modified after creation. If not provided, the `default`\nkey is used.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the client.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "redirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Redirection URI values used by the client. \nOne of these values must exactly match the `redirect_uri` parameter value\nused in each authentication request.\n"
                }
            },
            "required": [
                "accessTokenTtl",
                "clientId",
                "clientSecret",
                "clientType",
                "idTokenTtl",
                "key",
                "name"
            ],
            "inputProperties": {
                "accessTokenTtl": {
                    "type": "integer",
                    "description": "The time-to-live for access tokens obtained by the client.\n"
                },
                "assignments": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of assignment resources associated with the client.\n"
                },
                "clientType": {
                    "type": "string",
                    "description": "The client type based on its ability to maintain confidentiality of credentials.\nThe following client types are supported: `confidential`, `public`. Defaults to `confidential`.\n"
                },
                "idTokenTtl": {
                    "type": "integer",
                    "description": "The time-to-live for ID tokens obtained by the client. \nThe value should be less than the `verification_ttl` on the key.\n"
                },
                "key": {
                    "type": "string",
                    "description": "A reference to a named key resource in Vault.\nThis cannot be modified after creation. If not provided, the `default`\nkey is used.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the client.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "redirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Redirection URI values used by the client. \nOne of these values must exactly match the `redirect_uri` parameter value\nused in each authentication request.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OidcClient resources.\n",
                "properties": {
                    "accessTokenTtl": {
                        "type": "integer",
                        "description": "The time-to-live for access tokens obtained by the client.\n"
                    },
                    "assignments": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of assignment resources associated with the client.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The Client ID from Vault.\n"
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "The Client Secret from Vault.\n",
                        "secret": true
                    },
                    "clientType": {
                        "type": "string",
                        "description": "The client type based on its ability to maintain confidentiality of credentials.\nThe following client types are supported: `confidential`, `public`. Defaults to `confidential`.\n"
                    },
                    "idTokenTtl": {
                        "type": "integer",
                        "description": "The time-to-live for ID tokens obtained by the client. \nThe value should be less than the `verification_ttl` on the key.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "A reference to a named key resource in Vault.\nThis cannot be modified after creation. If not provided, the `default`\nkey is used.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the client.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "redirectUris": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Redirection URI values used by the client. \nOne of these values must exactly match the `redirect_uri` parameter value\nused in each authentication request.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/oidcKey:OidcKey": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst key = new vault.identity.OidcKey(\"key\", {algorithm: \"RS256\"});\nconst roleOidcRole = new vault.identity.OidcRole(\"roleOidcRole\", {key: key.name});\nconst roleOidcKeyAllowedClientID = new vault.identity.OidcKeyAllowedClientID(\"roleOidcKeyAllowedClientID\", {\n    keyName: key.name,\n    allowedClientId: roleOidcRole.clientId,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nkey = vault.identity.OidcKey(\"key\", algorithm=\"RS256\")\nrole_oidc_role = vault.identity.OidcRole(\"roleOidcRole\", key=key.name)\nrole_oidc_key_allowed_client_id = vault.identity.OidcKeyAllowedClientID(\"roleOidcKeyAllowedClientID\",\n    key_name=key.name,\n    allowed_client_id=role_oidc_role.client_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var key = new Vault.Identity.OidcKey(\"key\", new()\n    {\n        Algorithm = \"RS256\",\n    });\n\n    var roleOidcRole = new Vault.Identity.OidcRole(\"roleOidcRole\", new()\n    {\n        Key = key.Name,\n    });\n\n    var roleOidcKeyAllowedClientID = new Vault.Identity.OidcKeyAllowedClientID(\"roleOidcKeyAllowedClientID\", new()\n    {\n        KeyName = key.Name,\n        AllowedClientId = roleOidcRole.ClientId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tkey, err := identity.NewOidcKey(ctx, \"key\", \u0026identity.OidcKeyArgs{\n\t\t\tAlgorithm: pulumi.String(\"RS256\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\troleOidcRole, err := identity.NewOidcRole(ctx, \"roleOidcRole\", \u0026identity.OidcRoleArgs{\n\t\t\tKey: key.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewOidcKeyAllowedClientID(ctx, \"roleOidcKeyAllowedClientID\", \u0026identity.OidcKeyAllowedClientIDArgs{\n\t\t\tKeyName:         key.Name,\n\t\t\tAllowedClientId: roleOidcRole.ClientId,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.OidcKey;\nimport com.pulumi.vault.identity.OidcKeyArgs;\nimport com.pulumi.vault.identity.OidcRole;\nimport com.pulumi.vault.identity.OidcRoleArgs;\nimport com.pulumi.vault.identity.OidcKeyAllowedClientID;\nimport com.pulumi.vault.identity.OidcKeyAllowedClientIDArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var key = new OidcKey(\"key\", OidcKeyArgs.builder()        \n            .algorithm(\"RS256\")\n            .build());\n\n        var roleOidcRole = new OidcRole(\"roleOidcRole\", OidcRoleArgs.builder()        \n            .key(key.name())\n            .build());\n\n        var roleOidcKeyAllowedClientID = new OidcKeyAllowedClientID(\"roleOidcKeyAllowedClientID\", OidcKeyAllowedClientIDArgs.builder()        \n            .keyName(key.name())\n            .allowedClientId(roleOidcRole.clientId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  key:\n    type: vault:identity:OidcKey\n    properties:\n      algorithm: RS256\n  roleOidcRole:\n    type: vault:identity:OidcRole\n    properties:\n      key: ${key.name}\n  roleOidcKeyAllowedClientID:\n    type: vault:identity:OidcKeyAllowedClientID\n    properties:\n      keyName: ${key.name}\n      allowedClientId: ${roleOidcRole.clientId}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nThe key can be imported with the key name, for example\n\n```sh\n $ pulumi import vault:identity/oidcKey:OidcKey key key\n```\n\n ",
            "properties": {
                "algorithm": {
                    "type": "string",
                    "description": "Signing algorithm to use. Signing algorithm to use.\nAllowed values are: RS256 (default), RS384, RS512, ES256, ES384, ES512, EdDSA.\n"
                },
                "allowedClientIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Array of role client ids allowed to use this key for signing. If empty, no roles are allowed. If \"*\", all roles are\nallowed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the OIDC Key to create.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "rotationPeriod": {
                    "type": "integer",
                    "description": "How often to generate a new signing key in number of seconds\n"
                },
                "verificationTtl": {
                    "type": "integer",
                    "description": "\"Controls how long the public portion of a signing key will be\navailable for verification after being rotated in seconds.\n"
                }
            },
            "required": [
                "allowedClientIds",
                "name"
            ],
            "inputProperties": {
                "algorithm": {
                    "type": "string",
                    "description": "Signing algorithm to use. Signing algorithm to use.\nAllowed values are: RS256 (default), RS384, RS512, ES256, ES384, ES512, EdDSA.\n"
                },
                "allowedClientIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Array of role client ids allowed to use this key for signing. If empty, no roles are allowed. If \"*\", all roles are\nallowed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the OIDC Key to create.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "rotationPeriod": {
                    "type": "integer",
                    "description": "How often to generate a new signing key in number of seconds\n"
                },
                "verificationTtl": {
                    "type": "integer",
                    "description": "\"Controls how long the public portion of a signing key will be\navailable for verification after being rotated in seconds.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OidcKey resources.\n",
                "properties": {
                    "algorithm": {
                        "type": "string",
                        "description": "Signing algorithm to use. Signing algorithm to use.\nAllowed values are: RS256 (default), RS384, RS512, ES256, ES384, ES512, EdDSA.\n"
                    },
                    "allowedClientIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Array of role client ids allowed to use this key for signing. If empty, no roles are allowed. If \"*\", all roles are\nallowed.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the OIDC Key to create.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "rotationPeriod": {
                        "type": "integer",
                        "description": "How often to generate a new signing key in number of seconds\n"
                    },
                    "verificationTtl": {
                        "type": "integer",
                        "description": "\"Controls how long the public portion of a signing key will be\navailable for verification after being rotated in seconds.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/oidcKeyAllowedClientID:OidcKeyAllowedClientID": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst key = new vault.identity.OidcKey(\"key\", {algorithm: \"RS256\"});\nconst roleOidcRole = new vault.identity.OidcRole(\"roleOidcRole\", {key: key.name});\nconst roleOidcKeyAllowedClientID = new vault.identity.OidcKeyAllowedClientID(\"roleOidcKeyAllowedClientID\", {\n    keyName: key.name,\n    allowedClientId: roleOidcRole.clientId,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nkey = vault.identity.OidcKey(\"key\", algorithm=\"RS256\")\nrole_oidc_role = vault.identity.OidcRole(\"roleOidcRole\", key=key.name)\nrole_oidc_key_allowed_client_id = vault.identity.OidcKeyAllowedClientID(\"roleOidcKeyAllowedClientID\",\n    key_name=key.name,\n    allowed_client_id=role_oidc_role.client_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var key = new Vault.Identity.OidcKey(\"key\", new()\n    {\n        Algorithm = \"RS256\",\n    });\n\n    var roleOidcRole = new Vault.Identity.OidcRole(\"roleOidcRole\", new()\n    {\n        Key = key.Name,\n    });\n\n    var roleOidcKeyAllowedClientID = new Vault.Identity.OidcKeyAllowedClientID(\"roleOidcKeyAllowedClientID\", new()\n    {\n        KeyName = key.Name,\n        AllowedClientId = roleOidcRole.ClientId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tkey, err := identity.NewOidcKey(ctx, \"key\", \u0026identity.OidcKeyArgs{\n\t\t\tAlgorithm: pulumi.String(\"RS256\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\troleOidcRole, err := identity.NewOidcRole(ctx, \"roleOidcRole\", \u0026identity.OidcRoleArgs{\n\t\t\tKey: key.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewOidcKeyAllowedClientID(ctx, \"roleOidcKeyAllowedClientID\", \u0026identity.OidcKeyAllowedClientIDArgs{\n\t\t\tKeyName:         key.Name,\n\t\t\tAllowedClientId: roleOidcRole.ClientId,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.OidcKey;\nimport com.pulumi.vault.identity.OidcKeyArgs;\nimport com.pulumi.vault.identity.OidcRole;\nimport com.pulumi.vault.identity.OidcRoleArgs;\nimport com.pulumi.vault.identity.OidcKeyAllowedClientID;\nimport com.pulumi.vault.identity.OidcKeyAllowedClientIDArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var key = new OidcKey(\"key\", OidcKeyArgs.builder()        \n            .algorithm(\"RS256\")\n            .build());\n\n        var roleOidcRole = new OidcRole(\"roleOidcRole\", OidcRoleArgs.builder()        \n            .key(key.name())\n            .build());\n\n        var roleOidcKeyAllowedClientID = new OidcKeyAllowedClientID(\"roleOidcKeyAllowedClientID\", OidcKeyAllowedClientIDArgs.builder()        \n            .keyName(key.name())\n            .allowedClientId(roleOidcRole.clientId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  key:\n    type: vault:identity:OidcKey\n    properties:\n      algorithm: RS256\n  roleOidcRole:\n    type: vault:identity:OidcRole\n    properties:\n      key: ${key.name}\n  roleOidcKeyAllowedClientID:\n    type: vault:identity:OidcKeyAllowedClientID\n    properties:\n      keyName: ${key.name}\n      allowedClientId: ${roleOidcRole.clientId}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "allowedClientId": {
                    "type": "string",
                    "description": "Client ID to allow usage with the OIDC named key\n"
                },
                "keyName": {
                    "type": "string",
                    "description": "Name of the OIDC Key allow the Client ID.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                }
            },
            "required": [
                "allowedClientId",
                "keyName"
            ],
            "inputProperties": {
                "allowedClientId": {
                    "type": "string",
                    "description": "Client ID to allow usage with the OIDC named key\n",
                    "willReplaceOnChanges": true
                },
                "keyName": {
                    "type": "string",
                    "description": "Name of the OIDC Key allow the Client ID.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "allowedClientId",
                "keyName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OidcKeyAllowedClientID resources.\n",
                "properties": {
                    "allowedClientId": {
                        "type": "string",
                        "description": "Client ID to allow usage with the OIDC named key\n",
                        "willReplaceOnChanges": true
                    },
                    "keyName": {
                        "type": "string",
                        "description": "Name of the OIDC Key allow the Client ID.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/oidcProvider:OidcProvider": {
            "description": "Manages OIDC Providers in a Vault server. See the [Vault documentation](https://www.vaultproject.io/api-docs/secret/identity/oidc-provider#create-or-update-an-assignment)\nfor more information.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst testOidcKey = new vault.identity.OidcKey(\"testOidcKey\", {\n    allowedClientIds: [\"*\"],\n    rotationPeriod: 3600,\n    verificationTtl: 3600,\n});\nconst testOidcAssignment = new vault.identity.OidcAssignment(\"testOidcAssignment\", {\n    entityIds: [\"fake-ascbascas-2231a-sdfaa\"],\n    groupIds: [\"fake-sajkdsad-32414-sfsada\"],\n});\nconst testOidcClient = new vault.identity.OidcClient(\"testOidcClient\", {\n    key: testOidcKey.name,\n    redirectUris: [\n        \"http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\",\n        \"http://127.0.0.1:8251/callback\",\n        \"http://127.0.0.1:8080/callback\",\n    ],\n    assignments: [testOidcAssignment.name],\n    idTokenTtl: 2400,\n    accessTokenTtl: 7200,\n});\nconst testOidcScope = new vault.identity.OidcScope(\"testOidcScope\", {\n    template: JSON.stringify({\n        groups: \"{{identity.entity.groups.names}}\",\n    }),\n    description: \"Groups scope.\",\n});\nconst testOidcProvider = new vault.identity.OidcProvider(\"testOidcProvider\", {\n    httpsEnabled: false,\n    issuerHost: \"127.0.0.1:8200\",\n    allowedClientIds: [testOidcClient.clientId],\n    scopesSupporteds: [testOidcScope.name],\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_vault as vault\n\ntest_oidc_key = vault.identity.OidcKey(\"testOidcKey\",\n    allowed_client_ids=[\"*\"],\n    rotation_period=3600,\n    verification_ttl=3600)\ntest_oidc_assignment = vault.identity.OidcAssignment(\"testOidcAssignment\",\n    entity_ids=[\"fake-ascbascas-2231a-sdfaa\"],\n    group_ids=[\"fake-sajkdsad-32414-sfsada\"])\ntest_oidc_client = vault.identity.OidcClient(\"testOidcClient\",\n    key=test_oidc_key.name,\n    redirect_uris=[\n        \"http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\",\n        \"http://127.0.0.1:8251/callback\",\n        \"http://127.0.0.1:8080/callback\",\n    ],\n    assignments=[test_oidc_assignment.name],\n    id_token_ttl=2400,\n    access_token_ttl=7200)\ntest_oidc_scope = vault.identity.OidcScope(\"testOidcScope\",\n    template=json.dumps({\n        \"groups\": \"{{identity.entity.groups.names}}\",\n    }),\n    description=\"Groups scope.\")\ntest_oidc_provider = vault.identity.OidcProvider(\"testOidcProvider\",\n    https_enabled=False,\n    issuer_host=\"127.0.0.1:8200\",\n    allowed_client_ids=[test_oidc_client.client_id],\n    scopes_supporteds=[test_oidc_scope.name])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testOidcKey = new Vault.Identity.OidcKey(\"testOidcKey\", new()\n    {\n        AllowedClientIds = new[]\n        {\n            \"*\",\n        },\n        RotationPeriod = 3600,\n        VerificationTtl = 3600,\n    });\n\n    var testOidcAssignment = new Vault.Identity.OidcAssignment(\"testOidcAssignment\", new()\n    {\n        EntityIds = new[]\n        {\n            \"fake-ascbascas-2231a-sdfaa\",\n        },\n        GroupIds = new[]\n        {\n            \"fake-sajkdsad-32414-sfsada\",\n        },\n    });\n\n    var testOidcClient = new Vault.Identity.OidcClient(\"testOidcClient\", new()\n    {\n        Key = testOidcKey.Name,\n        RedirectUris = new[]\n        {\n            \"http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\",\n            \"http://127.0.0.1:8251/callback\",\n            \"http://127.0.0.1:8080/callback\",\n        },\n        Assignments = new[]\n        {\n            testOidcAssignment.Name,\n        },\n        IdTokenTtl = 2400,\n        AccessTokenTtl = 7200,\n    });\n\n    var testOidcScope = new Vault.Identity.OidcScope(\"testOidcScope\", new()\n    {\n        Template = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"groups\"] = \"{{identity.entity.groups.names}}\",\n        }),\n        Description = \"Groups scope.\",\n    });\n\n    var testOidcProvider = new Vault.Identity.OidcProvider(\"testOidcProvider\", new()\n    {\n        HttpsEnabled = false,\n        IssuerHost = \"127.0.0.1:8200\",\n        AllowedClientIds = new[]\n        {\n            testOidcClient.ClientId,\n        },\n        ScopesSupporteds = new[]\n        {\n            testOidcScope.Name,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestOidcKey, err := identity.NewOidcKey(ctx, \"testOidcKey\", \u0026identity.OidcKeyArgs{\n\t\t\tAllowedClientIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"*\"),\n\t\t\t},\n\t\t\tRotationPeriod:  pulumi.Int(3600),\n\t\t\tVerificationTtl: pulumi.Int(3600),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestOidcAssignment, err := identity.NewOidcAssignment(ctx, \"testOidcAssignment\", \u0026identity.OidcAssignmentArgs{\n\t\t\tEntityIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"fake-ascbascas-2231a-sdfaa\"),\n\t\t\t},\n\t\t\tGroupIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"fake-sajkdsad-32414-sfsada\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestOidcClient, err := identity.NewOidcClient(ctx, \"testOidcClient\", \u0026identity.OidcClientArgs{\n\t\t\tKey: testOidcKey.Name,\n\t\t\tRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\"),\n\t\t\t\tpulumi.String(\"http://127.0.0.1:8251/callback\"),\n\t\t\t\tpulumi.String(\"http://127.0.0.1:8080/callback\"),\n\t\t\t},\n\t\t\tAssignments: pulumi.StringArray{\n\t\t\t\ttestOidcAssignment.Name,\n\t\t\t},\n\t\t\tIdTokenTtl:     pulumi.Int(2400),\n\t\t\tAccessTokenTtl: pulumi.Int(7200),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"groups\": \"{{identity.entity.groups.names}}\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\ttestOidcScope, err := identity.NewOidcScope(ctx, \"testOidcScope\", \u0026identity.OidcScopeArgs{\n\t\t\tTemplate:    pulumi.String(json0),\n\t\t\tDescription: pulumi.String(\"Groups scope.\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewOidcProvider(ctx, \"testOidcProvider\", \u0026identity.OidcProviderArgs{\n\t\t\tHttpsEnabled: pulumi.Bool(false),\n\t\t\tIssuerHost:   pulumi.String(\"127.0.0.1:8200\"),\n\t\t\tAllowedClientIds: pulumi.StringArray{\n\t\t\t\ttestOidcClient.ClientId,\n\t\t\t},\n\t\t\tScopesSupporteds: pulumi.StringArray{\n\t\t\t\ttestOidcScope.Name,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.OidcKey;\nimport com.pulumi.vault.identity.OidcKeyArgs;\nimport com.pulumi.vault.identity.OidcAssignment;\nimport com.pulumi.vault.identity.OidcAssignmentArgs;\nimport com.pulumi.vault.identity.OidcClient;\nimport com.pulumi.vault.identity.OidcClientArgs;\nimport com.pulumi.vault.identity.OidcScope;\nimport com.pulumi.vault.identity.OidcScopeArgs;\nimport com.pulumi.vault.identity.OidcProvider;\nimport com.pulumi.vault.identity.OidcProviderArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testOidcKey = new OidcKey(\"testOidcKey\", OidcKeyArgs.builder()        \n            .allowedClientIds(\"*\")\n            .rotationPeriod(3600)\n            .verificationTtl(3600)\n            .build());\n\n        var testOidcAssignment = new OidcAssignment(\"testOidcAssignment\", OidcAssignmentArgs.builder()        \n            .entityIds(\"fake-ascbascas-2231a-sdfaa\")\n            .groupIds(\"fake-sajkdsad-32414-sfsada\")\n            .build());\n\n        var testOidcClient = new OidcClient(\"testOidcClient\", OidcClientArgs.builder()        \n            .key(testOidcKey.name())\n            .redirectUris(            \n                \"http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\",\n                \"http://127.0.0.1:8251/callback\",\n                \"http://127.0.0.1:8080/callback\")\n            .assignments(testOidcAssignment.name())\n            .idTokenTtl(2400)\n            .accessTokenTtl(7200)\n            .build());\n\n        var testOidcScope = new OidcScope(\"testOidcScope\", OidcScopeArgs.builder()        \n            .template(serializeJson(\n                jsonObject(\n                    jsonProperty(\"groups\", \"{{identity.entity.groups.names}}\")\n                )))\n            .description(\"Groups scope.\")\n            .build());\n\n        var testOidcProvider = new OidcProvider(\"testOidcProvider\", OidcProviderArgs.builder()        \n            .httpsEnabled(false)\n            .issuerHost(\"127.0.0.1:8200\")\n            .allowedClientIds(testOidcClient.clientId())\n            .scopesSupporteds(testOidcScope.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testOidcKey:\n    type: vault:identity:OidcKey\n    properties:\n      allowedClientIds:\n        - '*'\n      rotationPeriod: 3600\n      verificationTtl: 3600\n  testOidcAssignment:\n    type: vault:identity:OidcAssignment\n    properties:\n      entityIds:\n        - fake-ascbascas-2231a-sdfaa\n      groupIds:\n        - fake-sajkdsad-32414-sfsada\n  testOidcClient:\n    type: vault:identity:OidcClient\n    properties:\n      key: ${testOidcKey.name}\n      redirectUris:\n        - http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\n        - http://127.0.0.1:8251/callback\n        - http://127.0.0.1:8080/callback\n      assignments:\n        - ${testOidcAssignment.name}\n      idTokenTtl: 2400\n      accessTokenTtl: 7200\n  testOidcScope:\n    type: vault:identity:OidcScope\n    properties:\n      template:\n        Fn::ToJSON:\n          groups: '{{identity.entity.groups.names}}'\n      description: Groups scope.\n  testOidcProvider:\n    type: vault:identity:OidcProvider\n    properties:\n      httpsEnabled: false\n      issuerHost: 127.0.0.1:8200\n      allowedClientIds:\n        - ${testOidcClient.clientId}\n      scopesSupporteds:\n        - ${testOidcScope.name}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nOIDC Providers can be imported using the `name`, e.g.\n\n```sh\n $ pulumi import vault:identity/oidcProvider:OidcProvider test my-provider\n```\n\n ",
            "properties": {
                "allowedClientIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The client IDs that are permitted to use the provider. \nIf empty, no clients are allowed. If `*`, all clients are allowed.\n"
                },
                "httpsEnabled": {
                    "type": "boolean",
                    "description": "Set to true if the issuer endpoint uses HTTPS.\n"
                },
                "issuer": {
                    "type": "string",
                    "description": "Specifies what will be used as the `scheme://host:port`\ncomponent for the `iss` claim of ID tokens. This value is computed using the\n`issuer_host` and `https_enabled` fields.\n"
                },
                "issuerHost": {
                    "type": "string",
                    "description": "The host for the issuer. Can be either host or host:port.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the provider.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "scopesSupporteds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The scopes available for requesting on the provider.\n"
                }
            },
            "required": [
                "issuer",
                "name"
            ],
            "inputProperties": {
                "allowedClientIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The client IDs that are permitted to use the provider. \nIf empty, no clients are allowed. If `*`, all clients are allowed.\n"
                },
                "httpsEnabled": {
                    "type": "boolean",
                    "description": "Set to true if the issuer endpoint uses HTTPS.\n"
                },
                "issuerHost": {
                    "type": "string",
                    "description": "The host for the issuer. Can be either host or host:port.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the provider.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "scopesSupporteds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The scopes available for requesting on the provider.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OidcProvider resources.\n",
                "properties": {
                    "allowedClientIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The client IDs that are permitted to use the provider. \nIf empty, no clients are allowed. If `*`, all clients are allowed.\n"
                    },
                    "httpsEnabled": {
                        "type": "boolean",
                        "description": "Set to true if the issuer endpoint uses HTTPS.\n"
                    },
                    "issuer": {
                        "type": "string",
                        "description": "Specifies what will be used as the `scheme://host:port`\ncomponent for the `iss` claim of ID tokens. This value is computed using the\n`issuer_host` and `https_enabled` fields.\n"
                    },
                    "issuerHost": {
                        "type": "string",
                        "description": "The host for the issuer. Can be either host or host:port.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the provider.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "scopesSupporteds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The scopes available for requesting on the provider.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/oidcRole:OidcRole": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\nYou need to create a role with a named key.\nAt creation time, the key can be created independently of the role. However, the key must\nexist before the role can be used to issue tokens. You must also configure the key with the\nrole's Client ID to allow the role to use the key.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst config = new pulumi.Config();\nconst key = config.get(\"key\") || \"key\";\nconst role = new vault.identity.OidcRole(\"role\", {key: key});\nconst keyOidcKey = new vault.identity.OidcKey(\"keyOidcKey\", {\n    algorithm: \"RS256\",\n    allowedClientIds: [role.clientId],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nconfig = pulumi.Config()\nkey = config.get(\"key\")\nif key is None:\n    key = \"key\"\nrole = vault.identity.OidcRole(\"role\", key=key)\nkey_oidc_key = vault.identity.OidcKey(\"keyOidcKey\",\n    algorithm=\"RS256\",\n    allowed_client_ids=[role.client_id])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Config();\n    var key = config.Get(\"key\") ?? \"key\";\n    var role = new Vault.Identity.OidcRole(\"role\", new()\n    {\n        Key = key,\n    });\n\n    var keyOidcKey = new Vault.Identity.OidcKey(\"keyOidcKey\", new()\n    {\n        Algorithm = \"RS256\",\n        AllowedClientIds = new[]\n        {\n            role.ClientId,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcfg := config.New(ctx, \"\")\n\t\tkey := \"key\"\n\t\tif param := cfg.Get(\"key\"); param != \"\" {\n\t\t\tkey = param\n\t\t}\n\t\trole, err := identity.NewOidcRole(ctx, \"role\", \u0026identity.OidcRoleArgs{\n\t\t\tKey: pulumi.String(key),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewOidcKey(ctx, \"keyOidcKey\", \u0026identity.OidcKeyArgs{\n\t\t\tAlgorithm: pulumi.String(\"RS256\"),\n\t\t\tAllowedClientIds: pulumi.StringArray{\n\t\t\t\trole.ClientId,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.OidcRole;\nimport com.pulumi.vault.identity.OidcRoleArgs;\nimport com.pulumi.vault.identity.OidcKey;\nimport com.pulumi.vault.identity.OidcKeyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var config = ctx.config();\n        final var key = config.get(\"key\").orElse(\"key\");\n        var role = new OidcRole(\"role\", OidcRoleArgs.builder()        \n            .key(key)\n            .build());\n\n        var keyOidcKey = new OidcKey(\"keyOidcKey\", OidcKeyArgs.builder()        \n            .algorithm(\"RS256\")\n            .allowedClientIds(role.clientId())\n            .build());\n\n    }\n}\n```\n```yaml\nconfiguration:\n  key:\n    type: string\n    default: key\nresources:\n  keyOidcKey:\n    type: vault:identity:OidcKey\n    properties:\n      algorithm: RS256\n      allowedClientIds:\n        - ${role.clientId}\n  role:\n    type: vault:identity:OidcRole\n    properties:\n      key: ${key}\n```\n\nIf you want to create the key first before creating the role, you can use a separate\nresource to configure the allowed Client ID on\nthe key.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst key = new vault.identity.OidcKey(\"key\", {algorithm: \"RS256\"});\nconst roleOidcRole = new vault.identity.OidcRole(\"roleOidcRole\", {key: key.name});\nconst roleOidcKeyAllowedClientID = new vault.identity.OidcKeyAllowedClientID(\"roleOidcKeyAllowedClientID\", {\n    keyName: key.name,\n    allowedClientId: roleOidcRole.clientId,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nkey = vault.identity.OidcKey(\"key\", algorithm=\"RS256\")\nrole_oidc_role = vault.identity.OidcRole(\"roleOidcRole\", key=key.name)\nrole_oidc_key_allowed_client_id = vault.identity.OidcKeyAllowedClientID(\"roleOidcKeyAllowedClientID\",\n    key_name=key.name,\n    allowed_client_id=role_oidc_role.client_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var key = new Vault.Identity.OidcKey(\"key\", new()\n    {\n        Algorithm = \"RS256\",\n    });\n\n    var roleOidcRole = new Vault.Identity.OidcRole(\"roleOidcRole\", new()\n    {\n        Key = key.Name,\n    });\n\n    var roleOidcKeyAllowedClientID = new Vault.Identity.OidcKeyAllowedClientID(\"roleOidcKeyAllowedClientID\", new()\n    {\n        KeyName = key.Name,\n        AllowedClientId = roleOidcRole.ClientId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tkey, err := identity.NewOidcKey(ctx, \"key\", \u0026identity.OidcKeyArgs{\n\t\t\tAlgorithm: pulumi.String(\"RS256\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\troleOidcRole, err := identity.NewOidcRole(ctx, \"roleOidcRole\", \u0026identity.OidcRoleArgs{\n\t\t\tKey: key.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewOidcKeyAllowedClientID(ctx, \"roleOidcKeyAllowedClientID\", \u0026identity.OidcKeyAllowedClientIDArgs{\n\t\t\tKeyName:         key.Name,\n\t\t\tAllowedClientId: roleOidcRole.ClientId,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.OidcKey;\nimport com.pulumi.vault.identity.OidcKeyArgs;\nimport com.pulumi.vault.identity.OidcRole;\nimport com.pulumi.vault.identity.OidcRoleArgs;\nimport com.pulumi.vault.identity.OidcKeyAllowedClientID;\nimport com.pulumi.vault.identity.OidcKeyAllowedClientIDArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var key = new OidcKey(\"key\", OidcKeyArgs.builder()        \n            .algorithm(\"RS256\")\n            .build());\n\n        var roleOidcRole = new OidcRole(\"roleOidcRole\", OidcRoleArgs.builder()        \n            .key(key.name())\n            .build());\n\n        var roleOidcKeyAllowedClientID = new OidcKeyAllowedClientID(\"roleOidcKeyAllowedClientID\", OidcKeyAllowedClientIDArgs.builder()        \n            .keyName(key.name())\n            .allowedClientId(roleOidcRole.clientId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  key:\n    type: vault:identity:OidcKey\n    properties:\n      algorithm: RS256\n  roleOidcRole:\n    type: vault:identity:OidcRole\n    properties:\n      key: ${key.name}\n  roleOidcKeyAllowedClientID:\n    type: vault:identity:OidcKeyAllowedClientID\n    properties:\n      keyName: ${key.name}\n      allowedClientId: ${roleOidcRole.clientId}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nThe key can be imported with the role name, for example\n\n```sh\n $ pulumi import vault:identity/oidcRole:OidcRole role role\n```\n\n ",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The value that will be included in the `aud` field of all the OIDC identity\ntokens issued by this role\n"
                },
                "key": {
                    "type": "string",
                    "description": "A configured named key, the key must already exist\nbefore tokens can be issued.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the OIDC Role to create.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "template": {
                    "type": "string",
                    "description": "The template string to use for generating tokens. This may be in\nstring-ified JSON or base64 format. See the\n[documentation](https://www.vaultproject.io/docs/secrets/identity/index.html#token-contents-and-templates)\nfor the template format.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "TTL of the tokens generated against the role in number of seconds.\n"
                }
            },
            "required": [
                "clientId",
                "key",
                "name"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The value that will be included in the `aud` field of all the OIDC identity\ntokens issued by this role\n"
                },
                "key": {
                    "type": "string",
                    "description": "A configured named key, the key must already exist\nbefore tokens can be issued.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Name of the OIDC Role to create.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "template": {
                    "type": "string",
                    "description": "The template string to use for generating tokens. This may be in\nstring-ified JSON or base64 format. See the\n[documentation](https://www.vaultproject.io/docs/secrets/identity/index.html#token-contents-and-templates)\nfor the template format.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "TTL of the tokens generated against the role in number of seconds.\n"
                }
            },
            "requiredInputs": [
                "key"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OidcRole resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The value that will be included in the `aud` field of all the OIDC identity\ntokens issued by this role\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "A configured named key, the key must already exist\nbefore tokens can be issued.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the OIDC Role to create.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "template": {
                        "type": "string",
                        "description": "The template string to use for generating tokens. This may be in\nstring-ified JSON or base64 format. See the\n[documentation](https://www.vaultproject.io/docs/secrets/identity/index.html#token-contents-and-templates)\nfor the template format.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "TTL of the tokens generated against the role in number of seconds.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/oidcScope:OidcScope": {
            "description": "Manages OIDC Scopes in a Vault server. See the [Vault documentation](https://www.vaultproject.io/api-docs/secret/identity/oidc-provider#create-or-update-a-scope)\nfor more information.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst groups = new vault.identity.OidcScope(\"groups\", {\n    description: \"Vault OIDC Groups Scope\",\n    template: \"{\\\"groups\\\":{{identity.entity.groups.names}}}\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ngroups = vault.identity.OidcScope(\"groups\",\n    description=\"Vault OIDC Groups Scope\",\n    template=\"{\\\"groups\\\":{{identity.entity.groups.names}}}\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var groups = new Vault.Identity.OidcScope(\"groups\", new()\n    {\n        Description = \"Vault OIDC Groups Scope\",\n        Template = \"{\\\"groups\\\":{{identity.entity.groups.names}}}\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := identity.NewOidcScope(ctx, \"groups\", \u0026identity.OidcScopeArgs{\n\t\t\tDescription: pulumi.String(\"Vault OIDC Groups Scope\"),\n\t\t\tTemplate:    pulumi.String(\"{\\\"groups\\\":{{identity.entity.groups.names}}}\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.OidcScope;\nimport com.pulumi.vault.identity.OidcScopeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var groups = new OidcScope(\"groups\", OidcScopeArgs.builder()        \n            .description(\"Vault OIDC Groups Scope\")\n            .template(\"{\\\"groups\\\":{{identity.entity.groups.names}}}\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  groups:\n    type: vault:identity:OidcScope\n    properties:\n      description: Vault OIDC Groups Scope\n      template: '{\"groups\":{{identity.entity.groups.names}}}'\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nOIDC Scopes can be imported using the `name`, e.g.\n\n```sh\n $ pulumi import vault:identity/oidcScope:OidcScope groups groups\n```\n\n ",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "A description of the scope.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the scope. The `openid` scope name is reserved.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "template": {
                    "type": "string",
                    "description": "The template string for the scope. This may be provided as escaped JSON or base64 encoded JSON.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "A description of the scope.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the scope. The `openid` scope name is reserved.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "template": {
                    "type": "string",
                    "description": "The template string for the scope. This may be provided as escaped JSON or base64 encoded JSON.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OidcScope resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "A description of the scope.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the scope. The `openid` scope name is reserved.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "template": {
                        "type": "string",
                        "description": "The template string for the scope. This may be provided as escaped JSON or base64 encoded JSON.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/audit:Audit": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n### File Audit Device)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst test = new vault.Audit(\"test\", {\n    options: {\n        file_path: \"C:/temp/audit.txt\",\n    },\n    type: \"file\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntest = vault.Audit(\"test\",\n    options={\n        \"file_path\": \"C:/temp/audit.txt\",\n    },\n    type=\"file\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Vault.Audit(\"test\", new()\n    {\n        Options = \n        {\n            { \"file_path\", \"C:/temp/audit.txt\" },\n        },\n        Type = \"file\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewAudit(ctx, \"test\", \u0026vault.AuditArgs{\n\t\t\tOptions: pulumi.StringMap{\n\t\t\t\t\"file_path\": pulumi.String(\"C:/temp/audit.txt\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"file\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Audit;\nimport com.pulumi.vault.AuditArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new Audit(\"test\", AuditArgs.builder()        \n            .options(Map.of(\"file_path\", \"C:/temp/audit.txt\"))\n            .type(\"file\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: vault:Audit\n    properties:\n      options:\n        file_path: C:/temp/audit.txt\n      type: file\n```\n\n{{% /example %}}\n{{% example %}}\n### Socket Audit Device)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst test = new vault.Audit(\"test\", {\n    local: false,\n    options: {\n        address: \"127.0.0.1:8000\",\n        description: \"application x socket\",\n        socket_type: \"tcp\",\n    },\n    path: \"app_socket\",\n    type: \"socket\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntest = vault.Audit(\"test\",\n    local=False,\n    options={\n        \"address\": \"127.0.0.1:8000\",\n        \"description\": \"application x socket\",\n        \"socket_type\": \"tcp\",\n    },\n    path=\"app_socket\",\n    type=\"socket\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Vault.Audit(\"test\", new()\n    {\n        Local = false,\n        Options = \n        {\n            { \"address\", \"127.0.0.1:8000\" },\n            { \"description\", \"application x socket\" },\n            { \"socket_type\", \"tcp\" },\n        },\n        Path = \"app_socket\",\n        Type = \"socket\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewAudit(ctx, \"test\", \u0026vault.AuditArgs{\n\t\t\tLocal: pulumi.Bool(false),\n\t\t\tOptions: pulumi.StringMap{\n\t\t\t\t\"address\":     pulumi.String(\"127.0.0.1:8000\"),\n\t\t\t\t\"description\": pulumi.String(\"application x socket\"),\n\t\t\t\t\"socket_type\": pulumi.String(\"tcp\"),\n\t\t\t},\n\t\t\tPath: pulumi.String(\"app_socket\"),\n\t\t\tType: pulumi.String(\"socket\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Audit;\nimport com.pulumi.vault.AuditArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new Audit(\"test\", AuditArgs.builder()        \n            .local(false)\n            .options(Map.ofEntries(\n                Map.entry(\"address\", \"127.0.0.1:8000\"),\n                Map.entry(\"description\", \"application x socket\"),\n                Map.entry(\"socket_type\", \"tcp\")\n            ))\n            .path(\"app_socket\")\n            .type(\"socket\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: vault:Audit\n    properties:\n      local: false\n      options:\n        address: 127.0.0.1:8000\n        description: application x socket\n        socket_type: tcp\n      path: app_socket\n      type: socket\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAudit devices can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:index/audit:Audit test syslog\n```\n\n ",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the audit device.\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the audit device is a local only. Local audit devices are not replicated nor (if a secondary) removed by replication.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "options": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Configuration options to pass to the audit device itself.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path to mount the audit device. This defaults to the type.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the audit device, such as 'file'.\n"
                }
            },
            "required": [
                "options",
                "path",
                "type"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the audit device.\n",
                    "willReplaceOnChanges": true
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the audit device is a local only. Local audit devices are not replicated nor (if a secondary) removed by replication.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "options": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Configuration options to pass to the audit device itself.\n",
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "The path to mount the audit device. This defaults to the type.\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "Type of the audit device, such as 'file'.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "options",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Audit resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Human-friendly description of the audit device.\n",
                        "willReplaceOnChanges": true
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Specifies if the audit device is a local only. Local audit devices are not replicated nor (if a secondary) removed by replication.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "options": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Configuration options to pass to the audit device itself.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "The path to mount the audit device. This defaults to the type.\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of the audit device, such as 'file'.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:index/auditRequestHeader:AuditRequestHeader": {
            "description": "Manages additional request headers that appear in audited requests.\n\n\u003e **Note**\nBecause of the way the [sys/config/auditing/request-headers API](https://www.vaultproject.io/api-docs/system/config-auditing)\nis implemented in Vault, this resource will manage existing audited headers with\nmatching names without requiring import.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst xForwardedFor = new vault.AuditRequestHeader(\"x_forwarded_for\", {\n    hmac: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nx_forwarded_for = vault.AuditRequestHeader(\"xForwardedFor\", hmac=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var xForwardedFor = new Vault.AuditRequestHeader(\"xForwardedFor\", new()\n    {\n        Hmac = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewAuditRequestHeader(ctx, \"xForwardedFor\", \u0026vault.AuditRequestHeaderArgs{\n\t\t\tHmac: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.AuditRequestHeader;\nimport com.pulumi.vault.AuditRequestHeaderArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var xForwardedFor = new AuditRequestHeader(\"xForwardedFor\", AuditRequestHeaderArgs.builder()        \n            .hmac(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  xForwardedFor:\n    type: vault:AuditRequestHeader\n    properties:\n      hmac: false\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "hmac": {
                    "type": "boolean",
                    "description": "Whether this header's value should be HMAC'd in the audit logs.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the request header to audit.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "Target namespace. (requires Enterprise)\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "hmac": {
                    "type": "boolean",
                    "description": "Whether this header's value should be HMAC'd in the audit logs.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the request header to audit.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "Target namespace. (requires Enterprise)\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuditRequestHeader resources.\n",
                "properties": {
                    "hmac": {
                        "type": "boolean",
                        "description": "Whether this header's value should be HMAC'd in the audit logs.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the request header to audit.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "Target namespace. (requires Enterprise)\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:index/authBackend:AuthBackend": {
            "description": "\n\n\n## Import\n\nAuth methods can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:index/authBackend:AuthBackend example github\n```\n\n ",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The accessor for this auth method\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description of the auth method.\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the auth method is local only.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path to mount the auth method — this defaults to the name of the type.\n"
                },
                "tune": {
                    "$ref": "#/types/vault:index/AuthBackendTune:AuthBackendTune",
                    "description": "Extra configuration block. Structure is documented below.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The name of the auth method type.\n"
                }
            },
            "required": [
                "accessor",
                "path",
                "tune",
                "type"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "A description of the auth method.\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the auth method is local only.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "The path to mount the auth method — this defaults to the name of the type.\n"
                },
                "tune": {
                    "$ref": "#/types/vault:index/AuthBackendTune:AuthBackendTune",
                    "description": "Extra configuration block. Structure is documented below.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The name of the auth method type.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackend resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The accessor for this auth method\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description of the auth method.\n"
                    },
                    "disableRemount": {
                        "type": "boolean",
                        "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Specifies if the auth method is local only.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "The path to mount the auth method — this defaults to the name of the type.\n"
                    },
                    "tune": {
                        "$ref": "#/types/vault:index/AuthBackendTune:AuthBackendTune",
                        "description": "Extra configuration block. Structure is documented below.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The name of the auth method type.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:index/certAuthBackendRole:CertAuthBackendRole": {
            "description": "Provides a resource to create a role in an [Cert auth backend within Vault](https://www.vaultproject.io/docs/auth/cert.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as fs from \"fs\";\nimport * as vault from \"@pulumi/vault\";\n\nconst certAuthBackend = new vault.AuthBackend(\"certAuthBackend\", {\n    path: \"cert\",\n    type: \"cert\",\n});\nconst certCertAuthBackendRole = new vault.CertAuthBackendRole(\"certCertAuthBackendRole\", {\n    certificate: fs.readFileSync(\"/path/to/certs/ca-cert.pem\"),\n    backend: certAuthBackend.path,\n    allowedNames: [\n        \"foo.example.org\",\n        \"baz.example.org\",\n    ],\n    tokenTtl: 300,\n    tokenMaxTtl: 600,\n    tokenPolicies: [\"foo\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ncert_auth_backend = vault.AuthBackend(\"certAuthBackend\",\n    path=\"cert\",\n    type=\"cert\")\ncert_cert_auth_backend_role = vault.CertAuthBackendRole(\"certCertAuthBackendRole\",\n    certificate=(lambda path: open(path).read())(\"/path/to/certs/ca-cert.pem\"),\n    backend=cert_auth_backend.path,\n    allowed_names=[\n        \"foo.example.org\",\n        \"baz.example.org\",\n    ],\n    token_ttl=300,\n    token_max_ttl=600,\n    token_policies=[\"foo\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var certAuthBackend = new Vault.AuthBackend(\"certAuthBackend\", new()\n    {\n        Path = \"cert\",\n        Type = \"cert\",\n    });\n\n    var certCertAuthBackendRole = new Vault.CertAuthBackendRole(\"certCertAuthBackendRole\", new()\n    {\n        Certificate = File.ReadAllText(\"/path/to/certs/ca-cert.pem\"),\n        Backend = certAuthBackend.Path,\n        AllowedNames = new[]\n        {\n            \"foo.example.org\",\n            \"baz.example.org\",\n        },\n        TokenTtl = 300,\n        TokenMaxTtl = 600,\n        TokenPolicies = new[]\n        {\n            \"foo\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcertAuthBackend, err := vault.NewAuthBackend(ctx, \"certAuthBackend\", \u0026vault.AuthBackendArgs{\n\t\t\tPath: pulumi.String(\"cert\"),\n\t\t\tType: pulumi.String(\"cert\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vault.NewCertAuthBackendRole(ctx, \"certCertAuthBackendRole\", \u0026vault.CertAuthBackendRoleArgs{\n\t\t\tCertificate: readFileOrPanic(\"/path/to/certs/ca-cert.pem\"),\n\t\t\tBackend:     certAuthBackend.Path,\n\t\t\tAllowedNames: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"foo.example.org\"),\n\t\t\t\tpulumi.String(\"baz.example.org\"),\n\t\t\t},\n\t\t\tTokenTtl:    pulumi.Int(300),\n\t\t\tTokenMaxTtl: pulumi.Int(600),\n\t\t\tTokenPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"foo\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.AuthBackend;\nimport com.pulumi.vault.AuthBackendArgs;\nimport com.pulumi.vault.CertAuthBackendRole;\nimport com.pulumi.vault.CertAuthBackendRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var certAuthBackend = new AuthBackend(\"certAuthBackend\", AuthBackendArgs.builder()        \n            .path(\"cert\")\n            .type(\"cert\")\n            .build());\n\n        var certCertAuthBackendRole = new CertAuthBackendRole(\"certCertAuthBackendRole\", CertAuthBackendRoleArgs.builder()        \n            .certificate(Files.readString(Paths.get(\"/path/to/certs/ca-cert.pem\")))\n            .backend(certAuthBackend.path())\n            .allowedNames(            \n                \"foo.example.org\",\n                \"baz.example.org\")\n            .tokenTtl(300)\n            .tokenMaxTtl(600)\n            .tokenPolicies(\"foo\")\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "allowedCommonNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed the common names for authenticated client certificates\n"
                },
                "allowedDnsSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed alternative dns names for authenticated client certificates\n"
                },
                "allowedEmailSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed emails for authenticated client certificates\n"
                },
                "allowedNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed subject names for authenticated client certificates\n"
                },
                "allowedOrganizationUnits": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "deprecationMessage": "Use allowed_organizational_units"
                },
                "allowedOrganizationalUnits": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed organization units for authenticated client certificates.\n*In previous provider releases this field was incorrectly named `allowed_organization_units`, please update accordingly*\n"
                },
                "allowedUriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed URIs for authenticated client certificates\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Path to the mounted Cert auth backend\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "CA certificate used to validate client certificates\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "The name to display on tokens issued under this role.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the role\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "requiredExtensions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "TLS extensions required on client certificates\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The [maximum number](https://www.vaultproject.io/api-docs/auth/cert#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "required": [
                "allowedCommonNames",
                "allowedDnsSans",
                "allowedEmailSans",
                "allowedNames",
                "allowedOrganizationUnits",
                "allowedUriSans",
                "certificate",
                "displayName",
                "name",
                "requiredExtensions"
            ],
            "inputProperties": {
                "allowedCommonNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed the common names for authenticated client certificates\n"
                },
                "allowedDnsSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed alternative dns names for authenticated client certificates\n"
                },
                "allowedEmailSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed emails for authenticated client certificates\n"
                },
                "allowedNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed subject names for authenticated client certificates\n"
                },
                "allowedOrganizationUnits": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "deprecationMessage": "Use allowed_organizational_units"
                },
                "allowedOrganizationalUnits": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed organization units for authenticated client certificates.\n*In previous provider releases this field was incorrectly named `allowed_organization_units`, please update accordingly*\n"
                },
                "allowedUriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed URIs for authenticated client certificates\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Path to the mounted Cert auth backend\n",
                    "willReplaceOnChanges": true
                },
                "certificate": {
                    "type": "string",
                    "description": "CA certificate used to validate client certificates\n",
                    "willReplaceOnChanges": true
                },
                "displayName": {
                    "type": "string",
                    "description": "The name to display on tokens issued under this role.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the role\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "requiredExtensions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "TLS extensions required on client certificates\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The [maximum number](https://www.vaultproject.io/api-docs/auth/cert#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "requiredInputs": [
                "certificate"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CertAuthBackendRole resources.\n",
                "properties": {
                    "allowedCommonNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Allowed the common names for authenticated client certificates\n"
                    },
                    "allowedDnsSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Allowed alternative dns names for authenticated client certificates\n"
                    },
                    "allowedEmailSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Allowed emails for authenticated client certificates\n"
                    },
                    "allowedNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Allowed subject names for authenticated client certificates\n"
                    },
                    "allowedOrganizationUnits": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "deprecationMessage": "Use allowed_organizational_units"
                    },
                    "allowedOrganizationalUnits": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Allowed organization units for authenticated client certificates.\n*In previous provider releases this field was incorrectly named `allowed_organization_units`, please update accordingly*\n"
                    },
                    "allowedUriSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Allowed URIs for authenticated client certificates\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "Path to the mounted Cert auth backend\n",
                        "willReplaceOnChanges": true
                    },
                    "certificate": {
                        "type": "string",
                        "description": "CA certificate used to validate client certificates\n",
                        "willReplaceOnChanges": true
                    },
                    "displayName": {
                        "type": "string",
                        "description": "The name to display on tokens issued under this role.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the role\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "requiredExtensions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "TLS extensions required on client certificates\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The [maximum number](https://www.vaultproject.io/api-docs/auth/cert#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/egpPolicy:EgpPolicy": {
            "description": "Provides a resource to manage Endpoint Governing Policy (EGP) via [Sentinel](https://www.vaultproject.io/docs/enterprise/sentinel/index.html).\n\n**Note** this feature is available only with Vault Enterprise.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst allow_all = new vault.EgpPolicy(\"allow-all\", {\n    enforcementLevel: \"soft-mandatory\",\n    paths: [\"*\"],\n    policy: `main = rule {\n  true\n}\n`,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nallow_all = vault.EgpPolicy(\"allow-all\",\n    enforcement_level=\"soft-mandatory\",\n    paths=[\"*\"],\n    policy=\"\"\"main = rule {\n  true\n}\n\n\"\"\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var allow_all = new Vault.EgpPolicy(\"allow-all\", new()\n    {\n        EnforcementLevel = \"soft-mandatory\",\n        Paths = new[]\n        {\n            \"*\",\n        },\n        Policy = @\"main = rule {\n  true\n}\n\n\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewEgpPolicy(ctx, \"allow-all\", \u0026vault.EgpPolicyArgs{\n\t\t\tEnforcementLevel: pulumi.String(\"soft-mandatory\"),\n\t\t\tPaths: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"*\"),\n\t\t\t},\n\t\t\tPolicy: pulumi.String(\"main = rule {\\n  true\\n}\\n\\n\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.EgpPolicy;\nimport com.pulumi.vault.EgpPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var allow_all = new EgpPolicy(\"allow-all\", EgpPolicyArgs.builder()        \n            .enforcementLevel(\"soft-mandatory\")\n            .paths(\"*\")\n            .policy(\"\"\"\nmain = rule {\n  true\n}\n\n            \"\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  allow-all:\n    type: vault:EgpPolicy\n    properties:\n      enforcementLevel: soft-mandatory\n      paths:\n        - '*'\n      policy: |+\n        main = rule {\n          true\n        }\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "enforcementLevel": {
                    "type": "string",
                    "description": "Enforcement level of Sentinel policy. Can be either `advisory` or `soft-mandatory` or `hard-mandatory`\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the policy\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "paths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of paths to which the policy will be applied to\n"
                },
                "policy": {
                    "type": "string",
                    "description": "String containing a Sentinel policy\n"
                }
            },
            "required": [
                "enforcementLevel",
                "name",
                "paths",
                "policy"
            ],
            "inputProperties": {
                "enforcementLevel": {
                    "type": "string",
                    "description": "Enforcement level of Sentinel policy. Can be either `advisory` or `soft-mandatory` or `hard-mandatory`\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the policy\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "paths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of paths to which the policy will be applied to\n"
                },
                "policy": {
                    "type": "string",
                    "description": "String containing a Sentinel policy\n"
                }
            },
            "requiredInputs": [
                "enforcementLevel",
                "paths",
                "policy"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EgpPolicy resources.\n",
                "properties": {
                    "enforcementLevel": {
                        "type": "string",
                        "description": "Enforcement level of Sentinel policy. Can be either `advisory` or `soft-mandatory` or `hard-mandatory`\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the policy\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "paths": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of paths to which the policy will be applied to\n"
                    },
                    "policy": {
                        "type": "string",
                        "description": "String containing a Sentinel policy\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/mfaDuo:MfaDuo": {
            "description": "Provides a resource to manage [Duo MFA](https://www.vaultproject.io/docs/enterprise/mfa/mfa-duo.html).\n\n**Note** this feature is available only with Vault Enterprise.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst userpass = new vault.AuthBackend(\"userpass\", {\n    type: \"userpass\",\n    path: \"userpass\",\n});\nconst myDuo = new vault.MfaDuo(\"myDuo\", {\n    mountAccessor: userpass.accessor,\n    secretKey: \"8C7THtrIigh2rPZQMbguugt8IUftWhMRCOBzbuyz\",\n    integrationKey: \"BIACEUEAXI20BNWTEYXT\",\n    apiHostname: \"api-2b5c39f5.duosecurity.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nuserpass = vault.AuthBackend(\"userpass\",\n    type=\"userpass\",\n    path=\"userpass\")\nmy_duo = vault.MfaDuo(\"myDuo\",\n    mount_accessor=userpass.accessor,\n    secret_key=\"8C7THtrIigh2rPZQMbguugt8IUftWhMRCOBzbuyz\",\n    integration_key=\"BIACEUEAXI20BNWTEYXT\",\n    api_hostname=\"api-2b5c39f5.duosecurity.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var userpass = new Vault.AuthBackend(\"userpass\", new()\n    {\n        Type = \"userpass\",\n        Path = \"userpass\",\n    });\n\n    var myDuo = new Vault.MfaDuo(\"myDuo\", new()\n    {\n        MountAccessor = userpass.Accessor,\n        SecretKey = \"8C7THtrIigh2rPZQMbguugt8IUftWhMRCOBzbuyz\",\n        IntegrationKey = \"BIACEUEAXI20BNWTEYXT\",\n        ApiHostname = \"api-2b5c39f5.duosecurity.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tuserpass, err := vault.NewAuthBackend(ctx, \"userpass\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"userpass\"),\n\t\t\tPath: pulumi.String(\"userpass\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vault.NewMfaDuo(ctx, \"myDuo\", \u0026vault.MfaDuoArgs{\n\t\t\tMountAccessor:  userpass.Accessor,\n\t\t\tSecretKey:      pulumi.String(\"8C7THtrIigh2rPZQMbguugt8IUftWhMRCOBzbuyz\"),\n\t\t\tIntegrationKey: pulumi.String(\"BIACEUEAXI20BNWTEYXT\"),\n\t\t\tApiHostname:    pulumi.String(\"api-2b5c39f5.duosecurity.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.AuthBackend;\nimport com.pulumi.vault.AuthBackendArgs;\nimport com.pulumi.vault.MfaDuo;\nimport com.pulumi.vault.MfaDuoArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var userpass = new AuthBackend(\"userpass\", AuthBackendArgs.builder()        \n            .type(\"userpass\")\n            .path(\"userpass\")\n            .build());\n\n        var myDuo = new MfaDuo(\"myDuo\", MfaDuoArgs.builder()        \n            .mountAccessor(userpass.accessor())\n            .secretKey(\"8C7THtrIigh2rPZQMbguugt8IUftWhMRCOBzbuyz\")\n            .integrationKey(\"BIACEUEAXI20BNWTEYXT\")\n            .apiHostname(\"api-2b5c39f5.duosecurity.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  userpass:\n    type: vault:AuthBackend\n    properties:\n      type: userpass\n      path: userpass\n  myDuo:\n    type: vault:MfaDuo\n    properties:\n      mountAccessor: ${userpass.accessor}\n      secretKey: 8C7THtrIigh2rPZQMbguugt8IUftWhMRCOBzbuyz\n      integrationKey: BIACEUEAXI20BNWTEYXT\n      apiHostname: api-2b5c39f5.duosecurity.com\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nMounts can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:index/mfaDuo:MfaDuo my_duo my_duo\n```\n\n ",
            "properties": {
                "apiHostname": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - API hostname for Duo.\n"
                },
                "integrationKey": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - Integration key for Duo.\n",
                    "secret": true
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The mount to tie this method to for use in automatic mappings. The mapping will use the Name field of Aliases associated with this mount as the username in the mapping.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` – Name of the MFA method.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "pushInfo": {
                    "type": "string",
                    "description": "`(string)` - Push information for Duo.\n"
                },
                "secretKey": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - Secret key for Duo.\n",
                    "secret": true
                },
                "usernameFormat": {
                    "type": "string",
                    "description": "`(string)` - A format string for mapping Identity names to MFA method names. Values to substitute should be placed in `{{}}`. For example, `\"{{alias.name}}@example.com\"`. If blank, the Alias's Name field will be used as-is. Currently-supported mappings:\n- alias.name: The name returned by the mount configured via the `mount_accessor` parameter\n- entity.name: The name configured for the Entity\n- alias.metadata.`\u003ckey\u003e`: The value of the Alias's metadata parameter\n- entity.metadata.`\u003ckey\u003e`: The value of the Entity's metadata parameter\n"
                }
            },
            "required": [
                "apiHostname",
                "integrationKey",
                "mountAccessor",
                "name",
                "secretKey"
            ],
            "inputProperties": {
                "apiHostname": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - API hostname for Duo.\n"
                },
                "integrationKey": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - Integration key for Duo.\n",
                    "secret": true
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The mount to tie this method to for use in automatic mappings. The mapping will use the Name field of Aliases associated with this mount as the username in the mapping.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` – Name of the MFA method.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "pushInfo": {
                    "type": "string",
                    "description": "`(string)` - Push information for Duo.\n"
                },
                "secretKey": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - Secret key for Duo.\n",
                    "secret": true
                },
                "usernameFormat": {
                    "type": "string",
                    "description": "`(string)` - A format string for mapping Identity names to MFA method names. Values to substitute should be placed in `{{}}`. For example, `\"{{alias.name}}@example.com\"`. If blank, the Alias's Name field will be used as-is. Currently-supported mappings:\n- alias.name: The name returned by the mount configured via the `mount_accessor` parameter\n- entity.name: The name configured for the Entity\n- alias.metadata.`\u003ckey\u003e`: The value of the Alias's metadata parameter\n- entity.metadata.`\u003ckey\u003e`: The value of the Entity's metadata parameter\n"
                }
            },
            "requiredInputs": [
                "apiHostname",
                "integrationKey",
                "mountAccessor",
                "secretKey"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MfaDuo resources.\n",
                "properties": {
                    "apiHostname": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - API hostname for Duo.\n"
                    },
                    "integrationKey": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - Integration key for Duo.\n",
                        "secret": true
                    },
                    "mountAccessor": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The mount to tie this method to for use in automatic mappings. The mapping will use the Name field of Aliases associated with this mount as the username in the mapping.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` – Name of the MFA method.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "pushInfo": {
                        "type": "string",
                        "description": "`(string)` - Push information for Duo.\n"
                    },
                    "secretKey": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - Secret key for Duo.\n",
                        "secret": true
                    },
                    "usernameFormat": {
                        "type": "string",
                        "description": "`(string)` - A format string for mapping Identity names to MFA method names. Values to substitute should be placed in `{{}}`. For example, `\"{{alias.name}}@example.com\"`. If blank, the Alias's Name field will be used as-is. Currently-supported mappings:\n- alias.name: The name returned by the mount configured via the `mount_accessor` parameter\n- entity.name: The name configured for the Entity\n- alias.metadata.`\u003ckey\u003e`: The value of the Alias's metadata parameter\n- entity.metadata.`\u003ckey\u003e`: The value of the Entity's metadata parameter\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/mfaOkta:MfaOkta": {
            "description": "Provides a resource to manage [Okta MFA](https://www.vaultproject.io/docs/enterprise/mfa/mfa-okta).\n\n**Note** this feature is available only with Vault Enterprise.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst userpass = new vault.AuthBackend(\"userpass\", {\n    type: \"userpass\",\n    path: \"userpass\",\n});\nconst myOkta = new vault.MfaOkta(\"myOkta\", {\n    mountAccessor: userpass.accessor,\n    usernameFormat: \"user@example.com\",\n    orgName: \"hashicorp\",\n    apiToken: \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nuserpass = vault.AuthBackend(\"userpass\",\n    type=\"userpass\",\n    path=\"userpass\")\nmy_okta = vault.MfaOkta(\"myOkta\",\n    mount_accessor=userpass.accessor,\n    username_format=\"user@example.com\",\n    org_name=\"hashicorp\",\n    api_token=\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var userpass = new Vault.AuthBackend(\"userpass\", new()\n    {\n        Type = \"userpass\",\n        Path = \"userpass\",\n    });\n\n    var myOkta = new Vault.MfaOkta(\"myOkta\", new()\n    {\n        MountAccessor = userpass.Accessor,\n        UsernameFormat = \"user@example.com\",\n        OrgName = \"hashicorp\",\n        ApiToken = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tuserpass, err := vault.NewAuthBackend(ctx, \"userpass\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"userpass\"),\n\t\t\tPath: pulumi.String(\"userpass\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vault.NewMfaOkta(ctx, \"myOkta\", \u0026vault.MfaOktaArgs{\n\t\t\tMountAccessor:  userpass.Accessor,\n\t\t\tUsernameFormat: pulumi.String(\"user@example.com\"),\n\t\t\tOrgName:        pulumi.String(\"hashicorp\"),\n\t\t\tApiToken:       pulumi.String(\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.AuthBackend;\nimport com.pulumi.vault.AuthBackendArgs;\nimport com.pulumi.vault.MfaOkta;\nimport com.pulumi.vault.MfaOktaArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var userpass = new AuthBackend(\"userpass\", AuthBackendArgs.builder()        \n            .type(\"userpass\")\n            .path(\"userpass\")\n            .build());\n\n        var myOkta = new MfaOkta(\"myOkta\", MfaOktaArgs.builder()        \n            .mountAccessor(userpass.accessor())\n            .usernameFormat(\"user@example.com\")\n            .orgName(\"hashicorp\")\n            .apiToken(\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  userpass:\n    type: vault:AuthBackend\n    properties:\n      type: userpass\n      path: userpass\n  myOkta:\n    type: vault:MfaOkta\n    properties:\n      mountAccessor: ${userpass.accessor}\n      usernameFormat: user@example.com\n      orgName: hashicorp\n      apiToken: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nMounts can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:index/mfaOkta:MfaOkta my_okta my_okta\n```\n\n ",
            "properties": {
                "apiToken": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - Okta API key.\n",
                    "secret": true
                },
                "baseUrl": {
                    "type": "string",
                    "description": "`(string)` - If set, will be used as the base domain for API requests. Examples are `okta.com`, \n`oktapreview.com`, and `okta-emea.com`.\n"
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The mount to tie this method to for use in automatic mappings. \nThe mapping will use the Name field of Aliases associated with this mount as the username in the mapping.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` – Name of the MFA method.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "orgName": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - Name of the organization to be used in the Okta API.\n"
                },
                "primaryEmail": {
                    "type": "boolean",
                    "description": "`(string: \u003crequired\u003e)` - If set to true, the username will only match the \nprimary email for the account.\n"
                },
                "usernameFormat": {
                    "type": "string",
                    "description": "`(string)` - A format string for mapping Identity names to MFA method names. \nValues to substitute should be placed in `{{}}`. For example, `\"{{alias.name}}@example.com\"`.\nIf blank, the Alias's Name field will be used as-is. Currently-supported mappings:\n- alias.name: The name returned by the mount configured via the `mount_accessor` parameter\n- entity.name: The name configured for the Entity\n- alias.metadata.`\u003ckey\u003e`: The value of the Alias's metadata parameter\n- entity.metadata.`\u003ckey\u003e`: The value of the Entity's metadata parameter\n"
                }
            },
            "required": [
                "apiToken",
                "mountAccessor",
                "name",
                "orgName"
            ],
            "inputProperties": {
                "apiToken": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - Okta API key.\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                },
                "baseUrl": {
                    "type": "string",
                    "description": "`(string)` - If set, will be used as the base domain for API requests. Examples are `okta.com`, \n`oktapreview.com`, and `okta-emea.com`.\n",
                    "willReplaceOnChanges": true
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The mount to tie this method to for use in automatic mappings. \nThe mapping will use the Name field of Aliases associated with this mount as the username in the mapping.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` – Name of the MFA method.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "orgName": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - Name of the organization to be used in the Okta API.\n",
                    "willReplaceOnChanges": true
                },
                "primaryEmail": {
                    "type": "boolean",
                    "description": "`(string: \u003crequired\u003e)` - If set to true, the username will only match the \nprimary email for the account.\n",
                    "willReplaceOnChanges": true
                },
                "usernameFormat": {
                    "type": "string",
                    "description": "`(string)` - A format string for mapping Identity names to MFA method names. \nValues to substitute should be placed in `{{}}`. For example, `\"{{alias.name}}@example.com\"`.\nIf blank, the Alias's Name field will be used as-is. Currently-supported mappings:\n- alias.name: The name returned by the mount configured via the `mount_accessor` parameter\n- entity.name: The name configured for the Entity\n- alias.metadata.`\u003ckey\u003e`: The value of the Alias's metadata parameter\n- entity.metadata.`\u003ckey\u003e`: The value of the Entity's metadata parameter\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "apiToken",
                "mountAccessor",
                "orgName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MfaOkta resources.\n",
                "properties": {
                    "apiToken": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - Okta API key.\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "baseUrl": {
                        "type": "string",
                        "description": "`(string)` - If set, will be used as the base domain for API requests. Examples are `okta.com`, \n`oktapreview.com`, and `okta-emea.com`.\n",
                        "willReplaceOnChanges": true
                    },
                    "mountAccessor": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The mount to tie this method to for use in automatic mappings. \nThe mapping will use the Name field of Aliases associated with this mount as the username in the mapping.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` – Name of the MFA method.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "orgName": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - Name of the organization to be used in the Okta API.\n",
                        "willReplaceOnChanges": true
                    },
                    "primaryEmail": {
                        "type": "boolean",
                        "description": "`(string: \u003crequired\u003e)` - If set to true, the username will only match the \nprimary email for the account.\n",
                        "willReplaceOnChanges": true
                    },
                    "usernameFormat": {
                        "type": "string",
                        "description": "`(string)` - A format string for mapping Identity names to MFA method names. \nValues to substitute should be placed in `{{}}`. For example, `\"{{alias.name}}@example.com\"`.\nIf blank, the Alias's Name field will be used as-is. Currently-supported mappings:\n- alias.name: The name returned by the mount configured via the `mount_accessor` parameter\n- entity.name: The name configured for the Entity\n- alias.metadata.`\u003ckey\u003e`: The value of the Alias's metadata parameter\n- entity.metadata.`\u003ckey\u003e`: The value of the Entity's metadata parameter\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:index/mfaPingid:MfaPingid": {
            "description": "Provides a resource to manage [PingID MFA](https://www.vaultproject.io/docs/enterprise/mfa/mfa-pingid).\n\n**Note** this feature is available only with Vault Enterprise.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst config = new pulumi.Config();\nconst settingsFile = config.requireObject(\"settingsFile\");\nconst userpass = new vault.AuthBackend(\"userpass\", {\n    type: \"userpass\",\n    path: \"userpass\",\n});\nconst myPingid = new vault.MfaPingid(\"myPingid\", {\n    mountAccessor: userpass.accessor,\n    usernameFormat: \"user@example.com\",\n    settingsFileBase64: settingsFile,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nconfig = pulumi.Config()\nsettings_file = config.require_object(\"settingsFile\")\nuserpass = vault.AuthBackend(\"userpass\",\n    type=\"userpass\",\n    path=\"userpass\")\nmy_pingid = vault.MfaPingid(\"myPingid\",\n    mount_accessor=userpass.accessor,\n    username_format=\"user@example.com\",\n    settings_file_base64=settings_file)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Config();\n    var settingsFile = config.RequireObject\u003cdynamic\u003e(\"settingsFile\");\n    var userpass = new Vault.AuthBackend(\"userpass\", new()\n    {\n        Type = \"userpass\",\n        Path = \"userpass\",\n    });\n\n    var myPingid = new Vault.MfaPingid(\"myPingid\", new()\n    {\n        MountAccessor = userpass.Accessor,\n        UsernameFormat = \"user@example.com\",\n        SettingsFileBase64 = settingsFile,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcfg := config.New(ctx, \"\")\n\t\tsettingsFile := cfg.RequireObject(\"settingsFile\")\n\t\tuserpass, err := vault.NewAuthBackend(ctx, \"userpass\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"userpass\"),\n\t\t\tPath: pulumi.String(\"userpass\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vault.NewMfaPingid(ctx, \"myPingid\", \u0026vault.MfaPingidArgs{\n\t\t\tMountAccessor:      userpass.Accessor,\n\t\t\tUsernameFormat:     pulumi.String(\"user@example.com\"),\n\t\t\tSettingsFileBase64: pulumi.Any(settingsFile),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.AuthBackend;\nimport com.pulumi.vault.AuthBackendArgs;\nimport com.pulumi.vault.MfaPingid;\nimport com.pulumi.vault.MfaPingidArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var config = ctx.config();\n        final var settingsFile = config.get(\"settingsFile\");\n        var userpass = new AuthBackend(\"userpass\", AuthBackendArgs.builder()        \n            .type(\"userpass\")\n            .path(\"userpass\")\n            .build());\n\n        var myPingid = new MfaPingid(\"myPingid\", MfaPingidArgs.builder()        \n            .mountAccessor(userpass.accessor())\n            .usernameFormat(\"user@example.com\")\n            .settingsFileBase64(settingsFile)\n            .build());\n\n    }\n}\n```\n```yaml\nconfiguration:\n  settingsFile:\n    type: dynamic\nresources:\n  userpass:\n    type: vault:AuthBackend\n    properties:\n      type: userpass\n      path: userpass\n  myPingid:\n    type: vault:MfaPingid\n    properties:\n      mountAccessor: ${userpass.accessor}\n      usernameFormat: user@example.com\n      settingsFileBase64: ${settingsFile}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nMounts can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:index/mfaPingid:MfaPingid my_pingid my_pingid\n```\n\n ",
            "properties": {
                "adminUrl": {
                    "type": "string",
                    "description": "Admin URL computed by Vault.\n"
                },
                "authenticatorUrl": {
                    "type": "string",
                    "description": "Authenticator URL computed by Vault.\n"
                },
                "idpUrl": {
                    "type": "string",
                    "description": "IDP URL computed by Vault.\n"
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The mount to tie this method to for use in automatic mappings. \nThe mapping will use the Name field of Aliases associated with this mount as the username in the mapping.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` – Name of the MFA method.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "namespaceId": {
                    "type": "string",
                    "description": "Namespace ID computed by Vault.\n"
                },
                "orgAlias": {
                    "type": "string",
                    "description": "Org Alias computed by Vault.\n"
                },
                "settingsFileBase64": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - A base64-encoded third-party settings file retrieved\nfrom PingID's configuration page.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of configuration computed by Vault.\n"
                },
                "useSignature": {
                    "type": "boolean",
                    "description": "If set, enables use of PingID signature. Computed by Vault\n"
                },
                "usernameFormat": {
                    "type": "string",
                    "description": "`(string)` - A format string for mapping Identity names to MFA method names. \nValues to substitute should be placed in `{{}}`. For example, `\"{{alias.name}}@example.com\"`.\nIf blank, the Alias's Name field will be used as-is. Currently-supported mappings:\n- alias.name: The name returned by the mount configured via the `mount_accessor` parameter\n- entity.name: The name configured for the Entity\n- alias.metadata.`\u003ckey\u003e`: The value of the Alias's metadata parameter\n- entity.metadata.`\u003ckey\u003e`: The value of the Entity's metadata parameter\n"
                }
            },
            "required": [
                "adminUrl",
                "authenticatorUrl",
                "idpUrl",
                "mountAccessor",
                "name",
                "namespaceId",
                "orgAlias",
                "settingsFileBase64",
                "type",
                "useSignature"
            ],
            "inputProperties": {
                "mountAccessor": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The mount to tie this method to for use in automatic mappings. \nThe mapping will use the Name field of Aliases associated with this mount as the username in the mapping.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` – Name of the MFA method.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "settingsFileBase64": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - A base64-encoded third-party settings file retrieved\nfrom PingID's configuration page.\n",
                    "willReplaceOnChanges": true
                },
                "usernameFormat": {
                    "type": "string",
                    "description": "`(string)` - A format string for mapping Identity names to MFA method names. \nValues to substitute should be placed in `{{}}`. For example, `\"{{alias.name}}@example.com\"`.\nIf blank, the Alias's Name field will be used as-is. Currently-supported mappings:\n- alias.name: The name returned by the mount configured via the `mount_accessor` parameter\n- entity.name: The name configured for the Entity\n- alias.metadata.`\u003ckey\u003e`: The value of the Alias's metadata parameter\n- entity.metadata.`\u003ckey\u003e`: The value of the Entity's metadata parameter\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "mountAccessor",
                "settingsFileBase64"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MfaPingid resources.\n",
                "properties": {
                    "adminUrl": {
                        "type": "string",
                        "description": "Admin URL computed by Vault.\n"
                    },
                    "authenticatorUrl": {
                        "type": "string",
                        "description": "Authenticator URL computed by Vault.\n"
                    },
                    "idpUrl": {
                        "type": "string",
                        "description": "IDP URL computed by Vault.\n"
                    },
                    "mountAccessor": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The mount to tie this method to for use in automatic mappings. \nThe mapping will use the Name field of Aliases associated with this mount as the username in the mapping.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` – Name of the MFA method.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespaceId": {
                        "type": "string",
                        "description": "Namespace ID computed by Vault.\n"
                    },
                    "orgAlias": {
                        "type": "string",
                        "description": "Org Alias computed by Vault.\n"
                    },
                    "settingsFileBase64": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - A base64-encoded third-party settings file retrieved\nfrom PingID's configuration page.\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of configuration computed by Vault.\n"
                    },
                    "useSignature": {
                        "type": "boolean",
                        "description": "If set, enables use of PingID signature. Computed by Vault\n"
                    },
                    "usernameFormat": {
                        "type": "string",
                        "description": "`(string)` - A format string for mapping Identity names to MFA method names. \nValues to substitute should be placed in `{{}}`. For example, `\"{{alias.name}}@example.com\"`.\nIf blank, the Alias's Name field will be used as-is. Currently-supported mappings:\n- alias.name: The name returned by the mount configured via the `mount_accessor` parameter\n- entity.name: The name configured for the Entity\n- alias.metadata.`\u003ckey\u003e`: The value of the Alias's metadata parameter\n- entity.metadata.`\u003ckey\u003e`: The value of the Entity's metadata parameter\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:index/mfaTotp:MfaTotp": {
            "description": "Provides a resource to manage [TOTP MFA](https://www.vaultproject.io/docs/enterprise/mfa/mfa-totp).\n\n**Note** this feature is available only with Vault Enterprise.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst myTotp = new vault.MfaTotp(\"my_totp\", {\n    algorithm: \"SHA256\",\n    digits: 8,\n    issuer: \"hashicorp\",\n    keySize: 20,\n    period: 60,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nmy_totp = vault.MfaTotp(\"myTotp\",\n    algorithm=\"SHA256\",\n    digits=8,\n    issuer=\"hashicorp\",\n    key_size=20,\n    period=60)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myTotp = new Vault.MfaTotp(\"myTotp\", new()\n    {\n        Algorithm = \"SHA256\",\n        Digits = 8,\n        Issuer = \"hashicorp\",\n        KeySize = 20,\n        Period = 60,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewMfaTotp(ctx, \"myTotp\", \u0026vault.MfaTotpArgs{\n\t\t\tAlgorithm: pulumi.String(\"SHA256\"),\n\t\t\tDigits:    pulumi.Int(8),\n\t\t\tIssuer:    pulumi.String(\"hashicorp\"),\n\t\t\tKeySize:   pulumi.Int(20),\n\t\t\tPeriod:    pulumi.Int(60),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.MfaTotp;\nimport com.pulumi.vault.MfaTotpArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myTotp = new MfaTotp(\"myTotp\", MfaTotpArgs.builder()        \n            .algorithm(\"SHA256\")\n            .digits(8)\n            .issuer(\"hashicorp\")\n            .keySize(20)\n            .period(60)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myTotp:\n    type: vault:MfaTotp\n    properties:\n      algorithm: SHA256\n      digits: 8\n      issuer: hashicorp\n      keySize: 20\n      period: 60\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nMounts can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:index/mfaTotp:MfaTotp my_totp my_totp\n```\n\n ",
            "properties": {
                "algorithm": {
                    "type": "string",
                    "description": "`(string)` - Specifies the hashing algorithm used to generate the TOTP code.\nOptions include `SHA1`, `SHA256` and `SHA512`\n"
                },
                "digits": {
                    "type": "integer",
                    "description": "`(int)` - The number of digits in the generated TOTP token.\nThis value can either be 6 or 8.\n"
                },
                "issuer": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The name of the key's issuing organization.\n"
                },
                "keySize": {
                    "type": "integer",
                    "description": "`(int)` - Specifies the size in bytes of the generated key.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` – Name of the MFA method.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "period": {
                    "type": "integer",
                    "description": "`(int)` - The length of time used to generate a counter for the TOTP token calculation.\n"
                },
                "qrSize": {
                    "type": "integer",
                    "description": "`(int)` - The pixel size of the generated square QR code.\n"
                },
                "skew": {
                    "type": "integer",
                    "description": "`(int)` - The number of delay periods that are allowed when validating a TOTP token.\nThis value can either be 0 or 1.\n"
                }
            },
            "required": [
                "issuer",
                "name"
            ],
            "inputProperties": {
                "algorithm": {
                    "type": "string",
                    "description": "`(string)` - Specifies the hashing algorithm used to generate the TOTP code.\nOptions include `SHA1`, `SHA256` and `SHA512`\n",
                    "willReplaceOnChanges": true
                },
                "digits": {
                    "type": "integer",
                    "description": "`(int)` - The number of digits in the generated TOTP token.\nThis value can either be 6 or 8.\n",
                    "willReplaceOnChanges": true
                },
                "issuer": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The name of the key's issuing organization.\n",
                    "willReplaceOnChanges": true
                },
                "keySize": {
                    "type": "integer",
                    "description": "`(int)` - Specifies the size in bytes of the generated key.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` – Name of the MFA method.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "period": {
                    "type": "integer",
                    "description": "`(int)` - The length of time used to generate a counter for the TOTP token calculation.\n",
                    "willReplaceOnChanges": true
                },
                "qrSize": {
                    "type": "integer",
                    "description": "`(int)` - The pixel size of the generated square QR code.\n",
                    "willReplaceOnChanges": true
                },
                "skew": {
                    "type": "integer",
                    "description": "`(int)` - The number of delay periods that are allowed when validating a TOTP token.\nThis value can either be 0 or 1.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "issuer"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MfaTotp resources.\n",
                "properties": {
                    "algorithm": {
                        "type": "string",
                        "description": "`(string)` - Specifies the hashing algorithm used to generate the TOTP code.\nOptions include `SHA1`, `SHA256` and `SHA512`\n",
                        "willReplaceOnChanges": true
                    },
                    "digits": {
                        "type": "integer",
                        "description": "`(int)` - The number of digits in the generated TOTP token.\nThis value can either be 6 or 8.\n",
                        "willReplaceOnChanges": true
                    },
                    "issuer": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The name of the key's issuing organization.\n",
                        "willReplaceOnChanges": true
                    },
                    "keySize": {
                        "type": "integer",
                        "description": "`(int)` - Specifies the size in bytes of the generated key.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` – Name of the MFA method.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "period": {
                        "type": "integer",
                        "description": "`(int)` - The length of time used to generate a counter for the TOTP token calculation.\n",
                        "willReplaceOnChanges": true
                    },
                    "qrSize": {
                        "type": "integer",
                        "description": "`(int)` - The pixel size of the generated square QR code.\n",
                        "willReplaceOnChanges": true
                    },
                    "skew": {
                        "type": "integer",
                        "description": "`(int)` - The number of delay periods that are allowed when validating a TOTP token.\nThis value can either be 0 or 1.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:index/mount:Mount": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.Mount(\"example\", {\n    description: \"This is an example mount\",\n    path: \"dummy\",\n    type: \"generic\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.Mount(\"example\",\n    description=\"This is an example mount\",\n    path=\"dummy\",\n    type=\"generic\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Vault.Mount(\"example\", new()\n    {\n        Description = \"This is an example mount\",\n        Path = \"dummy\",\n        Type = \"generic\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewMount(ctx, \"example\", \u0026vault.MountArgs{\n\t\t\tDescription: pulumi.String(\"This is an example mount\"),\n\t\t\tPath:        pulumi.String(\"dummy\"),\n\t\t\tType:        pulumi.String(\"generic\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Mount;\nimport com.pulumi.vault.MountArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Mount(\"example\", MountArgs.builder()        \n            .description(\"This is an example mount\")\n            .path(\"dummy\")\n            .type(\"generic\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: vault:Mount\n    properties:\n      description: This is an example mount\n      path: dummy\n      type: generic\n```\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst kvv2_example = new vault.Mount(\"kvv2-example\", {\n    description: \"This is an example KV Version 2 secret engine mount\",\n    path: \"version2-example\",\n    type: \"kv-v2\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nkvv2_example = vault.Mount(\"kvv2-example\",\n    description=\"This is an example KV Version 2 secret engine mount\",\n    path=\"version2-example\",\n    type=\"kv-v2\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var kvv2_example = new Vault.Mount(\"kvv2-example\", new()\n    {\n        Description = \"This is an example KV Version 2 secret engine mount\",\n        Path = \"version2-example\",\n        Type = \"kv-v2\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewMount(ctx, \"kvv2-example\", \u0026vault.MountArgs{\n\t\t\tDescription: pulumi.String(\"This is an example KV Version 2 secret engine mount\"),\n\t\t\tPath:        pulumi.String(\"version2-example\"),\n\t\t\tType:        pulumi.String(\"kv-v2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Mount;\nimport com.pulumi.vault.MountArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var kvv2_example = new Mount(\"kvv2-example\", MountArgs.builder()        \n            .description(\"This is an example KV Version 2 secret engine mount\")\n            .path(\"version2-example\")\n            .type(\"kv-v2\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  kvv2-example:\n    type: vault:Mount\n    properties:\n      description: This is an example KV Version 2 secret engine mount\n      path: version2-example\n      type: kv-v2\n```\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst transit_example = new vault.Mount(\"transit-example\", {\n    description: \"This is an example transit secret engine mount\",\n    options: {\n        convergent_encryption: false,\n    },\n    path: \"transit-example\",\n    type: \"transit\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntransit_example = vault.Mount(\"transit-example\",\n    description=\"This is an example transit secret engine mount\",\n    options={\n        \"convergent_encryption\": False,\n    },\n    path=\"transit-example\",\n    type=\"transit\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var transit_example = new Vault.Mount(\"transit-example\", new()\n    {\n        Description = \"This is an example transit secret engine mount\",\n        Options = \n        {\n            { \"convergent_encryption\", false },\n        },\n        Path = \"transit-example\",\n        Type = \"transit\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewMount(ctx, \"transit-example\", \u0026vault.MountArgs{\n\t\t\tDescription: pulumi.String(\"This is an example transit secret engine mount\"),\n\t\t\tOptions: pulumi.AnyMap{\n\t\t\t\t\"convergent_encryption\": pulumi.Any(false),\n\t\t\t},\n\t\t\tPath: pulumi.String(\"transit-example\"),\n\t\t\tType: pulumi.String(\"transit\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Mount;\nimport com.pulumi.vault.MountArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var transit_example = new Mount(\"transit-example\", MountArgs.builder()        \n            .description(\"This is an example transit secret engine mount\")\n            .options(Map.of(\"convergent_encryption\", false))\n            .path(\"transit-example\")\n            .type(\"transit\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  transit-example:\n    type: vault:Mount\n    properties:\n      description: This is an example transit secret engine mount\n      options:\n        convergent_encryption: false\n      path: transit-example\n      type: transit\n```\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst pki_example = new vault.Mount(\"pki-example\", {\n    defaultLeaseTtlSeconds: 3600,\n    description: \"This is an example PKI mount\",\n    maxLeaseTtlSeconds: 86400,\n    path: \"pki-example\",\n    type: \"pki\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\npki_example = vault.Mount(\"pki-example\",\n    default_lease_ttl_seconds=3600,\n    description=\"This is an example PKI mount\",\n    max_lease_ttl_seconds=86400,\n    path=\"pki-example\",\n    type=\"pki\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var pki_example = new Vault.Mount(\"pki-example\", new()\n    {\n        DefaultLeaseTtlSeconds = 3600,\n        Description = \"This is an example PKI mount\",\n        MaxLeaseTtlSeconds = 86400,\n        Path = \"pki-example\",\n        Type = \"pki\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewMount(ctx, \"pki-example\", \u0026vault.MountArgs{\n\t\t\tDefaultLeaseTtlSeconds: pulumi.Int(3600),\n\t\t\tDescription:            pulumi.String(\"This is an example PKI mount\"),\n\t\t\tMaxLeaseTtlSeconds:     pulumi.Int(86400),\n\t\t\tPath:                   pulumi.String(\"pki-example\"),\n\t\t\tType:                   pulumi.String(\"pki\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Mount;\nimport com.pulumi.vault.MountArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var pki_example = new Mount(\"pki-example\", MountArgs.builder()        \n            .defaultLeaseTtlSeconds(3600)\n            .description(\"This is an example PKI mount\")\n            .maxLeaseTtlSeconds(86400)\n            .path(\"pki-example\")\n            .type(\"pki\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  pki-example:\n    type: vault:Mount\n    properties:\n      defaultLeaseTtlSeconds: 3600\n      description: This is an example PKI mount\n      maxLeaseTtlSeconds: 86400\n      path: pki-example\n      type: pki\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nMounts can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:index/mount:Mount example dummy\n```\n\n ",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The accessor for this mount.\n"
                },
                "allowedManagedKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of managed key registry entry names that the mount in question is allowed to access\n"
                },
                "auditNonHmacRequestKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the request data object.\n"
                },
                "auditNonHmacResponseKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the response data object.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Default lease duration for tokens and secrets in seconds\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount\n"
                },
                "externalEntropyAccess": {
                    "type": "boolean",
                    "description": "Boolean flag that can be explicitly set to true to enable the secrets engine to access Vault's external entropy source\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Boolean flag that can be explicitly set to true to enforce local mount in HA environment\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Maximum possible lease duration for tokens and secrets in seconds\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "options": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies mount type specific options that are passed to the backend\n"
                },
                "path": {
                    "type": "string",
                    "description": "Where the secret backend will be mounted\n"
                },
                "sealWrap": {
                    "type": "boolean",
                    "description": "Boolean flag that can be explicitly set to true to enable seal wrapping for the mount, causing values stored by the mount to be wrapped by the seal's encryption capability\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the backend, such as \"aws\"\n"
                }
            },
            "required": [
                "accessor",
                "auditNonHmacRequestKeys",
                "auditNonHmacResponseKeys",
                "defaultLeaseTtlSeconds",
                "maxLeaseTtlSeconds",
                "path",
                "sealWrap",
                "type"
            ],
            "inputProperties": {
                "allowedManagedKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of managed key registry entry names that the mount in question is allowed to access\n",
                    "willReplaceOnChanges": true
                },
                "auditNonHmacRequestKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the request data object.\n"
                },
                "auditNonHmacResponseKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the response data object.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Default lease duration for tokens and secrets in seconds\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount\n"
                },
                "externalEntropyAccess": {
                    "type": "boolean",
                    "description": "Boolean flag that can be explicitly set to true to enable the secrets engine to access Vault's external entropy source\n",
                    "willReplaceOnChanges": true
                },
                "local": {
                    "type": "boolean",
                    "description": "Boolean flag that can be explicitly set to true to enforce local mount in HA environment\n",
                    "willReplaceOnChanges": true
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Maximum possible lease duration for tokens and secrets in seconds\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "options": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies mount type specific options that are passed to the backend\n"
                },
                "path": {
                    "type": "string",
                    "description": "Where the secret backend will be mounted\n"
                },
                "sealWrap": {
                    "type": "boolean",
                    "description": "Boolean flag that can be explicitly set to true to enable seal wrapping for the mount, causing values stored by the mount to be wrapped by the seal's encryption capability\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "Type of the backend, such as \"aws\"\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "path",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Mount resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The accessor for this mount.\n"
                    },
                    "allowedManagedKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of managed key registry entry names that the mount in question is allowed to access\n",
                        "willReplaceOnChanges": true
                    },
                    "auditNonHmacRequestKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the request data object.\n"
                    },
                    "auditNonHmacResponseKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the response data object.\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "Default lease duration for tokens and secrets in seconds\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Human-friendly description of the mount\n"
                    },
                    "externalEntropyAccess": {
                        "type": "boolean",
                        "description": "Boolean flag that can be explicitly set to true to enable the secrets engine to access Vault's external entropy source\n",
                        "willReplaceOnChanges": true
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Boolean flag that can be explicitly set to true to enforce local mount in HA environment\n",
                        "willReplaceOnChanges": true
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "Maximum possible lease duration for tokens and secrets in seconds\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "options": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Specifies mount type specific options that are passed to the backend\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Where the secret backend will be mounted\n"
                    },
                    "sealWrap": {
                        "type": "boolean",
                        "description": "Boolean flag that can be explicitly set to true to enable seal wrapping for the mount, causing values stored by the mount to be wrapped by the seal's encryption capability\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of the backend, such as \"aws\"\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:index/namespace:Namespace": {
            "description": "\n\n\n## Import\n\nNamespaces can be imported using its `name` as accessor id\n\n```sh\n $ pulumi import vault:index/namespace:Namespace example \u003cname\u003e\n```\n\n If the declared resource is imported and intends to support namespaces using a provider alias, then the name is relative to the namespace path. hcl provider \"vault\" {\n\n # Configuration options\n\n namespace = \"example\"\n\n alias\n\n\n\n = \"example\" } resource \"vault_namespace\" \"example2\" {\n\n provider = vault.example\n\n path\n\n\n\n = \"example2\" }\n\n```sh\n $ pulumi import vault:index/namespace:Namespace example2 example2\n```\n\n $ terraform state show vault_namespace.example2 vault_namespace.example2resource \"vault_namespace\" \"example2\" {\n\n\n\n id\n\n\n\n\n\n\n\n\n\n = \"example/example2/\"\n\n\n\n namespace_id = \u003cknown after import\u003e\n\n\n\n path\n\n\n\n\n\n\n\n = \"example2\"\n\n\n\n path_fq\n\n\n\n\n\n= \"example2\" } ",
            "properties": {
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "language": {
                        "csharp": {
                            "name": "TargetNamespace"
                        }
                    }
                },
                "namespaceId": {
                    "type": "string",
                    "description": "Vault server's internal ID of the namespace.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path of the namespace. Must not have a trailing `/`.\n"
                },
                "pathFq": {
                    "type": "string",
                    "description": "The fully qualified path to the namespace. Useful when provisioning resources in a child `namespace`.\nThe path is relative to the provider's `namespace` argument.\n"
                }
            },
            "required": [
                "namespaceId",
                "path",
                "pathFq"
            ],
            "inputProperties": {
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "language": {
                        "csharp": {
                            "name": "TargetNamespace"
                        }
                    },
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "The path of the namespace. Must not have a trailing `/`.\n",
                    "willReplaceOnChanges": true
                },
                "pathFq": {
                    "type": "string",
                    "description": "The fully qualified path to the namespace. Useful when provisioning resources in a child `namespace`.\nThe path is relative to the provider's `namespace` argument.\n"
                }
            },
            "requiredInputs": [
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Namespace resources.\n",
                "properties": {
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "language": {
                            "csharp": {
                                "name": "TargetNamespace"
                            }
                        },
                        "willReplaceOnChanges": true
                    },
                    "namespaceId": {
                        "type": "string",
                        "description": "Vault server's internal ID of the namespace.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path of the namespace. Must not have a trailing `/`.\n",
                        "willReplaceOnChanges": true
                    },
                    "pathFq": {
                        "type": "string",
                        "description": "The fully qualified path to the namespace. Useful when provisioning resources in a child `namespace`.\nThe path is relative to the provider's `namespace` argument.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/nomadSecretBackend:NomadSecretBackend": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst config = new vault.NomadSecretBackend(\"config\", {\n    address: \"https://127.0.0.1:4646\",\n    backend: \"nomad\",\n    defaultLeaseTtlSeconds: 3600,\n    description: \"test description\",\n    maxLeaseTtlSeconds: 7200,\n    maxTtl: 240,\n    token: \"ae20ceaa-...\",\n    ttl: 120,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nconfig = vault.NomadSecretBackend(\"config\",\n    address=\"https://127.0.0.1:4646\",\n    backend=\"nomad\",\n    default_lease_ttl_seconds=3600,\n    description=\"test description\",\n    max_lease_ttl_seconds=7200,\n    max_ttl=240,\n    token=\"ae20ceaa-...\",\n    ttl=120)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Vault.NomadSecretBackend(\"config\", new()\n    {\n        Address = \"https://127.0.0.1:4646\",\n        Backend = \"nomad\",\n        DefaultLeaseTtlSeconds = 3600,\n        Description = \"test description\",\n        MaxLeaseTtlSeconds = 7200,\n        MaxTtl = 240,\n        Token = \"ae20ceaa-...\",\n        Ttl = 120,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewNomadSecretBackend(ctx, \"config\", \u0026vault.NomadSecretBackendArgs{\n\t\t\tAddress:                pulumi.String(\"https://127.0.0.1:4646\"),\n\t\t\tBackend:                pulumi.String(\"nomad\"),\n\t\t\tDefaultLeaseTtlSeconds: pulumi.Int(3600),\n\t\t\tDescription:            pulumi.String(\"test description\"),\n\t\t\tMaxLeaseTtlSeconds:     pulumi.Int(7200),\n\t\t\tMaxTtl:                 pulumi.Int(240),\n\t\t\tToken:                  pulumi.String(\"ae20ceaa-...\"),\n\t\t\tTtl:                    pulumi.Int(120),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.NomadSecretBackend;\nimport com.pulumi.vault.NomadSecretBackendArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var config = new NomadSecretBackend(\"config\", NomadSecretBackendArgs.builder()        \n            .address(\"https://127.0.0.1:4646\")\n            .backend(\"nomad\")\n            .defaultLeaseTtlSeconds(\"3600\")\n            .description(\"test description\")\n            .maxLeaseTtlSeconds(\"7200\")\n            .maxTtl(\"240\")\n            .token(\"ae20ceaa-...\")\n            .ttl(\"120\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  config:\n    type: vault:NomadSecretBackend\n    properties:\n      address: https://127.0.0.1:4646\n      backend: nomad\n      defaultLeaseTtlSeconds: 3600\n      description: test description\n      maxLeaseTtlSeconds: 7200\n      maxTtl: 240\n      token: ae20ceaa-...\n      ttl: 120\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nNomad secret backend can be imported using the `backend`, e.g.\n\n```sh\n $ pulumi import vault:index/nomadSecretBackend:NomadSecretBackend nomad nomad\n```\n\n ",
            "properties": {
                "address": {
                    "type": "string",
                    "description": "Specifies the address of the Nomad instance, provided\nas \"protocol://host:port\" like \"http://127.0.0.1:4646\".\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `nomad`.\n"
                },
                "caCert": {
                    "type": "string",
                    "description": "CA certificate to use when verifying the Nomad server certificate, must be\nx509 PEM encoded.\n"
                },
                "clientCert": {
                    "type": "string",
                    "description": "Client certificate to provide to the Nomad server, must be x509 PEM encoded.\n",
                    "secret": true
                },
                "clientKey": {
                    "type": "string",
                    "description": "Client certificate key to provide to the Nomad server, must be x509 PEM encoded.\n",
                    "secret": true
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Default lease duration for secrets in seconds.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the Active Directory backend.\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Mark the secrets engine as local-only. Local engines are not replicated or removed by\nreplication.Tolerance duration to use when checking the last rotation time.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Maximum possible lease duration for secrets in seconds.\n"
                },
                "maxTokenNameLength": {
                    "type": "integer",
                    "description": "Specifies the maximum length to use for the name of the Nomad token\ngenerated with Generate Credential. If omitted, 0 is used and ignored, defaulting to the max value allowed\nby the Nomad version.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "Maximum possible lease duration for secrets in seconds.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "token": {
                    "type": "string",
                    "description": "Specifies the Nomad Management token to use.\n",
                    "secret": true
                },
                "ttl": {
                    "type": "integer",
                    "description": "Specifies the ttl of the lease for the generated token.\n"
                }
            },
            "required": [
                "defaultLeaseTtlSeconds",
                "maxLeaseTtlSeconds",
                "maxTokenNameLength",
                "maxTtl",
                "ttl"
            ],
            "inputProperties": {
                "address": {
                    "type": "string",
                    "description": "Specifies the address of the Nomad instance, provided\nas \"protocol://host:port\" like \"http://127.0.0.1:4646\".\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `nomad`.\n"
                },
                "caCert": {
                    "type": "string",
                    "description": "CA certificate to use when verifying the Nomad server certificate, must be\nx509 PEM encoded.\n"
                },
                "clientCert": {
                    "type": "string",
                    "description": "Client certificate to provide to the Nomad server, must be x509 PEM encoded.\n",
                    "secret": true
                },
                "clientKey": {
                    "type": "string",
                    "description": "Client certificate key to provide to the Nomad server, must be x509 PEM encoded.\n",
                    "secret": true
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Default lease duration for secrets in seconds.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the Active Directory backend.\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Mark the secrets engine as local-only. Local engines are not replicated or removed by\nreplication.Tolerance duration to use when checking the last rotation time.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Maximum possible lease duration for secrets in seconds.\n"
                },
                "maxTokenNameLength": {
                    "type": "integer",
                    "description": "Specifies the maximum length to use for the name of the Nomad token\ngenerated with Generate Credential. If omitted, 0 is used and ignored, defaulting to the max value allowed\nby the Nomad version.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "Maximum possible lease duration for secrets in seconds.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "token": {
                    "type": "string",
                    "description": "Specifies the Nomad Management token to use.\n",
                    "secret": true
                },
                "ttl": {
                    "type": "integer",
                    "description": "Specifies the ttl of the lease for the generated token.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NomadSecretBackend resources.\n",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "Specifies the address of the Nomad instance, provided\nas \"protocol://host:port\" like \"http://127.0.0.1:4646\".\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `nomad`.\n"
                    },
                    "caCert": {
                        "type": "string",
                        "description": "CA certificate to use when verifying the Nomad server certificate, must be\nx509 PEM encoded.\n"
                    },
                    "clientCert": {
                        "type": "string",
                        "description": "Client certificate to provide to the Nomad server, must be x509 PEM encoded.\n",
                        "secret": true
                    },
                    "clientKey": {
                        "type": "string",
                        "description": "Client certificate key to provide to the Nomad server, must be x509 PEM encoded.\n",
                        "secret": true
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "Default lease duration for secrets in seconds.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Human-friendly description of the mount for the Active Directory backend.\n"
                    },
                    "disableRemount": {
                        "type": "boolean",
                        "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Mark the secrets engine as local-only. Local engines are not replicated or removed by\nreplication.Tolerance duration to use when checking the last rotation time.\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "Maximum possible lease duration for secrets in seconds.\n"
                    },
                    "maxTokenNameLength": {
                        "type": "integer",
                        "description": "Specifies the maximum length to use for the name of the Nomad token\ngenerated with Generate Credential. If omitted, 0 is used and ignored, defaulting to the max value allowed\nby the Nomad version.\n"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "Maximum possible lease duration for secrets in seconds.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "token": {
                        "type": "string",
                        "description": "Specifies the Nomad Management token to use.\n",
                        "secret": true
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "Specifies the ttl of the lease for the generated token.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/nomadSecretRole:NomadSecretRole": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst config = new vault.NomadSecretBackend(\"config\", {\n    backend: \"nomad\",\n    description: \"test description\",\n    defaultLeaseTtlSeconds: 3600,\n    maxLeaseTtlSeconds: 7200,\n    address: \"https://127.0.0.1:4646\",\n    token: \"ae20ceaa-...\",\n});\nconst test = new vault.NomadSecretRole(\"test\", {\n    backend: config.backend,\n    role: \"test\",\n    type: \"client\",\n    policies: [\"readonly\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nconfig = vault.NomadSecretBackend(\"config\",\n    backend=\"nomad\",\n    description=\"test description\",\n    default_lease_ttl_seconds=3600,\n    max_lease_ttl_seconds=7200,\n    address=\"https://127.0.0.1:4646\",\n    token=\"ae20ceaa-...\")\ntest = vault.NomadSecretRole(\"test\",\n    backend=config.backend,\n    role=\"test\",\n    type=\"client\",\n    policies=[\"readonly\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Vault.NomadSecretBackend(\"config\", new()\n    {\n        Backend = \"nomad\",\n        Description = \"test description\",\n        DefaultLeaseTtlSeconds = 3600,\n        MaxLeaseTtlSeconds = 7200,\n        Address = \"https://127.0.0.1:4646\",\n        Token = \"ae20ceaa-...\",\n    });\n\n    var test = new Vault.NomadSecretRole(\"test\", new()\n    {\n        Backend = config.Backend,\n        Role = \"test\",\n        Type = \"client\",\n        Policies = new[]\n        {\n            \"readonly\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfig, err := vault.NewNomadSecretBackend(ctx, \"config\", \u0026vault.NomadSecretBackendArgs{\n\t\t\tBackend:                pulumi.String(\"nomad\"),\n\t\t\tDescription:            pulumi.String(\"test description\"),\n\t\t\tDefaultLeaseTtlSeconds: pulumi.Int(3600),\n\t\t\tMaxLeaseTtlSeconds:     pulumi.Int(7200),\n\t\t\tAddress:                pulumi.String(\"https://127.0.0.1:4646\"),\n\t\t\tToken:                  pulumi.String(\"ae20ceaa-...\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vault.NewNomadSecretRole(ctx, \"test\", \u0026vault.NomadSecretRoleArgs{\n\t\t\tBackend: config.Backend,\n\t\t\tRole:    pulumi.String(\"test\"),\n\t\t\tType:    pulumi.String(\"client\"),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"readonly\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.NomadSecretBackend;\nimport com.pulumi.vault.NomadSecretBackendArgs;\nimport com.pulumi.vault.NomadSecretRole;\nimport com.pulumi.vault.NomadSecretRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var config = new NomadSecretBackend(\"config\", NomadSecretBackendArgs.builder()        \n            .backend(\"nomad\")\n            .description(\"test description\")\n            .defaultLeaseTtlSeconds(\"3600\")\n            .maxLeaseTtlSeconds(\"7200\")\n            .address(\"https://127.0.0.1:4646\")\n            .token(\"ae20ceaa-...\")\n            .build());\n\n        var test = new NomadSecretRole(\"test\", NomadSecretRoleArgs.builder()        \n            .backend(config.backend())\n            .role(\"test\")\n            .type(\"client\")\n            .policies(\"readonly\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  config:\n    type: vault:NomadSecretBackend\n    properties:\n      backend: nomad\n      description: test description\n      defaultLeaseTtlSeconds: 3600\n      maxLeaseTtlSeconds: 7200\n      address: https://127.0.0.1:4646\n      token: ae20ceaa-...\n  test:\n    type: vault:NomadSecretRole\n    properties:\n      backend: ${config.backend}\n      role: test\n      type: client\n      policies:\n        - readonly\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nNomad secret role can be imported using the `backend`, e.g.\n\n```sh\n $ pulumi import vault:index/nomadSecretRole:NomadSecretRole bob nomad/role/bob\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `nomad`.\n"
                },
                "global": {
                    "type": "boolean",
                    "description": "Specifies if the generated token should be global. Defaults to \nfalse.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies attached to the generated token. This setting is only used \nwhen `type` is 'client'.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Specifies the type of token to create when using this role. Valid \nsettings are 'client' and 'management'. Defaults to 'client'.\n"
                }
            },
            "required": [
                "backend",
                "global",
                "policies",
                "role",
                "type"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `nomad`.\n",
                    "willReplaceOnChanges": true
                },
                "global": {
                    "type": "boolean",
                    "description": "Specifies if the generated token should be global. Defaults to \nfalse.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies attached to the generated token. This setting is only used \nwhen `type` is 'client'.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "Specifies the type of token to create when using this role. Valid \nsettings are 'client' and 'management'. Defaults to 'client'.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NomadSecretRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `nomad`.\n",
                        "willReplaceOnChanges": true
                    },
                    "global": {
                        "type": "boolean",
                        "description": "Specifies if the generated token should be global. Defaults to \nfalse.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies attached to the generated token. This setting is only used \nwhen `type` is 'client'.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "Specifies the type of token to create when using this role. Valid \nsettings are 'client' and 'management'. Defaults to 'client'.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/passwordPolicy:PasswordPolicy": {
            "description": "Provides a resource to manage Password Policies \n\n**Note** this feature is available only Vault 1.5+ \n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst alphanumeric = new vault.PasswordPolicy(\"alphanumeric\", {\n    policy: `    length = 20\n    rule \"charset\" {\n      charset = \"abcdefghijklmnopqrstuvwxyz0123456789\"\n    }\n  `,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nalphanumeric = vault.PasswordPolicy(\"alphanumeric\", policy=\"\"\"    length = 20\n    rule \"charset\" {\n      charset = \"abcdefghijklmnopqrstuvwxyz0123456789\"\n    }\n  \n\"\"\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var alphanumeric = new Vault.PasswordPolicy(\"alphanumeric\", new()\n    {\n        Policy = @\"    length = 20\n    rule \"\"charset\"\" {\n      charset = \"\"abcdefghijklmnopqrstuvwxyz0123456789\"\"\n    }\n  \n\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewPasswordPolicy(ctx, \"alphanumeric\", \u0026vault.PasswordPolicyArgs{\n\t\t\tPolicy: pulumi.String(\"    length = 20\\n    rule \\\"charset\\\" {\\n      charset = \\\"abcdefghijklmnopqrstuvwxyz0123456789\\\"\\n    }\\n  \\n\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.PasswordPolicy;\nimport com.pulumi.vault.PasswordPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var alphanumeric = new PasswordPolicy(\"alphanumeric\", PasswordPolicyArgs.builder()        \n            .policy(\"\"\"\n    length = 20\n    rule \"charset\" {\n      charset = \"abcdefghijklmnopqrstuvwxyz0123456789\"\n    }\n  \n            \"\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  alphanumeric:\n    type: vault:PasswordPolicy\n    properties:\n      policy: \"    length = 20\\n    rule \\\"charset\\\" {\\n      charset = \\\"abcdefghijklmnopqrstuvwxyz0123456789\\\"\\n    }\\n  \\n\"\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nPassword policies can be imported using the `name`, e.g.\n\n```sh\n $ pulumi import vault:index/passwordPolicy:PasswordPolicy alphanumeric alphanumeric\n```\n\n ",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the password policy.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "policy": {
                    "type": "string",
                    "description": "String containing a password policy.\n"
                }
            },
            "required": [
                "name",
                "policy"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "The name of the password policy.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "policy": {
                    "type": "string",
                    "description": "String containing a password policy.\n"
                }
            },
            "requiredInputs": [
                "policy"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PasswordPolicy resources.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the password policy.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "policy": {
                        "type": "string",
                        "description": "String containing a password policy.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/policy:Policy": {
            "description": "\n\n\n## Import\n\nPolicies can be imported using the `name`, e.g.\n\n```sh\n $ pulumi import vault:index/policy:Policy example dev-team\n```\n\n ",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the policy\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "policy": {
                    "type": "string",
                    "description": "String containing a Vault policy\n",
                    "language": {
                        "csharp": {
                            "name": "PolicyContents"
                        }
                    }
                }
            },
            "required": [
                "name",
                "policy"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "The name of the policy\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "policy": {
                    "type": "string",
                    "description": "String containing a Vault policy\n",
                    "language": {
                        "csharp": {
                            "name": "PolicyContents"
                        }
                    }
                }
            },
            "requiredInputs": [
                "policy"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Policy resources.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the policy\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "policy": {
                        "type": "string",
                        "description": "String containing a Vault policy\n",
                        "language": {
                            "csharp": {
                                "name": "PolicyContents"
                            }
                        }
                    }
                },
                "type": "object"
            }
        },
        "vault:index/quotaLeaseCount:QuotaLeaseCount": {
            "description": "Manage lease count quotas which enforce the number of leases that can be created.\nA lease count quota can be created at the root level or defined on a namespace or mount by\nspecifying a path when creating the quota.\n\nSee [Vault's Documentation](https://www.vaultproject.io/docs/enterprise/lease-count-quotas) for more\ninformation.   \n\n**Note** this feature is available only with Vault Enterprise.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst global = new vault.QuotaLeaseCount(\"global\", {\n    maxLeases: 100,\n    path: \"\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nglobal_ = vault.QuotaLeaseCount(\"global\",\n    max_leases=100,\n    path=\"\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @global = new Vault.QuotaLeaseCount(\"global\", new()\n    {\n        MaxLeases = 100,\n        Path = \"\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewQuotaLeaseCount(ctx, \"global\", \u0026vault.QuotaLeaseCountArgs{\n\t\t\tMaxLeases: pulumi.Int(100),\n\t\t\tPath:      pulumi.String(\"\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.QuotaLeaseCount;\nimport com.pulumi.vault.QuotaLeaseCountArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var global = new QuotaLeaseCount(\"global\", QuotaLeaseCountArgs.builder()        \n            .maxLeases(100)\n            .path(\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  global:\n    type: vault:QuotaLeaseCount\n    properties:\n      maxLeases: 100\n      path:\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nLease count quotas can be imported using their names\n\n```sh\n $ pulumi import vault:index/quotaLeaseCount:QuotaLeaseCount global global\n```\n\n ",
            "properties": {
                "maxLeases": {
                    "type": "integer",
                    "description": "The maximum number of leases to be allowed by the quota\nrule. The `max_leases` must be positive.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the rate limit quota\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path of the mount or namespace to apply the quota. A blank path configures a\nglobal rate limit quota. For example `namespace1/` adds a quota to a full namespace,\n`namespace1/auth/userpass` adds a `quota` to `userpass` in `namespace1`.\nUpdating this field on an existing quota can have \"moving\" effects. For example, updating\n`auth/userpass` to `namespace1/auth/userpass` moves this quota from being a global mount quota to\na namespace specific mount quota. **Note, namespaces are supported in Enterprise only.**\n"
                }
            },
            "required": [
                "maxLeases",
                "name"
            ],
            "inputProperties": {
                "maxLeases": {
                    "type": "integer",
                    "description": "The maximum number of leases to be allowed by the quota\nrule. The `max_leases` must be positive.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the rate limit quota\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "Path of the mount or namespace to apply the quota. A blank path configures a\nglobal rate limit quota. For example `namespace1/` adds a quota to a full namespace,\n`namespace1/auth/userpass` adds a `quota` to `userpass` in `namespace1`.\nUpdating this field on an existing quota can have \"moving\" effects. For example, updating\n`auth/userpass` to `namespace1/auth/userpass` moves this quota from being a global mount quota to\na namespace specific mount quota. **Note, namespaces are supported in Enterprise only.**\n"
                }
            },
            "requiredInputs": [
                "maxLeases"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering QuotaLeaseCount resources.\n",
                "properties": {
                    "maxLeases": {
                        "type": "integer",
                        "description": "The maximum number of leases to be allowed by the quota\nrule. The `max_leases` must be positive.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the rate limit quota\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "Path of the mount or namespace to apply the quota. A blank path configures a\nglobal rate limit quota. For example `namespace1/` adds a quota to a full namespace,\n`namespace1/auth/userpass` adds a `quota` to `userpass` in `namespace1`.\nUpdating this field on an existing quota can have \"moving\" effects. For example, updating\n`auth/userpass` to `namespace1/auth/userpass` moves this quota from being a global mount quota to\na namespace specific mount quota. **Note, namespaces are supported in Enterprise only.**\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/quotaRateLimit:QuotaRateLimit": {
            "description": "Manage rate limit quotas which enforce API rate limiting using a token bucket algorithm.\nA rate limit quota can be created at the root level or defined on a namespace or mount by\nspecifying a path when creating the quota.\n\nSee [Vault's Documentation](https://www.vaultproject.io/docs/concepts/resource-quotas) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst global = new vault.QuotaRateLimit(\"global\", {\n    path: \"\",\n    rate: 100,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nglobal_ = vault.QuotaRateLimit(\"global\",\n    path=\"\",\n    rate=100)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @global = new Vault.QuotaRateLimit(\"global\", new()\n    {\n        Path = \"\",\n        Rate = 100,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewQuotaRateLimit(ctx, \"global\", \u0026vault.QuotaRateLimitArgs{\n\t\t\tPath: pulumi.String(\"\"),\n\t\t\tRate: pulumi.Float64(100),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.QuotaRateLimit;\nimport com.pulumi.vault.QuotaRateLimitArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var global = new QuotaRateLimit(\"global\", QuotaRateLimitArgs.builder()        \n            .path(\"\")\n            .rate(100)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  global:\n    type: vault:QuotaRateLimit\n    properties:\n      path:\n      rate: 100\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nRate limit quotas can be imported using their names\n\n```sh\n $ pulumi import vault:index/quotaRateLimit:QuotaRateLimit global global\n```\n\n ",
            "properties": {
                "blockInterval": {
                    "type": "integer",
                    "description": "If set, when a client reaches a rate limit threshold, the client will\nbe prohibited from any further requests until after the 'block_interval' in seconds has elapsed.\n"
                },
                "interval": {
                    "type": "integer",
                    "description": "The duration in seconds to enforce rate limiting for.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the rate limit quota\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path of the mount or namespace to apply the quota. A blank path configures a\nglobal rate limit quota. For example `namespace1/` adds a quota to a full namespace,\n`namespace1/auth/userpass` adds a `quota` to `userpass` in `namespace1`.\nUpdating this field on an existing quota can have \"moving\" effects. For example, updating\n`auth/userpass` to `namespace1/auth/userpass` moves this quota from being a global mount quota to\na namespace specific mount quota. **Note, namespaces are supported in Enterprise only.**\n"
                },
                "rate": {
                    "type": "number",
                    "description": "The maximum number of requests at any given second to be allowed by the quota\nrule. The `rate` must be positive.\n"
                }
            },
            "required": [
                "interval",
                "name",
                "rate"
            ],
            "inputProperties": {
                "blockInterval": {
                    "type": "integer",
                    "description": "If set, when a client reaches a rate limit threshold, the client will\nbe prohibited from any further requests until after the 'block_interval' in seconds has elapsed.\n"
                },
                "interval": {
                    "type": "integer",
                    "description": "The duration in seconds to enforce rate limiting for.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the rate limit quota\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "Path of the mount or namespace to apply the quota. A blank path configures a\nglobal rate limit quota. For example `namespace1/` adds a quota to a full namespace,\n`namespace1/auth/userpass` adds a `quota` to `userpass` in `namespace1`.\nUpdating this field on an existing quota can have \"moving\" effects. For example, updating\n`auth/userpass` to `namespace1/auth/userpass` moves this quota from being a global mount quota to\na namespace specific mount quota. **Note, namespaces are supported in Enterprise only.**\n",
                    "willReplaceOnChanges": true
                },
                "rate": {
                    "type": "number",
                    "description": "The maximum number of requests at any given second to be allowed by the quota\nrule. The `rate` must be positive.\n"
                }
            },
            "requiredInputs": [
                "rate"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering QuotaRateLimit resources.\n",
                "properties": {
                    "blockInterval": {
                        "type": "integer",
                        "description": "If set, when a client reaches a rate limit threshold, the client will\nbe prohibited from any further requests until after the 'block_interval' in seconds has elapsed.\n"
                    },
                    "interval": {
                        "type": "integer",
                        "description": "The duration in seconds to enforce rate limiting for.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the rate limit quota\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "Path of the mount or namespace to apply the quota. A blank path configures a\nglobal rate limit quota. For example `namespace1/` adds a quota to a full namespace,\n`namespace1/auth/userpass` adds a `quota` to `userpass` in `namespace1`.\nUpdating this field on an existing quota can have \"moving\" effects. For example, updating\n`auth/userpass` to `namespace1/auth/userpass` moves this quota from being a global mount quota to\na namespace specific mount quota. **Note, namespaces are supported in Enterprise only.**\n",
                        "willReplaceOnChanges": true
                    },
                    "rate": {
                        "type": "number",
                        "description": "The maximum number of requests at any given second to be allowed by the quota\nrule. The `rate` must be positive.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/raftAutopilot:RaftAutopilot": {
            "description": "Autopilot enables automated workflows for managing Raft clusters. The \ncurrent feature set includes 3 main features: Server Stabilization, Dead \nServer Cleanup and State API. **These three features are introduced in \nVault 1.7.**\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst autopilot = new vault.RaftAutopilot(\"autopilot\", {\n    cleanupDeadServers: true,\n    deadServerLastContactThreshold: \"24h0m0s\",\n    lastContactThreshold: \"10s\",\n    maxTrailingLogs: 1000,\n    minQuorum: 3,\n    serverStabilizationTime: \"10s\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nautopilot = vault.RaftAutopilot(\"autopilot\",\n    cleanup_dead_servers=True,\n    dead_server_last_contact_threshold=\"24h0m0s\",\n    last_contact_threshold=\"10s\",\n    max_trailing_logs=1000,\n    min_quorum=3,\n    server_stabilization_time=\"10s\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var autopilot = new Vault.RaftAutopilot(\"autopilot\", new()\n    {\n        CleanupDeadServers = true,\n        DeadServerLastContactThreshold = \"24h0m0s\",\n        LastContactThreshold = \"10s\",\n        MaxTrailingLogs = 1000,\n        MinQuorum = 3,\n        ServerStabilizationTime = \"10s\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewRaftAutopilot(ctx, \"autopilot\", \u0026vault.RaftAutopilotArgs{\n\t\t\tCleanupDeadServers:             pulumi.Bool(true),\n\t\t\tDeadServerLastContactThreshold: pulumi.String(\"24h0m0s\"),\n\t\t\tLastContactThreshold:           pulumi.String(\"10s\"),\n\t\t\tMaxTrailingLogs:                pulumi.Int(1000),\n\t\t\tMinQuorum:                      pulumi.Int(3),\n\t\t\tServerStabilizationTime:        pulumi.String(\"10s\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.RaftAutopilot;\nimport com.pulumi.vault.RaftAutopilotArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var autopilot = new RaftAutopilot(\"autopilot\", RaftAutopilotArgs.builder()        \n            .cleanupDeadServers(true)\n            .deadServerLastContactThreshold(\"24h0m0s\")\n            .lastContactThreshold(\"10s\")\n            .maxTrailingLogs(1000)\n            .minQuorum(3)\n            .serverStabilizationTime(\"10s\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  autopilot:\n    type: vault:RaftAutopilot\n    properties:\n      cleanupDeadServers: true\n      deadServerLastContactThreshold: 24h0m0s\n      lastContactThreshold: 10s\n      maxTrailingLogs: 1000\n      minQuorum: 3\n      serverStabilizationTime: 10s\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nRaft Autopilot config can be imported using the ID, e.g.\n\n```sh\n $ pulumi import vault:index/raftAutopilot:RaftAutopilot autopilot sys/storage/raft/autopilot/configuration\n```\n\n ",
            "properties": {
                "cleanupDeadServers": {
                    "type": "boolean",
                    "description": "Specifies whether to remove dead server nodes\nperiodically or when a new server joins. This requires that `min-quorum` is also set.\n"
                },
                "deadServerLastContactThreshold": {
                    "type": "string",
                    "description": "Limit the amount of time a \nserver can go without leader contact before being considered failed. This only takes\neffect when `cleanup_dead_servers` is set.\n"
                },
                "disableUpgradeMigration": {
                    "type": "boolean",
                    "description": "Disables automatically upgrading Vault using autopilot. (Enterprise-only)\n"
                },
                "lastContactThreshold": {
                    "type": "string",
                    "description": "Limit the amount of time a server can go \nwithout leader contact before being considered unhealthy.\n"
                },
                "maxTrailingLogs": {
                    "type": "integer",
                    "description": "Maximum number of log entries in the Raft log \nthat a server can be behind its leader before being considered unhealthy.\n"
                },
                "minQuorum": {
                    "type": "integer",
                    "description": "Minimum number of servers allowed in a cluster before \nautopilot can prune dead servers. This should at least be 3. Applicable only for\nvoting nodes.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "serverStabilizationTime": {
                    "type": "string",
                    "description": "Minimum amount of time a server must be \nstable in the 'healthy' state before being added to the cluster.\n"
                }
            },
            "inputProperties": {
                "cleanupDeadServers": {
                    "type": "boolean",
                    "description": "Specifies whether to remove dead server nodes\nperiodically or when a new server joins. This requires that `min-quorum` is also set.\n"
                },
                "deadServerLastContactThreshold": {
                    "type": "string",
                    "description": "Limit the amount of time a \nserver can go without leader contact before being considered failed. This only takes\neffect when `cleanup_dead_servers` is set.\n"
                },
                "disableUpgradeMigration": {
                    "type": "boolean",
                    "description": "Disables automatically upgrading Vault using autopilot. (Enterprise-only)\n"
                },
                "lastContactThreshold": {
                    "type": "string",
                    "description": "Limit the amount of time a server can go \nwithout leader contact before being considered unhealthy.\n"
                },
                "maxTrailingLogs": {
                    "type": "integer",
                    "description": "Maximum number of log entries in the Raft log \nthat a server can be behind its leader before being considered unhealthy.\n"
                },
                "minQuorum": {
                    "type": "integer",
                    "description": "Minimum number of servers allowed in a cluster before \nautopilot can prune dead servers. This should at least be 3. Applicable only for\nvoting nodes.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "serverStabilizationTime": {
                    "type": "string",
                    "description": "Minimum amount of time a server must be \nstable in the 'healthy' state before being added to the cluster.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RaftAutopilot resources.\n",
                "properties": {
                    "cleanupDeadServers": {
                        "type": "boolean",
                        "description": "Specifies whether to remove dead server nodes\nperiodically or when a new server joins. This requires that `min-quorum` is also set.\n"
                    },
                    "deadServerLastContactThreshold": {
                        "type": "string",
                        "description": "Limit the amount of time a \nserver can go without leader contact before being considered failed. This only takes\neffect when `cleanup_dead_servers` is set.\n"
                    },
                    "disableUpgradeMigration": {
                        "type": "boolean",
                        "description": "Disables automatically upgrading Vault using autopilot. (Enterprise-only)\n"
                    },
                    "lastContactThreshold": {
                        "type": "string",
                        "description": "Limit the amount of time a server can go \nwithout leader contact before being considered unhealthy.\n"
                    },
                    "maxTrailingLogs": {
                        "type": "integer",
                        "description": "Maximum number of log entries in the Raft log \nthat a server can be behind its leader before being considered unhealthy.\n"
                    },
                    "minQuorum": {
                        "type": "integer",
                        "description": "Minimum number of servers allowed in a cluster before \nautopilot can prune dead servers. This should at least be 3. Applicable only for\nvoting nodes.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "serverStabilizationTime": {
                        "type": "string",
                        "description": "Minimum amount of time a server must be \nstable in the 'healthy' state before being added to the cluster.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/raftSnapshotAgentConfig:RaftSnapshotAgentConfig": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n### Local Storage\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst localBackups = new vault.RaftSnapshotAgentConfig(\"local_backups\", {\n    intervalSeconds: 86400, // 24h\n    // Storage Type Configuration\n    localMaxSpace: 10000000,\n    pathPrefix: \"/opt/vault/snapshots/\",\n    retain: 7,\n    storageType: \"local\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nlocal_backups = vault.RaftSnapshotAgentConfig(\"localBackups\",\n    interval_seconds=86400,\n    local_max_space=10000000,\n    path_prefix=\"/opt/vault/snapshots/\",\n    retain=7,\n    storage_type=\"local\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var localBackups = new Vault.RaftSnapshotAgentConfig(\"localBackups\", new()\n    {\n        IntervalSeconds = 86400,\n        LocalMaxSpace = 10000000,\n        PathPrefix = \"/opt/vault/snapshots/\",\n        Retain = 7,\n        StorageType = \"local\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewRaftSnapshotAgentConfig(ctx, \"localBackups\", \u0026vault.RaftSnapshotAgentConfigArgs{\n\t\t\tIntervalSeconds: pulumi.Int(86400),\n\t\t\tLocalMaxSpace:   pulumi.Int(10000000),\n\t\t\tPathPrefix:      pulumi.String(\"/opt/vault/snapshots/\"),\n\t\t\tRetain:          pulumi.Int(7),\n\t\t\tStorageType:     pulumi.String(\"local\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.RaftSnapshotAgentConfig;\nimport com.pulumi.vault.RaftSnapshotAgentConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var localBackups = new RaftSnapshotAgentConfig(\"localBackups\", RaftSnapshotAgentConfigArgs.builder()        \n            .intervalSeconds(86400)\n            .localMaxSpace(10000000)\n            .pathPrefix(\"/opt/vault/snapshots/\")\n            .retain(7)\n            .storageType(\"local\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  localBackups:\n    type: vault:RaftSnapshotAgentConfig\n    properties:\n      intervalSeconds: 86400\n      # 24h\n      #     // Storage Type Configuration\n      localMaxSpace: 1e+07\n      pathPrefix: /opt/vault/snapshots/\n      retain: 7\n      storageType: local\n```\n{{% /example %}}\n{{% example %}}\n### AWS S3\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\nimport * as vault from \"@pulumi/vault\";\n\nconst config = new pulumi.Config();\nconst awsAccessKeyId = config.requireObject(\"awsAccessKeyId\");\nconst awsSecretAccessKey = config.requireObject(\"awsSecretAccessKey\");\nconst current = aws.getRegion({});\nconst s3Backups = new vault.RaftSnapshotAgentConfig(\"s3Backups\", {\n    intervalSeconds: 86400,\n    retain: 7,\n    pathPrefix: \"/path/in/bucket\",\n    storageType: \"aws-s3\",\n    awsS3Bucket: \"my-bucket\",\n    awsS3Region: current.then(current =\u003e current.name),\n    awsAccessKeyId: awsAccessKeyId,\n    awsSecretAccessKey: awsSecretAccessKey,\n    awsS3EnableKms: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\nimport pulumi_vault as vault\n\nconfig = pulumi.Config()\naws_access_key_id = config.require_object(\"awsAccessKeyId\")\naws_secret_access_key = config.require_object(\"awsSecretAccessKey\")\ncurrent = aws.get_region()\ns3_backups = vault.RaftSnapshotAgentConfig(\"s3Backups\",\n    interval_seconds=86400,\n    retain=7,\n    path_prefix=\"/path/in/bucket\",\n    storage_type=\"aws-s3\",\n    aws_s3_bucket=\"my-bucket\",\n    aws_s3_region=current.name,\n    aws_access_key_id=aws_access_key_id,\n    aws_secret_access_key=aws_secret_access_key,\n    aws_s3_enable_kms=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Config();\n    var awsAccessKeyId = config.RequireObject\u003cdynamic\u003e(\"awsAccessKeyId\");\n    var awsSecretAccessKey = config.RequireObject\u003cdynamic\u003e(\"awsSecretAccessKey\");\n    var current = Aws.GetRegion.Invoke();\n\n    var s3Backups = new Vault.RaftSnapshotAgentConfig(\"s3Backups\", new()\n    {\n        IntervalSeconds = 86400,\n        Retain = 7,\n        PathPrefix = \"/path/in/bucket\",\n        StorageType = \"aws-s3\",\n        AwsS3Bucket = \"my-bucket\",\n        AwsS3Region = current.Apply(getRegionResult =\u003e getRegionResult.Name),\n        AwsAccessKeyId = awsAccessKeyId,\n        AwsSecretAccessKey = awsSecretAccessKey,\n        AwsS3EnableKms = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v5/go/aws\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcfg := config.New(ctx, \"\")\n\t\tawsAccessKeyId := cfg.RequireObject(\"awsAccessKeyId\")\n\t\tawsSecretAccessKey := cfg.RequireObject(\"awsSecretAccessKey\")\n\t\tcurrent, err := aws.GetRegion(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vault.NewRaftSnapshotAgentConfig(ctx, \"s3Backups\", \u0026vault.RaftSnapshotAgentConfigArgs{\n\t\t\tIntervalSeconds:    pulumi.Int(86400),\n\t\t\tRetain:             pulumi.Int(7),\n\t\t\tPathPrefix:         pulumi.String(\"/path/in/bucket\"),\n\t\t\tStorageType:        pulumi.String(\"aws-s3\"),\n\t\t\tAwsS3Bucket:        pulumi.String(\"my-bucket\"),\n\t\t\tAwsS3Region:        pulumi.String(current.Name),\n\t\t\tAwsAccessKeyId:     pulumi.Any(awsAccessKeyId),\n\t\t\tAwsSecretAccessKey: pulumi.Any(awsSecretAccessKey),\n\t\t\tAwsS3EnableKms:     pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.aws.AwsFunctions;\nimport com.pulumi.aws.inputs.GetRegionArgs;\nimport com.pulumi.vault.RaftSnapshotAgentConfig;\nimport com.pulumi.vault.RaftSnapshotAgentConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var config = ctx.config();\n        final var awsAccessKeyId = config.get(\"awsAccessKeyId\");\n        final var awsSecretAccessKey = config.get(\"awsSecretAccessKey\");\n        final var current = AwsFunctions.getRegion();\n\n        var s3Backups = new RaftSnapshotAgentConfig(\"s3Backups\", RaftSnapshotAgentConfigArgs.builder()        \n            .intervalSeconds(86400)\n            .retain(7)\n            .pathPrefix(\"/path/in/bucket\")\n            .storageType(\"aws-s3\")\n            .awsS3Bucket(\"my-bucket\")\n            .awsS3Region(current.applyValue(getRegionResult -\u003e getRegionResult.name()))\n            .awsAccessKeyId(awsAccessKeyId)\n            .awsSecretAccessKey(awsSecretAccessKey)\n            .awsS3EnableKms(true)\n            .build());\n\n    }\n}\n```\n```yaml\nconfiguration:\n  awsAccessKeyId:\n    type: dynamic\n  awsSecretAccessKey:\n    type: dynamic\nresources:\n  s3Backups:\n    type: vault:RaftSnapshotAgentConfig\n    properties:\n      intervalSeconds: 86400\n      # 24h\n      retain: 7\n      pathPrefix: /path/in/bucket\n      storageType: aws-s3\n      # Storage Type Configuration\n      awsS3Bucket: my-bucket\n      awsS3Region: ${current.name}\n      awsAccessKeyId: ${awsAccessKeyId}\n      awsSecretAccessKey: ${awsSecretAccessKey}\n      awsS3EnableKms: true\nvariables:\n  current:\n    Fn::Invoke:\n      Function: aws:getRegion\n      Arguments: {}\n```\n{{% /example %}}\n{{% example %}}\n### Azure BLOB\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst config = new pulumi.Config();\nconst azureAccountName = config.requireObject(\"azureAccountName\");\nconst azureAccountKey = config.requireObject(\"azureAccountKey\");\nconst azureBackups = new vault.RaftSnapshotAgentConfig(\"azureBackups\", {\n    intervalSeconds: 86400,\n    retain: 7,\n    pathPrefix: \"/\",\n    storageType: \"azure-blob\",\n    azureContainerName: \"vault-blob\",\n    azureAccountName: azureAccountName,\n    azureAccountKey: azureAccountKey,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nconfig = pulumi.Config()\nazure_account_name = config.require_object(\"azureAccountName\")\nazure_account_key = config.require_object(\"azureAccountKey\")\nazure_backups = vault.RaftSnapshotAgentConfig(\"azureBackups\",\n    interval_seconds=86400,\n    retain=7,\n    path_prefix=\"/\",\n    storage_type=\"azure-blob\",\n    azure_container_name=\"vault-blob\",\n    azure_account_name=azure_account_name,\n    azure_account_key=azure_account_key)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Config();\n    var azureAccountName = config.RequireObject\u003cdynamic\u003e(\"azureAccountName\");\n    var azureAccountKey = config.RequireObject\u003cdynamic\u003e(\"azureAccountKey\");\n    var azureBackups = new Vault.RaftSnapshotAgentConfig(\"azureBackups\", new()\n    {\n        IntervalSeconds = 86400,\n        Retain = 7,\n        PathPrefix = \"/\",\n        StorageType = \"azure-blob\",\n        AzureContainerName = \"vault-blob\",\n        AzureAccountName = azureAccountName,\n        AzureAccountKey = azureAccountKey,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcfg := config.New(ctx, \"\")\n\t\tazureAccountName := cfg.RequireObject(\"azureAccountName\")\n\t\tazureAccountKey := cfg.RequireObject(\"azureAccountKey\")\n\t\t_, err := vault.NewRaftSnapshotAgentConfig(ctx, \"azureBackups\", \u0026vault.RaftSnapshotAgentConfigArgs{\n\t\t\tIntervalSeconds:    pulumi.Int(86400),\n\t\t\tRetain:             pulumi.Int(7),\n\t\t\tPathPrefix:         pulumi.String(\"/\"),\n\t\t\tStorageType:        pulumi.String(\"azure-blob\"),\n\t\t\tAzureContainerName: pulumi.String(\"vault-blob\"),\n\t\t\tAzureAccountName:   pulumi.Any(azureAccountName),\n\t\t\tAzureAccountKey:    pulumi.Any(azureAccountKey),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.RaftSnapshotAgentConfig;\nimport com.pulumi.vault.RaftSnapshotAgentConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var config = ctx.config();\n        final var azureAccountName = config.get(\"azureAccountName\");\n        final var azureAccountKey = config.get(\"azureAccountKey\");\n        var azureBackups = new RaftSnapshotAgentConfig(\"azureBackups\", RaftSnapshotAgentConfigArgs.builder()        \n            .intervalSeconds(86400)\n            .retain(7)\n            .pathPrefix(\"/\")\n            .storageType(\"azure-blob\")\n            .azureContainerName(\"vault-blob\")\n            .azureAccountName(azureAccountName)\n            .azureAccountKey(azureAccountKey)\n            .build());\n\n    }\n}\n```\n```yaml\nconfiguration:\n  azureAccountName:\n    type: dynamic\n  azureAccountKey:\n    type: dynamic\nresources:\n  azureBackups:\n    type: vault:RaftSnapshotAgentConfig\n    properties:\n      intervalSeconds: 86400\n      # 24h\n      retain: 7\n      pathPrefix: /\n      storageType: azure-blob\n      # Storage Type Configuration\n      azureContainerName: vault-blob\n      azureAccountName: ${azureAccountName}\n      azureAccountKey: ${azureAccountKey}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nRaft Snapshot Agent Configurations can be imported using the `name`, e.g.\n\n```sh\n $ pulumi import vault:index/raftSnapshotAgentConfig:RaftSnapshotAgentConfig local local\n```\n\n ",
            "properties": {
                "awsAccessKeyId": {
                    "type": "string",
                    "description": "AWS access key ID.\n"
                },
                "awsS3Bucket": {
                    "type": "string",
                    "description": "`\u003crequired\u003e` - S3 bucket to write snapshots to.\n"
                },
                "awsS3DisableTls": {
                    "type": "boolean",
                    "description": "Disable TLS for the S3 endpoint. This\nshould only be used for testing purposes, typically in conjunction with\n`aws_s3_endpoint`.\n"
                },
                "awsS3EnableKms": {
                    "type": "boolean",
                    "description": "Use KMS to encrypt bucket contents.\n"
                },
                "awsS3Endpoint": {
                    "type": "string",
                    "description": "AWS endpoint. This is typically only set when\nusing a non-AWS S3 implementation like Minio.\n"
                },
                "awsS3ForcePathStyle": {
                    "type": "boolean",
                    "description": "Use the endpoint/bucket URL style\ninstead of bucket.endpoint. May be needed when setting `aws_s3_endpoint`.\n"
                },
                "awsS3KmsKey": {
                    "type": "string",
                    "description": "Use named KMS key, when `aws_s3_enable_kms = true`\n"
                },
                "awsS3Region": {
                    "type": "string",
                    "description": "`\u003crequired\u003e` - AWS region bucket is in.\n"
                },
                "awsS3ServerSideEncryption": {
                    "type": "boolean",
                    "description": "Use AES256 to encrypt bucket contents.\n"
                },
                "awsSecretAccessKey": {
                    "type": "string",
                    "description": "AWS secret access key.\n"
                },
                "awsSessionToken": {
                    "type": "string",
                    "description": "AWS session token.\n"
                },
                "azureAccountKey": {
                    "type": "string",
                    "description": "Azure account key.\n"
                },
                "azureAccountName": {
                    "type": "string",
                    "description": "Azure account name.\n"
                },
                "azureBlobEnvironment": {
                    "type": "string",
                    "description": "Azure blob environment.\n"
                },
                "azureContainerName": {
                    "type": "string",
                    "description": "`\u003crequired\u003e` - Azure container name to write\nsnapshots to.\n"
                },
                "azureEndpoint": {
                    "type": "string",
                    "description": "Azure blob storage endpoint. This is typically\nonly set when using a non-Azure implementation like Azurite.\n"
                },
                "filePrefix": {
                    "type": "string",
                    "description": "Within the directory or bucket\nprefix given by `path_prefix`, the file or object name of snapshot files\nwill start with this string.\n"
                },
                "googleDisableTls": {
                    "type": "boolean",
                    "description": "Disable TLS for the GCS endpoint. This\nshould only be used for testing purposes, typically in conjunction with\n`google_endpoint`.\n"
                },
                "googleEndpoint": {
                    "type": "string",
                    "description": "GCS endpoint. This is typically only set when\nusing a non-Google GCS implementation like fake-gcs-server.\n"
                },
                "googleGcsBucket": {
                    "type": "string",
                    "description": "`\u003crequired\u003e` - GCS bucket to write snapshots to.\n"
                },
                "googleServiceAccountKey": {
                    "type": "string",
                    "description": "Google service account key in JSON format. \nThe raw value looks like this:\n"
                },
                "intervalSeconds": {
                    "type": "integer",
                    "description": "`\u003crequired\u003e` - Time (in seconds) between snapshots.\n"
                },
                "localMaxSpace": {
                    "type": "integer",
                    "description": "For `storage_type = local`, the maximum\nspace, in bytes, to use for snapshots. Snapshot attempts will fail if there is not enough\nspace left in this allowance.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`\u003crequired\u003e` – Name of the configuration to modify.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "pathPrefix": {
                    "type": "string",
                    "description": "`\u003crequired\u003e` - For `storage_type = \"local\"`, the directory to\nwrite the snapshots in. For cloud storage types, the bucket prefix to use.\nTypes `azure-s3` and `google-gcs` require a trailing `/` (slash).\nTypes `local` and `aws-s3` the trailing `/` is optional.\n"
                },
                "retain": {
                    "type": "integer",
                    "description": "How many snapshots are to be kept; when writing a\nsnapshot, if there are more snapshots already stored than this number, the\noldest ones will be deleted.\n"
                },
                "storageType": {
                    "type": "string",
                    "description": "`\u003crequired\u003e` - One of \"local\", \"azure-blob\", \"aws-s3\",\nor \"google-gcs\". The remaining parameters described below are all specific to\nthe selected `storage_type` and prefixed accordingly.\n"
                }
            },
            "required": [
                "intervalSeconds",
                "name",
                "pathPrefix",
                "storageType"
            ],
            "inputProperties": {
                "awsAccessKeyId": {
                    "type": "string",
                    "description": "AWS access key ID.\n"
                },
                "awsS3Bucket": {
                    "type": "string",
                    "description": "`\u003crequired\u003e` - S3 bucket to write snapshots to.\n"
                },
                "awsS3DisableTls": {
                    "type": "boolean",
                    "description": "Disable TLS for the S3 endpoint. This\nshould only be used for testing purposes, typically in conjunction with\n`aws_s3_endpoint`.\n"
                },
                "awsS3EnableKms": {
                    "type": "boolean",
                    "description": "Use KMS to encrypt bucket contents.\n"
                },
                "awsS3Endpoint": {
                    "type": "string",
                    "description": "AWS endpoint. This is typically only set when\nusing a non-AWS S3 implementation like Minio.\n"
                },
                "awsS3ForcePathStyle": {
                    "type": "boolean",
                    "description": "Use the endpoint/bucket URL style\ninstead of bucket.endpoint. May be needed when setting `aws_s3_endpoint`.\n"
                },
                "awsS3KmsKey": {
                    "type": "string",
                    "description": "Use named KMS key, when `aws_s3_enable_kms = true`\n"
                },
                "awsS3Region": {
                    "type": "string",
                    "description": "`\u003crequired\u003e` - AWS region bucket is in.\n"
                },
                "awsS3ServerSideEncryption": {
                    "type": "boolean",
                    "description": "Use AES256 to encrypt bucket contents.\n"
                },
                "awsSecretAccessKey": {
                    "type": "string",
                    "description": "AWS secret access key.\n"
                },
                "awsSessionToken": {
                    "type": "string",
                    "description": "AWS session token.\n"
                },
                "azureAccountKey": {
                    "type": "string",
                    "description": "Azure account key.\n"
                },
                "azureAccountName": {
                    "type": "string",
                    "description": "Azure account name.\n"
                },
                "azureBlobEnvironment": {
                    "type": "string",
                    "description": "Azure blob environment.\n"
                },
                "azureContainerName": {
                    "type": "string",
                    "description": "`\u003crequired\u003e` - Azure container name to write\nsnapshots to.\n"
                },
                "azureEndpoint": {
                    "type": "string",
                    "description": "Azure blob storage endpoint. This is typically\nonly set when using a non-Azure implementation like Azurite.\n"
                },
                "filePrefix": {
                    "type": "string",
                    "description": "Within the directory or bucket\nprefix given by `path_prefix`, the file or object name of snapshot files\nwill start with this string.\n"
                },
                "googleDisableTls": {
                    "type": "boolean",
                    "description": "Disable TLS for the GCS endpoint. This\nshould only be used for testing purposes, typically in conjunction with\n`google_endpoint`.\n"
                },
                "googleEndpoint": {
                    "type": "string",
                    "description": "GCS endpoint. This is typically only set when\nusing a non-Google GCS implementation like fake-gcs-server.\n"
                },
                "googleGcsBucket": {
                    "type": "string",
                    "description": "`\u003crequired\u003e` - GCS bucket to write snapshots to.\n"
                },
                "googleServiceAccountKey": {
                    "type": "string",
                    "description": "Google service account key in JSON format. \nThe raw value looks like this:\n"
                },
                "intervalSeconds": {
                    "type": "integer",
                    "description": "`\u003crequired\u003e` - Time (in seconds) between snapshots.\n"
                },
                "localMaxSpace": {
                    "type": "integer",
                    "description": "For `storage_type = local`, the maximum\nspace, in bytes, to use for snapshots. Snapshot attempts will fail if there is not enough\nspace left in this allowance.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`\u003crequired\u003e` – Name of the configuration to modify.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "pathPrefix": {
                    "type": "string",
                    "description": "`\u003crequired\u003e` - For `storage_type = \"local\"`, the directory to\nwrite the snapshots in. For cloud storage types, the bucket prefix to use.\nTypes `azure-s3` and `google-gcs` require a trailing `/` (slash).\nTypes `local` and `aws-s3` the trailing `/` is optional.\n"
                },
                "retain": {
                    "type": "integer",
                    "description": "How many snapshots are to be kept; when writing a\nsnapshot, if there are more snapshots already stored than this number, the\noldest ones will be deleted.\n"
                },
                "storageType": {
                    "type": "string",
                    "description": "`\u003crequired\u003e` - One of \"local\", \"azure-blob\", \"aws-s3\",\nor \"google-gcs\". The remaining parameters described below are all specific to\nthe selected `storage_type` and prefixed accordingly.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "intervalSeconds",
                "pathPrefix",
                "storageType"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RaftSnapshotAgentConfig resources.\n",
                "properties": {
                    "awsAccessKeyId": {
                        "type": "string",
                        "description": "AWS access key ID.\n"
                    },
                    "awsS3Bucket": {
                        "type": "string",
                        "description": "`\u003crequired\u003e` - S3 bucket to write snapshots to.\n"
                    },
                    "awsS3DisableTls": {
                        "type": "boolean",
                        "description": "Disable TLS for the S3 endpoint. This\nshould only be used for testing purposes, typically in conjunction with\n`aws_s3_endpoint`.\n"
                    },
                    "awsS3EnableKms": {
                        "type": "boolean",
                        "description": "Use KMS to encrypt bucket contents.\n"
                    },
                    "awsS3Endpoint": {
                        "type": "string",
                        "description": "AWS endpoint. This is typically only set when\nusing a non-AWS S3 implementation like Minio.\n"
                    },
                    "awsS3ForcePathStyle": {
                        "type": "boolean",
                        "description": "Use the endpoint/bucket URL style\ninstead of bucket.endpoint. May be needed when setting `aws_s3_endpoint`.\n"
                    },
                    "awsS3KmsKey": {
                        "type": "string",
                        "description": "Use named KMS key, when `aws_s3_enable_kms = true`\n"
                    },
                    "awsS3Region": {
                        "type": "string",
                        "description": "`\u003crequired\u003e` - AWS region bucket is in.\n"
                    },
                    "awsS3ServerSideEncryption": {
                        "type": "boolean",
                        "description": "Use AES256 to encrypt bucket contents.\n"
                    },
                    "awsSecretAccessKey": {
                        "type": "string",
                        "description": "AWS secret access key.\n"
                    },
                    "awsSessionToken": {
                        "type": "string",
                        "description": "AWS session token.\n"
                    },
                    "azureAccountKey": {
                        "type": "string",
                        "description": "Azure account key.\n"
                    },
                    "azureAccountName": {
                        "type": "string",
                        "description": "Azure account name.\n"
                    },
                    "azureBlobEnvironment": {
                        "type": "string",
                        "description": "Azure blob environment.\n"
                    },
                    "azureContainerName": {
                        "type": "string",
                        "description": "`\u003crequired\u003e` - Azure container name to write\nsnapshots to.\n"
                    },
                    "azureEndpoint": {
                        "type": "string",
                        "description": "Azure blob storage endpoint. This is typically\nonly set when using a non-Azure implementation like Azurite.\n"
                    },
                    "filePrefix": {
                        "type": "string",
                        "description": "Within the directory or bucket\nprefix given by `path_prefix`, the file or object name of snapshot files\nwill start with this string.\n"
                    },
                    "googleDisableTls": {
                        "type": "boolean",
                        "description": "Disable TLS for the GCS endpoint. This\nshould only be used for testing purposes, typically in conjunction with\n`google_endpoint`.\n"
                    },
                    "googleEndpoint": {
                        "type": "string",
                        "description": "GCS endpoint. This is typically only set when\nusing a non-Google GCS implementation like fake-gcs-server.\n"
                    },
                    "googleGcsBucket": {
                        "type": "string",
                        "description": "`\u003crequired\u003e` - GCS bucket to write snapshots to.\n"
                    },
                    "googleServiceAccountKey": {
                        "type": "string",
                        "description": "Google service account key in JSON format. \nThe raw value looks like this:\n"
                    },
                    "intervalSeconds": {
                        "type": "integer",
                        "description": "`\u003crequired\u003e` - Time (in seconds) between snapshots.\n"
                    },
                    "localMaxSpace": {
                        "type": "integer",
                        "description": "For `storage_type = local`, the maximum\nspace, in bytes, to use for snapshots. Snapshot attempts will fail if there is not enough\nspace left in this allowance.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "`\u003crequired\u003e` – Name of the configuration to modify.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "pathPrefix": {
                        "type": "string",
                        "description": "`\u003crequired\u003e` - For `storage_type = \"local\"`, the directory to\nwrite the snapshots in. For cloud storage types, the bucket prefix to use.\nTypes `azure-s3` and `google-gcs` require a trailing `/` (slash).\nTypes `local` and `aws-s3` the trailing `/` is optional.\n"
                    },
                    "retain": {
                        "type": "integer",
                        "description": "How many snapshots are to be kept; when writing a\nsnapshot, if there are more snapshots already stored than this number, the\noldest ones will be deleted.\n"
                    },
                    "storageType": {
                        "type": "string",
                        "description": "`\u003crequired\u003e` - One of \"local\", \"azure-blob\", \"aws-s3\",\nor \"google-gcs\". The remaining parameters described below are all specific to\nthe selected `storage_type` and prefixed accordingly.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:index/rgpPolicy:RgpPolicy": {
            "description": "Provides a resource to manage Role Governing Policy (RGP) via [Sentinel](https://www.vaultproject.io/docs/enterprise/sentinel/index.html).\n\n**Note** this feature is available only with Vault Enterprise.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst allow_all = new vault.RgpPolicy(\"allow-all\", {\n    enforcementLevel: \"soft-mandatory\",\n    policy: `main = rule {\n  true\n}\n`,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nallow_all = vault.RgpPolicy(\"allow-all\",\n    enforcement_level=\"soft-mandatory\",\n    policy=\"\"\"main = rule {\n  true\n}\n\n\"\"\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var allow_all = new Vault.RgpPolicy(\"allow-all\", new()\n    {\n        EnforcementLevel = \"soft-mandatory\",\n        Policy = @\"main = rule {\n  true\n}\n\n\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewRgpPolicy(ctx, \"allow-all\", \u0026vault.RgpPolicyArgs{\n\t\t\tEnforcementLevel: pulumi.String(\"soft-mandatory\"),\n\t\t\tPolicy:           pulumi.String(\"main = rule {\\n  true\\n}\\n\\n\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.RgpPolicy;\nimport com.pulumi.vault.RgpPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var allow_all = new RgpPolicy(\"allow-all\", RgpPolicyArgs.builder()        \n            .enforcementLevel(\"soft-mandatory\")\n            .policy(\"\"\"\nmain = rule {\n  true\n}\n\n            \"\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  allow-all:\n    type: vault:RgpPolicy\n    properties:\n      enforcementLevel: soft-mandatory\n      policy: |+\n        main = rule {\n          true\n        }\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "enforcementLevel": {
                    "type": "string",
                    "description": "Enforcement level of Sentinel policy. Can be either `advisory` or `soft-mandatory` or `hard-mandatory`\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the policy\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "policy": {
                    "type": "string",
                    "description": "String containing a Sentinel policy\n"
                }
            },
            "required": [
                "enforcementLevel",
                "name",
                "policy"
            ],
            "inputProperties": {
                "enforcementLevel": {
                    "type": "string",
                    "description": "Enforcement level of Sentinel policy. Can be either `advisory` or `soft-mandatory` or `hard-mandatory`\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the policy\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "policy": {
                    "type": "string",
                    "description": "String containing a Sentinel policy\n"
                }
            },
            "requiredInputs": [
                "enforcementLevel",
                "policy"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RgpPolicy resources.\n",
                "properties": {
                    "enforcementLevel": {
                        "type": "string",
                        "description": "Enforcement level of Sentinel policy. Can be either `advisory` or `soft-mandatory` or `hard-mandatory`\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the policy\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "policy": {
                        "type": "string",
                        "description": "String containing a Sentinel policy\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/token:Token": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.Token(\"example\", {\n    metadata: {\n        purpose: \"service-account\",\n    },\n    policies: [\n        \"policy1\",\n        \"policy2\",\n    ],\n    renewIncrement: 86400,\n    renewMinLease: 43200,\n    renewable: true,\n    roleName: \"app\",\n    ttl: \"24h\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.Token(\"example\",\n    metadata={\n        \"purpose\": \"service-account\",\n    },\n    policies=[\n        \"policy1\",\n        \"policy2\",\n    ],\n    renew_increment=86400,\n    renew_min_lease=43200,\n    renewable=True,\n    role_name=\"app\",\n    ttl=\"24h\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Vault.Token(\"example\", new()\n    {\n        Metadata = \n        {\n            { \"purpose\", \"service-account\" },\n        },\n        Policies = new[]\n        {\n            \"policy1\",\n            \"policy2\",\n        },\n        RenewIncrement = 86400,\n        RenewMinLease = 43200,\n        Renewable = true,\n        RoleName = \"app\",\n        Ttl = \"24h\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewToken(ctx, \"example\", \u0026vault.TokenArgs{\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"purpose\": pulumi.String(\"service-account\"),\n\t\t\t},\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"policy1\"),\n\t\t\t\tpulumi.String(\"policy2\"),\n\t\t\t},\n\t\t\tRenewIncrement: pulumi.Int(86400),\n\t\t\tRenewMinLease:  pulumi.Int(43200),\n\t\t\tRenewable:      pulumi.Bool(true),\n\t\t\tRoleName:       pulumi.String(\"app\"),\n\t\t\tTtl:            pulumi.String(\"24h\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Token;\nimport com.pulumi.vault.TokenArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Token(\"example\", TokenArgs.builder()        \n            .metadata(Map.of(\"purpose\", \"service-account\"))\n            .policies(            \n                \"policy1\",\n                \"policy2\")\n            .renewIncrement(86400)\n            .renewMinLease(43200)\n            .renewable(true)\n            .roleName(\"app\")\n            .ttl(\"24h\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: vault:Token\n    properties:\n      metadata:\n        purpose: service-account\n      policies:\n        - policy1\n        - policy2\n      renewIncrement: 86400\n      renewMinLease: 43200\n      renewable: true\n      roleName: app\n      ttl: 24h\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nTokens can be imported using its `id` as accessor id, e.g.\n\n```sh\n $ pulumi import vault:index/token:Token example \u003caccessor_id\u003e\n```\n\n ",
            "properties": {
                "clientToken": {
                    "type": "string",
                    "description": "String containing the client token if stored in present file\n",
                    "secret": true
                },
                "displayName": {
                    "type": "string",
                    "description": "String containing the token display name\n"
                },
                "explicitMaxTtl": {
                    "type": "string",
                    "description": "The explicit max TTL of this token. This is specified as a numeric string with suffix like \"30s\" ro \"5m\"\n"
                },
                "leaseDuration": {
                    "type": "integer",
                    "description": "String containing the token lease duration if present in state file\n"
                },
                "leaseStarted": {
                    "type": "string",
                    "description": "String containing the token lease started time if present in state file\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Metadata to be set on this token\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "noDefaultPolicy": {
                    "type": "boolean",
                    "description": "Flag to not attach the default policy to this token\n"
                },
                "noParent": {
                    "type": "boolean",
                    "description": "Flag to create a token without parent\n"
                },
                "numUses": {
                    "type": "integer",
                    "description": "The number of allowed uses of this token\n"
                },
                "period": {
                    "type": "string",
                    "description": "The period of this token. This is specified as a numeric string with suffix like \"30s\" ro \"5m\"\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to attach to this token\n"
                },
                "renewIncrement": {
                    "type": "integer",
                    "description": "The renew increment. This is specified in seconds\n"
                },
                "renewMinLease": {
                    "type": "integer",
                    "description": "The minimal lease to renew this token\n"
                },
                "renewable": {
                    "type": "boolean",
                    "description": "Flag to allow to renew this token\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The token role name\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "The TTL period of this token. This is specified as a numeric string with suffix like \"30s\" ro \"5m\"\n"
                },
                "wrappedToken": {
                    "type": "string",
                    "description": "The client wrapped token.\n",
                    "secret": true
                },
                "wrappingAccessor": {
                    "type": "string",
                    "description": "The client wrapping accessor.\n",
                    "secret": true
                },
                "wrappingTtl": {
                    "type": "string",
                    "description": "The TTL period of the wrapped token.\n"
                }
            },
            "required": [
                "clientToken",
                "leaseDuration",
                "leaseStarted",
                "noParent",
                "numUses",
                "renewable",
                "wrappedToken",
                "wrappingAccessor"
            ],
            "inputProperties": {
                "displayName": {
                    "type": "string",
                    "description": "String containing the token display name\n",
                    "willReplaceOnChanges": true
                },
                "explicitMaxTtl": {
                    "type": "string",
                    "description": "The explicit max TTL of this token. This is specified as a numeric string with suffix like \"30s\" ro \"5m\"\n",
                    "willReplaceOnChanges": true
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Metadata to be set on this token\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "noDefaultPolicy": {
                    "type": "boolean",
                    "description": "Flag to not attach the default policy to this token\n",
                    "willReplaceOnChanges": true
                },
                "noParent": {
                    "type": "boolean",
                    "description": "Flag to create a token without parent\n",
                    "willReplaceOnChanges": true
                },
                "numUses": {
                    "type": "integer",
                    "description": "The number of allowed uses of this token\n",
                    "willReplaceOnChanges": true
                },
                "period": {
                    "type": "string",
                    "description": "The period of this token. This is specified as a numeric string with suffix like \"30s\" ro \"5m\"\n",
                    "willReplaceOnChanges": true
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to attach to this token\n",
                    "willReplaceOnChanges": true
                },
                "renewIncrement": {
                    "type": "integer",
                    "description": "The renew increment. This is specified in seconds\n"
                },
                "renewMinLease": {
                    "type": "integer",
                    "description": "The minimal lease to renew this token\n"
                },
                "renewable": {
                    "type": "boolean",
                    "description": "Flag to allow to renew this token\n",
                    "willReplaceOnChanges": true
                },
                "roleName": {
                    "type": "string",
                    "description": "The token role name\n",
                    "willReplaceOnChanges": true
                },
                "ttl": {
                    "type": "string",
                    "description": "The TTL period of this token. This is specified as a numeric string with suffix like \"30s\" ro \"5m\"\n",
                    "willReplaceOnChanges": true
                },
                "wrappingTtl": {
                    "type": "string",
                    "description": "The TTL period of the wrapped token.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Token resources.\n",
                "properties": {
                    "clientToken": {
                        "type": "string",
                        "description": "String containing the client token if stored in present file\n",
                        "secret": true
                    },
                    "displayName": {
                        "type": "string",
                        "description": "String containing the token display name\n",
                        "willReplaceOnChanges": true
                    },
                    "explicitMaxTtl": {
                        "type": "string",
                        "description": "The explicit max TTL of this token. This is specified as a numeric string with suffix like \"30s\" ro \"5m\"\n",
                        "willReplaceOnChanges": true
                    },
                    "leaseDuration": {
                        "type": "integer",
                        "description": "String containing the token lease duration if present in state file\n"
                    },
                    "leaseStarted": {
                        "type": "string",
                        "description": "String containing the token lease started time if present in state file\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Metadata to be set on this token\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "noDefaultPolicy": {
                        "type": "boolean",
                        "description": "Flag to not attach the default policy to this token\n",
                        "willReplaceOnChanges": true
                    },
                    "noParent": {
                        "type": "boolean",
                        "description": "Flag to create a token without parent\n",
                        "willReplaceOnChanges": true
                    },
                    "numUses": {
                        "type": "integer",
                        "description": "The number of allowed uses of this token\n",
                        "willReplaceOnChanges": true
                    },
                    "period": {
                        "type": "string",
                        "description": "The period of this token. This is specified as a numeric string with suffix like \"30s\" ro \"5m\"\n",
                        "willReplaceOnChanges": true
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to attach to this token\n",
                        "willReplaceOnChanges": true
                    },
                    "renewIncrement": {
                        "type": "integer",
                        "description": "The renew increment. This is specified in seconds\n"
                    },
                    "renewMinLease": {
                        "type": "integer",
                        "description": "The minimal lease to renew this token\n"
                    },
                    "renewable": {
                        "type": "boolean",
                        "description": "Flag to allow to renew this token\n",
                        "willReplaceOnChanges": true
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The token role name\n",
                        "willReplaceOnChanges": true
                    },
                    "ttl": {
                        "type": "string",
                        "description": "The TTL period of this token. This is specified as a numeric string with suffix like \"30s\" ro \"5m\"\n",
                        "willReplaceOnChanges": true
                    },
                    "wrappedToken": {
                        "type": "string",
                        "description": "The client wrapped token.\n",
                        "secret": true
                    },
                    "wrappingAccessor": {
                        "type": "string",
                        "description": "The client wrapping accessor.\n",
                        "secret": true
                    },
                    "wrappingTtl": {
                        "type": "string",
                        "description": "The TTL period of the wrapped token.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:jwt/authBackend:AuthBackend": {
            "description": "Provides a resource for managing an\n[JWT auth backend within Vault](https://www.vaultproject.io/docs/auth/jwt.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nManage JWT auth backend:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.jwt.AuthBackend(\"example\", {\n    boundIssuer: \"https://myco.auth0.com/\",\n    description: \"Demonstration of the Terraform JWT auth backend\",\n    oidcDiscoveryUrl: \"https://myco.auth0.com/\",\n    path: \"jwt\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.jwt.AuthBackend(\"example\",\n    bound_issuer=\"https://myco.auth0.com/\",\n    description=\"Demonstration of the Terraform JWT auth backend\",\n    oidc_discovery_url=\"https://myco.auth0.com/\",\n    path=\"jwt\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Vault.Jwt.AuthBackend(\"example\", new()\n    {\n        BoundIssuer = \"https://myco.auth0.com/\",\n        Description = \"Demonstration of the Terraform JWT auth backend\",\n        OidcDiscoveryUrl = \"https://myco.auth0.com/\",\n        Path = \"jwt\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/jwt\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := jwt.NewAuthBackend(ctx, \"example\", \u0026jwt.AuthBackendArgs{\n\t\t\tBoundIssuer:      pulumi.String(\"https://myco.auth0.com/\"),\n\t\t\tDescription:      pulumi.String(\"Demonstration of the Terraform JWT auth backend\"),\n\t\t\tOidcDiscoveryUrl: pulumi.String(\"https://myco.auth0.com/\"),\n\t\t\tPath:             pulumi.String(\"jwt\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.jwt.AuthBackend;\nimport com.pulumi.vault.jwt.AuthBackendArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new AuthBackend(\"example\", AuthBackendArgs.builder()        \n            .boundIssuer(\"https://myco.auth0.com/\")\n            .description(\"Demonstration of the Terraform JWT auth backend\")\n            .oidcDiscoveryUrl(\"https://myco.auth0.com/\")\n            .path(\"jwt\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: vault:jwt:AuthBackend\n    properties:\n      boundIssuer: https://myco.auth0.com/\n      description: Demonstration of the Terraform JWT auth backend\n      oidcDiscoveryUrl: https://myco.auth0.com/\n      path: jwt\n```\n\nManage OIDC auth backend:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.jwt.AuthBackend(\"example\", {\n    boundIssuer: \"https://myco.auth0.com/\",\n    description: \"Demonstration of the Terraform JWT auth backend\",\n    oidcClientId: \"1234567890\",\n    oidcClientSecret: \"secret123456\",\n    oidcDiscoveryUrl: \"https://myco.auth0.com/\",\n    path: \"oidc\",\n    tune: {\n        listingVisibility: \"unauth\",\n    },\n    type: \"oidc\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.jwt.AuthBackend(\"example\",\n    bound_issuer=\"https://myco.auth0.com/\",\n    description=\"Demonstration of the Terraform JWT auth backend\",\n    oidc_client_id=\"1234567890\",\n    oidc_client_secret=\"secret123456\",\n    oidc_discovery_url=\"https://myco.auth0.com/\",\n    path=\"oidc\",\n    tune=vault.jwt.AuthBackendTuneArgs(\n        listing_visibility=\"unauth\",\n    ),\n    type=\"oidc\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Vault.Jwt.AuthBackend(\"example\", new()\n    {\n        BoundIssuer = \"https://myco.auth0.com/\",\n        Description = \"Demonstration of the Terraform JWT auth backend\",\n        OidcClientId = \"1234567890\",\n        OidcClientSecret = \"secret123456\",\n        OidcDiscoveryUrl = \"https://myco.auth0.com/\",\n        Path = \"oidc\",\n        Tune = new Vault.Jwt.Inputs.AuthBackendTuneArgs\n        {\n            ListingVisibility = \"unauth\",\n        },\n        Type = \"oidc\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/jwt\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := jwt.NewAuthBackend(ctx, \"example\", \u0026jwt.AuthBackendArgs{\n\t\t\tBoundIssuer:      pulumi.String(\"https://myco.auth0.com/\"),\n\t\t\tDescription:      pulumi.String(\"Demonstration of the Terraform JWT auth backend\"),\n\t\t\tOidcClientId:     pulumi.String(\"1234567890\"),\n\t\t\tOidcClientSecret: pulumi.String(\"secret123456\"),\n\t\t\tOidcDiscoveryUrl: pulumi.String(\"https://myco.auth0.com/\"),\n\t\t\tPath:             pulumi.String(\"oidc\"),\n\t\t\tTune: \u0026jwt.AuthBackendTuneArgs{\n\t\t\t\tListingVisibility: pulumi.String(\"unauth\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"oidc\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.jwt.AuthBackend;\nimport com.pulumi.vault.jwt.AuthBackendArgs;\nimport com.pulumi.vault.jwt.inputs.AuthBackendTuneArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new AuthBackend(\"example\", AuthBackendArgs.builder()        \n            .boundIssuer(\"https://myco.auth0.com/\")\n            .description(\"Demonstration of the Terraform JWT auth backend\")\n            .oidcClientId(\"1234567890\")\n            .oidcClientSecret(\"secret123456\")\n            .oidcDiscoveryUrl(\"https://myco.auth0.com/\")\n            .path(\"oidc\")\n            .tune(AuthBackendTuneArgs.builder()\n                .listingVisibility(\"unauth\")\n                .build())\n            .type(\"oidc\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: vault:jwt:AuthBackend\n    properties:\n      boundIssuer: https://myco.auth0.com/\n      description: Demonstration of the Terraform JWT auth backend\n      oidcClientId: 1234567890\n      oidcClientSecret: secret123456\n      oidcDiscoveryUrl: https://myco.auth0.com/\n      path: oidc\n      tune:\n        listingVisibility: unauth\n      type: oidc\n```\n\nConfiguring the auth backend with a `provider_config:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst gsuite = new vault.jwt.AuthBackend(\"gsuite\", {\n    description: \"OIDC backend\",\n    oidcDiscoveryUrl: \"https://accounts.google.com\",\n    path: \"oidc\",\n    providerConfig: {\n        fetch_groups: true,\n        fetch_user_info: true,\n        groups_recurse_max_depth: 1,\n        provider: \"gsuite\",\n    },\n    type: \"oidc\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ngsuite = vault.jwt.AuthBackend(\"gsuite\",\n    description=\"OIDC backend\",\n    oidc_discovery_url=\"https://accounts.google.com\",\n    path=\"oidc\",\n    provider_config={\n        \"fetch_groups\": \"true\",\n        \"fetch_user_info\": \"true\",\n        \"groups_recurse_max_depth\": \"1\",\n        \"provider\": \"gsuite\",\n    },\n    type=\"oidc\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var gsuite = new Vault.Jwt.AuthBackend(\"gsuite\", new()\n    {\n        Description = \"OIDC backend\",\n        OidcDiscoveryUrl = \"https://accounts.google.com\",\n        Path = \"oidc\",\n        ProviderConfig = \n        {\n            { \"fetch_groups\", \"true\" },\n            { \"fetch_user_info\", \"true\" },\n            { \"groups_recurse_max_depth\", \"1\" },\n            { \"provider\", \"gsuite\" },\n        },\n        Type = \"oidc\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/jwt\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := jwt.NewAuthBackend(ctx, \"gsuite\", \u0026jwt.AuthBackendArgs{\n\t\t\tDescription:      pulumi.String(\"OIDC backend\"),\n\t\t\tOidcDiscoveryUrl: pulumi.String(\"https://accounts.google.com\"),\n\t\t\tPath:             pulumi.String(\"oidc\"),\n\t\t\tProviderConfig: pulumi.StringMap{\n\t\t\t\t\"fetch_groups\":             pulumi.String(\"true\"),\n\t\t\t\t\"fetch_user_info\":          pulumi.String(\"true\"),\n\t\t\t\t\"groups_recurse_max_depth\": pulumi.String(\"1\"),\n\t\t\t\t\"provider\":                 pulumi.String(\"gsuite\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"oidc\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.jwt.AuthBackend;\nimport com.pulumi.vault.jwt.AuthBackendArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var gsuite = new AuthBackend(\"gsuite\", AuthBackendArgs.builder()        \n            .description(\"OIDC backend\")\n            .oidcDiscoveryUrl(\"https://accounts.google.com\")\n            .path(\"oidc\")\n            .providerConfig(Map.ofEntries(\n                Map.entry(\"fetch_groups\", true),\n                Map.entry(\"fetch_user_info\", true),\n                Map.entry(\"groups_recurse_max_depth\", 1),\n                Map.entry(\"provider\", \"gsuite\")\n            ))\n            .type(\"oidc\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  gsuite:\n    type: vault:jwt:AuthBackend\n    properties:\n      description: OIDC backend\n      oidcDiscoveryUrl: https://accounts.google.com\n      path: oidc\n      providerConfig:\n        fetch_groups: true\n        fetch_user_info: true\n        groups_recurse_max_depth: 1\n        provider: gsuite\n      type: oidc\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nJWT auth backend can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:jwt/authBackend:AuthBackend oidc oidc\n```\n\n or\n\n```sh\n $ pulumi import vault:jwt/authBackend:AuthBackend jwt jwt\n```\n\n ",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The accessor for this auth method\n"
                },
                "boundIssuer": {
                    "type": "string",
                    "description": "The value against which to match the iss claim in a JWT\n"
                },
                "defaultRole": {
                    "type": "string",
                    "description": "The default role to use if none is provided during login\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the auth backend\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "jwksCaPem": {
                    "type": "string",
                    "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the JWKS URL. If not set, system certificates are used.\n"
                },
                "jwksUrl": {
                    "type": "string",
                    "description": "JWKS URL to use to authenticate signatures. Cannot be used with \"oidc_discovery_url\" or \"jwt_validation_pubkeys\".\n"
                },
                "jwtSupportedAlgs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of supported signing algorithms. Vault 1.1.0 defaults to [RS256] but future or past versions of Vault may differ\n"
                },
                "jwtValidationPubkeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of PEM-encoded public keys to use to authenticate signatures locally. Cannot be used in combination with `oidc_discovery_url`\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the auth method is local only.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "namespaceInState": {
                    "type": "boolean",
                    "description": "Pass namespace in the OIDC state parameter instead of as a separate query parameter. With this setting, the allowed redirect URL(s) in Vault and on the provider side should not contain a namespace query parameter. This means only one redirect URL entry needs to be maintained on the OIDC provider side for all vault namespaces that will be authenticating against it. Defaults to true for new configs\n"
                },
                "oidcClientId": {
                    "type": "string",
                    "description": "Client ID used for OIDC backends\n"
                },
                "oidcClientSecret": {
                    "type": "string",
                    "description": "Client Secret used for OIDC backends\n",
                    "secret": true
                },
                "oidcDiscoveryCaPem": {
                    "type": "string",
                    "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the OIDC Discovery URL. If not set, system certificates are used\n"
                },
                "oidcDiscoveryUrl": {
                    "type": "string",
                    "description": "The OIDC Discovery URL, without any .well-known component (base path). Cannot be used in combination with `jwt_validation_pubkeys`\n"
                },
                "oidcResponseMode": {
                    "type": "string",
                    "description": "The response mode to be used in the OAuth2 request. Allowed values are `query` and `form_post`. Defaults to `query`. If using Vault namespaces, and `oidc_response_mode` is `form_post`, then `namespace_in_state` should be set to `false`.\n"
                },
                "oidcResponseTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of response types to request. Allowed values are 'code' and 'id_token'. Defaults to `[\"code\"]`. Note: `id_token` may only be used if `oidc_response_mode` is set to `form_post`.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to mount the JWT/OIDC auth backend\n"
                },
                "providerConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Provider specific handling configuration. All values may be strings, and the provider will convert to the appropriate type when configuring Vault.\n"
                },
                "tune": {
                    "$ref": "#/types/vault:jwt/AuthBackendTune:AuthBackendTune"
                },
                "type": {
                    "type": "string",
                    "description": "Type of auth backend. Should be one of `jwt` or `oidc`. Default - `jwt`\n"
                }
            },
            "required": [
                "accessor",
                "tune"
            ],
            "inputProperties": {
                "boundIssuer": {
                    "type": "string",
                    "description": "The value against which to match the iss claim in a JWT\n"
                },
                "defaultRole": {
                    "type": "string",
                    "description": "The default role to use if none is provided during login\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the auth backend\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "jwksCaPem": {
                    "type": "string",
                    "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the JWKS URL. If not set, system certificates are used.\n"
                },
                "jwksUrl": {
                    "type": "string",
                    "description": "JWKS URL to use to authenticate signatures. Cannot be used with \"oidc_discovery_url\" or \"jwt_validation_pubkeys\".\n"
                },
                "jwtSupportedAlgs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of supported signing algorithms. Vault 1.1.0 defaults to [RS256] but future or past versions of Vault may differ\n"
                },
                "jwtValidationPubkeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of PEM-encoded public keys to use to authenticate signatures locally. Cannot be used in combination with `oidc_discovery_url`\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the auth method is local only.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "namespaceInState": {
                    "type": "boolean",
                    "description": "Pass namespace in the OIDC state parameter instead of as a separate query parameter. With this setting, the allowed redirect URL(s) in Vault and on the provider side should not contain a namespace query parameter. This means only one redirect URL entry needs to be maintained on the OIDC provider side for all vault namespaces that will be authenticating against it. Defaults to true for new configs\n"
                },
                "oidcClientId": {
                    "type": "string",
                    "description": "Client ID used for OIDC backends\n"
                },
                "oidcClientSecret": {
                    "type": "string",
                    "description": "Client Secret used for OIDC backends\n",
                    "secret": true
                },
                "oidcDiscoveryCaPem": {
                    "type": "string",
                    "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the OIDC Discovery URL. If not set, system certificates are used\n"
                },
                "oidcDiscoveryUrl": {
                    "type": "string",
                    "description": "The OIDC Discovery URL, without any .well-known component (base path). Cannot be used in combination with `jwt_validation_pubkeys`\n"
                },
                "oidcResponseMode": {
                    "type": "string",
                    "description": "The response mode to be used in the OAuth2 request. Allowed values are `query` and `form_post`. Defaults to `query`. If using Vault namespaces, and `oidc_response_mode` is `form_post`, then `namespace_in_state` should be set to `false`.\n"
                },
                "oidcResponseTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of response types to request. Allowed values are 'code' and 'id_token'. Defaults to `[\"code\"]`. Note: `id_token` may only be used if `oidc_response_mode` is set to `form_post`.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to mount the JWT/OIDC auth backend\n"
                },
                "providerConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Provider specific handling configuration. All values may be strings, and the provider will convert to the appropriate type when configuring Vault.\n"
                },
                "tune": {
                    "$ref": "#/types/vault:jwt/AuthBackendTune:AuthBackendTune"
                },
                "type": {
                    "type": "string",
                    "description": "Type of auth backend. Should be one of `jwt` or `oidc`. Default - `jwt`\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackend resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The accessor for this auth method\n"
                    },
                    "boundIssuer": {
                        "type": "string",
                        "description": "The value against which to match the iss claim in a JWT\n"
                    },
                    "defaultRole": {
                        "type": "string",
                        "description": "The default role to use if none is provided during login\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the auth backend\n"
                    },
                    "disableRemount": {
                        "type": "boolean",
                        "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                    },
                    "jwksCaPem": {
                        "type": "string",
                        "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the JWKS URL. If not set, system certificates are used.\n"
                    },
                    "jwksUrl": {
                        "type": "string",
                        "description": "JWKS URL to use to authenticate signatures. Cannot be used with \"oidc_discovery_url\" or \"jwt_validation_pubkeys\".\n"
                    },
                    "jwtSupportedAlgs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of supported signing algorithms. Vault 1.1.0 defaults to [RS256] but future or past versions of Vault may differ\n"
                    },
                    "jwtValidationPubkeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of PEM-encoded public keys to use to authenticate signatures locally. Cannot be used in combination with `oidc_discovery_url`\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Specifies if the auth method is local only.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespaceInState": {
                        "type": "boolean",
                        "description": "Pass namespace in the OIDC state parameter instead of as a separate query parameter. With this setting, the allowed redirect URL(s) in Vault and on the provider side should not contain a namespace query parameter. This means only one redirect URL entry needs to be maintained on the OIDC provider side for all vault namespaces that will be authenticating against it. Defaults to true for new configs\n"
                    },
                    "oidcClientId": {
                        "type": "string",
                        "description": "Client ID used for OIDC backends\n"
                    },
                    "oidcClientSecret": {
                        "type": "string",
                        "description": "Client Secret used for OIDC backends\n",
                        "secret": true
                    },
                    "oidcDiscoveryCaPem": {
                        "type": "string",
                        "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the OIDC Discovery URL. If not set, system certificates are used\n"
                    },
                    "oidcDiscoveryUrl": {
                        "type": "string",
                        "description": "The OIDC Discovery URL, without any .well-known component (base path). Cannot be used in combination with `jwt_validation_pubkeys`\n"
                    },
                    "oidcResponseMode": {
                        "type": "string",
                        "description": "The response mode to be used in the OAuth2 request. Allowed values are `query` and `form_post`. Defaults to `query`. If using Vault namespaces, and `oidc_response_mode` is `form_post`, then `namespace_in_state` should be set to `false`.\n"
                    },
                    "oidcResponseTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of response types to request. Allowed values are 'code' and 'id_token'. Defaults to `[\"code\"]`. Note: `id_token` may only be used if `oidc_response_mode` is set to `form_post`.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Path to mount the JWT/OIDC auth backend\n"
                    },
                    "providerConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Provider specific handling configuration. All values may be strings, and the provider will convert to the appropriate type when configuring Vault.\n"
                    },
                    "tune": {
                        "$ref": "#/types/vault:jwt/AuthBackendTune:AuthBackendTune"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of auth backend. Should be one of `jwt` or `oidc`. Default - `jwt`\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:jwt/authBackendRole:AuthBackendRole": {
            "description": "Manages an JWT/OIDC auth backend role in a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/jwt.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nRole for JWT backend:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst jwt = new vault.jwt.AuthBackend(\"jwt\", {path: \"jwt\"});\nconst example = new vault.jwt.AuthBackendRole(\"example\", {\n    backend: jwt.path,\n    roleName: \"test-role\",\n    tokenPolicies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    boundAudiences: [\"https://myco.test\"],\n    boundClaims: {\n        color: \"red,green,blue\",\n    },\n    userClaim: \"https://vault/user\",\n    roleType: \"jwt\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\njwt = vault.jwt.AuthBackend(\"jwt\", path=\"jwt\")\nexample = vault.jwt.AuthBackendRole(\"example\",\n    backend=jwt.path,\n    role_name=\"test-role\",\n    token_policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    bound_audiences=[\"https://myco.test\"],\n    bound_claims={\n        \"color\": \"red,green,blue\",\n    },\n    user_claim=\"https://vault/user\",\n    role_type=\"jwt\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var jwt = new Vault.Jwt.AuthBackend(\"jwt\", new()\n    {\n        Path = \"jwt\",\n    });\n\n    var example = new Vault.Jwt.AuthBackendRole(\"example\", new()\n    {\n        Backend = jwt.Path,\n        RoleName = \"test-role\",\n        TokenPolicies = new[]\n        {\n            \"default\",\n            \"dev\",\n            \"prod\",\n        },\n        BoundAudiences = new[]\n        {\n            \"https://myco.test\",\n        },\n        BoundClaims = \n        {\n            { \"color\", \"red,green,blue\" },\n        },\n        UserClaim = \"https://vault/user\",\n        RoleType = \"jwt\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/jwt\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tjwt, err := jwt.NewAuthBackend(ctx, \"jwt\", \u0026jwt.AuthBackendArgs{\n\t\t\tPath: pulumi.String(\"jwt\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = jwt.NewAuthBackendRole(ctx, \"example\", \u0026jwt.AuthBackendRoleArgs{\n\t\t\tBackend:  jwt.Path,\n\t\t\tRoleName: pulumi.String(\"test-role\"),\n\t\t\tTokenPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t\tBoundAudiences: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"https://myco.test\"),\n\t\t\t},\n\t\t\tBoundClaims: pulumi.AnyMap{\n\t\t\t\t\"color\": pulumi.Any(\"red,green,blue\"),\n\t\t\t},\n\t\t\tUserClaim: pulumi.String(\"https://vault/user\"),\n\t\t\tRoleType:  pulumi.String(\"jwt\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.jwt.AuthBackend;\nimport com.pulumi.vault.jwt.AuthBackendArgs;\nimport com.pulumi.vault.jwt.AuthBackendRole;\nimport com.pulumi.vault.jwt.AuthBackendRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var jwt = new AuthBackend(\"jwt\", AuthBackendArgs.builder()        \n            .path(\"jwt\")\n            .build());\n\n        var example = new AuthBackendRole(\"example\", AuthBackendRoleArgs.builder()        \n            .backend(jwt.path())\n            .roleName(\"test-role\")\n            .tokenPolicies(            \n                \"default\",\n                \"dev\",\n                \"prod\")\n            .boundAudiences(\"https://myco.test\")\n            .boundClaims(Map.of(\"color\", \"red,green,blue\"))\n            .userClaim(\"https://vault/user\")\n            .roleType(\"jwt\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  jwt:\n    type: vault:jwt:AuthBackend\n    properties:\n      path: jwt\n  example:\n    type: vault:jwt:AuthBackendRole\n    properties:\n      backend: ${jwt.path}\n      roleName: test-role\n      tokenPolicies:\n        - default\n        - dev\n        - prod\n      boundAudiences:\n        - https://myco.test\n      boundClaims:\n        color: red,green,blue\n      userClaim: https://vault/user\n      roleType: jwt\n```\n\nRole for OIDC backend:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst oidc = new vault.jwt.AuthBackend(\"oidc\", {\n    path: \"oidc\",\n    defaultRole: \"test-role\",\n});\nconst example = new vault.jwt.AuthBackendRole(\"example\", {\n    backend: oidc.path,\n    roleName: \"test-role\",\n    tokenPolicies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    userClaim: \"https://vault/user\",\n    roleType: \"oidc\",\n    allowedRedirectUris: [\"http://localhost:8200/ui/vault/auth/oidc/oidc/callback\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\noidc = vault.jwt.AuthBackend(\"oidc\",\n    path=\"oidc\",\n    default_role=\"test-role\")\nexample = vault.jwt.AuthBackendRole(\"example\",\n    backend=oidc.path,\n    role_name=\"test-role\",\n    token_policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    user_claim=\"https://vault/user\",\n    role_type=\"oidc\",\n    allowed_redirect_uris=[\"http://localhost:8200/ui/vault/auth/oidc/oidc/callback\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var oidc = new Vault.Jwt.AuthBackend(\"oidc\", new()\n    {\n        Path = \"oidc\",\n        DefaultRole = \"test-role\",\n    });\n\n    var example = new Vault.Jwt.AuthBackendRole(\"example\", new()\n    {\n        Backend = oidc.Path,\n        RoleName = \"test-role\",\n        TokenPolicies = new[]\n        {\n            \"default\",\n            \"dev\",\n            \"prod\",\n        },\n        UserClaim = \"https://vault/user\",\n        RoleType = \"oidc\",\n        AllowedRedirectUris = new[]\n        {\n            \"http://localhost:8200/ui/vault/auth/oidc/oidc/callback\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/jwt\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\toidc, err := jwt.NewAuthBackend(ctx, \"oidc\", \u0026jwt.AuthBackendArgs{\n\t\t\tPath:        pulumi.String(\"oidc\"),\n\t\t\tDefaultRole: pulumi.String(\"test-role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = jwt.NewAuthBackendRole(ctx, \"example\", \u0026jwt.AuthBackendRoleArgs{\n\t\t\tBackend:  oidc.Path,\n\t\t\tRoleName: pulumi.String(\"test-role\"),\n\t\t\tTokenPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t\tUserClaim: pulumi.String(\"https://vault/user\"),\n\t\t\tRoleType:  pulumi.String(\"oidc\"),\n\t\t\tAllowedRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8200/ui/vault/auth/oidc/oidc/callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.jwt.AuthBackend;\nimport com.pulumi.vault.jwt.AuthBackendArgs;\nimport com.pulumi.vault.jwt.AuthBackendRole;\nimport com.pulumi.vault.jwt.AuthBackendRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var oidc = new AuthBackend(\"oidc\", AuthBackendArgs.builder()        \n            .path(\"oidc\")\n            .defaultRole(\"test-role\")\n            .build());\n\n        var example = new AuthBackendRole(\"example\", AuthBackendRoleArgs.builder()        \n            .backend(oidc.path())\n            .roleName(\"test-role\")\n            .tokenPolicies(            \n                \"default\",\n                \"dev\",\n                \"prod\")\n            .userClaim(\"https://vault/user\")\n            .roleType(\"oidc\")\n            .allowedRedirectUris(\"http://localhost:8200/ui/vault/auth/oidc/oidc/callback\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  oidc:\n    type: vault:jwt:AuthBackend\n    properties:\n      path: oidc\n      defaultRole: test-role\n  example:\n    type: vault:jwt:AuthBackendRole\n    properties:\n      backend: ${oidc.path}\n      roleName: test-role\n      tokenPolicies:\n        - default\n        - dev\n        - prod\n      userClaim: https://vault/user\n      roleType: oidc\n      allowedRedirectUris:\n        - http://localhost:8200/ui/vault/auth/oidc/oidc/callback\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nJWT authentication backend roles can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:jwt/authBackendRole:AuthBackendRole example auth/jwt/role/test-role\n```\n\n ",
            "properties": {
                "allowedRedirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of allowed values for redirect_uri during OIDC logins.\nRequired for OIDC roles\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique name of the auth backend to configure.\nDefaults to `jwt`.\n"
                },
                "boundAudiences": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(For \"jwt\" roles, at least one of `bound_audiences`, `bound_subject`, `bound_claims`\nor `token_bound_cidrs` is required. Optional for \"oidc\" roles.) List of `aud` claims to match against.\nAny match is sufficient.\n"
                },
                "boundClaims": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "If set, a map of claims to values to match against.\nA claim's value must be a string, which may contain one value or multiple\ncomma-separated values, e.g. `\"red\"` or `\"red,green,blue\"`.\n"
                },
                "boundClaimsType": {
                    "type": "string",
                    "description": "How to interpret values in the claims/values\nmap (`bound_claims`): can be either `string` (exact match) or `glob` (wildcard\nmatch). Requires Vault 1.4.0 or above.\n"
                },
                "boundSubject": {
                    "type": "string",
                    "description": "If set, requires that the `sub` claim matches\nthis value.\n"
                },
                "claimMappings": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "If set, a map of claims (keys) to be copied\nto specified metadata fields (values).\n"
                },
                "clockSkewLeeway": {
                    "type": "integer",
                    "description": "The amount of leeway to add to all claims to account for clock skew, in\nseconds. Defaults to `60` seconds if set to `0` and can be disabled if set to `-1`.\nOnly applicable with \"jwt\" roles.\n"
                },
                "disableBoundClaimsParsing": {
                    "type": "boolean",
                    "description": "Disable bound claim value parsing. Useful when values contain commas.\n"
                },
                "expirationLeeway": {
                    "type": "integer",
                    "description": "The amount of leeway to add to expiration (`exp`) claims to account for\nclock skew, in seconds. Defaults to `60` seconds if set to `0` and can be disabled if set to `-1`.\nOnly applicable with \"jwt\" roles.\n"
                },
                "groupsClaim": {
                    "type": "string",
                    "description": "The claim to use to uniquely identify\nthe set of groups to which the user belongs; this will be used as the names\nfor the Identity group aliases created due to a successful login. The claim\nvalue must be a list of strings.\n"
                },
                "maxAge": {
                    "type": "integer",
                    "description": "Specifies the allowable elapsed time in seconds since the last time \nthe user was actively authenticated with the OIDC provider.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "notBeforeLeeway": {
                    "type": "integer",
                    "description": "The amount of leeway to add to not before (`nbf`) claims to account for\nclock skew, in seconds. Defaults to `60` seconds if set to `0` and can be disabled if set to `-1`.\nOnly applicable with \"jwt\" roles.\n"
                },
                "oidcScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, a list of OIDC scopes to be used with an OIDC role.\nThe standard scope \"openid\" is automatically included and need not be specified.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "roleType": {
                    "type": "string",
                    "description": "Type of role, either \"oidc\" (default) or \"jwt\".\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The [maximum number](https://www.vaultproject.io/api-docs/jwt#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                },
                "userClaim": {
                    "type": "string",
                    "description": "The claim to use to uniquely identify\nthe user; this will be used as the name for the Identity entity alias created\ndue to a successful login.\n"
                },
                "userClaimJsonPointer": {
                    "type": "boolean",
                    "description": "Specifies if the `user_claim` value uses\n[JSON pointer](https://www.vaultproject.io/docs/auth/jwt#claim-specifications-and-json-pointer)\nsyntax for referencing claims. By default, the `user_claim` value will not use JSON pointer.\nRequires Vault 1.11+.\n"
                },
                "verboseOidcLogging": {
                    "type": "boolean",
                    "description": "Log received OIDC tokens and claims when debug-level\nlogging is active. Not recommended in production since sensitive information may be present\nin OIDC responses.\n"
                }
            },
            "required": [
                "boundClaimsType",
                "roleName",
                "roleType",
                "userClaim"
            ],
            "inputProperties": {
                "allowedRedirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of allowed values for redirect_uri during OIDC logins.\nRequired for OIDC roles\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique name of the auth backend to configure.\nDefaults to `jwt`.\n",
                    "willReplaceOnChanges": true
                },
                "boundAudiences": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(For \"jwt\" roles, at least one of `bound_audiences`, `bound_subject`, `bound_claims`\nor `token_bound_cidrs` is required. Optional for \"oidc\" roles.) List of `aud` claims to match against.\nAny match is sufficient.\n"
                },
                "boundClaims": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "If set, a map of claims to values to match against.\nA claim's value must be a string, which may contain one value or multiple\ncomma-separated values, e.g. `\"red\"` or `\"red,green,blue\"`.\n"
                },
                "boundClaimsType": {
                    "type": "string",
                    "description": "How to interpret values in the claims/values\nmap (`bound_claims`): can be either `string` (exact match) or `glob` (wildcard\nmatch). Requires Vault 1.4.0 or above.\n"
                },
                "boundSubject": {
                    "type": "string",
                    "description": "If set, requires that the `sub` claim matches\nthis value.\n"
                },
                "claimMappings": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "If set, a map of claims (keys) to be copied\nto specified metadata fields (values).\n"
                },
                "clockSkewLeeway": {
                    "type": "integer",
                    "description": "The amount of leeway to add to all claims to account for clock skew, in\nseconds. Defaults to `60` seconds if set to `0` and can be disabled if set to `-1`.\nOnly applicable with \"jwt\" roles.\n"
                },
                "disableBoundClaimsParsing": {
                    "type": "boolean",
                    "description": "Disable bound claim value parsing. Useful when values contain commas.\n"
                },
                "expirationLeeway": {
                    "type": "integer",
                    "description": "The amount of leeway to add to expiration (`exp`) claims to account for\nclock skew, in seconds. Defaults to `60` seconds if set to `0` and can be disabled if set to `-1`.\nOnly applicable with \"jwt\" roles.\n"
                },
                "groupsClaim": {
                    "type": "string",
                    "description": "The claim to use to uniquely identify\nthe set of groups to which the user belongs; this will be used as the names\nfor the Identity group aliases created due to a successful login. The claim\nvalue must be a list of strings.\n"
                },
                "maxAge": {
                    "type": "integer",
                    "description": "Specifies the allowable elapsed time in seconds since the last time \nthe user was actively authenticated with the OIDC provider.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "notBeforeLeeway": {
                    "type": "integer",
                    "description": "The amount of leeway to add to not before (`nbf`) claims to account for\nclock skew, in seconds. Defaults to `60` seconds if set to `0` and can be disabled if set to `-1`.\nOnly applicable with \"jwt\" roles.\n"
                },
                "oidcScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, a list of OIDC scopes to be used with an OIDC role.\nThe standard scope \"openid\" is automatically included and need not be specified.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role.\n",
                    "willReplaceOnChanges": true
                },
                "roleType": {
                    "type": "string",
                    "description": "Type of role, either \"oidc\" (default) or \"jwt\".\n",
                    "willReplaceOnChanges": true
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The [maximum number](https://www.vaultproject.io/api-docs/jwt#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                },
                "userClaim": {
                    "type": "string",
                    "description": "The claim to use to uniquely identify\nthe user; this will be used as the name for the Identity entity alias created\ndue to a successful login.\n"
                },
                "userClaimJsonPointer": {
                    "type": "boolean",
                    "description": "Specifies if the `user_claim` value uses\n[JSON pointer](https://www.vaultproject.io/docs/auth/jwt#claim-specifications-and-json-pointer)\nsyntax for referencing claims. By default, the `user_claim` value will not use JSON pointer.\nRequires Vault 1.11+.\n"
                },
                "verboseOidcLogging": {
                    "type": "boolean",
                    "description": "Log received OIDC tokens and claims when debug-level\nlogging is active. Not recommended in production since sensitive information may be present\nin OIDC responses.\n"
                }
            },
            "requiredInputs": [
                "roleName",
                "userClaim"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "allowedRedirectUris": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of allowed values for redirect_uri during OIDC logins.\nRequired for OIDC roles\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The unique name of the auth backend to configure.\nDefaults to `jwt`.\n",
                        "willReplaceOnChanges": true
                    },
                    "boundAudiences": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(For \"jwt\" roles, at least one of `bound_audiences`, `bound_subject`, `bound_claims`\nor `token_bound_cidrs` is required. Optional for \"oidc\" roles.) List of `aud` claims to match against.\nAny match is sufficient.\n"
                    },
                    "boundClaims": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "If set, a map of claims to values to match against.\nA claim's value must be a string, which may contain one value or multiple\ncomma-separated values, e.g. `\"red\"` or `\"red,green,blue\"`.\n"
                    },
                    "boundClaimsType": {
                        "type": "string",
                        "description": "How to interpret values in the claims/values\nmap (`bound_claims`): can be either `string` (exact match) or `glob` (wildcard\nmatch). Requires Vault 1.4.0 or above.\n"
                    },
                    "boundSubject": {
                        "type": "string",
                        "description": "If set, requires that the `sub` claim matches\nthis value.\n"
                    },
                    "claimMappings": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "If set, a map of claims (keys) to be copied\nto specified metadata fields (values).\n"
                    },
                    "clockSkewLeeway": {
                        "type": "integer",
                        "description": "The amount of leeway to add to all claims to account for clock skew, in\nseconds. Defaults to `60` seconds if set to `0` and can be disabled if set to `-1`.\nOnly applicable with \"jwt\" roles.\n"
                    },
                    "disableBoundClaimsParsing": {
                        "type": "boolean",
                        "description": "Disable bound claim value parsing. Useful when values contain commas.\n"
                    },
                    "expirationLeeway": {
                        "type": "integer",
                        "description": "The amount of leeway to add to expiration (`exp`) claims to account for\nclock skew, in seconds. Defaults to `60` seconds if set to `0` and can be disabled if set to `-1`.\nOnly applicable with \"jwt\" roles.\n"
                    },
                    "groupsClaim": {
                        "type": "string",
                        "description": "The claim to use to uniquely identify\nthe set of groups to which the user belongs; this will be used as the names\nfor the Identity group aliases created due to a successful login. The claim\nvalue must be a list of strings.\n"
                    },
                    "maxAge": {
                        "type": "integer",
                        "description": "Specifies the allowable elapsed time in seconds since the last time \nthe user was actively authenticated with the OIDC provider.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "notBeforeLeeway": {
                        "type": "integer",
                        "description": "The amount of leeway to add to not before (`nbf`) claims to account for\nclock skew, in seconds. Defaults to `60` seconds if set to `0` and can be disabled if set to `-1`.\nOnly applicable with \"jwt\" roles.\n"
                    },
                    "oidcScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, a list of OIDC scopes to be used with an OIDC role.\nThe standard scope \"openid\" is automatically included and need not be specified.\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role.\n",
                        "willReplaceOnChanges": true
                    },
                    "roleType": {
                        "type": "string",
                        "description": "Type of role, either \"oidc\" (default) or \"jwt\".\n",
                        "willReplaceOnChanges": true
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The [maximum number](https://www.vaultproject.io/api-docs/jwt#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    },
                    "userClaim": {
                        "type": "string",
                        "description": "The claim to use to uniquely identify\nthe user; this will be used as the name for the Identity entity alias created\ndue to a successful login.\n"
                    },
                    "userClaimJsonPointer": {
                        "type": "boolean",
                        "description": "Specifies if the `user_claim` value uses\n[JSON pointer](https://www.vaultproject.io/docs/auth/jwt#claim-specifications-and-json-pointer)\nsyntax for referencing claims. By default, the `user_claim` value will not use JSON pointer.\nRequires Vault 1.11+.\n"
                    },
                    "verboseOidcLogging": {
                        "type": "boolean",
                        "description": "Log received OIDC tokens and claims when debug-level\nlogging is active. Not recommended in production since sensitive information may be present\nin OIDC responses.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:kmip/secretBackend:SecretBackend": {
            "description": "Manages KMIP Secret backends in a Vault server. This feature requires\nVault Enterprise. See the [Vault documentation](https://www.vaultproject.io/docs/secrets/kmip)\nfor more information.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst defaultSecretBackend = new vault.kmip.SecretBackend(\"default\", {\n    defaultTlsClientKeyBits: 4096,\n    defaultTlsClientKeyType: \"rsa\",\n    defaultTlsClientTtl: 86400,\n    description: \"Vault KMIP backend\",\n    listenAddrs: [\n        \"127.0.0.1:5696\",\n        \"127.0.0.1:8080\",\n    ],\n    path: \"kmip\",\n    tlsCaKeyBits: 4096,\n    tlsCaKeyType: \"rsa\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ndefault = vault.kmip.SecretBackend(\"default\",\n    default_tls_client_key_bits=4096,\n    default_tls_client_key_type=\"rsa\",\n    default_tls_client_ttl=86400,\n    description=\"Vault KMIP backend\",\n    listen_addrs=[\n        \"127.0.0.1:5696\",\n        \"127.0.0.1:8080\",\n    ],\n    path=\"kmip\",\n    tls_ca_key_bits=4096,\n    tls_ca_key_type=\"rsa\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @default = new Vault.Kmip.SecretBackend(\"default\", new()\n    {\n        DefaultTlsClientKeyBits = 4096,\n        DefaultTlsClientKeyType = \"rsa\",\n        DefaultTlsClientTtl = 86400,\n        Description = \"Vault KMIP backend\",\n        ListenAddrs = new[]\n        {\n            \"127.0.0.1:5696\",\n            \"127.0.0.1:8080\",\n        },\n        Path = \"kmip\",\n        TlsCaKeyBits = 4096,\n        TlsCaKeyType = \"rsa\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/kmip\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := kmip.NewSecretBackend(ctx, \"default\", \u0026kmip.SecretBackendArgs{\n\t\t\tDefaultTlsClientKeyBits: pulumi.Int(4096),\n\t\t\tDefaultTlsClientKeyType: pulumi.String(\"rsa\"),\n\t\t\tDefaultTlsClientTtl:     pulumi.Int(86400),\n\t\t\tDescription:             pulumi.String(\"Vault KMIP backend\"),\n\t\t\tListenAddrs: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"127.0.0.1:5696\"),\n\t\t\t\tpulumi.String(\"127.0.0.1:8080\"),\n\t\t\t},\n\t\t\tPath:         pulumi.String(\"kmip\"),\n\t\t\tTlsCaKeyBits: pulumi.Int(4096),\n\t\t\tTlsCaKeyType: pulumi.String(\"rsa\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.kmip.SecretBackend;\nimport com.pulumi.vault.kmip.SecretBackendArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var default_ = new SecretBackend(\"default\", SecretBackendArgs.builder()        \n            .defaultTlsClientKeyBits(4096)\n            .defaultTlsClientKeyType(\"rsa\")\n            .defaultTlsClientTtl(86400)\n            .description(\"Vault KMIP backend\")\n            .listenAddrs(            \n                \"127.0.0.1:5696\",\n                \"127.0.0.1:8080\")\n            .path(\"kmip\")\n            .tlsCaKeyBits(4096)\n            .tlsCaKeyType(\"rsa\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  default:\n    type: vault:kmip:SecretBackend\n    properties:\n      defaultTlsClientKeyBits: 4096\n      defaultTlsClientKeyType: rsa\n      defaultTlsClientTtl: 86400\n      description: Vault KMIP backend\n      listenAddrs:\n        - 127.0.0.1:5696\n        - 127.0.0.1:8080\n      path: kmip\n      tlsCaKeyBits: 4096\n      tlsCaKeyType: rsa\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nKMIP Secret backend can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:kmip/secretBackend:SecretBackend default kmip\n```\n\n ",
            "properties": {
                "defaultTlsClientKeyBits": {
                    "type": "integer",
                    "description": "Client certificate key bits, valid values depend on key type.\n"
                },
                "defaultTlsClientKeyType": {
                    "type": "string",
                    "description": "Client certificate key type, `rsa` or `ec`.\n"
                },
                "defaultTlsClientTtl": {
                    "type": "integer",
                    "description": "Client certificate TTL in seconds\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "listenAddrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Addresses the KMIP server should listen on (`host:port`).\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `kmip`.\n"
                },
                "serverHostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Hostnames to include in the server's TLS certificate as SAN DNS names. The first will be used as the common name (CN).\n"
                },
                "serverIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IPs to include in the server's TLS certificate as SAN IP addresses.\n"
                },
                "tlsCaKeyBits": {
                    "type": "integer",
                    "description": "CA key bits, valid values depend on key type.\n"
                },
                "tlsCaKeyType": {
                    "type": "string",
                    "description": "CA key type, rsa or ec.\n"
                },
                "tlsMinVersion": {
                    "type": "string",
                    "description": "Minimum TLS version to accept.\n"
                }
            },
            "required": [
                "defaultTlsClientKeyBits",
                "defaultTlsClientKeyType",
                "defaultTlsClientTtl",
                "listenAddrs",
                "path",
                "serverHostnames",
                "serverIps",
                "tlsCaKeyBits",
                "tlsCaKeyType",
                "tlsMinVersion"
            ],
            "inputProperties": {
                "defaultTlsClientKeyBits": {
                    "type": "integer",
                    "description": "Client certificate key bits, valid values depend on key type.\n"
                },
                "defaultTlsClientKeyType": {
                    "type": "string",
                    "description": "Client certificate key type, `rsa` or `ec`.\n"
                },
                "defaultTlsClientTtl": {
                    "type": "integer",
                    "description": "Client certificate TTL in seconds\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "listenAddrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Addresses the KMIP server should listen on (`host:port`).\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `kmip`.\n"
                },
                "serverHostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Hostnames to include in the server's TLS certificate as SAN DNS names. The first will be used as the common name (CN).\n"
                },
                "serverIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IPs to include in the server's TLS certificate as SAN IP addresses.\n"
                },
                "tlsCaKeyBits": {
                    "type": "integer",
                    "description": "CA key bits, valid values depend on key type.\n"
                },
                "tlsCaKeyType": {
                    "type": "string",
                    "description": "CA key type, rsa or ec.\n"
                },
                "tlsMinVersion": {
                    "type": "string",
                    "description": "Minimum TLS version to accept.\n"
                }
            },
            "requiredInputs": [
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackend resources.\n",
                "properties": {
                    "defaultTlsClientKeyBits": {
                        "type": "integer",
                        "description": "Client certificate key bits, valid values depend on key type.\n"
                    },
                    "defaultTlsClientKeyType": {
                        "type": "string",
                        "description": "Client certificate key type, `rsa` or `ec`.\n"
                    },
                    "defaultTlsClientTtl": {
                        "type": "integer",
                        "description": "Client certificate TTL in seconds\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A human-friendly description for this backend.\n"
                    },
                    "disableRemount": {
                        "type": "boolean",
                        "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                    },
                    "listenAddrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Addresses the KMIP server should listen on (`host:port`).\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `kmip`.\n"
                    },
                    "serverHostnames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Hostnames to include in the server's TLS certificate as SAN DNS names. The first will be used as the common name (CN).\n"
                    },
                    "serverIps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "IPs to include in the server's TLS certificate as SAN IP addresses.\n"
                    },
                    "tlsCaKeyBits": {
                        "type": "integer",
                        "description": "CA key bits, valid values depend on key type.\n"
                    },
                    "tlsCaKeyType": {
                        "type": "string",
                        "description": "CA key type, rsa or ec.\n"
                    },
                    "tlsMinVersion": {
                        "type": "string",
                        "description": "Minimum TLS version to accept.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:kmip/secretRole:SecretRole": {
            "description": "Manages KMIP Secret roles in a Vault server. This feature requires\nVault Enterprise. See the [Vault documentation](https://www.vaultproject.io/docs/secrets/kmip)\nfor more information.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst _default = new vault.kmip.SecretBackend(\"default\", {\n    path: \"kmip\",\n    description: \"Vault KMIP backend\",\n});\nconst dev = new vault.kmip.SecretScope(\"dev\", {\n    path: _default.path,\n    scope: \"dev\",\n    force: true,\n});\nconst admin = new vault.kmip.SecretRole(\"admin\", {\n    path: dev.path,\n    scope: dev.scope,\n    role: \"admin\",\n    tlsClientKeyType: \"ec\",\n    tlsClientKeyBits: 256,\n    operationActivate: true,\n    operationGet: true,\n    operationGetAttributes: true,\n    operationCreate: true,\n    operationDestroy: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ndefault = vault.kmip.SecretBackend(\"default\",\n    path=\"kmip\",\n    description=\"Vault KMIP backend\")\ndev = vault.kmip.SecretScope(\"dev\",\n    path=default.path,\n    scope=\"dev\",\n    force=True)\nadmin = vault.kmip.SecretRole(\"admin\",\n    path=dev.path,\n    scope=dev.scope,\n    role=\"admin\",\n    tls_client_key_type=\"ec\",\n    tls_client_key_bits=256,\n    operation_activate=True,\n    operation_get=True,\n    operation_get_attributes=True,\n    operation_create=True,\n    operation_destroy=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @default = new Vault.Kmip.SecretBackend(\"default\", new()\n    {\n        Path = \"kmip\",\n        Description = \"Vault KMIP backend\",\n    });\n\n    var dev = new Vault.Kmip.SecretScope(\"dev\", new()\n    {\n        Path = @default.Path,\n        Scope = \"dev\",\n        Force = true,\n    });\n\n    var admin = new Vault.Kmip.SecretRole(\"admin\", new()\n    {\n        Path = dev.Path,\n        Scope = dev.Scope,\n        Role = \"admin\",\n        TlsClientKeyType = \"ec\",\n        TlsClientKeyBits = 256,\n        OperationActivate = true,\n        OperationGet = true,\n        OperationGetAttributes = true,\n        OperationCreate = true,\n        OperationDestroy = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/kmip\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := kmip.NewSecretBackend(ctx, \"default\", \u0026kmip.SecretBackendArgs{\n\t\t\tPath:        pulumi.String(\"kmip\"),\n\t\t\tDescription: pulumi.String(\"Vault KMIP backend\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdev, err := kmip.NewSecretScope(ctx, \"dev\", \u0026kmip.SecretScopeArgs{\n\t\t\tPath:  _default.Path,\n\t\t\tScope: pulumi.String(\"dev\"),\n\t\t\tForce: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = kmip.NewSecretRole(ctx, \"admin\", \u0026kmip.SecretRoleArgs{\n\t\t\tPath:                   dev.Path,\n\t\t\tScope:                  dev.Scope,\n\t\t\tRole:                   pulumi.String(\"admin\"),\n\t\t\tTlsClientKeyType:       pulumi.String(\"ec\"),\n\t\t\tTlsClientKeyBits:       pulumi.Int(256),\n\t\t\tOperationActivate:      pulumi.Bool(true),\n\t\t\tOperationGet:           pulumi.Bool(true),\n\t\t\tOperationGetAttributes: pulumi.Bool(true),\n\t\t\tOperationCreate:        pulumi.Bool(true),\n\t\t\tOperationDestroy:       pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.kmip.SecretBackend;\nimport com.pulumi.vault.kmip.SecretBackendArgs;\nimport com.pulumi.vault.kmip.SecretScope;\nimport com.pulumi.vault.kmip.SecretScopeArgs;\nimport com.pulumi.vault.kmip.SecretRole;\nimport com.pulumi.vault.kmip.SecretRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var default_ = new SecretBackend(\"default\", SecretBackendArgs.builder()        \n            .path(\"kmip\")\n            .description(\"Vault KMIP backend\")\n            .build());\n\n        var dev = new SecretScope(\"dev\", SecretScopeArgs.builder()        \n            .path(default_.path())\n            .scope(\"dev\")\n            .force(true)\n            .build());\n\n        var admin = new SecretRole(\"admin\", SecretRoleArgs.builder()        \n            .path(dev.path())\n            .scope(dev.scope())\n            .role(\"admin\")\n            .tlsClientKeyType(\"ec\")\n            .tlsClientKeyBits(256)\n            .operationActivate(true)\n            .operationGet(true)\n            .operationGetAttributes(true)\n            .operationCreate(true)\n            .operationDestroy(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  default:\n    type: vault:kmip:SecretBackend\n    properties:\n      path: kmip\n      description: Vault KMIP backend\n  dev:\n    type: vault:kmip:SecretScope\n    properties:\n      path: ${default.path}\n      scope: dev\n      force: true\n  admin:\n    type: vault:kmip:SecretRole\n    properties:\n      path: ${dev.path}\n      scope: ${dev.scope}\n      role: admin\n      tlsClientKeyType: ec\n      tlsClientKeyBits: 256\n      operationActivate: true\n      operationGet: true\n      operationGetAttributes: true\n      operationCreate: true\n      operationDestroy: true\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nKMIP Secret role can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:kmip/secretRole:SecretRole admin kmip\n```\n\n ",
            "properties": {
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "operationActivate": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Activate operation.\n"
                },
                "operationAddAttribute": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Add Attribute operation.\n"
                },
                "operationAll": {
                    "type": "boolean",
                    "description": "Grant all permissions to this role. May not be specified with any other `operation_*` params.\n"
                },
                "operationCreate": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Create operation.\n"
                },
                "operationDestroy": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Destroy operation.\n"
                },
                "operationDiscoverVersions": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Discover Version operation.\n"
                },
                "operationGet": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Get operation.\n"
                },
                "operationGetAttributeList": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Get Atrribute List operation.\n"
                },
                "operationGetAttributes": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Get Atrributes operation.\n"
                },
                "operationLocate": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Get Locate operation.\n"
                },
                "operationNone": {
                    "type": "boolean",
                    "description": "Remove all permissions from this role. May not be specified with any other `operation_*` params.\n"
                },
                "operationRegister": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Register operation.\n"
                },
                "operationRekey": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Rekey operation.\n"
                },
                "operationRevoke": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Revoke operation.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `kmip`.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the role.\n"
                },
                "scope": {
                    "type": "string",
                    "description": "Name of the scope.\n"
                },
                "tlsClientKeyBits": {
                    "type": "integer",
                    "description": "Client certificate key bits, valid values depend on key type.\n"
                },
                "tlsClientKeyType": {
                    "type": "string",
                    "description": "Client certificate key type, `rsa` or `ec`.\n"
                },
                "tlsClientTtl": {
                    "type": "integer",
                    "description": "Client certificate TTL in seconds.\n"
                }
            },
            "required": [
                "operationActivate",
                "operationAddAttribute",
                "operationAll",
                "operationCreate",
                "operationDestroy",
                "operationDiscoverVersions",
                "operationGet",
                "operationGetAttributeList",
                "operationGetAttributes",
                "operationLocate",
                "operationNone",
                "operationRegister",
                "operationRekey",
                "operationRevoke",
                "path",
                "role",
                "scope"
            ],
            "inputProperties": {
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "operationActivate": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Activate operation.\n"
                },
                "operationAddAttribute": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Add Attribute operation.\n"
                },
                "operationAll": {
                    "type": "boolean",
                    "description": "Grant all permissions to this role. May not be specified with any other `operation_*` params.\n"
                },
                "operationCreate": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Create operation.\n"
                },
                "operationDestroy": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Destroy operation.\n"
                },
                "operationDiscoverVersions": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Discover Version operation.\n"
                },
                "operationGet": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Get operation.\n"
                },
                "operationGetAttributeList": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Get Atrribute List operation.\n"
                },
                "operationGetAttributes": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Get Atrributes operation.\n"
                },
                "operationLocate": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Get Locate operation.\n"
                },
                "operationNone": {
                    "type": "boolean",
                    "description": "Remove all permissions from this role. May not be specified with any other `operation_*` params.\n"
                },
                "operationRegister": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Register operation.\n"
                },
                "operationRekey": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Rekey operation.\n"
                },
                "operationRevoke": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Revoke operation.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `kmip`.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the role.\n",
                    "willReplaceOnChanges": true
                },
                "scope": {
                    "type": "string",
                    "description": "Name of the scope.\n",
                    "willReplaceOnChanges": true
                },
                "tlsClientKeyBits": {
                    "type": "integer",
                    "description": "Client certificate key bits, valid values depend on key type.\n"
                },
                "tlsClientKeyType": {
                    "type": "string",
                    "description": "Client certificate key type, `rsa` or `ec`.\n"
                },
                "tlsClientTtl": {
                    "type": "integer",
                    "description": "Client certificate TTL in seconds.\n"
                }
            },
            "requiredInputs": [
                "path",
                "role",
                "scope"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretRole resources.\n",
                "properties": {
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "operationActivate": {
                        "type": "boolean",
                        "description": "Grant permission to use the KMIP Activate operation.\n"
                    },
                    "operationAddAttribute": {
                        "type": "boolean",
                        "description": "Grant permission to use the KMIP Add Attribute operation.\n"
                    },
                    "operationAll": {
                        "type": "boolean",
                        "description": "Grant all permissions to this role. May not be specified with any other `operation_*` params.\n"
                    },
                    "operationCreate": {
                        "type": "boolean",
                        "description": "Grant permission to use the KMIP Create operation.\n"
                    },
                    "operationDestroy": {
                        "type": "boolean",
                        "description": "Grant permission to use the KMIP Destroy operation.\n"
                    },
                    "operationDiscoverVersions": {
                        "type": "boolean",
                        "description": "Grant permission to use the KMIP Discover Version operation.\n"
                    },
                    "operationGet": {
                        "type": "boolean",
                        "description": "Grant permission to use the KMIP Get operation.\n"
                    },
                    "operationGetAttributeList": {
                        "type": "boolean",
                        "description": "Grant permission to use the KMIP Get Atrribute List operation.\n"
                    },
                    "operationGetAttributes": {
                        "type": "boolean",
                        "description": "Grant permission to use the KMIP Get Atrributes operation.\n"
                    },
                    "operationLocate": {
                        "type": "boolean",
                        "description": "Grant permission to use the KMIP Get Locate operation.\n"
                    },
                    "operationNone": {
                        "type": "boolean",
                        "description": "Remove all permissions from this role. May not be specified with any other `operation_*` params.\n"
                    },
                    "operationRegister": {
                        "type": "boolean",
                        "description": "Grant permission to use the KMIP Register operation.\n"
                    },
                    "operationRekey": {
                        "type": "boolean",
                        "description": "Grant permission to use the KMIP Rekey operation.\n"
                    },
                    "operationRevoke": {
                        "type": "boolean",
                        "description": "Grant permission to use the KMIP Revoke operation.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `kmip`.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "Name of the role.\n",
                        "willReplaceOnChanges": true
                    },
                    "scope": {
                        "type": "string",
                        "description": "Name of the scope.\n",
                        "willReplaceOnChanges": true
                    },
                    "tlsClientKeyBits": {
                        "type": "integer",
                        "description": "Client certificate key bits, valid values depend on key type.\n"
                    },
                    "tlsClientKeyType": {
                        "type": "string",
                        "description": "Client certificate key type, `rsa` or `ec`.\n"
                    },
                    "tlsClientTtl": {
                        "type": "integer",
                        "description": "Client certificate TTL in seconds.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:kmip/secretScope:SecretScope": {
            "description": "Manages KMIP Secret Scopes in a Vault server. This feature requires\nVault Enterprise. See the [Vault documentation](https://www.vaultproject.io/docs/secrets/kmip)\nfor more information.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst _default = new vault.kmip.SecretBackend(\"default\", {\n    path: \"kmip\",\n    description: \"Vault KMIP backend\",\n});\nconst dev = new vault.kmip.SecretScope(\"dev\", {\n    path: _default.path,\n    scope: \"dev\",\n    force: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ndefault = vault.kmip.SecretBackend(\"default\",\n    path=\"kmip\",\n    description=\"Vault KMIP backend\")\ndev = vault.kmip.SecretScope(\"dev\",\n    path=default.path,\n    scope=\"dev\",\n    force=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @default = new Vault.Kmip.SecretBackend(\"default\", new()\n    {\n        Path = \"kmip\",\n        Description = \"Vault KMIP backend\",\n    });\n\n    var dev = new Vault.Kmip.SecretScope(\"dev\", new()\n    {\n        Path = @default.Path,\n        Scope = \"dev\",\n        Force = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/kmip\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := kmip.NewSecretBackend(ctx, \"default\", \u0026kmip.SecretBackendArgs{\n\t\t\tPath:        pulumi.String(\"kmip\"),\n\t\t\tDescription: pulumi.String(\"Vault KMIP backend\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = kmip.NewSecretScope(ctx, \"dev\", \u0026kmip.SecretScopeArgs{\n\t\t\tPath:  _default.Path,\n\t\t\tScope: pulumi.String(\"dev\"),\n\t\t\tForce: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.kmip.SecretBackend;\nimport com.pulumi.vault.kmip.SecretBackendArgs;\nimport com.pulumi.vault.kmip.SecretScope;\nimport com.pulumi.vault.kmip.SecretScopeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var default_ = new SecretBackend(\"default\", SecretBackendArgs.builder()        \n            .path(\"kmip\")\n            .description(\"Vault KMIP backend\")\n            .build());\n\n        var dev = new SecretScope(\"dev\", SecretScopeArgs.builder()        \n            .path(default_.path())\n            .scope(\"dev\")\n            .force(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  default:\n    type: vault:kmip:SecretBackend\n    properties:\n      path: kmip\n      description: Vault KMIP backend\n  dev:\n    type: vault:kmip:SecretScope\n    properties:\n      path: ${default.path}\n      scope: dev\n      force: true\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nKMIP Secret scope can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:kmip/secretScope:SecretScope dev kmip\n```\n\n ",
            "properties": {
                "force": {
                    "type": "boolean",
                    "description": "Boolean field to force deletion even if there are managed objects in the scope.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `kmip`.\n"
                },
                "scope": {
                    "type": "string",
                    "description": "Name of the scope.\n"
                }
            },
            "required": [
                "path",
                "scope"
            ],
            "inputProperties": {
                "force": {
                    "type": "boolean",
                    "description": "Boolean field to force deletion even if there are managed objects in the scope.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `kmip`.\n"
                },
                "scope": {
                    "type": "string",
                    "description": "Name of the scope.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "path",
                "scope"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretScope resources.\n",
                "properties": {
                    "force": {
                        "type": "boolean",
                        "description": "Boolean field to force deletion even if there are managed objects in the scope.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `kmip`.\n"
                    },
                    "scope": {
                        "type": "string",
                        "description": "Name of the scope.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:kubernetes/authBackendConfig:AuthBackendConfig": {
            "description": "Manages an Kubernetes auth backend config in a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/kubernetes.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst kubernetes = new vault.AuthBackend(\"kubernetes\", {type: \"kubernetes\"});\nconst example = new vault.kubernetes.AuthBackendConfig(\"example\", {\n    backend: kubernetes.path,\n    kubernetesHost: \"http://example.com:443\",\n    kubernetesCaCert: `-----BEGIN CERTIFICATE-----\nexample\n-----END CERTIFICATE-----`,\n    tokenReviewerJwt: \"ZXhhbXBsZQo=\",\n    issuer: \"api\",\n    disableIssValidation: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nkubernetes = vault.AuthBackend(\"kubernetes\", type=\"kubernetes\")\nexample = vault.kubernetes.AuthBackendConfig(\"example\",\n    backend=kubernetes.path,\n    kubernetes_host=\"http://example.com:443\",\n    kubernetes_ca_cert=\"\"\"-----BEGIN CERTIFICATE-----\nexample\n-----END CERTIFICATE-----\"\"\",\n    token_reviewer_jwt=\"ZXhhbXBsZQo=\",\n    issuer=\"api\",\n    disable_iss_validation=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var kubernetes = new Vault.AuthBackend(\"kubernetes\", new()\n    {\n        Type = \"kubernetes\",\n    });\n\n    var example = new Vault.Kubernetes.AuthBackendConfig(\"example\", new()\n    {\n        Backend = kubernetes.Path,\n        KubernetesHost = \"http://example.com:443\",\n        KubernetesCaCert = @\"-----BEGIN CERTIFICATE-----\nexample\n-----END CERTIFICATE-----\",\n        TokenReviewerJwt = \"ZXhhbXBsZQo=\",\n        Issuer = \"api\",\n        DisableIssValidation = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/kubernetes\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tkubernetes, err := vault.NewAuthBackend(ctx, \"kubernetes\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"kubernetes\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = kubernetes.NewAuthBackendConfig(ctx, \"example\", \u0026kubernetes.AuthBackendConfigArgs{\n\t\t\tBackend:              kubernetes.Path,\n\t\t\tKubernetesHost:       pulumi.String(\"http://example.com:443\"),\n\t\t\tKubernetesCaCert:     pulumi.String(\"-----BEGIN CERTIFICATE-----\\nexample\\n-----END CERTIFICATE-----\"),\n\t\t\tTokenReviewerJwt:     pulumi.String(\"ZXhhbXBsZQo=\"),\n\t\t\tIssuer:               pulumi.String(\"api\"),\n\t\t\tDisableIssValidation: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.AuthBackend;\nimport com.pulumi.vault.AuthBackendArgs;\nimport com.pulumi.vault.kubernetes.AuthBackendConfig;\nimport com.pulumi.vault.kubernetes.AuthBackendConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var kubernetes = new AuthBackend(\"kubernetes\", AuthBackendArgs.builder()        \n            .type(\"kubernetes\")\n            .build());\n\n        var example = new AuthBackendConfig(\"example\", AuthBackendConfigArgs.builder()        \n            .backend(kubernetes.path())\n            .kubernetesHost(\"http://example.com:443\")\n            .kubernetesCaCert(\"\"\"\n-----BEGIN CERTIFICATE-----\nexample\n-----END CERTIFICATE-----            \"\"\")\n            .tokenReviewerJwt(\"ZXhhbXBsZQo=\")\n            .issuer(\"api\")\n            .disableIssValidation(\"true\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  kubernetes:\n    type: vault:AuthBackend\n    properties:\n      type: kubernetes\n  example:\n    type: vault:kubernetes:AuthBackendConfig\n    properties:\n      backend: ${kubernetes.path}\n      kubernetesHost: http://example.com:443\n      kubernetesCaCert: |-\n        -----BEGIN CERTIFICATE-----\n        example\n        -----END CERTIFICATE-----\n      tokenReviewerJwt: ZXhhbXBsZQo=\n      issuer: api\n      disableIssValidation: true\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nKubernetes authentication backend can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:kubernetes/authBackendConfig:AuthBackendConfig config auth/kubernetes/config\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Unique name of the kubernetes backend to configure.\n"
                },
                "disableIssValidation": {
                    "type": "boolean",
                    "description": "Disable JWT issuer validation. Allows to skip ISS validation. Requires Vault `v1.5.4+` or Vault auth kubernetes plugin `v0.7.1+`\n"
                },
                "disableLocalCaJwt": {
                    "type": "boolean",
                    "description": "Disable defaulting to the local CA cert and service account JWT when running in a Kubernetes pod. Requires Vault `v1.5.4+` or Vault auth kubernetes plugin `v0.7.1+`\n"
                },
                "issuer": {
                    "type": "string",
                    "description": "JWT issuer. If no issuer is specified, `kubernetes.io/serviceaccount` will be used as the default issuer.\n"
                },
                "kubernetesCaCert": {
                    "type": "string",
                    "description": "PEM encoded CA cert for use by the TLS client used to talk with the Kubernetes API.\n"
                },
                "kubernetesHost": {
                    "type": "string",
                    "description": "Host must be a host string, a host:port pair, or a URL to the base of the Kubernetes API server.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n"
                },
                "pemKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of PEM-formatted public keys or certificates used to verify the signatures of Kubernetes service account JWTs. If a certificate is given, its public key will be extracted. Not every installation of Kubernetes exposes these keys.\n"
                },
                "tokenReviewerJwt": {
                    "type": "string",
                    "description": "A service account JWT used to access the TokenReview API to validate other JWTs during login. If not set the JWT used for login will be used to access the API.\n",
                    "secret": true
                }
            },
            "required": [
                "disableIssValidation",
                "disableLocalCaJwt",
                "kubernetesCaCert",
                "kubernetesHost"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Unique name of the kubernetes backend to configure.\n",
                    "willReplaceOnChanges": true
                },
                "disableIssValidation": {
                    "type": "boolean",
                    "description": "Disable JWT issuer validation. Allows to skip ISS validation. Requires Vault `v1.5.4+` or Vault auth kubernetes plugin `v0.7.1+`\n"
                },
                "disableLocalCaJwt": {
                    "type": "boolean",
                    "description": "Disable defaulting to the local CA cert and service account JWT when running in a Kubernetes pod. Requires Vault `v1.5.4+` or Vault auth kubernetes plugin `v0.7.1+`\n"
                },
                "issuer": {
                    "type": "string",
                    "description": "JWT issuer. If no issuer is specified, `kubernetes.io/serviceaccount` will be used as the default issuer.\n"
                },
                "kubernetesCaCert": {
                    "type": "string",
                    "description": "PEM encoded CA cert for use by the TLS client used to talk with the Kubernetes API.\n"
                },
                "kubernetesHost": {
                    "type": "string",
                    "description": "Host must be a host string, a host:port pair, or a URL to the base of the Kubernetes API server.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "pemKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of PEM-formatted public keys or certificates used to verify the signatures of Kubernetes service account JWTs. If a certificate is given, its public key will be extracted. Not every installation of Kubernetes exposes these keys.\n"
                },
                "tokenReviewerJwt": {
                    "type": "string",
                    "description": "A service account JWT used to access the TokenReview API to validate other JWTs during login. If not set the JWT used for login will be used to access the API.\n",
                    "secret": true
                }
            },
            "requiredInputs": [
                "kubernetesHost"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendConfig resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Unique name of the kubernetes backend to configure.\n",
                        "willReplaceOnChanges": true
                    },
                    "disableIssValidation": {
                        "type": "boolean",
                        "description": "Disable JWT issuer validation. Allows to skip ISS validation. Requires Vault `v1.5.4+` or Vault auth kubernetes plugin `v0.7.1+`\n"
                    },
                    "disableLocalCaJwt": {
                        "type": "boolean",
                        "description": "Disable defaulting to the local CA cert and service account JWT when running in a Kubernetes pod. Requires Vault `v1.5.4+` or Vault auth kubernetes plugin `v0.7.1+`\n"
                    },
                    "issuer": {
                        "type": "string",
                        "description": "JWT issuer. If no issuer is specified, `kubernetes.io/serviceaccount` will be used as the default issuer.\n"
                    },
                    "kubernetesCaCert": {
                        "type": "string",
                        "description": "PEM encoded CA cert for use by the TLS client used to talk with the Kubernetes API.\n"
                    },
                    "kubernetesHost": {
                        "type": "string",
                        "description": "Host must be a host string, a host:port pair, or a URL to the base of the Kubernetes API server.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "pemKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of PEM-formatted public keys or certificates used to verify the signatures of Kubernetes service account JWTs. If a certificate is given, its public key will be extracted. Not every installation of Kubernetes exposes these keys.\n"
                    },
                    "tokenReviewerJwt": {
                        "type": "string",
                        "description": "A service account JWT used to access the TokenReview API to validate other JWTs during login. If not set the JWT used for login will be used to access the API.\n",
                        "secret": true
                    }
                },
                "type": "object"
            }
        },
        "vault:kubernetes/authBackendRole:AuthBackendRole": {
            "description": "Manages an Kubernetes auth backend role in a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/kubernetes.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst kubernetes = new vault.AuthBackend(\"kubernetes\", {type: \"kubernetes\"});\nconst example = new vault.kubernetes.AuthBackendRole(\"example\", {\n    backend: kubernetes.path,\n    roleName: \"example-role\",\n    boundServiceAccountNames: [\"example\"],\n    boundServiceAccountNamespaces: [\"example\"],\n    tokenTtl: 3600,\n    tokenPolicies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    audience: \"vault\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nkubernetes = vault.AuthBackend(\"kubernetes\", type=\"kubernetes\")\nexample = vault.kubernetes.AuthBackendRole(\"example\",\n    backend=kubernetes.path,\n    role_name=\"example-role\",\n    bound_service_account_names=[\"example\"],\n    bound_service_account_namespaces=[\"example\"],\n    token_ttl=3600,\n    token_policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    audience=\"vault\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var kubernetes = new Vault.AuthBackend(\"kubernetes\", new()\n    {\n        Type = \"kubernetes\",\n    });\n\n    var example = new Vault.Kubernetes.AuthBackendRole(\"example\", new()\n    {\n        Backend = kubernetes.Path,\n        RoleName = \"example-role\",\n        BoundServiceAccountNames = new[]\n        {\n            \"example\",\n        },\n        BoundServiceAccountNamespaces = new[]\n        {\n            \"example\",\n        },\n        TokenTtl = 3600,\n        TokenPolicies = new[]\n        {\n            \"default\",\n            \"dev\",\n            \"prod\",\n        },\n        Audience = \"vault\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/kubernetes\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tkubernetes, err := vault.NewAuthBackend(ctx, \"kubernetes\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"kubernetes\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = kubernetes.NewAuthBackendRole(ctx, \"example\", \u0026kubernetes.AuthBackendRoleArgs{\n\t\t\tBackend:  kubernetes.Path,\n\t\t\tRoleName: pulumi.String(\"example-role\"),\n\t\t\tBoundServiceAccountNames: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"example\"),\n\t\t\t},\n\t\t\tBoundServiceAccountNamespaces: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"example\"),\n\t\t\t},\n\t\t\tTokenTtl: pulumi.Int(3600),\n\t\t\tTokenPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t\tAudience: pulumi.String(\"vault\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.AuthBackend;\nimport com.pulumi.vault.AuthBackendArgs;\nimport com.pulumi.vault.kubernetes.AuthBackendRole;\nimport com.pulumi.vault.kubernetes.AuthBackendRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var kubernetes = new AuthBackend(\"kubernetes\", AuthBackendArgs.builder()        \n            .type(\"kubernetes\")\n            .build());\n\n        var example = new AuthBackendRole(\"example\", AuthBackendRoleArgs.builder()        \n            .backend(kubernetes.path())\n            .roleName(\"example-role\")\n            .boundServiceAccountNames(\"example\")\n            .boundServiceAccountNamespaces(\"example\")\n            .tokenTtl(3600)\n            .tokenPolicies(            \n                \"default\",\n                \"dev\",\n                \"prod\")\n            .audience(\"vault\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  kubernetes:\n    type: vault:AuthBackend\n    properties:\n      type: kubernetes\n  example:\n    type: vault:kubernetes:AuthBackendRole\n    properties:\n      backend: ${kubernetes.path}\n      roleName: example-role\n      boundServiceAccountNames:\n        - example\n      boundServiceAccountNamespaces:\n        - example\n      tokenTtl: 3600\n      tokenPolicies:\n        - default\n        - dev\n        - prod\n      audience: vault\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nKubernetes auth backend role can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:kubernetes/authBackendRole:AuthBackendRole foo auth/kubernetes/role/foo\n```\n\n ",
            "properties": {
                "aliasNameSource": {
                    "type": "string",
                    "description": "Configures how identity aliases are generated.\nValid choices are: `serviceaccount_uid`, `serviceaccount_name`. (vault-1.9+)\n"
                },
                "audience": {
                    "type": "string",
                    "description": "Audience claim to verify in the JWT.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Unique name of the kubernetes backend to configure.\n"
                },
                "boundServiceAccountNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of service account names able to access this role. If set to `[\"*\"]` all names are allowed, both this and bound_service_account_namespaces can not be \"*\".\n"
                },
                "boundServiceAccountNamespaces": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of namespaces allowed to access this role. If set to `[\"*\"]` all namespaces are allowed, both this and bound_service_account_names can not be set to \"*\".\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "Name of the role.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The [maximum number](https://www.vaultproject.io/api-docs/kubernetes#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "required": [
                "aliasNameSource",
                "boundServiceAccountNames",
                "boundServiceAccountNamespaces",
                "roleName"
            ],
            "inputProperties": {
                "aliasNameSource": {
                    "type": "string",
                    "description": "Configures how identity aliases are generated.\nValid choices are: `serviceaccount_uid`, `serviceaccount_name`. (vault-1.9+)\n"
                },
                "audience": {
                    "type": "string",
                    "description": "Audience claim to verify in the JWT.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Unique name of the kubernetes backend to configure.\n",
                    "willReplaceOnChanges": true
                },
                "boundServiceAccountNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of service account names able to access this role. If set to `[\"*\"]` all names are allowed, both this and bound_service_account_namespaces can not be \"*\".\n"
                },
                "boundServiceAccountNamespaces": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of namespaces allowed to access this role. If set to `[\"*\"]` all namespaces are allowed, both this and bound_service_account_names can not be set to \"*\".\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "roleName": {
                    "type": "string",
                    "description": "Name of the role.\n",
                    "willReplaceOnChanges": true
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The [maximum number](https://www.vaultproject.io/api-docs/kubernetes#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "requiredInputs": [
                "boundServiceAccountNames",
                "boundServiceAccountNamespaces",
                "roleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "aliasNameSource": {
                        "type": "string",
                        "description": "Configures how identity aliases are generated.\nValid choices are: `serviceaccount_uid`, `serviceaccount_name`. (vault-1.9+)\n"
                    },
                    "audience": {
                        "type": "string",
                        "description": "Audience claim to verify in the JWT.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "Unique name of the kubernetes backend to configure.\n",
                        "willReplaceOnChanges": true
                    },
                    "boundServiceAccountNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of service account names able to access this role. If set to `[\"*\"]` all names are allowed, both this and bound_service_account_namespaces can not be \"*\".\n"
                    },
                    "boundServiceAccountNamespaces": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of namespaces allowed to access this role. If set to `[\"*\"]` all namespaces are allowed, both this and bound_service_account_names can not be set to \"*\".\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "roleName": {
                        "type": "string",
                        "description": "Name of the role.\n",
                        "willReplaceOnChanges": true
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The [maximum number](https://www.vaultproject.io/api-docs/kubernetes#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The initial ttl of the token to generate in seconds\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:kubernetes/secretBackend:SecretBackend": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as fs from \"fs\";\nimport * as vault from \"@pulumi/vault\";\n\nconst config = new vault.kubernetes.SecretBackend(\"config\", {\n    path: \"kubernetes\",\n    description: \"kubernetes secrets engine description\",\n    defaultLeaseTtlSeconds: 43200,\n    maxLeaseTtlSeconds: 86400,\n    kubernetesHost: \"https://127.0.0.1:61233\",\n    kubernetesCaCert: fs.readFileSync(\"/path/to/cert\"),\n    serviceAccountJwt: fs.readFileSync(\"/path/to/token\"),\n    disableLocalCaJwt: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nconfig = vault.kubernetes.SecretBackend(\"config\",\n    path=\"kubernetes\",\n    description=\"kubernetes secrets engine description\",\n    default_lease_ttl_seconds=43200,\n    max_lease_ttl_seconds=86400,\n    kubernetes_host=\"https://127.0.0.1:61233\",\n    kubernetes_ca_cert=(lambda path: open(path).read())(\"/path/to/cert\"),\n    service_account_jwt=(lambda path: open(path).read())(\"/path/to/token\"),\n    disable_local_ca_jwt=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Vault.Kubernetes.SecretBackend(\"config\", new()\n    {\n        Path = \"kubernetes\",\n        Description = \"kubernetes secrets engine description\",\n        DefaultLeaseTtlSeconds = 43200,\n        MaxLeaseTtlSeconds = 86400,\n        KubernetesHost = \"https://127.0.0.1:61233\",\n        KubernetesCaCert = File.ReadAllText(\"/path/to/cert\"),\n        ServiceAccountJwt = File.ReadAllText(\"/path/to/token\"),\n        DisableLocalCaJwt = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/kubernetes\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := kubernetes.NewSecretBackend(ctx, \"config\", \u0026kubernetes.SecretBackendArgs{\n\t\t\tPath:                   pulumi.String(\"kubernetes\"),\n\t\t\tDescription:            pulumi.String(\"kubernetes secrets engine description\"),\n\t\t\tDefaultLeaseTtlSeconds: pulumi.Int(43200),\n\t\t\tMaxLeaseTtlSeconds:     pulumi.Int(86400),\n\t\t\tKubernetesHost:         pulumi.String(\"https://127.0.0.1:61233\"),\n\t\t\tKubernetesCaCert:       readFileOrPanic(\"/path/to/cert\"),\n\t\t\tServiceAccountJwt:      readFileOrPanic(\"/path/to/token\"),\n\t\t\tDisableLocalCaJwt:      pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.kubernetes.SecretBackend;\nimport com.pulumi.vault.kubernetes.SecretBackendArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var config = new SecretBackend(\"config\", SecretBackendArgs.builder()        \n            .path(\"kubernetes\")\n            .description(\"kubernetes secrets engine description\")\n            .defaultLeaseTtlSeconds(43200)\n            .maxLeaseTtlSeconds(86400)\n            .kubernetesHost(\"https://127.0.0.1:61233\")\n            .kubernetesCaCert(Files.readString(Paths.get(\"/path/to/cert\")))\n            .serviceAccountJwt(Files.readString(Paths.get(\"/path/to/token\")))\n            .disableLocalCaJwt(false)\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nThe Kubernetes secret backend can be imported using its `path` e.g.\n\n```sh\n $ pulumi import vault:kubernetes/secretBackend:SecretBackend config kubernetes\n```\n\n ",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "Accessor of the mount\n"
                },
                "allowedManagedKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of managed key registry entry names that the mount in question is allowed to access\n"
                },
                "auditNonHmacRequestKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the request data object.\n"
                },
                "auditNonHmacResponseKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the response data object.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Default lease duration for tokens and secrets in seconds\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount\n"
                },
                "disableLocalCaJwt": {
                    "type": "boolean",
                    "description": "Disable defaulting to the local CA certificate and \nservice account JWT when Vault is running in a Kubernetes pod.\n"
                },
                "externalEntropyAccess": {
                    "type": "boolean",
                    "description": "Enable the secrets engine to access Vault's external entropy source\n"
                },
                "kubernetesCaCert": {
                    "type": "string",
                    "description": "A PEM-encoded CA certificate used by the \nsecrets engine to verify the Kubernetes API server certificate. Defaults to the local\npod’s CA if Vault is running in Kubernetes. Otherwise, defaults to the root CA set where\nVault is running.\n"
                },
                "kubernetesHost": {
                    "type": "string",
                    "description": "The Kubernetes API URL to connect to. Required if the \nstandard pod environment variables `KUBERNETES_SERVICE_HOST` or `KUBERNETES_SERVICE_PORT`\nare not set on the host that Vault is running on.\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Local mount flag that can be explicitly set to true to enforce local mount in HA environment\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Maximum possible lease duration for tokens and secrets in seconds\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "options": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies mount type specific options that are passed to the backend\n"
                },
                "path": {
                    "type": "string",
                    "description": "Where the secret backend will be mounted\n"
                },
                "sealWrap": {
                    "type": "boolean",
                    "description": "Enable seal wrapping for the mount, causing values stored by the mount to be wrapped by the seal's encryption capability\n"
                },
                "serviceAccountJwt": {
                    "type": "string",
                    "description": "The JSON web token of the service account used by the\nsecrets engine to manage Kubernetes credentials. Defaults to the local pod’s JWT if Vault\nis running in Kubernetes.\n",
                    "secret": true
                }
            },
            "required": [
                "accessor",
                "auditNonHmacRequestKeys",
                "auditNonHmacResponseKeys",
                "defaultLeaseTtlSeconds",
                "maxLeaseTtlSeconds",
                "path",
                "sealWrap"
            ],
            "inputProperties": {
                "allowedManagedKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of managed key registry entry names that the mount in question is allowed to access\n",
                    "willReplaceOnChanges": true
                },
                "auditNonHmacRequestKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the request data object.\n"
                },
                "auditNonHmacResponseKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the response data object.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Default lease duration for tokens and secrets in seconds\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount\n"
                },
                "disableLocalCaJwt": {
                    "type": "boolean",
                    "description": "Disable defaulting to the local CA certificate and \nservice account JWT when Vault is running in a Kubernetes pod.\n"
                },
                "externalEntropyAccess": {
                    "type": "boolean",
                    "description": "Enable the secrets engine to access Vault's external entropy source\n",
                    "willReplaceOnChanges": true
                },
                "kubernetesCaCert": {
                    "type": "string",
                    "description": "A PEM-encoded CA certificate used by the \nsecrets engine to verify the Kubernetes API server certificate. Defaults to the local\npod’s CA if Vault is running in Kubernetes. Otherwise, defaults to the root CA set where\nVault is running.\n"
                },
                "kubernetesHost": {
                    "type": "string",
                    "description": "The Kubernetes API URL to connect to. Required if the \nstandard pod environment variables `KUBERNETES_SERVICE_HOST` or `KUBERNETES_SERVICE_PORT`\nare not set on the host that Vault is running on.\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Local mount flag that can be explicitly set to true to enforce local mount in HA environment\n",
                    "willReplaceOnChanges": true
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Maximum possible lease duration for tokens and secrets in seconds\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "options": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies mount type specific options that are passed to the backend\n"
                },
                "path": {
                    "type": "string",
                    "description": "Where the secret backend will be mounted\n"
                },
                "sealWrap": {
                    "type": "boolean",
                    "description": "Enable seal wrapping for the mount, causing values stored by the mount to be wrapped by the seal's encryption capability\n",
                    "willReplaceOnChanges": true
                },
                "serviceAccountJwt": {
                    "type": "string",
                    "description": "The JSON web token of the service account used by the\nsecrets engine to manage Kubernetes credentials. Defaults to the local pod’s JWT if Vault\nis running in Kubernetes.\n",
                    "secret": true
                }
            },
            "requiredInputs": [
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackend resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "Accessor of the mount\n"
                    },
                    "allowedManagedKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of managed key registry entry names that the mount in question is allowed to access\n",
                        "willReplaceOnChanges": true
                    },
                    "auditNonHmacRequestKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the request data object.\n"
                    },
                    "auditNonHmacResponseKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the response data object.\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "Default lease duration for tokens and secrets in seconds\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Human-friendly description of the mount\n"
                    },
                    "disableLocalCaJwt": {
                        "type": "boolean",
                        "description": "Disable defaulting to the local CA certificate and \nservice account JWT when Vault is running in a Kubernetes pod.\n"
                    },
                    "externalEntropyAccess": {
                        "type": "boolean",
                        "description": "Enable the secrets engine to access Vault's external entropy source\n",
                        "willReplaceOnChanges": true
                    },
                    "kubernetesCaCert": {
                        "type": "string",
                        "description": "A PEM-encoded CA certificate used by the \nsecrets engine to verify the Kubernetes API server certificate. Defaults to the local\npod’s CA if Vault is running in Kubernetes. Otherwise, defaults to the root CA set where\nVault is running.\n"
                    },
                    "kubernetesHost": {
                        "type": "string",
                        "description": "The Kubernetes API URL to connect to. Required if the \nstandard pod environment variables `KUBERNETES_SERVICE_HOST` or `KUBERNETES_SERVICE_PORT`\nare not set on the host that Vault is running on.\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Local mount flag that can be explicitly set to true to enforce local mount in HA environment\n",
                        "willReplaceOnChanges": true
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "Maximum possible lease duration for tokens and secrets in seconds\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "options": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Specifies mount type specific options that are passed to the backend\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Where the secret backend will be mounted\n"
                    },
                    "sealWrap": {
                        "type": "boolean",
                        "description": "Enable seal wrapping for the mount, causing values stored by the mount to be wrapped by the seal's encryption capability\n",
                        "willReplaceOnChanges": true
                    },
                    "serviceAccountJwt": {
                        "type": "string",
                        "description": "The JSON web token of the service account used by the\nsecrets engine to manage Kubernetes credentials. Defaults to the local pod’s JWT if Vault\nis running in Kubernetes.\n",
                        "secret": true
                    }
                },
                "type": "object"
            }
        },
        "vault:kubernetes/secretBackendRole:SecretBackendRole": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\nExample using `service_account_name` mode:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as fs from \"fs\";\nimport * as vault from \"@pulumi/vault\";\n\nconst config = new vault.kubernetes.SecretBackend(\"config\", {\n    path: \"kubernetes\",\n    description: \"kubernetes secrets engine description\",\n    kubernetesHost: \"https://127.0.0.1:61233\",\n    kubernetesCaCert: fs.readFileSync(\"/path/to/cert\"),\n    serviceAccountJwt: fs.readFileSync(\"/path/to/token\"),\n    disableLocalCaJwt: false,\n});\nconst sa_example = new vault.kubernetes.SecretBackendRole(\"sa-example\", {\n    backend: config.path,\n    allowedKubernetesNamespaces: [\"*\"],\n    tokenMaxTtl: 43200,\n    tokenDefaultTtl: 21600,\n    serviceAccountName: \"test-service-account-with-generated-token\",\n    extraLabels: {\n        id: \"abc123\",\n        name: \"some_name\",\n    },\n    extraAnnotations: {\n        env: \"development\",\n        location: \"earth\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nconfig = vault.kubernetes.SecretBackend(\"config\",\n    path=\"kubernetes\",\n    description=\"kubernetes secrets engine description\",\n    kubernetes_host=\"https://127.0.0.1:61233\",\n    kubernetes_ca_cert=(lambda path: open(path).read())(\"/path/to/cert\"),\n    service_account_jwt=(lambda path: open(path).read())(\"/path/to/token\"),\n    disable_local_ca_jwt=False)\nsa_example = vault.kubernetes.SecretBackendRole(\"sa-example\",\n    backend=config.path,\n    allowed_kubernetes_namespaces=[\"*\"],\n    token_max_ttl=43200,\n    token_default_ttl=21600,\n    service_account_name=\"test-service-account-with-generated-token\",\n    extra_labels={\n        \"id\": \"abc123\",\n        \"name\": \"some_name\",\n    },\n    extra_annotations={\n        \"env\": \"development\",\n        \"location\": \"earth\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Vault.Kubernetes.SecretBackend(\"config\", new()\n    {\n        Path = \"kubernetes\",\n        Description = \"kubernetes secrets engine description\",\n        KubernetesHost = \"https://127.0.0.1:61233\",\n        KubernetesCaCert = File.ReadAllText(\"/path/to/cert\"),\n        ServiceAccountJwt = File.ReadAllText(\"/path/to/token\"),\n        DisableLocalCaJwt = false,\n    });\n\n    var sa_example = new Vault.Kubernetes.SecretBackendRole(\"sa-example\", new()\n    {\n        Backend = config.Path,\n        AllowedKubernetesNamespaces = new[]\n        {\n            \"*\",\n        },\n        TokenMaxTtl = 43200,\n        TokenDefaultTtl = 21600,\n        ServiceAccountName = \"test-service-account-with-generated-token\",\n        ExtraLabels = \n        {\n            { \"id\", \"abc123\" },\n            { \"name\", \"some_name\" },\n        },\n        ExtraAnnotations = \n        {\n            { \"env\", \"development\" },\n            { \"location\", \"earth\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/kubernetes\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfig, err := kubernetes.NewSecretBackend(ctx, \"config\", \u0026kubernetes.SecretBackendArgs{\n\t\t\tPath:              pulumi.String(\"kubernetes\"),\n\t\t\tDescription:       pulumi.String(\"kubernetes secrets engine description\"),\n\t\t\tKubernetesHost:    pulumi.String(\"https://127.0.0.1:61233\"),\n\t\t\tKubernetesCaCert:  readFileOrPanic(\"/path/to/cert\"),\n\t\t\tServiceAccountJwt: readFileOrPanic(\"/path/to/token\"),\n\t\t\tDisableLocalCaJwt: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = kubernetes.NewSecretBackendRole(ctx, \"sa-example\", \u0026kubernetes.SecretBackendRoleArgs{\n\t\t\tBackend: config.Path,\n\t\t\tAllowedKubernetesNamespaces: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"*\"),\n\t\t\t},\n\t\t\tTokenMaxTtl:        pulumi.Int(43200),\n\t\t\tTokenDefaultTtl:    pulumi.Int(21600),\n\t\t\tServiceAccountName: pulumi.String(\"test-service-account-with-generated-token\"),\n\t\t\tExtraLabels: pulumi.StringMap{\n\t\t\t\t\"id\":   pulumi.String(\"abc123\"),\n\t\t\t\t\"name\": pulumi.String(\"some_name\"),\n\t\t\t},\n\t\t\tExtraAnnotations: pulumi.StringMap{\n\t\t\t\t\"env\":      pulumi.String(\"development\"),\n\t\t\t\t\"location\": pulumi.String(\"earth\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.kubernetes.SecretBackend;\nimport com.pulumi.vault.kubernetes.SecretBackendArgs;\nimport com.pulumi.vault.kubernetes.SecretBackendRole;\nimport com.pulumi.vault.kubernetes.SecretBackendRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var config = new SecretBackend(\"config\", SecretBackendArgs.builder()        \n            .path(\"kubernetes\")\n            .description(\"kubernetes secrets engine description\")\n            .kubernetesHost(\"https://127.0.0.1:61233\")\n            .kubernetesCaCert(Files.readString(Paths.get(\"/path/to/cert\")))\n            .serviceAccountJwt(Files.readString(Paths.get(\"/path/to/token\")))\n            .disableLocalCaJwt(false)\n            .build());\n\n        var sa_example = new SecretBackendRole(\"sa-example\", SecretBackendRoleArgs.builder()        \n            .backend(config.path())\n            .allowedKubernetesNamespaces(\"*\")\n            .tokenMaxTtl(43200)\n            .tokenDefaultTtl(21600)\n            .serviceAccountName(\"test-service-account-with-generated-token\")\n            .extraLabels(Map.ofEntries(\n                Map.entry(\"id\", \"abc123\"),\n                Map.entry(\"name\", \"some_name\")\n            ))\n            .extraAnnotations(Map.ofEntries(\n                Map.entry(\"env\", \"development\"),\n                Map.entry(\"location\", \"earth\")\n            ))\n            .build());\n\n    }\n}\n```\n\nExample using `kubernetes_role_name` mode:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as fs from \"fs\";\nimport * as vault from \"@pulumi/vault\";\n\nconst config = new vault.kubernetes.SecretBackend(\"config\", {\n    path: \"kubernetes\",\n    description: \"kubernetes secrets engine description\",\n    kubernetesHost: \"https://127.0.0.1:61233\",\n    kubernetesCaCert: fs.readFileSync(\"/path/to/cert\"),\n    serviceAccountJwt: fs.readFileSync(\"/path/to/token\"),\n    disableLocalCaJwt: false,\n});\nconst name_example = new vault.kubernetes.SecretBackendRole(\"name-example\", {\n    backend: config.path,\n    allowedKubernetesNamespaces: [\"*\"],\n    tokenMaxTtl: 43200,\n    tokenDefaultTtl: 21600,\n    kubernetesRoleName: \"vault-k8s-secrets-role\",\n    extraLabels: {\n        id: \"abc123\",\n        name: \"some_name\",\n    },\n    extraAnnotations: {\n        env: \"development\",\n        location: \"earth\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nconfig = vault.kubernetes.SecretBackend(\"config\",\n    path=\"kubernetes\",\n    description=\"kubernetes secrets engine description\",\n    kubernetes_host=\"https://127.0.0.1:61233\",\n    kubernetes_ca_cert=(lambda path: open(path).read())(\"/path/to/cert\"),\n    service_account_jwt=(lambda path: open(path).read())(\"/path/to/token\"),\n    disable_local_ca_jwt=False)\nname_example = vault.kubernetes.SecretBackendRole(\"name-example\",\n    backend=config.path,\n    allowed_kubernetes_namespaces=[\"*\"],\n    token_max_ttl=43200,\n    token_default_ttl=21600,\n    kubernetes_role_name=\"vault-k8s-secrets-role\",\n    extra_labels={\n        \"id\": \"abc123\",\n        \"name\": \"some_name\",\n    },\n    extra_annotations={\n        \"env\": \"development\",\n        \"location\": \"earth\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Vault.Kubernetes.SecretBackend(\"config\", new()\n    {\n        Path = \"kubernetes\",\n        Description = \"kubernetes secrets engine description\",\n        KubernetesHost = \"https://127.0.0.1:61233\",\n        KubernetesCaCert = File.ReadAllText(\"/path/to/cert\"),\n        ServiceAccountJwt = File.ReadAllText(\"/path/to/token\"),\n        DisableLocalCaJwt = false,\n    });\n\n    var name_example = new Vault.Kubernetes.SecretBackendRole(\"name-example\", new()\n    {\n        Backend = config.Path,\n        AllowedKubernetesNamespaces = new[]\n        {\n            \"*\",\n        },\n        TokenMaxTtl = 43200,\n        TokenDefaultTtl = 21600,\n        KubernetesRoleName = \"vault-k8s-secrets-role\",\n        ExtraLabels = \n        {\n            { \"id\", \"abc123\" },\n            { \"name\", \"some_name\" },\n        },\n        ExtraAnnotations = \n        {\n            { \"env\", \"development\" },\n            { \"location\", \"earth\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/kubernetes\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfig, err := kubernetes.NewSecretBackend(ctx, \"config\", \u0026kubernetes.SecretBackendArgs{\n\t\t\tPath:              pulumi.String(\"kubernetes\"),\n\t\t\tDescription:       pulumi.String(\"kubernetes secrets engine description\"),\n\t\t\tKubernetesHost:    pulumi.String(\"https://127.0.0.1:61233\"),\n\t\t\tKubernetesCaCert:  readFileOrPanic(\"/path/to/cert\"),\n\t\t\tServiceAccountJwt: readFileOrPanic(\"/path/to/token\"),\n\t\t\tDisableLocalCaJwt: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = kubernetes.NewSecretBackendRole(ctx, \"name-example\", \u0026kubernetes.SecretBackendRoleArgs{\n\t\t\tBackend: config.Path,\n\t\t\tAllowedKubernetesNamespaces: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"*\"),\n\t\t\t},\n\t\t\tTokenMaxTtl:        pulumi.Int(43200),\n\t\t\tTokenDefaultTtl:    pulumi.Int(21600),\n\t\t\tKubernetesRoleName: pulumi.String(\"vault-k8s-secrets-role\"),\n\t\t\tExtraLabels: pulumi.StringMap{\n\t\t\t\t\"id\":   pulumi.String(\"abc123\"),\n\t\t\t\t\"name\": pulumi.String(\"some_name\"),\n\t\t\t},\n\t\t\tExtraAnnotations: pulumi.StringMap{\n\t\t\t\t\"env\":      pulumi.String(\"development\"),\n\t\t\t\t\"location\": pulumi.String(\"earth\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.kubernetes.SecretBackend;\nimport com.pulumi.vault.kubernetes.SecretBackendArgs;\nimport com.pulumi.vault.kubernetes.SecretBackendRole;\nimport com.pulumi.vault.kubernetes.SecretBackendRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var config = new SecretBackend(\"config\", SecretBackendArgs.builder()        \n            .path(\"kubernetes\")\n            .description(\"kubernetes secrets engine description\")\n            .kubernetesHost(\"https://127.0.0.1:61233\")\n            .kubernetesCaCert(Files.readString(Paths.get(\"/path/to/cert\")))\n            .serviceAccountJwt(Files.readString(Paths.get(\"/path/to/token\")))\n            .disableLocalCaJwt(false)\n            .build());\n\n        var name_example = new SecretBackendRole(\"name-example\", SecretBackendRoleArgs.builder()        \n            .backend(config.path())\n            .allowedKubernetesNamespaces(\"*\")\n            .tokenMaxTtl(43200)\n            .tokenDefaultTtl(21600)\n            .kubernetesRoleName(\"vault-k8s-secrets-role\")\n            .extraLabels(Map.ofEntries(\n                Map.entry(\"id\", \"abc123\"),\n                Map.entry(\"name\", \"some_name\")\n            ))\n            .extraAnnotations(Map.ofEntries(\n                Map.entry(\"env\", \"development\"),\n                Map.entry(\"location\", \"earth\")\n            ))\n            .build());\n\n    }\n}\n```\n\nExample using `generated_role_rules` mode:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as fs from \"fs\";\nimport * as vault from \"@pulumi/vault\";\n\nconst config = new vault.kubernetes.SecretBackend(\"config\", {\n    path: \"kubernetes\",\n    description: \"kubernetes secrets engine description\",\n    kubernetesHost: \"https://127.0.0.1:61233\",\n    kubernetesCaCert: fs.readFileSync(\"/path/to/cert\"),\n    serviceAccountJwt: fs.readFileSync(\"/path/to/token\"),\n    disableLocalCaJwt: false,\n});\nconst rules_example = new vault.kubernetes.SecretBackendRole(\"rules-example\", {\n    backend: config.path,\n    allowedKubernetesNamespaces: [\"*\"],\n    tokenMaxTtl: 43200,\n    tokenDefaultTtl: 21600,\n    kubernetesRoleType: \"Role\",\n    generatedRoleRules: `rules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"list\"]\n`,\n    extraLabels: {\n        id: \"abc123\",\n        name: \"some_name\",\n    },\n    extraAnnotations: {\n        env: \"development\",\n        location: \"earth\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nconfig = vault.kubernetes.SecretBackend(\"config\",\n    path=\"kubernetes\",\n    description=\"kubernetes secrets engine description\",\n    kubernetes_host=\"https://127.0.0.1:61233\",\n    kubernetes_ca_cert=(lambda path: open(path).read())(\"/path/to/cert\"),\n    service_account_jwt=(lambda path: open(path).read())(\"/path/to/token\"),\n    disable_local_ca_jwt=False)\nrules_example = vault.kubernetes.SecretBackendRole(\"rules-example\",\n    backend=config.path,\n    allowed_kubernetes_namespaces=[\"*\"],\n    token_max_ttl=43200,\n    token_default_ttl=21600,\n    kubernetes_role_type=\"Role\",\n    generated_role_rules=\"\"\"rules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"list\"]\n\"\"\",\n    extra_labels={\n        \"id\": \"abc123\",\n        \"name\": \"some_name\",\n    },\n    extra_annotations={\n        \"env\": \"development\",\n        \"location\": \"earth\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Vault.Kubernetes.SecretBackend(\"config\", new()\n    {\n        Path = \"kubernetes\",\n        Description = \"kubernetes secrets engine description\",\n        KubernetesHost = \"https://127.0.0.1:61233\",\n        KubernetesCaCert = File.ReadAllText(\"/path/to/cert\"),\n        ServiceAccountJwt = File.ReadAllText(\"/path/to/token\"),\n        DisableLocalCaJwt = false,\n    });\n\n    var rules_example = new Vault.Kubernetes.SecretBackendRole(\"rules-example\", new()\n    {\n        Backend = config.Path,\n        AllowedKubernetesNamespaces = new[]\n        {\n            \"*\",\n        },\n        TokenMaxTtl = 43200,\n        TokenDefaultTtl = 21600,\n        KubernetesRoleType = \"Role\",\n        GeneratedRoleRules = @\"rules:\n- apiGroups: [\"\"\"\"]\n  resources: [\"\"pods\"\"]\n  verbs: [\"\"list\"\"]\n\",\n        ExtraLabels = \n        {\n            { \"id\", \"abc123\" },\n            { \"name\", \"some_name\" },\n        },\n        ExtraAnnotations = \n        {\n            { \"env\", \"development\" },\n            { \"location\", \"earth\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/kubernetes\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfig, err := kubernetes.NewSecretBackend(ctx, \"config\", \u0026kubernetes.SecretBackendArgs{\n\t\t\tPath:              pulumi.String(\"kubernetes\"),\n\t\t\tDescription:       pulumi.String(\"kubernetes secrets engine description\"),\n\t\t\tKubernetesHost:    pulumi.String(\"https://127.0.0.1:61233\"),\n\t\t\tKubernetesCaCert:  readFileOrPanic(\"/path/to/cert\"),\n\t\t\tServiceAccountJwt: readFileOrPanic(\"/path/to/token\"),\n\t\t\tDisableLocalCaJwt: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = kubernetes.NewSecretBackendRole(ctx, \"rules-example\", \u0026kubernetes.SecretBackendRoleArgs{\n\t\t\tBackend: config.Path,\n\t\t\tAllowedKubernetesNamespaces: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"*\"),\n\t\t\t},\n\t\t\tTokenMaxTtl:        pulumi.Int(43200),\n\t\t\tTokenDefaultTtl:    pulumi.Int(21600),\n\t\t\tKubernetesRoleType: pulumi.String(\"Role\"),\n\t\t\tGeneratedRoleRules: pulumi.String(\"rules:\\n- apiGroups: [\\\"\\\"]\\n  resources: [\\\"pods\\\"]\\n  verbs: [\\\"list\\\"]\\n\"),\n\t\t\tExtraLabels: pulumi.StringMap{\n\t\t\t\t\"id\":   pulumi.String(\"abc123\"),\n\t\t\t\t\"name\": pulumi.String(\"some_name\"),\n\t\t\t},\n\t\t\tExtraAnnotations: pulumi.StringMap{\n\t\t\t\t\"env\":      pulumi.String(\"development\"),\n\t\t\t\t\"location\": pulumi.String(\"earth\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.kubernetes.SecretBackend;\nimport com.pulumi.vault.kubernetes.SecretBackendArgs;\nimport com.pulumi.vault.kubernetes.SecretBackendRole;\nimport com.pulumi.vault.kubernetes.SecretBackendRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var config = new SecretBackend(\"config\", SecretBackendArgs.builder()        \n            .path(\"kubernetes\")\n            .description(\"kubernetes secrets engine description\")\n            .kubernetesHost(\"https://127.0.0.1:61233\")\n            .kubernetesCaCert(Files.readString(Paths.get(\"/path/to/cert\")))\n            .serviceAccountJwt(Files.readString(Paths.get(\"/path/to/token\")))\n            .disableLocalCaJwt(false)\n            .build());\n\n        var rules_example = new SecretBackendRole(\"rules-example\", SecretBackendRoleArgs.builder()        \n            .backend(config.path())\n            .allowedKubernetesNamespaces(\"*\")\n            .tokenMaxTtl(43200)\n            .tokenDefaultTtl(21600)\n            .kubernetesRoleType(\"Role\")\n            .generatedRoleRules(\"\"\"\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"list\"]\n            \"\"\")\n            .extraLabels(Map.ofEntries(\n                Map.entry(\"id\", \"abc123\"),\n                Map.entry(\"name\", \"some_name\")\n            ))\n            .extraAnnotations(Map.ofEntries(\n                Map.entry(\"env\", \"development\"),\n                Map.entry(\"location\", \"earth\")\n            ))\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nThe Kubernetes secret backend role can be imported using the full path to the role of the form`\u003cbackend_path\u003e/roles/\u003crole_name\u003e` e.g.\n\n```sh\n $ pulumi import vault:kubernetes/secretBackendRole:SecretBackendRole example kubernetes kubernetes/roles/example-role\n```\n\n ",
            "properties": {
                "allowedKubernetesNamespaces": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of Kubernetes namespaces this role \ncan generate credentials for. If set to `*` all namespaces are allowed.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path of the Kubernetes Secrets Engine backend mount to create\nthe role in.\n"
                },
                "extraAnnotations": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Additional annotations to apply to all generated \nKubernetes objects.\n"
                },
                "extraLabels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Additional labels to apply to all generated Kubernetes \nobjects.\n"
                },
                "generatedRoleRules": {
                    "type": "string",
                    "description": "The Role or ClusterRole rules to use when generating \na role. Accepts either JSON or YAML formatted rules. Mutually exclusive with `service_account_name`\nand `kubernetes_role_name`. If set, the entire chain of Kubernetes objects will be generated\nwhen credentials are requested.\n"
                },
                "kubernetesRoleName": {
                    "type": "string",
                    "description": "The pre-existing Role or ClusterRole to bind a \ngenerated service account to. Mutually exclusive with `service_account_name` and\n`generated_role_rules`. If set, Kubernetes token, service account, and role\nbinding objects will be created when credentials are requested.\n"
                },
                "kubernetesRoleType": {
                    "type": "string",
                    "description": "Specifies whether the Kubernetes role is a Role or \nClusterRole.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "nameTemplate": {
                    "type": "string",
                    "description": "The name template to use when generating service accounts, \nroles and role bindings. If unset, a default template is used.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "serviceAccountName": {
                    "type": "string",
                    "description": "The pre-existing service account to generate tokens for.\nMutually exclusive with `kubernetes_role_name` and `generated_role_rules`. If set, only a\nKubernetes token will be created when credentials are requested.\n"
                },
                "tokenDefaultTtl": {
                    "type": "integer",
                    "description": "The default TTL for generated Kubernetes tokens in seconds.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum TTL for generated Kubernetes tokens in seconds.\n"
                }
            },
            "required": [
                "allowedKubernetesNamespaces",
                "backend",
                "name"
            ],
            "inputProperties": {
                "allowedKubernetesNamespaces": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of Kubernetes namespaces this role \ncan generate credentials for. If set to `*` all namespaces are allowed.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path of the Kubernetes Secrets Engine backend mount to create\nthe role in.\n",
                    "willReplaceOnChanges": true
                },
                "extraAnnotations": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Additional annotations to apply to all generated \nKubernetes objects.\n"
                },
                "extraLabels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Additional labels to apply to all generated Kubernetes \nobjects.\n"
                },
                "generatedRoleRules": {
                    "type": "string",
                    "description": "The Role or ClusterRole rules to use when generating \na role. Accepts either JSON or YAML formatted rules. Mutually exclusive with `service_account_name`\nand `kubernetes_role_name`. If set, the entire chain of Kubernetes objects will be generated\nwhen credentials are requested.\n"
                },
                "kubernetesRoleName": {
                    "type": "string",
                    "description": "The pre-existing Role or ClusterRole to bind a \ngenerated service account to. Mutually exclusive with `service_account_name` and\n`generated_role_rules`. If set, Kubernetes token, service account, and role\nbinding objects will be created when credentials are requested.\n"
                },
                "kubernetesRoleType": {
                    "type": "string",
                    "description": "Specifies whether the Kubernetes role is a Role or \nClusterRole.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the role.\n",
                    "willReplaceOnChanges": true
                },
                "nameTemplate": {
                    "type": "string",
                    "description": "The name template to use when generating service accounts, \nroles and role bindings. If unset, a default template is used.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "serviceAccountName": {
                    "type": "string",
                    "description": "The pre-existing service account to generate tokens for.\nMutually exclusive with `kubernetes_role_name` and `generated_role_rules`. If set, only a\nKubernetes token will be created when credentials are requested.\n"
                },
                "tokenDefaultTtl": {
                    "type": "integer",
                    "description": "The default TTL for generated Kubernetes tokens in seconds.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum TTL for generated Kubernetes tokens in seconds.\n"
                }
            },
            "requiredInputs": [
                "allowedKubernetesNamespaces",
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRole resources.\n",
                "properties": {
                    "allowedKubernetesNamespaces": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of Kubernetes namespaces this role \ncan generate credentials for. If set to `*` all namespaces are allowed.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path of the Kubernetes Secrets Engine backend mount to create\nthe role in.\n",
                        "willReplaceOnChanges": true
                    },
                    "extraAnnotations": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Additional annotations to apply to all generated \nKubernetes objects.\n"
                    },
                    "extraLabels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Additional labels to apply to all generated Kubernetes \nobjects.\n"
                    },
                    "generatedRoleRules": {
                        "type": "string",
                        "description": "The Role or ClusterRole rules to use when generating \na role. Accepts either JSON or YAML formatted rules. Mutually exclusive with `service_account_name`\nand `kubernetes_role_name`. If set, the entire chain of Kubernetes objects will be generated\nwhen credentials are requested.\n"
                    },
                    "kubernetesRoleName": {
                        "type": "string",
                        "description": "The pre-existing Role or ClusterRole to bind a \ngenerated service account to. Mutually exclusive with `service_account_name` and\n`generated_role_rules`. If set, Kubernetes token, service account, and role\nbinding objects will be created when credentials are requested.\n"
                    },
                    "kubernetesRoleType": {
                        "type": "string",
                        "description": "Specifies whether the Kubernetes role is a Role or \nClusterRole.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the role.\n",
                        "willReplaceOnChanges": true
                    },
                    "nameTemplate": {
                        "type": "string",
                        "description": "The name template to use when generating service accounts, \nroles and role bindings. If unset, a default template is used.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "serviceAccountName": {
                        "type": "string",
                        "description": "The pre-existing service account to generate tokens for.\nMutually exclusive with `kubernetes_role_name` and `generated_role_rules`. If set, only a\nKubernetes token will be created when credentials are requested.\n"
                    },
                    "tokenDefaultTtl": {
                        "type": "integer",
                        "description": "The default TTL for generated Kubernetes tokens in seconds.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum TTL for generated Kubernetes tokens in seconds.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:kv/secret:Secret": {
            "description": "Writes a KV-V1 secret to a given path in Vault.\n\nFor more information on Vault's KV-V1 secret backend\n[see here](https://www.vaultproject.io/docs/secrets/kv/kv-v1).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst kvv1 = new vault.Mount(\"kvv1\", {\n    path: \"kvv1\",\n    type: \"kv\",\n    options: {\n        version: \"1\",\n    },\n    description: \"KV Version 1 secret engine mount\",\n});\nconst secret = new vault.kv.Secret(\"secret\", {\n    path: pulumi.interpolate`${kvv1.path}/secret`,\n    dataJson: JSON.stringify({\n        zip: \"zap\",\n        foo: \"bar\",\n    }),\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_vault as vault\n\nkvv1 = vault.Mount(\"kvv1\",\n    path=\"kvv1\",\n    type=\"kv\",\n    options={\n        \"version\": \"1\",\n    },\n    description=\"KV Version 1 secret engine mount\")\nsecret = vault.kv.Secret(\"secret\",\n    path=kvv1.path.apply(lambda path: f\"{path}/secret\"),\n    data_json=json.dumps({\n        \"zip\": \"zap\",\n        \"foo\": \"bar\",\n    }))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var kvv1 = new Vault.Mount(\"kvv1\", new()\n    {\n        Path = \"kvv1\",\n        Type = \"kv\",\n        Options = \n        {\n            { \"version\", \"1\" },\n        },\n        Description = \"KV Version 1 secret engine mount\",\n    });\n\n    var secret = new Vault.Kv.Secret(\"secret\", new()\n    {\n        Path = kvv1.Path.Apply(path =\u003e $\"{path}/secret\"),\n        DataJson = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"zip\"] = \"zap\",\n            [\"foo\"] = \"bar\",\n        }),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/kv\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tkvv1, err := vault.NewMount(ctx, \"kvv1\", \u0026vault.MountArgs{\n\t\t\tPath: pulumi.String(\"kvv1\"),\n\t\t\tType: pulumi.String(\"kv\"),\n\t\t\tOptions: pulumi.AnyMap{\n\t\t\t\t\"version\": pulumi.Any(\"1\"),\n\t\t\t},\n\t\t\tDescription: pulumi.String(\"KV Version 1 secret engine mount\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"zip\": \"zap\",\n\t\t\t\"foo\": \"bar\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\t_, err = kv.NewSecret(ctx, \"secret\", \u0026kv.SecretArgs{\n\t\t\tPath: kvv1.Path.ApplyT(func(path string) (string, error) {\n\t\t\t\treturn fmt.Sprintf(\"%v/secret\", path), nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t\tDataJson: pulumi.String(json0),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Mount;\nimport com.pulumi.vault.MountArgs;\nimport com.pulumi.vault.kv.Secret;\nimport com.pulumi.vault.kv.SecretArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var kvv1 = new Mount(\"kvv1\", MountArgs.builder()        \n            .path(\"kvv1\")\n            .type(\"kv\")\n            .options(Map.of(\"version\", \"1\"))\n            .description(\"KV Version 1 secret engine mount\")\n            .build());\n\n        var secret = new Secret(\"secret\", SecretArgs.builder()        \n            .path(kvv1.path().applyValue(path -\u003e String.format(\"%s/secret\", path)))\n            .dataJson(serializeJson(\n                jsonObject(\n                    jsonProperty(\"zip\", \"zap\"),\n                    jsonProperty(\"foo\", \"bar\")\n                )))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  kvv1:\n    type: vault:Mount\n    properties:\n      path: kvv1\n      type: kv\n      options:\n        version: 1\n      description: KV Version 1 secret engine mount\n  secret:\n    type: vault:kv:Secret\n    properties:\n      path: ${kvv1.path}/secret\n      dataJson:\n        Fn::ToJSON:\n          zip: zap\n          foo: bar\n```\n{{% /example %}}\n{{% /examples %}}\n## Required Vault Capabilities\n\nUse of this resource requires the `create` or `update` capability\n(depending on whether the resource already exists) on the given path,\nthe `delete` capability if the resource is removed from configuration,\nand the `read` capability for drift detection (by default).\n\n\n## Import\n\nKV-V1 secrets can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:kv/secret:Secret secret kvv1/secret\n```\n\n ",
            "properties": {
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A mapping whose keys are the top-level data keys returned from\nVault and whose values are the corresponding values. This map can only\nrepresent string data, so any non-string values returned from Vault are\nserialized as JSON.\n",
                    "secret": true
                },
                "dataJson": {
                    "type": "string",
                    "description": "JSON-encoded string that will be\nwritten as the secret data at the given path.\n",
                    "secret": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Full path of the KV-V1 secret.\n"
                }
            },
            "required": [
                "data",
                "dataJson",
                "path"
            ],
            "inputProperties": {
                "dataJson": {
                    "type": "string",
                    "description": "JSON-encoded string that will be\nwritten as the secret data at the given path.\n",
                    "secret": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "Full path of the KV-V1 secret.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "dataJson",
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Secret resources.\n",
                "properties": {
                    "data": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A mapping whose keys are the top-level data keys returned from\nVault and whose values are the corresponding values. This map can only\nrepresent string data, so any non-string values returned from Vault are\nserialized as JSON.\n",
                        "secret": true
                    },
                    "dataJson": {
                        "type": "string",
                        "description": "JSON-encoded string that will be\nwritten as the secret data at the given path.\n",
                        "secret": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "Full path of the KV-V1 secret.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:kv/secretBackendV2:SecretBackendV2": {
            "description": "Configures KV-V2 backend level settings that are applied to\nevery key in the key-value store.\n\nFor more information on Vault's KV-V2 secret backend\n[see here](https://www.vaultproject.io/docs/secrets/kv/kv-v2).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst kvv2 = new vault.Mount(\"kvv2\", {\n    path: \"kvv2\",\n    type: \"kv\",\n    options: {\n        version: \"2\",\n    },\n    description: \"KV Version 2 secret engine mount\",\n});\nconst example = new vault.kv.SecretBackendV2(\"example\", {\n    mount: kvv2.path,\n    maxVersions: 5,\n    deleteVersionAfter: 12600,\n    casRequired: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nkvv2 = vault.Mount(\"kvv2\",\n    path=\"kvv2\",\n    type=\"kv\",\n    options={\n        \"version\": \"2\",\n    },\n    description=\"KV Version 2 secret engine mount\")\nexample = vault.kv.SecretBackendV2(\"example\",\n    mount=kvv2.path,\n    max_versions=5,\n    delete_version_after=12600,\n    cas_required=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var kvv2 = new Vault.Mount(\"kvv2\", new()\n    {\n        Path = \"kvv2\",\n        Type = \"kv\",\n        Options = \n        {\n            { \"version\", \"2\" },\n        },\n        Description = \"KV Version 2 secret engine mount\",\n    });\n\n    var example = new Vault.Kv.SecretBackendV2(\"example\", new()\n    {\n        Mount = kvv2.Path,\n        MaxVersions = 5,\n        DeleteVersionAfter = 12600,\n        CasRequired = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/kv\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tkvv2, err := vault.NewMount(ctx, \"kvv2\", \u0026vault.MountArgs{\n\t\t\tPath: pulumi.String(\"kvv2\"),\n\t\t\tType: pulumi.String(\"kv\"),\n\t\t\tOptions: pulumi.AnyMap{\n\t\t\t\t\"version\": pulumi.Any(\"2\"),\n\t\t\t},\n\t\t\tDescription: pulumi.String(\"KV Version 2 secret engine mount\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = kv.NewSecretBackendV2(ctx, \"example\", \u0026kv.SecretBackendV2Args{\n\t\t\tMount:              kvv2.Path,\n\t\t\tMaxVersions:        pulumi.Int(5),\n\t\t\tDeleteVersionAfter: pulumi.Int(12600),\n\t\t\tCasRequired:        pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Mount;\nimport com.pulumi.vault.MountArgs;\nimport com.pulumi.vault.kv.SecretBackendV2;\nimport com.pulumi.vault.kv.SecretBackendV2Args;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var kvv2 = new Mount(\"kvv2\", MountArgs.builder()        \n            .path(\"kvv2\")\n            .type(\"kv\")\n            .options(Map.of(\"version\", \"2\"))\n            .description(\"KV Version 2 secret engine mount\")\n            .build());\n\n        var example = new SecretBackendV2(\"example\", SecretBackendV2Args.builder()        \n            .mount(kvv2.path())\n            .maxVersions(5)\n            .deleteVersionAfter(12600)\n            .casRequired(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  kvv2:\n    type: vault:Mount\n    properties:\n      path: kvv2\n      type: kv\n      options:\n        version: 2\n      description: KV Version 2 secret engine mount\n  example:\n    type: vault:kv:SecretBackendV2\n    properties:\n      mount: ${kvv2.path}\n      maxVersions: 5\n      deleteVersionAfter: 12600\n      casRequired: true\n```\n{{% /example %}}\n{{% /examples %}}\n## Required Vault Capabilities\n\nUse of this resource requires the `create` or `update` capability\n(depending on whether the resource already exists) on the given path,\nthe `delete` capability if the resource is removed from configuration,\nand the `read` capability for drift detection (by default).\n\n\n## Import\n\nThe KV-V2 secret backend can be imported using its unique ID, the `${mount}/config`, e.g.\n\n```sh\n $ pulumi import vault:kv/secretBackendV2:SecretBackendV2 example kvv2/config\n```\n\n ",
            "properties": {
                "casRequired": {
                    "type": "boolean",
                    "description": "If true, all keys will require the cas\nparameter to be set on all write requests.\n"
                },
                "deleteVersionAfter": {
                    "type": "integer",
                    "description": "If set, specifies the length of time before\na version is deleted. Accepts duration in integer seconds.\n"
                },
                "maxVersions": {
                    "type": "integer",
                    "description": "The number of versions to keep per key.\n"
                },
                "mount": {
                    "type": "string",
                    "description": "Path where KV-V2 engine is mounted.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                }
            },
            "required": [
                "casRequired",
                "maxVersions",
                "mount"
            ],
            "inputProperties": {
                "casRequired": {
                    "type": "boolean",
                    "description": "If true, all keys will require the cas\nparameter to be set on all write requests.\n"
                },
                "deleteVersionAfter": {
                    "type": "integer",
                    "description": "If set, specifies the length of time before\na version is deleted. Accepts duration in integer seconds.\n"
                },
                "maxVersions": {
                    "type": "integer",
                    "description": "The number of versions to keep per key.\n"
                },
                "mount": {
                    "type": "string",
                    "description": "Path where KV-V2 engine is mounted.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "mount"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendV2 resources.\n",
                "properties": {
                    "casRequired": {
                        "type": "boolean",
                        "description": "If true, all keys will require the cas\nparameter to be set on all write requests.\n"
                    },
                    "deleteVersionAfter": {
                        "type": "integer",
                        "description": "If set, specifies the length of time before\na version is deleted. Accepts duration in integer seconds.\n"
                    },
                    "maxVersions": {
                        "type": "integer",
                        "description": "The number of versions to keep per key.\n"
                    },
                    "mount": {
                        "type": "string",
                        "description": "Path where KV-V2 engine is mounted.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:kv/secretV2:SecretV2": {
            "description": "Writes a KV-V2 secret to a given path in Vault.\n\nFor more information on Vault's KV-V2 secret backend\n[see here](https://www.vaultproject.io/docs/secrets/kv/kv-v2).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst kvv2 = new vault.Mount(\"kvv2\", {\n    path: \"kvv2\",\n    type: \"kv\",\n    options: {\n        version: \"2\",\n    },\n    description: \"KV Version 2 secret engine mount\",\n});\nconst example = new vault.kv.SecretV2(\"example\", {\n    mount: kvv2.path,\n    cas: 1,\n    deleteAllVersions: true,\n    dataJson: JSON.stringify({\n        zip: \"zap\",\n        foo: \"bar\",\n    }),\n    customMetadata: {\n        maxVersions: 5,\n        data: {\n            foo: \"vault@example.com\",\n            bar: \"12345\",\n        },\n    },\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_vault as vault\n\nkvv2 = vault.Mount(\"kvv2\",\n    path=\"kvv2\",\n    type=\"kv\",\n    options={\n        \"version\": \"2\",\n    },\n    description=\"KV Version 2 secret engine mount\")\nexample = vault.kv.SecretV2(\"example\",\n    mount=kvv2.path,\n    cas=1,\n    delete_all_versions=True,\n    data_json=json.dumps({\n        \"zip\": \"zap\",\n        \"foo\": \"bar\",\n    }),\n    custom_metadata=vault.kv.SecretV2CustomMetadataArgs(\n        max_versions=5,\n        data={\n            \"foo\": \"vault@example.com\",\n            \"bar\": \"12345\",\n        },\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var kvv2 = new Vault.Mount(\"kvv2\", new()\n    {\n        Path = \"kvv2\",\n        Type = \"kv\",\n        Options = \n        {\n            { \"version\", \"2\" },\n        },\n        Description = \"KV Version 2 secret engine mount\",\n    });\n\n    var example = new Vault.Kv.SecretV2(\"example\", new()\n    {\n        Mount = kvv2.Path,\n        Cas = 1,\n        DeleteAllVersions = true,\n        DataJson = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"zip\"] = \"zap\",\n            [\"foo\"] = \"bar\",\n        }),\n        CustomMetadata = new Vault.kv.Inputs.SecretV2CustomMetadataArgs\n        {\n            MaxVersions = 5,\n            Data = \n            {\n                { \"foo\", \"vault@example.com\" },\n                { \"bar\", \"12345\" },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/kv\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tkvv2, err := vault.NewMount(ctx, \"kvv2\", \u0026vault.MountArgs{\n\t\t\tPath: pulumi.String(\"kvv2\"),\n\t\t\tType: pulumi.String(\"kv\"),\n\t\t\tOptions: pulumi.AnyMap{\n\t\t\t\t\"version\": pulumi.Any(\"2\"),\n\t\t\t},\n\t\t\tDescription: pulumi.String(\"KV Version 2 secret engine mount\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"zip\": \"zap\",\n\t\t\t\"foo\": \"bar\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\t_, err = kv.NewSecretV2(ctx, \"example\", \u0026kv.SecretV2Args{\n\t\t\tMount:             kvv2.Path,\n\t\t\tCas:               pulumi.Int(1),\n\t\t\tDeleteAllVersions: pulumi.Bool(true),\n\t\t\tDataJson:          pulumi.String(json0),\n\t\t\tCustomMetadata: \u0026kv.SecretV2CustomMetadataArgs{\n\t\t\t\tMaxVersions: pulumi.Int(5),\n\t\t\t\tData: pulumi.AnyMap{\n\t\t\t\t\t\"foo\": pulumi.Any(\"vault@example.com\"),\n\t\t\t\t\t\"bar\": pulumi.Any(\"12345\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Mount;\nimport com.pulumi.vault.MountArgs;\nimport com.pulumi.vault.kv.SecretV2;\nimport com.pulumi.vault.kv.SecretV2Args;\nimport com.pulumi.vault.kv.inputs.SecretV2CustomMetadataArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var kvv2 = new Mount(\"kvv2\", MountArgs.builder()        \n            .path(\"kvv2\")\n            .type(\"kv\")\n            .options(Map.of(\"version\", \"2\"))\n            .description(\"KV Version 2 secret engine mount\")\n            .build());\n\n        var example = new SecretV2(\"example\", SecretV2Args.builder()        \n            .mount(kvv2.path())\n            .cas(1)\n            .deleteAllVersions(true)\n            .dataJson(serializeJson(\n                jsonObject(\n                    jsonProperty(\"zip\", \"zap\"),\n                    jsonProperty(\"foo\", \"bar\")\n                )))\n            .customMetadata(SecretV2CustomMetadataArgs.builder()\n                .maxVersions(5)\n                .data(Map.ofEntries(\n                    Map.entry(\"foo\", \"vault@example.com\"),\n                    Map.entry(\"bar\", \"12345\")\n                ))\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  kvv2:\n    type: vault:Mount\n    properties:\n      path: kvv2\n      type: kv\n      options:\n        version: 2\n      description: KV Version 2 secret engine mount\n  example:\n    type: vault:kv:SecretV2\n    properties:\n      mount: ${kvv2.path}\n      cas: 1\n      deleteAllVersions: true\n      dataJson:\n        Fn::ToJSON:\n          zip: zap\n          foo: bar\n      customMetadata:\n        maxVersions: 5\n        data:\n          foo: vault@example.com\n          bar: 12345\n```\n{{% /example %}}\n{{% /examples %}}\n## Required Vault Capabilities\n\nUse of this resource requires the `create` or `update` capability\n(depending on whether the resource already exists) on the given path,\nthe `delete` capability if the resource is removed from configuration,\nand the `read` capability for drift detection (by default).\n\n### Custom Metadata Configuration Options\n\n* `max_versions` - (Optional) The number of versions to keep per key.\n\n* `cas_required` - (Optional) If true, all keys will require the cas\n  parameter to be set on all write requests.\n\n* `delete_version_after` - (Optional) If set, specifies the length of time before\n  a version is deleted. Accepts duration in integer seconds.\n\n* `data` - (Optional) A string to string map describing the secret.\n\n\n## Import\n\nKV-V2 secrets can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:kv/secretV2:SecretV2 example kvv2/data/secret\n```\n\n ",
            "properties": {
                "cas": {
                    "type": "integer",
                    "description": "This flag is required if `cas_required` is set to true\non either the secret or the engine's config. In order for a\nwrite operation to be successful, cas must be set to the current version\nof the secret.\n"
                },
                "customMetadata": {
                    "$ref": "#/types/vault:kv/SecretV2CustomMetadata:SecretV2CustomMetadata",
                    "description": "A nested block that allows configuring metadata for the\nKV secret. Refer to the\nConfiguration Options for more info.\n"
                },
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A mapping whose keys are the top-level data keys returned from\nVault and whose values are the corresponding values. This map can only\nrepresent string data, so any non-string values returned from Vault are\nserialized as JSON.\n",
                    "secret": true
                },
                "dataJson": {
                    "type": "string",
                    "description": "JSON-encoded string that will be\nwritten as the secret data at the given path.\n",
                    "secret": true
                },
                "deleteAllVersions": {
                    "type": "boolean",
                    "description": "If set to true, permanently deletes all\nversions for the specified key.\n"
                },
                "disableRead": {
                    "type": "boolean",
                    "description": "If set to true, disables reading secret from Vault;\nnote: drift won't be detected.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Metadata associated with this secret read from Vault.\n"
                },
                "mount": {
                    "type": "string",
                    "description": "Path where KV-V2 engine is mounted.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Full name of the secret. For a nested secret\nthe name is the nested path excluding the mount and data\nprefix. For example, for a secret at `kvv2/data/foo/bar/baz`\nthe name is `foo/bar/baz`.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "options": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "An object that holds option settings.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Full path where the KV-V2 secret will be written.\n"
                }
            },
            "required": [
                "customMetadata",
                "data",
                "dataJson",
                "metadata",
                "mount",
                "name",
                "path"
            ],
            "inputProperties": {
                "cas": {
                    "type": "integer",
                    "description": "This flag is required if `cas_required` is set to true\non either the secret or the engine's config. In order for a\nwrite operation to be successful, cas must be set to the current version\nof the secret.\n"
                },
                "customMetadata": {
                    "$ref": "#/types/vault:kv/SecretV2CustomMetadata:SecretV2CustomMetadata",
                    "description": "A nested block that allows configuring metadata for the\nKV secret. Refer to the\nConfiguration Options for more info.\n"
                },
                "dataJson": {
                    "type": "string",
                    "description": "JSON-encoded string that will be\nwritten as the secret data at the given path.\n",
                    "secret": true
                },
                "deleteAllVersions": {
                    "type": "boolean",
                    "description": "If set to true, permanently deletes all\nversions for the specified key.\n"
                },
                "disableRead": {
                    "type": "boolean",
                    "description": "If set to true, disables reading secret from Vault;\nnote: drift won't be detected.\n"
                },
                "mount": {
                    "type": "string",
                    "description": "Path where KV-V2 engine is mounted.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Full name of the secret. For a nested secret\nthe name is the nested path excluding the mount and data\nprefix. For example, for a secret at `kvv2/data/foo/bar/baz`\nthe name is `foo/bar/baz`.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "options": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "An object that holds option settings.\n"
                }
            },
            "requiredInputs": [
                "dataJson",
                "mount"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretV2 resources.\n",
                "properties": {
                    "cas": {
                        "type": "integer",
                        "description": "This flag is required if `cas_required` is set to true\non either the secret or the engine's config. In order for a\nwrite operation to be successful, cas must be set to the current version\nof the secret.\n"
                    },
                    "customMetadata": {
                        "$ref": "#/types/vault:kv/SecretV2CustomMetadata:SecretV2CustomMetadata",
                        "description": "A nested block that allows configuring metadata for the\nKV secret. Refer to the\nConfiguration Options for more info.\n"
                    },
                    "data": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A mapping whose keys are the top-level data keys returned from\nVault and whose values are the corresponding values. This map can only\nrepresent string data, so any non-string values returned from Vault are\nserialized as JSON.\n",
                        "secret": true
                    },
                    "dataJson": {
                        "type": "string",
                        "description": "JSON-encoded string that will be\nwritten as the secret data at the given path.\n",
                        "secret": true
                    },
                    "deleteAllVersions": {
                        "type": "boolean",
                        "description": "If set to true, permanently deletes all\nversions for the specified key.\n"
                    },
                    "disableRead": {
                        "type": "boolean",
                        "description": "If set to true, disables reading secret from Vault;\nnote: drift won't be detected.\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Metadata associated with this secret read from Vault.\n"
                    },
                    "mount": {
                        "type": "string",
                        "description": "Path where KV-V2 engine is mounted.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Full name of the secret. For a nested secret\nthe name is the nested path excluding the mount and data\nprefix. For example, for a secret at `kvv2/data/foo/bar/baz`\nthe name is `foo/bar/baz`.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "options": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "An object that holds option settings.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Full path where the KV-V2 secret will be written.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:ldap/authBackend:AuthBackend": {
            "description": "Provides a resource for managing an [LDAP auth backend within Vault](https://www.vaultproject.io/docs/auth/ldap.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst ldap = new vault.ldap.AuthBackend(\"ldap\", {\n    discoverdn: false,\n    groupdn: \"OU=Groups,DC=example,DC=org\",\n    groupfilter: \"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n    path: \"ldap\",\n    upndomain: \"EXAMPLE.ORG\",\n    url: \"ldaps://dc-01.example.org\",\n    userattr: \"sAMAccountName\",\n    userdn: \"OU=Users,OU=Accounts,DC=example,DC=org\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nldap = vault.ldap.AuthBackend(\"ldap\",\n    discoverdn=False,\n    groupdn=\"OU=Groups,DC=example,DC=org\",\n    groupfilter=\"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n    path=\"ldap\",\n    upndomain=\"EXAMPLE.ORG\",\n    url=\"ldaps://dc-01.example.org\",\n    userattr=\"sAMAccountName\",\n    userdn=\"OU=Users,OU=Accounts,DC=example,DC=org\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ldap = new Vault.Ldap.AuthBackend(\"ldap\", new()\n    {\n        Discoverdn = false,\n        Groupdn = \"OU=Groups,DC=example,DC=org\",\n        Groupfilter = \"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n        Path = \"ldap\",\n        Upndomain = \"EXAMPLE.ORG\",\n        Url = \"ldaps://dc-01.example.org\",\n        Userattr = \"sAMAccountName\",\n        Userdn = \"OU=Users,OU=Accounts,DC=example,DC=org\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := ldap.NewAuthBackend(ctx, \"ldap\", \u0026ldap.AuthBackendArgs{\n\t\t\tDiscoverdn:  pulumi.Bool(false),\n\t\t\tGroupdn:     pulumi.String(\"OU=Groups,DC=example,DC=org\"),\n\t\t\tGroupfilter: pulumi.String(\"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\"),\n\t\t\tPath:        pulumi.String(\"ldap\"),\n\t\t\tUpndomain:   pulumi.String(\"EXAMPLE.ORG\"),\n\t\t\tUrl:         pulumi.String(\"ldaps://dc-01.example.org\"),\n\t\t\tUserattr:    pulumi.String(\"sAMAccountName\"),\n\t\t\tUserdn:      pulumi.String(\"OU=Users,OU=Accounts,DC=example,DC=org\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.ldap.AuthBackend;\nimport com.pulumi.vault.ldap.AuthBackendArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var ldap = new AuthBackend(\"ldap\", AuthBackendArgs.builder()        \n            .discoverdn(false)\n            .groupdn(\"OU=Groups,DC=example,DC=org\")\n            .groupfilter(\"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\")\n            .path(\"ldap\")\n            .upndomain(\"EXAMPLE.ORG\")\n            .url(\"ldaps://dc-01.example.org\")\n            .userattr(\"sAMAccountName\")\n            .userdn(\"OU=Users,OU=Accounts,DC=example,DC=org\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  ldap:\n    type: vault:ldap:AuthBackend\n    properties:\n      discoverdn: false\n      groupdn: OU=Groups,DC=example,DC=org\n      groupfilter: (\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\n      path: ldap\n      upndomain: EXAMPLE.ORG\n      url: ldaps://dc-01.example.org\n      userattr: sAMAccountName\n      userdn: OU=Users,OU=Accounts,DC=example,DC=org\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nLDAP authentication backends can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:ldap/authBackend:AuthBackend ldap ldap\n```\n\n ",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The accessor for this auth mount.\n"
                },
                "binddn": {
                    "type": "string",
                    "description": "DN of object to bind when performing user search\n"
                },
                "bindpass": {
                    "type": "string",
                    "description": "Password to use with `binddn` when performing user search\n",
                    "secret": true
                },
                "caseSensitiveNames": {
                    "type": "boolean",
                    "description": "Control case senstivity of objects fetched from LDAP, this is used for object matching in vault\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "Trusted CA to validate TLS certificate\n"
                },
                "clientTlsCert": {
                    "type": "string"
                },
                "clientTlsKey": {
                    "type": "string",
                    "secret": true
                },
                "denyNullBind": {
                    "type": "boolean"
                },
                "description": {
                    "type": "string",
                    "description": "Description for the LDAP auth backend mount\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "discoverdn": {
                    "type": "boolean"
                },
                "groupattr": {
                    "type": "string",
                    "description": "LDAP attribute to follow on objects returned by groupfilter\n"
                },
                "groupdn": {
                    "type": "string",
                    "description": "Base DN under which to perform group search\n"
                },
                "groupfilter": {
                    "type": "string",
                    "description": "Go template used to construct group membership query\n"
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Control whether or TLS certificates must be validated\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the auth method is local only.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to mount the LDAP auth backend under\n"
                },
                "starttls": {
                    "type": "boolean",
                    "description": "Control use of TLS when conecting to LDAP\n"
                },
                "tlsMaxVersion": {
                    "type": "string",
                    "description": "Maximum acceptable version of TLS\n"
                },
                "tlsMinVersion": {
                    "type": "string",
                    "description": "Minimum acceptable version of TLS\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The [maximum number](https://www.vaultproject.io/api-docs/ldap#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                },
                "upndomain": {
                    "type": "string",
                    "description": "The userPrincipalDomain used to construct UPN string\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL of the LDAP server\n"
                },
                "useTokenGroups": {
                    "type": "boolean",
                    "description": "Use the Active Directory tokenGroups constructed attribute of the user to find the group memberships\n"
                },
                "userattr": {
                    "type": "string",
                    "description": "Attribute on user object matching username passed in\n"
                },
                "userdn": {
                    "type": "string",
                    "description": "Base DN under which to perform user search\n"
                },
                "userfilter": {
                    "type": "string",
                    "description": "LDAP user search filter\n"
                },
                "usernameAsAlias": {
                    "type": "boolean",
                    "description": "Force the auth method to use the username passed by the user as the alias name.\n"
                }
            },
            "required": [
                "accessor",
                "binddn",
                "bindpass",
                "caseSensitiveNames",
                "certificate",
                "clientTlsCert",
                "clientTlsKey",
                "denyNullBind",
                "description",
                "discoverdn",
                "groupattr",
                "groupdn",
                "groupfilter",
                "insecureTls",
                "starttls",
                "tlsMaxVersion",
                "tlsMinVersion",
                "upndomain",
                "url",
                "useTokenGroups",
                "userattr",
                "userdn",
                "userfilter",
                "usernameAsAlias"
            ],
            "inputProperties": {
                "binddn": {
                    "type": "string",
                    "description": "DN of object to bind when performing user search\n"
                },
                "bindpass": {
                    "type": "string",
                    "description": "Password to use with `binddn` when performing user search\n",
                    "secret": true
                },
                "caseSensitiveNames": {
                    "type": "boolean",
                    "description": "Control case senstivity of objects fetched from LDAP, this is used for object matching in vault\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "Trusted CA to validate TLS certificate\n"
                },
                "clientTlsCert": {
                    "type": "string"
                },
                "clientTlsKey": {
                    "type": "string",
                    "secret": true
                },
                "denyNullBind": {
                    "type": "boolean"
                },
                "description": {
                    "type": "string",
                    "description": "Description for the LDAP auth backend mount\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "discoverdn": {
                    "type": "boolean"
                },
                "groupattr": {
                    "type": "string",
                    "description": "LDAP attribute to follow on objects returned by groupfilter\n"
                },
                "groupdn": {
                    "type": "string",
                    "description": "Base DN under which to perform group search\n"
                },
                "groupfilter": {
                    "type": "string",
                    "description": "Go template used to construct group membership query\n"
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Control whether or TLS certificates must be validated\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the auth method is local only.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "Path to mount the LDAP auth backend under\n"
                },
                "starttls": {
                    "type": "boolean",
                    "description": "Control use of TLS when conecting to LDAP\n"
                },
                "tlsMaxVersion": {
                    "type": "string",
                    "description": "Maximum acceptable version of TLS\n"
                },
                "tlsMinVersion": {
                    "type": "string",
                    "description": "Minimum acceptable version of TLS\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The [maximum number](https://www.vaultproject.io/api-docs/ldap#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                },
                "upndomain": {
                    "type": "string",
                    "description": "The userPrincipalDomain used to construct UPN string\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL of the LDAP server\n"
                },
                "useTokenGroups": {
                    "type": "boolean",
                    "description": "Use the Active Directory tokenGroups constructed attribute of the user to find the group memberships\n"
                },
                "userattr": {
                    "type": "string",
                    "description": "Attribute on user object matching username passed in\n"
                },
                "userdn": {
                    "type": "string",
                    "description": "Base DN under which to perform user search\n"
                },
                "userfilter": {
                    "type": "string",
                    "description": "LDAP user search filter\n"
                },
                "usernameAsAlias": {
                    "type": "boolean",
                    "description": "Force the auth method to use the username passed by the user as the alias name.\n"
                }
            },
            "requiredInputs": [
                "url"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackend resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The accessor for this auth mount.\n"
                    },
                    "binddn": {
                        "type": "string",
                        "description": "DN of object to bind when performing user search\n"
                    },
                    "bindpass": {
                        "type": "string",
                        "description": "Password to use with `binddn` when performing user search\n",
                        "secret": true
                    },
                    "caseSensitiveNames": {
                        "type": "boolean",
                        "description": "Control case senstivity of objects fetched from LDAP, this is used for object matching in vault\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "Trusted CA to validate TLS certificate\n"
                    },
                    "clientTlsCert": {
                        "type": "string"
                    },
                    "clientTlsKey": {
                        "type": "string",
                        "secret": true
                    },
                    "denyNullBind": {
                        "type": "boolean"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description for the LDAP auth backend mount\n"
                    },
                    "disableRemount": {
                        "type": "boolean",
                        "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                    },
                    "discoverdn": {
                        "type": "boolean"
                    },
                    "groupattr": {
                        "type": "string",
                        "description": "LDAP attribute to follow on objects returned by groupfilter\n"
                    },
                    "groupdn": {
                        "type": "string",
                        "description": "Base DN under which to perform group search\n"
                    },
                    "groupfilter": {
                        "type": "string",
                        "description": "Go template used to construct group membership query\n"
                    },
                    "insecureTls": {
                        "type": "boolean",
                        "description": "Control whether or TLS certificates must be validated\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Specifies if the auth method is local only.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "Path to mount the LDAP auth backend under\n"
                    },
                    "starttls": {
                        "type": "boolean",
                        "description": "Control use of TLS when conecting to LDAP\n"
                    },
                    "tlsMaxVersion": {
                        "type": "string",
                        "description": "Maximum acceptable version of TLS\n"
                    },
                    "tlsMinVersion": {
                        "type": "string",
                        "description": "Minimum acceptable version of TLS\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The [maximum number](https://www.vaultproject.io/api-docs/ldap#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    },
                    "upndomain": {
                        "type": "string",
                        "description": "The userPrincipalDomain used to construct UPN string\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "The URL of the LDAP server\n"
                    },
                    "useTokenGroups": {
                        "type": "boolean",
                        "description": "Use the Active Directory tokenGroups constructed attribute of the user to find the group memberships\n"
                    },
                    "userattr": {
                        "type": "string",
                        "description": "Attribute on user object matching username passed in\n"
                    },
                    "userdn": {
                        "type": "string",
                        "description": "Base DN under which to perform user search\n"
                    },
                    "userfilter": {
                        "type": "string",
                        "description": "LDAP user search filter\n"
                    },
                    "usernameAsAlias": {
                        "type": "boolean",
                        "description": "Force the auth method to use the username passed by the user as the alias name.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:ldap/authBackendGroup:AuthBackendGroup": {
            "description": "Provides a resource to create a group in an [LDAP auth backend within Vault](https://www.vaultproject.io/docs/auth/ldap.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst ldap = new vault.ldap.AuthBackend(\"ldap\", {\n    path: \"ldap\",\n    url: \"ldaps://dc-01.example.org\",\n    userdn: \"OU=Users,OU=Accounts,DC=example,DC=org\",\n    userattr: \"sAMAccountName\",\n    upndomain: \"EXAMPLE.ORG\",\n    discoverdn: false,\n    groupdn: \"OU=Groups,DC=example,DC=org\",\n    groupfilter: \"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n});\nconst group = new vault.ldap.AuthBackendGroup(\"group\", {\n    groupname: \"dba\",\n    policies: [\"dba\"],\n    backend: ldap.path,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nldap = vault.ldap.AuthBackend(\"ldap\",\n    path=\"ldap\",\n    url=\"ldaps://dc-01.example.org\",\n    userdn=\"OU=Users,OU=Accounts,DC=example,DC=org\",\n    userattr=\"sAMAccountName\",\n    upndomain=\"EXAMPLE.ORG\",\n    discoverdn=False,\n    groupdn=\"OU=Groups,DC=example,DC=org\",\n    groupfilter=\"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\")\ngroup = vault.ldap.AuthBackendGroup(\"group\",\n    groupname=\"dba\",\n    policies=[\"dba\"],\n    backend=ldap.path)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ldap = new Vault.Ldap.AuthBackend(\"ldap\", new()\n    {\n        Path = \"ldap\",\n        Url = \"ldaps://dc-01.example.org\",\n        Userdn = \"OU=Users,OU=Accounts,DC=example,DC=org\",\n        Userattr = \"sAMAccountName\",\n        Upndomain = \"EXAMPLE.ORG\",\n        Discoverdn = false,\n        Groupdn = \"OU=Groups,DC=example,DC=org\",\n        Groupfilter = \"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n    });\n\n    var @group = new Vault.Ldap.AuthBackendGroup(\"group\", new()\n    {\n        Groupname = \"dba\",\n        Policies = new[]\n        {\n            \"dba\",\n        },\n        Backend = ldap.Path,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tldap, err := ldap.NewAuthBackend(ctx, \"ldap\", \u0026ldap.AuthBackendArgs{\n\t\t\tPath:        pulumi.String(\"ldap\"),\n\t\t\tUrl:         pulumi.String(\"ldaps://dc-01.example.org\"),\n\t\t\tUserdn:      pulumi.String(\"OU=Users,OU=Accounts,DC=example,DC=org\"),\n\t\t\tUserattr:    pulumi.String(\"sAMAccountName\"),\n\t\t\tUpndomain:   pulumi.String(\"EXAMPLE.ORG\"),\n\t\t\tDiscoverdn:  pulumi.Bool(false),\n\t\t\tGroupdn:     pulumi.String(\"OU=Groups,DC=example,DC=org\"),\n\t\t\tGroupfilter: pulumi.String(\"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewAuthBackendGroup(ctx, \"group\", \u0026ldap.AuthBackendGroupArgs{\n\t\t\tGroupname: pulumi.String(\"dba\"),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dba\"),\n\t\t\t},\n\t\t\tBackend: ldap.Path,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.ldap.AuthBackend;\nimport com.pulumi.vault.ldap.AuthBackendArgs;\nimport com.pulumi.vault.ldap.AuthBackendGroup;\nimport com.pulumi.vault.ldap.AuthBackendGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var ldap = new AuthBackend(\"ldap\", AuthBackendArgs.builder()        \n            .path(\"ldap\")\n            .url(\"ldaps://dc-01.example.org\")\n            .userdn(\"OU=Users,OU=Accounts,DC=example,DC=org\")\n            .userattr(\"sAMAccountName\")\n            .upndomain(\"EXAMPLE.ORG\")\n            .discoverdn(false)\n            .groupdn(\"OU=Groups,DC=example,DC=org\")\n            .groupfilter(\"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\")\n            .build());\n\n        var group = new AuthBackendGroup(\"group\", AuthBackendGroupArgs.builder()        \n            .groupname(\"dba\")\n            .policies(\"dba\")\n            .backend(ldap.path())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  ldap:\n    type: vault:ldap:AuthBackend\n    properties:\n      path: ldap\n      url: ldaps://dc-01.example.org\n      userdn: OU=Users,OU=Accounts,DC=example,DC=org\n      userattr: sAMAccountName\n      upndomain: EXAMPLE.ORG\n      discoverdn: false\n      groupdn: OU=Groups,DC=example,DC=org\n      groupfilter: (\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\n  group:\n    type: vault:ldap:AuthBackendGroup\n    properties:\n      groupname: dba\n      policies:\n        - dba\n      backend: ${ldap.path}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nLDAP authentication backend groups can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:ldap/authBackendGroup:AuthBackendGroup foo auth/ldap/groups/foo\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Path to the authentication backend\n"
                },
                "groupname": {
                    "type": "string",
                    "description": "The LDAP groupname\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Policies which should be granted to members of the group\n"
                }
            },
            "required": [
                "groupname",
                "policies"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Path to the authentication backend\n",
                    "willReplaceOnChanges": true
                },
                "groupname": {
                    "type": "string",
                    "description": "The LDAP groupname\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Policies which should be granted to members of the group\n"
                }
            },
            "requiredInputs": [
                "groupname"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendGroup resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Path to the authentication backend\n",
                        "willReplaceOnChanges": true
                    },
                    "groupname": {
                        "type": "string",
                        "description": "The LDAP groupname\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Policies which should be granted to members of the group\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:ldap/authBackendUser:AuthBackendUser": {
            "description": "Provides a resource to create a user in an [LDAP auth backend within Vault](https://www.vaultproject.io/docs/auth/ldap.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst ldap = new vault.ldap.AuthBackend(\"ldap\", {\n    path: \"ldap\",\n    url: \"ldaps://dc-01.example.org\",\n    userdn: \"OU=Users,OU=Accounts,DC=example,DC=org\",\n    userattr: \"sAMAccountName\",\n    upndomain: \"EXAMPLE.ORG\",\n    discoverdn: false,\n    groupdn: \"OU=Groups,DC=example,DC=org\",\n    groupfilter: \"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n});\nconst user = new vault.ldap.AuthBackendUser(\"user\", {\n    username: \"test-user\",\n    policies: [\n        \"dba\",\n        \"sysops\",\n    ],\n    backend: ldap.path,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nldap = vault.ldap.AuthBackend(\"ldap\",\n    path=\"ldap\",\n    url=\"ldaps://dc-01.example.org\",\n    userdn=\"OU=Users,OU=Accounts,DC=example,DC=org\",\n    userattr=\"sAMAccountName\",\n    upndomain=\"EXAMPLE.ORG\",\n    discoverdn=False,\n    groupdn=\"OU=Groups,DC=example,DC=org\",\n    groupfilter=\"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\")\nuser = vault.ldap.AuthBackendUser(\"user\",\n    username=\"test-user\",\n    policies=[\n        \"dba\",\n        \"sysops\",\n    ],\n    backend=ldap.path)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ldap = new Vault.Ldap.AuthBackend(\"ldap\", new()\n    {\n        Path = \"ldap\",\n        Url = \"ldaps://dc-01.example.org\",\n        Userdn = \"OU=Users,OU=Accounts,DC=example,DC=org\",\n        Userattr = \"sAMAccountName\",\n        Upndomain = \"EXAMPLE.ORG\",\n        Discoverdn = false,\n        Groupdn = \"OU=Groups,DC=example,DC=org\",\n        Groupfilter = \"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n    });\n\n    var user = new Vault.Ldap.AuthBackendUser(\"user\", new()\n    {\n        Username = \"test-user\",\n        Policies = new[]\n        {\n            \"dba\",\n            \"sysops\",\n        },\n        Backend = ldap.Path,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tldap, err := ldap.NewAuthBackend(ctx, \"ldap\", \u0026ldap.AuthBackendArgs{\n\t\t\tPath:        pulumi.String(\"ldap\"),\n\t\t\tUrl:         pulumi.String(\"ldaps://dc-01.example.org\"),\n\t\t\tUserdn:      pulumi.String(\"OU=Users,OU=Accounts,DC=example,DC=org\"),\n\t\t\tUserattr:    pulumi.String(\"sAMAccountName\"),\n\t\t\tUpndomain:   pulumi.String(\"EXAMPLE.ORG\"),\n\t\t\tDiscoverdn:  pulumi.Bool(false),\n\t\t\tGroupdn:     pulumi.String(\"OU=Groups,DC=example,DC=org\"),\n\t\t\tGroupfilter: pulumi.String(\"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewAuthBackendUser(ctx, \"user\", \u0026ldap.AuthBackendUserArgs{\n\t\t\tUsername: pulumi.String(\"test-user\"),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dba\"),\n\t\t\t\tpulumi.String(\"sysops\"),\n\t\t\t},\n\t\t\tBackend: ldap.Path,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.ldap.AuthBackend;\nimport com.pulumi.vault.ldap.AuthBackendArgs;\nimport com.pulumi.vault.ldap.AuthBackendUser;\nimport com.pulumi.vault.ldap.AuthBackendUserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var ldap = new AuthBackend(\"ldap\", AuthBackendArgs.builder()        \n            .path(\"ldap\")\n            .url(\"ldaps://dc-01.example.org\")\n            .userdn(\"OU=Users,OU=Accounts,DC=example,DC=org\")\n            .userattr(\"sAMAccountName\")\n            .upndomain(\"EXAMPLE.ORG\")\n            .discoverdn(false)\n            .groupdn(\"OU=Groups,DC=example,DC=org\")\n            .groupfilter(\"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\")\n            .build());\n\n        var user = new AuthBackendUser(\"user\", AuthBackendUserArgs.builder()        \n            .username(\"test-user\")\n            .policies(            \n                \"dba\",\n                \"sysops\")\n            .backend(ldap.path())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  ldap:\n    type: vault:ldap:AuthBackend\n    properties:\n      path: ldap\n      url: ldaps://dc-01.example.org\n      userdn: OU=Users,OU=Accounts,DC=example,DC=org\n      userattr: sAMAccountName\n      upndomain: EXAMPLE.ORG\n      discoverdn: false\n      groupdn: OU=Groups,DC=example,DC=org\n      groupfilter: (\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\n  user:\n    type: vault:ldap:AuthBackendUser\n    properties:\n      username: test-user\n      policies:\n        - dba\n        - sysops\n      backend: ${ldap.path}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nLDAP authentication backend users can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:ldap/authBackendUser:AuthBackendUser foo auth/ldap/users/foo\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Path to the authentication backend\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Override LDAP groups which should be granted to user\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Policies which should be granted to user\n"
                },
                "username": {
                    "type": "string",
                    "description": "The LDAP username\n"
                }
            },
            "required": [
                "groups",
                "policies",
                "username"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Path to the authentication backend\n",
                    "willReplaceOnChanges": true
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Override LDAP groups which should be granted to user\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Policies which should be granted to user\n"
                },
                "username": {
                    "type": "string",
                    "description": "The LDAP username\n"
                }
            },
            "requiredInputs": [
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendUser resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Path to the authentication backend\n",
                        "willReplaceOnChanges": true
                    },
                    "groups": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Override LDAP groups which should be granted to user\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Policies which should be granted to user\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "The LDAP username\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:ldap/secretBackend:SecretBackend": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst config = new vault.ldap.SecretBackend(\"config\", {\n    binddn: \"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\",\n    bindpass: \"SuperSecretPassw0rd\",\n    insecureTls: true,\n    path: \"my-custom-ldap\",\n    url: \"ldaps://localhost\",\n    userdn: \"CN=Users,DC=corp,DC=example,DC=net\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nconfig = vault.ldap.SecretBackend(\"config\",\n    binddn=\"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\",\n    bindpass=\"SuperSecretPassw0rd\",\n    insecure_tls=True,\n    path=\"my-custom-ldap\",\n    url=\"ldaps://localhost\",\n    userdn=\"CN=Users,DC=corp,DC=example,DC=net\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Vault.Ldap.SecretBackend(\"config\", new()\n    {\n        Binddn = \"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\",\n        Bindpass = \"SuperSecretPassw0rd\",\n        InsecureTls = true,\n        Path = \"my-custom-ldap\",\n        Url = \"ldaps://localhost\",\n        Userdn = \"CN=Users,DC=corp,DC=example,DC=net\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := ldap.NewSecretBackend(ctx, \"config\", \u0026ldap.SecretBackendArgs{\n\t\t\tBinddn:      pulumi.String(\"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\"),\n\t\t\tBindpass:    pulumi.String(\"SuperSecretPassw0rd\"),\n\t\t\tInsecureTls: pulumi.Bool(true),\n\t\t\tPath:        pulumi.String(\"my-custom-ldap\"),\n\t\t\tUrl:         pulumi.String(\"ldaps://localhost\"),\n\t\t\tUserdn:      pulumi.String(\"CN=Users,DC=corp,DC=example,DC=net\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.ldap.SecretBackend;\nimport com.pulumi.vault.ldap.SecretBackendArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var config = new SecretBackend(\"config\", SecretBackendArgs.builder()        \n            .binddn(\"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\")\n            .bindpass(\"SuperSecretPassw0rd\")\n            .insecureTls(\"true\")\n            .path(\"my-custom-ldap\")\n            .url(\"ldaps://localhost\")\n            .userdn(\"CN=Users,DC=corp,DC=example,DC=net\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  config:\n    type: vault:ldap:SecretBackend\n    properties:\n      binddn: CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\n      bindpass: SuperSecretPassw0rd\n      insecureTls: true\n      path: my-custom-ldap\n      url: ldaps://localhost\n      userdn: CN=Users,DC=corp,DC=example,DC=net\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nLDAP secret backend can be imported using the `${mount}/config`, e.g.\n\n```sh\n $ pulumi import vault:ldap/secretBackend:SecretBackend config ldap/config\n```\n\n ",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "Accessor of the mount\n"
                },
                "allowedManagedKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of managed key registry entry names that the mount in question is allowed to access\n"
                },
                "auditNonHmacRequestKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the request data object.\n"
                },
                "auditNonHmacResponseKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the response data object.\n"
                },
                "binddn": {
                    "type": "string",
                    "description": "Distinguished name of object to bind when performing user and group search.\n"
                },
                "bindpass": {
                    "type": "string",
                    "description": "Password to use along with binddn when performing user search.\n",
                    "secret": true
                },
                "certificate": {
                    "type": "string",
                    "description": "CA certificate to use when verifying LDAP server certificate, must be\nx509 PEM encoded.\n"
                },
                "clientTlsCert": {
                    "type": "string",
                    "description": "Client certificate to provide to the LDAP server, must be x509 PEM encoded.\n",
                    "secret": true
                },
                "clientTlsKey": {
                    "type": "string",
                    "description": "Client certificate key to provide to the LDAP server, must be x509 PEM encoded.\n",
                    "secret": true
                },
                "connectionTimeout": {
                    "type": "integer",
                    "description": "Timeout, in seconds, when attempting to connect to the LDAP server before trying\nthe next URL in the configuration.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Default lease duration for secrets in seconds.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the Active Directory backend.\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\n"
                },
                "externalEntropyAccess": {
                    "type": "boolean",
                    "description": "Enable the secrets engine to access Vault's external entropy source\n"
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Skip LDAP server SSL Certificate verification. This is not recommended for production.\nDefaults to `false`.\n"
                },
                "length": {
                    "type": "integer",
                    "description": "**Deprecated** use `password_policy`. The desired length of passwords that Vault generates.\n*Mutually exclusive with `password_policy` on vault-1.11+*\n",
                    "deprecationMessage": "Length is deprecated and password_policy should be used with Vault \u003e= 1.5."
                },
                "local": {
                    "type": "boolean",
                    "description": "Mark the secrets engine as local-only. Local engines are not replicated or removed by\nreplication.Tolerance duration to use when checking the last rotation time.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Maximum possible lease duration for secrets in seconds.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "options": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies mount type specific options that are passed to the backend\n"
                },
                "passwordPolicy": {
                    "type": "string",
                    "description": "Name of the password policy to use to generate passwords.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `ldap`.\n"
                },
                "requestTimeout": {
                    "type": "integer",
                    "description": "Timeout, in seconds, for the connection when making requests against the server\nbefore returning back an error.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The LDAP schema to use when storing entry passwords. Valid schemas include openldap, ad, and racf.\n"
                },
                "sealWrap": {
                    "type": "boolean",
                    "description": "Enable seal wrapping for the mount, causing values stored by the mount to be wrapped by the seal's encryption capability\n"
                },
                "starttls": {
                    "type": "boolean",
                    "description": "Issue a StartTLS command after establishing unencrypted connection.\n"
                },
                "upndomain": {
                    "type": "string",
                    "description": "Enables userPrincipalDomain login with [username]@UPNDomain.\n"
                },
                "url": {
                    "type": "string",
                    "description": "LDAP URL to connect to. Multiple URLs can be specified by concatenating\nthem with commas; they will be tried in-order. Defaults to `ldap://127.0.0.1`.\n"
                },
                "userattr": {
                    "type": "string",
                    "description": "Attribute used when searching users. Defaults to `cn`.\n"
                },
                "userdn": {
                    "type": "string",
                    "description": "LDAP domain to use for users (eg: ou=People,dc=example,dc=org)`.\n"
                }
            },
            "required": [
                "accessor",
                "auditNonHmacRequestKeys",
                "auditNonHmacResponseKeys",
                "binddn",
                "bindpass",
                "defaultLeaseTtlSeconds",
                "length",
                "maxLeaseTtlSeconds",
                "requestTimeout",
                "schema",
                "sealWrap",
                "starttls",
                "upndomain",
                "url",
                "userattr"
            ],
            "inputProperties": {
                "allowedManagedKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of managed key registry entry names that the mount in question is allowed to access\n",
                    "willReplaceOnChanges": true
                },
                "auditNonHmacRequestKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the request data object.\n"
                },
                "auditNonHmacResponseKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the response data object.\n"
                },
                "binddn": {
                    "type": "string",
                    "description": "Distinguished name of object to bind when performing user and group search.\n"
                },
                "bindpass": {
                    "type": "string",
                    "description": "Password to use along with binddn when performing user search.\n",
                    "secret": true
                },
                "certificate": {
                    "type": "string",
                    "description": "CA certificate to use when verifying LDAP server certificate, must be\nx509 PEM encoded.\n"
                },
                "clientTlsCert": {
                    "type": "string",
                    "description": "Client certificate to provide to the LDAP server, must be x509 PEM encoded.\n",
                    "secret": true
                },
                "clientTlsKey": {
                    "type": "string",
                    "description": "Client certificate key to provide to the LDAP server, must be x509 PEM encoded.\n",
                    "secret": true
                },
                "connectionTimeout": {
                    "type": "integer",
                    "description": "Timeout, in seconds, when attempting to connect to the LDAP server before trying\nthe next URL in the configuration.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Default lease duration for secrets in seconds.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the Active Directory backend.\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\n"
                },
                "externalEntropyAccess": {
                    "type": "boolean",
                    "description": "Enable the secrets engine to access Vault's external entropy source\n",
                    "willReplaceOnChanges": true
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Skip LDAP server SSL Certificate verification. This is not recommended for production.\nDefaults to `false`.\n"
                },
                "length": {
                    "type": "integer",
                    "description": "**Deprecated** use `password_policy`. The desired length of passwords that Vault generates.\n*Mutually exclusive with `password_policy` on vault-1.11+*\n",
                    "deprecationMessage": "Length is deprecated and password_policy should be used with Vault \u003e= 1.5."
                },
                "local": {
                    "type": "boolean",
                    "description": "Mark the secrets engine as local-only. Local engines are not replicated or removed by\nreplication.Tolerance duration to use when checking the last rotation time.\n",
                    "willReplaceOnChanges": true
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Maximum possible lease duration for secrets in seconds.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "options": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies mount type specific options that are passed to the backend\n"
                },
                "passwordPolicy": {
                    "type": "string",
                    "description": "Name of the password policy to use to generate passwords.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `ldap`.\n"
                },
                "requestTimeout": {
                    "type": "integer",
                    "description": "Timeout, in seconds, for the connection when making requests against the server\nbefore returning back an error.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The LDAP schema to use when storing entry passwords. Valid schemas include openldap, ad, and racf.\n"
                },
                "sealWrap": {
                    "type": "boolean",
                    "description": "Enable seal wrapping for the mount, causing values stored by the mount to be wrapped by the seal's encryption capability\n",
                    "willReplaceOnChanges": true
                },
                "starttls": {
                    "type": "boolean",
                    "description": "Issue a StartTLS command after establishing unencrypted connection.\n"
                },
                "upndomain": {
                    "type": "string",
                    "description": "Enables userPrincipalDomain login with [username]@UPNDomain.\n"
                },
                "url": {
                    "type": "string",
                    "description": "LDAP URL to connect to. Multiple URLs can be specified by concatenating\nthem with commas; they will be tried in-order. Defaults to `ldap://127.0.0.1`.\n"
                },
                "userattr": {
                    "type": "string",
                    "description": "Attribute used when searching users. Defaults to `cn`.\n"
                },
                "userdn": {
                    "type": "string",
                    "description": "LDAP domain to use for users (eg: ou=People,dc=example,dc=org)`.\n"
                }
            },
            "requiredInputs": [
                "binddn",
                "bindpass"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackend resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "Accessor of the mount\n"
                    },
                    "allowedManagedKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of managed key registry entry names that the mount in question is allowed to access\n",
                        "willReplaceOnChanges": true
                    },
                    "auditNonHmacRequestKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the request data object.\n"
                    },
                    "auditNonHmacResponseKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the response data object.\n"
                    },
                    "binddn": {
                        "type": "string",
                        "description": "Distinguished name of object to bind when performing user and group search.\n"
                    },
                    "bindpass": {
                        "type": "string",
                        "description": "Password to use along with binddn when performing user search.\n",
                        "secret": true
                    },
                    "certificate": {
                        "type": "string",
                        "description": "CA certificate to use when verifying LDAP server certificate, must be\nx509 PEM encoded.\n"
                    },
                    "clientTlsCert": {
                        "type": "string",
                        "description": "Client certificate to provide to the LDAP server, must be x509 PEM encoded.\n",
                        "secret": true
                    },
                    "clientTlsKey": {
                        "type": "string",
                        "description": "Client certificate key to provide to the LDAP server, must be x509 PEM encoded.\n",
                        "secret": true
                    },
                    "connectionTimeout": {
                        "type": "integer",
                        "description": "Timeout, in seconds, when attempting to connect to the LDAP server before trying\nthe next URL in the configuration.\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "Default lease duration for secrets in seconds.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Human-friendly description of the mount for the Active Directory backend.\n"
                    },
                    "disableRemount": {
                        "type": "boolean",
                        "description": "If set, opts out of mount migration on path updates.\n"
                    },
                    "externalEntropyAccess": {
                        "type": "boolean",
                        "description": "Enable the secrets engine to access Vault's external entropy source\n",
                        "willReplaceOnChanges": true
                    },
                    "insecureTls": {
                        "type": "boolean",
                        "description": "Skip LDAP server SSL Certificate verification. This is not recommended for production.\nDefaults to `false`.\n"
                    },
                    "length": {
                        "type": "integer",
                        "description": "**Deprecated** use `password_policy`. The desired length of passwords that Vault generates.\n*Mutually exclusive with `password_policy` on vault-1.11+*\n",
                        "deprecationMessage": "Length is deprecated and password_policy should be used with Vault \u003e= 1.5."
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Mark the secrets engine as local-only. Local engines are not replicated or removed by\nreplication.Tolerance duration to use when checking the last rotation time.\n",
                        "willReplaceOnChanges": true
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "Maximum possible lease duration for secrets in seconds.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "options": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Specifies mount type specific options that are passed to the backend\n"
                    },
                    "passwordPolicy": {
                        "type": "string",
                        "description": "Name of the password policy to use to generate passwords.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `ldap`.\n"
                    },
                    "requestTimeout": {
                        "type": "integer",
                        "description": "Timeout, in seconds, for the connection when making requests against the server\nbefore returning back an error.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The LDAP schema to use when storing entry passwords. Valid schemas include openldap, ad, and racf.\n"
                    },
                    "sealWrap": {
                        "type": "boolean",
                        "description": "Enable seal wrapping for the mount, causing values stored by the mount to be wrapped by the seal's encryption capability\n",
                        "willReplaceOnChanges": true
                    },
                    "starttls": {
                        "type": "boolean",
                        "description": "Issue a StartTLS command after establishing unencrypted connection.\n"
                    },
                    "upndomain": {
                        "type": "string",
                        "description": "Enables userPrincipalDomain login with [username]@UPNDomain.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "LDAP URL to connect to. Multiple URLs can be specified by concatenating\nthem with commas; they will be tried in-order. Defaults to `ldap://127.0.0.1`.\n"
                    },
                    "userattr": {
                        "type": "string",
                        "description": "Attribute used when searching users. Defaults to `cn`.\n"
                    },
                    "userdn": {
                        "type": "string",
                        "description": "LDAP domain to use for users (eg: ou=People,dc=example,dc=org)`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:ldap/secretBackendDynamicRole:SecretBackendDynamicRole": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst config = new vault.ldap.SecretBackend(\"config\", {\n    path: \"my-custom-ldap\",\n    binddn: \"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\",\n    bindpass: \"SuperSecretPassw0rd\",\n    url: \"ldaps://localhost\",\n    userdn: \"CN=Users,DC=corp,DC=example,DC=net\",\n});\nconst role = new vault.ldap.SecretBackendDynamicRole(\"role\", {\n    mount: config.path,\n    roleName: \"alice\",\n    creationLdif: `dn: cn={{.Username}},ou=users,dc=learn,dc=example\nobjectClass: person\nobjectClass: top\ncn: learn\nsn: {{.Password | utf16le | base64}}\nmemberOf: cn=dev,ou=groups,dc=learn,dc=example\nuserPassword: {{.Password}}\n`,\n    deletionLdif: `dn: cn={{.Username}},ou=users,dc=learn,dc=example\nchangetype: delete\n  rollback_ldif = \u003c\u003cEOT\ndn: cn={{.Username}},ou=users,dc=learn,dc=example\nchangetype: delete\n`,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nconfig = vault.ldap.SecretBackend(\"config\",\n    path=\"my-custom-ldap\",\n    binddn=\"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\",\n    bindpass=\"SuperSecretPassw0rd\",\n    url=\"ldaps://localhost\",\n    userdn=\"CN=Users,DC=corp,DC=example,DC=net\")\nrole = vault.ldap.SecretBackendDynamicRole(\"role\",\n    mount=config.path,\n    role_name=\"alice\",\n    creation_ldif=\"\"\"dn: cn={{.Username}},ou=users,dc=learn,dc=example\nobjectClass: person\nobjectClass: top\ncn: learn\nsn: {{.Password | utf16le | base64}}\nmemberOf: cn=dev,ou=groups,dc=learn,dc=example\nuserPassword: {{.Password}}\n\"\"\",\n    deletion_ldif=\"\"\"dn: cn={{.Username}},ou=users,dc=learn,dc=example\nchangetype: delete\n  rollback_ldif = \u003c\u003cEOT\ndn: cn={{.Username}},ou=users,dc=learn,dc=example\nchangetype: delete\n\"\"\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Vault.Ldap.SecretBackend(\"config\", new()\n    {\n        Path = \"my-custom-ldap\",\n        Binddn = \"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\",\n        Bindpass = \"SuperSecretPassw0rd\",\n        Url = \"ldaps://localhost\",\n        Userdn = \"CN=Users,DC=corp,DC=example,DC=net\",\n    });\n\n    var role = new Vault.Ldap.SecretBackendDynamicRole(\"role\", new()\n    {\n        Mount = config.Path,\n        RoleName = \"alice\",\n        CreationLdif = @\"dn: cn={{.Username}},ou=users,dc=learn,dc=example\nobjectClass: person\nobjectClass: top\ncn: learn\nsn: {{.Password | utf16le | base64}}\nmemberOf: cn=dev,ou=groups,dc=learn,dc=example\nuserPassword: {{.Password}}\n\",\n        DeletionLdif = @\"dn: cn={{.Username}},ou=users,dc=learn,dc=example\nchangetype: delete\n  rollback_ldif = \u003c\u003cEOT\ndn: cn={{.Username}},ou=users,dc=learn,dc=example\nchangetype: delete\n\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfig, err := ldap.NewSecretBackend(ctx, \"config\", \u0026ldap.SecretBackendArgs{\n\t\t\tPath:     pulumi.String(\"my-custom-ldap\"),\n\t\t\tBinddn:   pulumi.String(\"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\"),\n\t\t\tBindpass: pulumi.String(\"SuperSecretPassw0rd\"),\n\t\t\tUrl:      pulumi.String(\"ldaps://localhost\"),\n\t\t\tUserdn:   pulumi.String(\"CN=Users,DC=corp,DC=example,DC=net\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewSecretBackendDynamicRole(ctx, \"role\", \u0026ldap.SecretBackendDynamicRoleArgs{\n\t\t\tMount:        config.Path,\n\t\t\tRoleName:     pulumi.String(\"alice\"),\n\t\t\tCreationLdif: pulumi.String(\"dn: cn={{.Username}},ou=users,dc=learn,dc=example\\nobjectClass: person\\nobjectClass: top\\ncn: learn\\nsn: {{.Password | utf16le | base64}}\\nmemberOf: cn=dev,ou=groups,dc=learn,dc=example\\nuserPassword: {{.Password}}\\n\"),\n\t\t\tDeletionLdif: pulumi.String(\"dn: cn={{.Username}},ou=users,dc=learn,dc=example\\nchangetype: delete\\n  rollback_ldif = \u003c\u003cEOT\\ndn: cn={{.Username}},ou=users,dc=learn,dc=example\\nchangetype: delete\\n\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.ldap.SecretBackend;\nimport com.pulumi.vault.ldap.SecretBackendArgs;\nimport com.pulumi.vault.ldap.SecretBackendDynamicRole;\nimport com.pulumi.vault.ldap.SecretBackendDynamicRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var config = new SecretBackend(\"config\", SecretBackendArgs.builder()        \n            .path(\"my-custom-ldap\")\n            .binddn(\"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\")\n            .bindpass(\"SuperSecretPassw0rd\")\n            .url(\"ldaps://localhost\")\n            .userdn(\"CN=Users,DC=corp,DC=example,DC=net\")\n            .build());\n\n        var role = new SecretBackendDynamicRole(\"role\", SecretBackendDynamicRoleArgs.builder()        \n            .mount(config.path())\n            .roleName(\"alice\")\n            .creationLdif(\"\"\"\ndn: cn={{.Username}},ou=users,dc=learn,dc=example\nobjectClass: person\nobjectClass: top\ncn: learn\nsn: {{.Password | utf16le | base64}}\nmemberOf: cn=dev,ou=groups,dc=learn,dc=example\nuserPassword: {{.Password}}\n            \"\"\")\n            .deletionLdif(\"\"\"\ndn: cn={{.Username}},ou=users,dc=learn,dc=example\nchangetype: delete\n  rollback_ldif = \u003c\u003cEOT\ndn: cn={{.Username}},ou=users,dc=learn,dc=example\nchangetype: delete\n            \"\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  config:\n    type: vault:ldap:SecretBackend\n    properties:\n      path: my-custom-ldap\n      binddn: CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\n      bindpass: SuperSecretPassw0rd\n      url: ldaps://localhost\n      userdn: CN=Users,DC=corp,DC=example,DC=net\n  role:\n    type: vault:ldap:SecretBackendDynamicRole\n    properties:\n      mount: ${config.path}\n      roleName: alice\n      creationLdif: |\n        dn: cn={{.Username}},ou=users,dc=learn,dc=example\n        objectClass: person\n        objectClass: top\n        cn: learn\n        sn: {{.Password | utf16le | base64}}\n        memberOf: cn=dev,ou=groups,dc=learn,dc=example\n        userPassword: {{.Password}}\n      deletionLdif: |\n        dn: cn={{.Username}},ou=users,dc=learn,dc=example\n        changetype: delete\n          rollback_ldif = \u003c\u003cEOT\n        dn: cn={{.Username}},ou=users,dc=learn,dc=example\n        changetype: delete\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nLDAP secret backend dynamic role can be imported using the full path to the role of the form`\u003cmount_path\u003e/dynamic-role/\u003crole_name\u003e` e.g.\n\n```sh\n $ pulumi import vault:ldap/secretBackendDynamicRole:SecretBackendDynamicRole role ldap/role/dynamic-role\n```\n\n ",
            "properties": {
                "creationLdif": {
                    "type": "string",
                    "description": "A templatized LDIF string used to create a user\naccount. This may contain multiple LDIF entries. The `creation_ldif` can also\nbe used to add the user account to an existing group. All LDIF entries are\nperformed in order. If Vault encounters an error while executing the\n`creation_ldif` it will stop at the first error and not execute any remaining\nLDIF entries. If an error occurs and `rollback_ldif` is specified, the LDIF\nentries in `rollback_ldif` will be executed. See `rollback_ldif` for more\ndetails. This field may optionally be provided as a base64 encoded string.\n"
                },
                "defaultTtl": {
                    "type": "integer",
                    "description": "Specifies the TTL for the leases associated with this role.\n"
                },
                "deletionLdif": {
                    "type": "string",
                    "description": "A templatized LDIF string used to delete the\nuser account once its TTL has expired. This may contain multiple LDIF\nentries. All LDIF entries are performed in order. If Vault encounters an\nerror while executing an entry in the `deletion_ldif` it will attempt to\ncontinue executing any remaining entries. This field may optionally be\nprovided as a base64 encoded string.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "Specifies the maximum TTL for the leases associated with this role.\n"
                },
                "mount": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `ldap`.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "Name of the role.\n"
                },
                "rollbackLdif": {
                    "type": "string",
                    "description": "A templatized LDIF string used to attempt to\nrollback any changes in the event that execution of the `creation_ldif` results\nin an error. This may contain multiple LDIF entries. All LDIF entries are\nperformed in order. If Vault encounters an error while executing an entry in\nthe `rollback_ldif` it will attempt to continue executing any remaining\nentries. This field may optionally be provided as a base64 encoded string.\n"
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "A template used to generate a dynamic\nusername. This will be used to fill in the `.Username` field within the\n`creation_ldif` string.\n"
                }
            },
            "required": [
                "creationLdif",
                "deletionLdif",
                "roleName"
            ],
            "inputProperties": {
                "creationLdif": {
                    "type": "string",
                    "description": "A templatized LDIF string used to create a user\naccount. This may contain multiple LDIF entries. The `creation_ldif` can also\nbe used to add the user account to an existing group. All LDIF entries are\nperformed in order. If Vault encounters an error while executing the\n`creation_ldif` it will stop at the first error and not execute any remaining\nLDIF entries. If an error occurs and `rollback_ldif` is specified, the LDIF\nentries in `rollback_ldif` will be executed. See `rollback_ldif` for more\ndetails. This field may optionally be provided as a base64 encoded string.\n"
                },
                "defaultTtl": {
                    "type": "integer",
                    "description": "Specifies the TTL for the leases associated with this role.\n"
                },
                "deletionLdif": {
                    "type": "string",
                    "description": "A templatized LDIF string used to delete the\nuser account once its TTL has expired. This may contain multiple LDIF\nentries. All LDIF entries are performed in order. If Vault encounters an\nerror while executing an entry in the `deletion_ldif` it will attempt to\ncontinue executing any remaining entries. This field may optionally be\nprovided as a base64 encoded string.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "Specifies the maximum TTL for the leases associated with this role.\n"
                },
                "mount": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `ldap`.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "roleName": {
                    "type": "string",
                    "description": "Name of the role.\n",
                    "willReplaceOnChanges": true
                },
                "rollbackLdif": {
                    "type": "string",
                    "description": "A templatized LDIF string used to attempt to\nrollback any changes in the event that execution of the `creation_ldif` results\nin an error. This may contain multiple LDIF entries. All LDIF entries are\nperformed in order. If Vault encounters an error while executing an entry in\nthe `rollback_ldif` it will attempt to continue executing any remaining\nentries. This field may optionally be provided as a base64 encoded string.\n"
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "A template used to generate a dynamic\nusername. This will be used to fill in the `.Username` field within the\n`creation_ldif` string.\n"
                }
            },
            "requiredInputs": [
                "creationLdif",
                "deletionLdif",
                "roleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendDynamicRole resources.\n",
                "properties": {
                    "creationLdif": {
                        "type": "string",
                        "description": "A templatized LDIF string used to create a user\naccount. This may contain multiple LDIF entries. The `creation_ldif` can also\nbe used to add the user account to an existing group. All LDIF entries are\nperformed in order. If Vault encounters an error while executing the\n`creation_ldif` it will stop at the first error and not execute any remaining\nLDIF entries. If an error occurs and `rollback_ldif` is specified, the LDIF\nentries in `rollback_ldif` will be executed. See `rollback_ldif` for more\ndetails. This field may optionally be provided as a base64 encoded string.\n"
                    },
                    "defaultTtl": {
                        "type": "integer",
                        "description": "Specifies the TTL for the leases associated with this role.\n"
                    },
                    "deletionLdif": {
                        "type": "string",
                        "description": "A templatized LDIF string used to delete the\nuser account once its TTL has expired. This may contain multiple LDIF\nentries. All LDIF entries are performed in order. If Vault encounters an\nerror while executing an entry in the `deletion_ldif` it will attempt to\ncontinue executing any remaining entries. This field may optionally be\nprovided as a base64 encoded string.\n"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "Specifies the maximum TTL for the leases associated with this role.\n"
                    },
                    "mount": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `ldap`.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "roleName": {
                        "type": "string",
                        "description": "Name of the role.\n",
                        "willReplaceOnChanges": true
                    },
                    "rollbackLdif": {
                        "type": "string",
                        "description": "A templatized LDIF string used to attempt to\nrollback any changes in the event that execution of the `creation_ldif` results\nin an error. This may contain multiple LDIF entries. All LDIF entries are\nperformed in order. If Vault encounters an error while executing an entry in\nthe `rollback_ldif` it will attempt to continue executing any remaining\nentries. This field may optionally be provided as a base64 encoded string.\n"
                    },
                    "usernameTemplate": {
                        "type": "string",
                        "description": "A template used to generate a dynamic\nusername. This will be used to fill in the `.Username` field within the\n`creation_ldif` string.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:ldap/secretBackendLibrarySet:SecretBackendLibrarySet": {
            "description": "\n\n## Import\n\nLDAP secret backend libraries can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:ldap/secretBackendLibrarySet:SecretBackendLibrarySet set ldap/library/bob\n```\n\n ",
            "properties": {
                "disableCheckInEnforcement": {
                    "type": "boolean",
                    "description": "Disable enforcing that service\naccounts must be checked in by the entity or client token that checked them\nout. Defaults to false.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum password time-to-live in seconds. Defaults\nto the configuration max_ttl if not provided.\n"
                },
                "mount": {
                    "type": "string",
                    "description": "The path where the LDAP secrets backend is mounted.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this set of service accounts.\nMust be unique within the backend.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "serviceAccountNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the slice of service accounts mapped to this set.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The password time-to-live in seconds. Defaults to the configuration\nttl if not provided.\n"
                }
            },
            "required": [
                "maxTtl",
                "name",
                "serviceAccountNames",
                "ttl"
            ],
            "inputProperties": {
                "disableCheckInEnforcement": {
                    "type": "boolean",
                    "description": "Disable enforcing that service\naccounts must be checked in by the entity or client token that checked them\nout. Defaults to false.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum password time-to-live in seconds. Defaults\nto the configuration max_ttl if not provided.\n"
                },
                "mount": {
                    "type": "string",
                    "description": "The path where the LDAP secrets backend is mounted.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this set of service accounts.\nMust be unique within the backend.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "serviceAccountNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the slice of service accounts mapped to this set.\n",
                    "willReplaceOnChanges": true
                },
                "ttl": {
                    "type": "integer",
                    "description": "The password time-to-live in seconds. Defaults to the configuration\nttl if not provided.\n"
                }
            },
            "requiredInputs": [
                "serviceAccountNames"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendLibrarySet resources.\n",
                "properties": {
                    "disableCheckInEnforcement": {
                        "type": "boolean",
                        "description": "Disable enforcing that service\naccounts must be checked in by the entity or client token that checked them\nout. Defaults to false.\n"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "The maximum password time-to-live in seconds. Defaults\nto the configuration max_ttl if not provided.\n"
                    },
                    "mount": {
                        "type": "string",
                        "description": "The path where the LDAP secrets backend is mounted.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name to identify this set of service accounts.\nMust be unique within the backend.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "serviceAccountNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the slice of service accounts mapped to this set.\n",
                        "willReplaceOnChanges": true
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "The password time-to-live in seconds. Defaults to the configuration\nttl if not provided.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:ldap/secretBackendStaticRole:SecretBackendStaticRole": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst config = new vault.ldap.SecretBackend(\"config\", {\n    path: \"my-custom-ldap\",\n    binddn: \"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\",\n    bindpass: \"SuperSecretPassw0rd\",\n    url: \"ldaps://localhost\",\n    insecureTls: true,\n    userdn: \"CN=Users,DC=corp,DC=example,DC=net\",\n});\nconst role = new vault.ldap.SecretBackendStaticRole(\"role\", {\n    mount: config.path,\n    username: \"alice\",\n    dn: \"cn=alice,ou=Users,DC=corp,DC=example,DC=net\",\n    roleName: \"alice\",\n    rotationPeriod: 60,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nconfig = vault.ldap.SecretBackend(\"config\",\n    path=\"my-custom-ldap\",\n    binddn=\"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\",\n    bindpass=\"SuperSecretPassw0rd\",\n    url=\"ldaps://localhost\",\n    insecure_tls=True,\n    userdn=\"CN=Users,DC=corp,DC=example,DC=net\")\nrole = vault.ldap.SecretBackendStaticRole(\"role\",\n    mount=config.path,\n    username=\"alice\",\n    dn=\"cn=alice,ou=Users,DC=corp,DC=example,DC=net\",\n    role_name=\"alice\",\n    rotation_period=60)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Vault.Ldap.SecretBackend(\"config\", new()\n    {\n        Path = \"my-custom-ldap\",\n        Binddn = \"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\",\n        Bindpass = \"SuperSecretPassw0rd\",\n        Url = \"ldaps://localhost\",\n        InsecureTls = true,\n        Userdn = \"CN=Users,DC=corp,DC=example,DC=net\",\n    });\n\n    var role = new Vault.Ldap.SecretBackendStaticRole(\"role\", new()\n    {\n        Mount = config.Path,\n        Username = \"alice\",\n        Dn = \"cn=alice,ou=Users,DC=corp,DC=example,DC=net\",\n        RoleName = \"alice\",\n        RotationPeriod = 60,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfig, err := ldap.NewSecretBackend(ctx, \"config\", \u0026ldap.SecretBackendArgs{\n\t\t\tPath:        pulumi.String(\"my-custom-ldap\"),\n\t\t\tBinddn:      pulumi.String(\"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\"),\n\t\t\tBindpass:    pulumi.String(\"SuperSecretPassw0rd\"),\n\t\t\tUrl:         pulumi.String(\"ldaps://localhost\"),\n\t\t\tInsecureTls: pulumi.Bool(true),\n\t\t\tUserdn:      pulumi.String(\"CN=Users,DC=corp,DC=example,DC=net\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewSecretBackendStaticRole(ctx, \"role\", \u0026ldap.SecretBackendStaticRoleArgs{\n\t\t\tMount:          config.Path,\n\t\t\tUsername:       pulumi.String(\"alice\"),\n\t\t\tDn:             pulumi.String(\"cn=alice,ou=Users,DC=corp,DC=example,DC=net\"),\n\t\t\tRoleName:       pulumi.String(\"alice\"),\n\t\t\tRotationPeriod: pulumi.Int(60),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.ldap.SecretBackend;\nimport com.pulumi.vault.ldap.SecretBackendArgs;\nimport com.pulumi.vault.ldap.SecretBackendStaticRole;\nimport com.pulumi.vault.ldap.SecretBackendStaticRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var config = new SecretBackend(\"config\", SecretBackendArgs.builder()        \n            .path(\"my-custom-ldap\")\n            .binddn(\"CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\")\n            .bindpass(\"SuperSecretPassw0rd\")\n            .url(\"ldaps://localhost\")\n            .insecureTls(\"true\")\n            .userdn(\"CN=Users,DC=corp,DC=example,DC=net\")\n            .build());\n\n        var role = new SecretBackendStaticRole(\"role\", SecretBackendStaticRoleArgs.builder()        \n            .mount(config.path())\n            .username(\"alice\")\n            .dn(\"cn=alice,ou=Users,DC=corp,DC=example,DC=net\")\n            .roleName(\"alice\")\n            .rotationPeriod(60)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  config:\n    type: vault:ldap:SecretBackend\n    properties:\n      path: my-custom-ldap\n      binddn: CN=Administrator,CN=Users,DC=corp,DC=example,DC=net\n      bindpass: SuperSecretPassw0rd\n      url: ldaps://localhost\n      insecureTls: true\n      userdn: CN=Users,DC=corp,DC=example,DC=net\n  role:\n    type: vault:ldap:SecretBackendStaticRole\n    properties:\n      mount: ${config.path}\n      username: alice\n      dn: cn=alice,ou=Users,DC=corp,DC=example,DC=net\n      roleName: alice\n      rotationPeriod: 60\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nLDAP secret backend static role can be imported using the full path to the role of the form`\u003cmount_path\u003e/static-role/\u003crole_name\u003e` e.g.\n\n```sh\n $ pulumi import vault:ldap/secretBackendStaticRole:SecretBackendStaticRole role ldap/static-role/example-role\n```\n\n ",
            "properties": {
                "dn": {
                    "type": "string",
                    "description": "Distinguished name (DN) of the existing LDAP entry to manage\npassword rotation for. If given, it will take precedence over `username` for the LDAP\nsearch performed during password rotation. Cannot be modified after creation.\n"
                },
                "mount": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `ldap`.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "Name of the role.\n"
                },
                "rotationPeriod": {
                    "type": "integer",
                    "description": "How often Vault should rotate the password of the user entry.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The username of the existing LDAP entry to manage password rotation for.\n"
                }
            },
            "required": [
                "roleName",
                "rotationPeriod",
                "username"
            ],
            "inputProperties": {
                "dn": {
                    "type": "string",
                    "description": "Distinguished name (DN) of the existing LDAP entry to manage\npassword rotation for. If given, it will take precedence over `username` for the LDAP\nsearch performed during password rotation. Cannot be modified after creation.\n"
                },
                "mount": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `ldap`.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "roleName": {
                    "type": "string",
                    "description": "Name of the role.\n",
                    "willReplaceOnChanges": true
                },
                "rotationPeriod": {
                    "type": "integer",
                    "description": "How often Vault should rotate the password of the user entry.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The username of the existing LDAP entry to manage password rotation for.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "roleName",
                "rotationPeriod",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendStaticRole resources.\n",
                "properties": {
                    "dn": {
                        "type": "string",
                        "description": "Distinguished name (DN) of the existing LDAP entry to manage\npassword rotation for. If given, it will take precedence over `username` for the LDAP\nsearch performed during password rotation. Cannot be modified after creation.\n"
                    },
                    "mount": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `ldap`.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "roleName": {
                        "type": "string",
                        "description": "Name of the role.\n",
                        "willReplaceOnChanges": true
                    },
                    "rotationPeriod": {
                        "type": "integer",
                        "description": "How often Vault should rotate the password of the user entry.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "The username of the existing LDAP entry to manage password rotation for.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:managed/keys:Keys": {
            "description": "\n\n\n## Import\n\nMounts can be imported using the `id` of `default`, e.g.\n\n```sh\n $ pulumi import vault:managed/keys:Keys keys default\n```\n\n ",
            "properties": {
                "aws": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:managed/KeysAw:KeysAw"
                    },
                    "description": "Configuration block for AWS Managed Keys\n"
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:managed/KeysAzure:KeysAzure"
                    },
                    "description": "Configuration block for Azure Managed Keys\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n"
                },
                "pkcs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:managed/KeysPkc:KeysPkc"
                    },
                    "description": "Configuration block for PKCS Managed Keys\n"
                }
            },
            "inputProperties": {
                "aws": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:managed/KeysAw:KeysAw"
                    },
                    "description": "Configuration block for AWS Managed Keys\n"
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:managed/KeysAzure:KeysAzure"
                    },
                    "description": "Configuration block for Azure Managed Keys\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "pkcs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:managed/KeysPkc:KeysPkc"
                    },
                    "description": "Configuration block for PKCS Managed Keys\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Keys resources.\n",
                "properties": {
                    "aws": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:managed/KeysAw:KeysAw"
                        },
                        "description": "Configuration block for AWS Managed Keys\n"
                    },
                    "azures": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:managed/KeysAzure:KeysAzure"
                        },
                        "description": "Configuration block for Azure Managed Keys\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "pkcs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:managed/KeysPkc:KeysPkc"
                        },
                        "description": "Configuration block for PKCS Managed Keys\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:mongodbatlas/secretBackend:SecretBackend": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst mongo = new vault.Mount(\"mongo\", {\n    description: \"MongoDB Atlas secret engine mount\",\n    path: \"mongodbatlas\",\n    type: \"mongodbatlas\",\n});\nconst config = new vault.mongodbatlas.SecretBackend(\"config\", {\n    mount: \"vault_mount.mongo.path\",\n    privateKey: \"privateKey\",\n    publicKey: \"publicKey\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nmongo = vault.Mount(\"mongo\",\n    description=\"MongoDB Atlas secret engine mount\",\n    path=\"mongodbatlas\",\n    type=\"mongodbatlas\")\nconfig = vault.mongodbatlas.SecretBackend(\"config\",\n    mount=\"vault_mount.mongo.path\",\n    private_key=\"privateKey\",\n    public_key=\"publicKey\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var mongo = new Vault.Mount(\"mongo\", new()\n    {\n        Description = \"MongoDB Atlas secret engine mount\",\n        Path = \"mongodbatlas\",\n        Type = \"mongodbatlas\",\n    });\n\n    var config = new Vault.MongoDBAtlas.SecretBackend(\"config\", new()\n    {\n        Mount = \"vault_mount.mongo.path\",\n        PrivateKey = \"privateKey\",\n        PublicKey = \"publicKey\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewMount(ctx, \"mongo\", \u0026vault.MountArgs{\n\t\t\tDescription: pulumi.String(\"MongoDB Atlas secret engine mount\"),\n\t\t\tPath:        pulumi.String(\"mongodbatlas\"),\n\t\t\tType:        pulumi.String(\"mongodbatlas\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewSecretBackend(ctx, \"config\", \u0026mongodbatlas.SecretBackendArgs{\n\t\t\tMount:      pulumi.String(\"vault_mount.mongo.path\"),\n\t\t\tPrivateKey: pulumi.String(\"privateKey\"),\n\t\t\tPublicKey:  pulumi.String(\"publicKey\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Mount;\nimport com.pulumi.vault.MountArgs;\nimport com.pulumi.vault.mongodbatlas.SecretBackend;\nimport com.pulumi.vault.mongodbatlas.SecretBackendArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var mongo = new Mount(\"mongo\", MountArgs.builder()        \n            .description(\"MongoDB Atlas secret engine mount\")\n            .path(\"mongodbatlas\")\n            .type(\"mongodbatlas\")\n            .build());\n\n        var config = new SecretBackend(\"config\", SecretBackendArgs.builder()        \n            .mount(\"vault_mount.mongo.path\")\n            .privateKey(\"privateKey\")\n            .publicKey(\"publicKey\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  mongo:\n    type: vault:Mount\n    properties:\n      description: MongoDB Atlas secret engine mount\n      path: mongodbatlas\n      type: mongodbatlas\n  config:\n    type: vault:mongodbatlas:SecretBackend\n    properties:\n      mount: vault_mount.mongo.path\n      privateKey: privateKey\n      publicKey: publicKey\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nMongoDB Atlas secret backends can be imported using the `${mount}/config`, e.g.\n\n```sh\n $ pulumi import vault:mongodbatlas/secretBackend:SecretBackend config mongodbatlas/config\n```\n\n ",
            "properties": {
                "mount": {
                    "type": "string",
                    "description": "Path where the MongoDB Atlas Secrets Engine is mounted.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path where MongoDB Atlas configuration is located\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "Specifies the Private API Key used to authenticate with the MongoDB Atlas API.\n"
                },
                "publicKey": {
                    "type": "string",
                    "description": "Specifies the Public API Key used to authenticate with the MongoDB Atlas API.\n"
                }
            },
            "required": [
                "mount",
                "path",
                "privateKey",
                "publicKey"
            ],
            "inputProperties": {
                "mount": {
                    "type": "string",
                    "description": "Path where the MongoDB Atlas Secrets Engine is mounted.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "privateKey": {
                    "type": "string",
                    "description": "Specifies the Private API Key used to authenticate with the MongoDB Atlas API.\n"
                },
                "publicKey": {
                    "type": "string",
                    "description": "Specifies the Public API Key used to authenticate with the MongoDB Atlas API.\n"
                }
            },
            "requiredInputs": [
                "mount",
                "privateKey",
                "publicKey"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackend resources.\n",
                "properties": {
                    "mount": {
                        "type": "string",
                        "description": "Path where the MongoDB Atlas Secrets Engine is mounted.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "Path where MongoDB Atlas configuration is located\n"
                    },
                    "privateKey": {
                        "type": "string",
                        "description": "Specifies the Private API Key used to authenticate with the MongoDB Atlas API.\n"
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "Specifies the Public API Key used to authenticate with the MongoDB Atlas API.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:mongodbatlas/secretRole:SecretRole": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst mongo = new vault.Mount(\"mongo\", {\n    path: \"%s\",\n    type: \"mongodbatlas\",\n    description: \"MongoDB Atlas secret engine mount\",\n});\nconst config = new vault.mongodbatlas.SecretBackend(\"config\", {\n    mount: \"vault_mount.mongo.path\",\n    privateKey: \"privateKey\",\n    publicKey: \"publicKey\",\n});\nconst role = new vault.mongodbatlas.SecretRole(\"role\", {\n    mount: mongo.path,\n    organizationId: \"7cf5a45a9ccf6400e60981b7\",\n    projectId: \"5cf5a45a9ccf6400e60981b6\",\n    roles: \"ORG_READ_ONLY\",\n    ipAddresses: \"192.168.1.5, 192.168.1.6\",\n    cidrBlocks: \"192.168.1.3/35\",\n    projectRoles: \"GROUP_READ_ONLY\",\n    ttl: \"60\",\n    maxTtl: \"120\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nmongo = vault.Mount(\"mongo\",\n    path=\"%s\",\n    type=\"mongodbatlas\",\n    description=\"MongoDB Atlas secret engine mount\")\nconfig = vault.mongodbatlas.SecretBackend(\"config\",\n    mount=\"vault_mount.mongo.path\",\n    private_key=\"privateKey\",\n    public_key=\"publicKey\")\nrole = vault.mongodbatlas.SecretRole(\"role\",\n    mount=mongo.path,\n    organization_id=\"7cf5a45a9ccf6400e60981b7\",\n    project_id=\"5cf5a45a9ccf6400e60981b6\",\n    roles=\"ORG_READ_ONLY\",\n    ip_addresses=\"192.168.1.5, 192.168.1.6\",\n    cidr_blocks=\"192.168.1.3/35\",\n    project_roles=\"GROUP_READ_ONLY\",\n    ttl=\"60\",\n    max_ttl=\"120\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var mongo = new Vault.Mount(\"mongo\", new()\n    {\n        Path = \"%s\",\n        Type = \"mongodbatlas\",\n        Description = \"MongoDB Atlas secret engine mount\",\n    });\n\n    var config = new Vault.MongoDBAtlas.SecretBackend(\"config\", new()\n    {\n        Mount = \"vault_mount.mongo.path\",\n        PrivateKey = \"privateKey\",\n        PublicKey = \"publicKey\",\n    });\n\n    var role = new Vault.MongoDBAtlas.SecretRole(\"role\", new()\n    {\n        Mount = mongo.Path,\n        OrganizationId = \"7cf5a45a9ccf6400e60981b7\",\n        ProjectId = \"5cf5a45a9ccf6400e60981b6\",\n        Roles = \"ORG_READ_ONLY\",\n        IpAddresses = \"192.168.1.5, 192.168.1.6\",\n        CidrBlocks = \"192.168.1.3/35\",\n        ProjectRoles = \"GROUP_READ_ONLY\",\n        Ttl = \"60\",\n        MaxTtl = \"120\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmongo, err := vault.NewMount(ctx, \"mongo\", \u0026vault.MountArgs{\n\t\t\tPath:        pulumi.String(\"%s\"),\n\t\t\tType:        pulumi.String(\"mongodbatlas\"),\n\t\t\tDescription: pulumi.String(\"MongoDB Atlas secret engine mount\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewSecretBackend(ctx, \"config\", \u0026mongodbatlas.SecretBackendArgs{\n\t\t\tMount:      pulumi.String(\"vault_mount.mongo.path\"),\n\t\t\tPrivateKey: pulumi.String(\"privateKey\"),\n\t\t\tPublicKey:  pulumi.String(\"publicKey\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewSecretRole(ctx, \"role\", \u0026mongodbatlas.SecretRoleArgs{\n\t\t\tMount:          mongo.Path,\n\t\t\tOrganizationId: pulumi.String(\"7cf5a45a9ccf6400e60981b7\"),\n\t\t\tProjectId:      pulumi.String(\"5cf5a45a9ccf6400e60981b6\"),\n\t\t\tRoles:          pulumi.StringArray(\"ORG_READ_ONLY\"),\n\t\t\tIpAddresses:    pulumi.StringArray(\"192.168.1.5, 192.168.1.6\"),\n\t\t\tCidrBlocks:     pulumi.StringArray(\"192.168.1.3/35\"),\n\t\t\tProjectRoles:   pulumi.StringArray(\"GROUP_READ_ONLY\"),\n\t\t\tTtl:            pulumi.String(\"60\"),\n\t\t\tMaxTtl:         pulumi.String(\"120\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Mount;\nimport com.pulumi.vault.MountArgs;\nimport com.pulumi.vault.mongodbatlas.SecretBackend;\nimport com.pulumi.vault.mongodbatlas.SecretBackendArgs;\nimport com.pulumi.vault.mongodbatlas.SecretRole;\nimport com.pulumi.vault.mongodbatlas.SecretRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var mongo = new Mount(\"mongo\", MountArgs.builder()        \n            .path(\"%s\")\n            .type(\"mongodbatlas\")\n            .description(\"MongoDB Atlas secret engine mount\")\n            .build());\n\n        var config = new SecretBackend(\"config\", SecretBackendArgs.builder()        \n            .mount(\"vault_mount.mongo.path\")\n            .privateKey(\"privateKey\")\n            .publicKey(\"publicKey\")\n            .build());\n\n        var role = new SecretRole(\"role\", SecretRoleArgs.builder()        \n            .mount(mongo.path())\n            .organizationId(\"7cf5a45a9ccf6400e60981b7\")\n            .projectId(\"5cf5a45a9ccf6400e60981b6\")\n            .roles(\"ORG_READ_ONLY\")\n            .ipAddresses(\"192.168.1.5, 192.168.1.6\")\n            .cidrBlocks(\"192.168.1.3/35\")\n            .projectRoles(\"GROUP_READ_ONLY\")\n            .ttl(\"60\")\n            .maxTtl(\"120\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  mongo:\n    type: vault:Mount\n    properties:\n      path: '%s'\n      type: mongodbatlas\n      description: MongoDB Atlas secret engine mount\n  config:\n    type: vault:mongodbatlas:SecretBackend\n    properties:\n      mount: vault_mount.mongo.path\n      privateKey: privateKey\n      publicKey: publicKey\n  role:\n    type: vault:mongodbatlas:SecretRole\n    properties:\n      mount: ${mongo.path}\n      organizationId: 7cf5a45a9ccf6400e60981b7\n      projectId: 5cf5a45a9ccf6400e60981b6\n      roles: ORG_READ_ONLY\n      ipAddresses: 192.168.1.5, 192.168.1.6\n      cidrBlocks: 192.168.1.3/35\n      projectRoles: GROUP_READ_ONLY\n      ttl: 60\n      maxTtl: 120\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nThe MongoDB Atlas secret role can be imported using the full path to the role of the form`\u003cmount_path\u003e/roles/\u003crole_name\u003e` e.g.\n\n```sh\n $ pulumi import vault:mongodbatlas/secretRole:SecretRole example mongodbatlas/roles/example-role\n```\n\n ",
            "properties": {
                "cidrBlocks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Whitelist entry in CIDR notation to be added for the API key.\n"
                },
                "ipAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IP address to be added to the whitelist for the API key.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "The maximum allowed lifetime of credentials issued using this role.\n"
                },
                "mount": {
                    "type": "string",
                    "description": "Path where the MongoDB Atlas Secrets Engine is mounted.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "organizationId": {
                    "type": "string",
                    "description": "Unique identifier for the organization to which the target API Key belongs. \nRequired if `project_id` is not set.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique identifier for the project to which the target API Key belongs.\nRequired if `organization_id is` not set.\n"
                },
                "projectRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Roles assigned when an org API key is assigned to a project API key.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of roles that the API Key needs to have.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Duration in seconds after which the issued credential should expire.\n"
                }
            },
            "required": [
                "mount",
                "name",
                "roles"
            ],
            "inputProperties": {
                "cidrBlocks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Whitelist entry in CIDR notation to be added for the API key.\n"
                },
                "ipAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IP address to be added to the whitelist for the API key.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "The maximum allowed lifetime of credentials issued using this role.\n"
                },
                "mount": {
                    "type": "string",
                    "description": "Path where the MongoDB Atlas Secrets Engine is mounted.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the role.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "organizationId": {
                    "type": "string",
                    "description": "Unique identifier for the organization to which the target API Key belongs. \nRequired if `project_id` is not set.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique identifier for the project to which the target API Key belongs.\nRequired if `organization_id is` not set.\n"
                },
                "projectRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Roles assigned when an org API key is assigned to a project API key.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of roles that the API Key needs to have.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Duration in seconds after which the issued credential should expire.\n"
                }
            },
            "requiredInputs": [
                "mount",
                "roles"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretRole resources.\n",
                "properties": {
                    "cidrBlocks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Whitelist entry in CIDR notation to be added for the API key.\n"
                    },
                    "ipAddresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "IP address to be added to the whitelist for the API key.\n"
                    },
                    "maxTtl": {
                        "type": "string",
                        "description": "The maximum allowed lifetime of credentials issued using this role.\n"
                    },
                    "mount": {
                        "type": "string",
                        "description": "Path where the MongoDB Atlas Secrets Engine is mounted.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the role.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "organizationId": {
                        "type": "string",
                        "description": "Unique identifier for the organization to which the target API Key belongs. \nRequired if `project_id` is not set.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique identifier for the project to which the target API Key belongs.\nRequired if `organization_id is` not set.\n"
                    },
                    "projectRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Roles assigned when an org API key is assigned to a project API key.\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of roles that the API Key needs to have.\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Duration in seconds after which the issued credential should expire.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:okta/authBackend:AuthBackend": {
            "description": "Provides a resource for managing an\n[Okta auth backend within Vault](https://www.vaultproject.io/docs/auth/okta.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.okta.AuthBackend(\"example\", {\n    description: \"Demonstration of the Terraform Okta auth backend\",\n    groups: [{\n        groupName: \"foo\",\n        policies: [\n            \"one\",\n            \"two\",\n        ],\n    }],\n    organization: \"example\",\n    token: \"something that should be kept secret\",\n    users: [{\n        groups: [\"foo\"],\n        username: \"bar\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.okta.AuthBackend(\"example\",\n    description=\"Demonstration of the Terraform Okta auth backend\",\n    groups=[vault.okta.AuthBackendGroupArgs(\n        group_name=\"foo\",\n        policies=[\n            \"one\",\n            \"two\",\n        ],\n    )],\n    organization=\"example\",\n    token=\"something that should be kept secret\",\n    users=[vault.okta.AuthBackendUserArgs(\n        groups=[\"foo\"],\n        username=\"bar\",\n    )])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Vault.Okta.AuthBackend(\"example\", new()\n    {\n        Description = \"Demonstration of the Terraform Okta auth backend\",\n        Groups = new[]\n        {\n            new Vault.Okta.Inputs.AuthBackendGroupArgs\n            {\n                GroupName = \"foo\",\n                Policies = new[]\n                {\n                    \"one\",\n                    \"two\",\n                },\n            },\n        },\n        Organization = \"example\",\n        Token = \"something that should be kept secret\",\n        Users = new[]\n        {\n            new Vault.Okta.Inputs.AuthBackendUserArgs\n            {\n                Groups = new[]\n                {\n                    \"foo\",\n                },\n                Username = \"bar\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/okta\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := okta.NewAuthBackend(ctx, \"example\", \u0026okta.AuthBackendArgs{\n\t\t\tDescription: pulumi.String(\"Demonstration of the Terraform Okta auth backend\"),\n\t\t\tGroups: okta.AuthBackendGroupTypeArray{\n\t\t\t\t\u0026okta.AuthBackendGroupTypeArgs{\n\t\t\t\t\tGroupName: pulumi.String(\"foo\"),\n\t\t\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"one\"),\n\t\t\t\t\t\tpulumi.String(\"two\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tOrganization: pulumi.String(\"example\"),\n\t\t\tToken:        pulumi.String(\"something that should be kept secret\"),\n\t\t\tUsers: okta.AuthBackendUserTypeArray{\n\t\t\t\t\u0026okta.AuthBackendUserTypeArgs{\n\t\t\t\t\tGroups: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"foo\"),\n\t\t\t\t\t},\n\t\t\t\t\tUsername: pulumi.String(\"bar\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.okta.AuthBackend;\nimport com.pulumi.vault.okta.AuthBackendArgs;\nimport com.pulumi.vault.okta.inputs.AuthBackendGroupArgs;\nimport com.pulumi.vault.okta.inputs.AuthBackendUserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new AuthBackend(\"example\", AuthBackendArgs.builder()        \n            .description(\"Demonstration of the Terraform Okta auth backend\")\n            .groups(AuthBackendGroupArgs.builder()\n                .groupName(\"foo\")\n                .policies(                \n                    \"one\",\n                    \"two\")\n                .build())\n            .organization(\"example\")\n            .token(\"something that should be kept secret\")\n            .users(AuthBackendUserArgs.builder()\n                .groups(\"foo\")\n                .username(\"bar\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: vault:okta:AuthBackend\n    properties:\n      description: Demonstration of the Terraform Okta auth backend\n      groups:\n        - groupName: foo\n          policies:\n            - one\n            - two\n      organization: example\n      token: something that should be kept secret\n      users:\n        - groups:\n            - foo\n          username: bar\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nOkta authentication backends can be imported using its `path`, e.g.\n\n```sh\n $ pulumi import vault:okta/authBackend:AuthBackend example okta\n```\n\n ",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The mount accessor related to the auth mount. It is useful for integration with [Identity Secrets Engine](https://www.vaultproject.io/docs/secrets/identity/index.html).\n"
                },
                "baseUrl": {
                    "type": "string",
                    "description": "The Okta url. Examples: oktapreview.com, okta.com\n"
                },
                "bypassOktaMfa": {
                    "type": "boolean",
                    "description": "When true, requests by Okta for a MFA check will be bypassed. This also disallows certain status checks on the account, such as whether the password is expired.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the auth backend\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:okta/AuthBackendGroup:AuthBackendGroup"
                    },
                    "description": "Associate Okta groups with policies within Vault.\nSee below for more details.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Maximum duration after which authentication will be expired\n[See the documentation for info on valid duration formats](https://golang.org/pkg/time/#ParseDuration).\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The Okta organization. This will be the first part of the url `https://XXX.okta.com`\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to mount the Okta auth backend. Default to path `okta`.\n"
                },
                "token": {
                    "type": "string",
                    "description": "The Okta API token. This is required to query Okta for user group membership.\nIf this is not supplied only locally configured groups will be enabled.\n",
                    "secret": true
                },
                "ttl": {
                    "type": "string",
                    "description": "Duration after which authentication will be expired.\n[See the documentation for info on valid duration formats](https://golang.org/pkg/time/#ParseDuration).\n"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:okta/AuthBackendUser:AuthBackendUser"
                    },
                    "description": "Associate Okta users with groups or policies within Vault.\nSee below for more details.\n"
                }
            },
            "required": [
                "accessor",
                "groups",
                "organization",
                "users"
            ],
            "inputProperties": {
                "baseUrl": {
                    "type": "string",
                    "description": "The Okta url. Examples: oktapreview.com, okta.com\n"
                },
                "bypassOktaMfa": {
                    "type": "boolean",
                    "description": "When true, requests by Okta for a MFA check will be bypassed. This also disallows certain status checks on the account, such as whether the password is expired.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the auth backend\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:okta/AuthBackendGroup:AuthBackendGroup"
                    },
                    "description": "Associate Okta groups with policies within Vault.\nSee below for more details.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Maximum duration after which authentication will be expired\n[See the documentation for info on valid duration formats](https://golang.org/pkg/time/#ParseDuration).\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "organization": {
                    "type": "string",
                    "description": "The Okta organization. This will be the first part of the url `https://XXX.okta.com`\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to mount the Okta auth backend. Default to path `okta`.\n"
                },
                "token": {
                    "type": "string",
                    "description": "The Okta API token. This is required to query Okta for user group membership.\nIf this is not supplied only locally configured groups will be enabled.\n",
                    "secret": true
                },
                "ttl": {
                    "type": "string",
                    "description": "Duration after which authentication will be expired.\n[See the documentation for info on valid duration formats](https://golang.org/pkg/time/#ParseDuration).\n"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:okta/AuthBackendUser:AuthBackendUser"
                    },
                    "description": "Associate Okta users with groups or policies within Vault.\nSee below for more details.\n"
                }
            },
            "requiredInputs": [
                "organization"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackend resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The mount accessor related to the auth mount. It is useful for integration with [Identity Secrets Engine](https://www.vaultproject.io/docs/secrets/identity/index.html).\n"
                    },
                    "baseUrl": {
                        "type": "string",
                        "description": "The Okta url. Examples: oktapreview.com, okta.com\n"
                    },
                    "bypassOktaMfa": {
                        "type": "boolean",
                        "description": "When true, requests by Okta for a MFA check will be bypassed. This also disallows certain status checks on the account, such as whether the password is expired.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the auth backend\n"
                    },
                    "disableRemount": {
                        "type": "boolean",
                        "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                    },
                    "groups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:okta/AuthBackendGroup:AuthBackendGroup"
                        },
                        "description": "Associate Okta groups with policies within Vault.\nSee below for more details.\n"
                    },
                    "maxTtl": {
                        "type": "string",
                        "description": "Maximum duration after which authentication will be expired\n[See the documentation for info on valid duration formats](https://golang.org/pkg/time/#ParseDuration).\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "organization": {
                        "type": "string",
                        "description": "The Okta organization. This will be the first part of the url `https://XXX.okta.com`\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Path to mount the Okta auth backend. Default to path `okta`.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "The Okta API token. This is required to query Okta for user group membership.\nIf this is not supplied only locally configured groups will be enabled.\n",
                        "secret": true
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Duration after which authentication will be expired.\n[See the documentation for info on valid duration formats](https://golang.org/pkg/time/#ParseDuration).\n"
                    },
                    "users": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:okta/AuthBackendUser:AuthBackendUser"
                        },
                        "description": "Associate Okta users with groups or policies within Vault.\nSee below for more details.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:okta/authBackendGroup:AuthBackendGroup": {
            "description": "Provides a resource to create a group in an\n[Okta auth backend within Vault](https://www.vaultproject.io/docs/auth/okta.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.okta.AuthBackend(\"example\", {\n    path: \"group_okta\",\n    organization: \"dummy\",\n});\nconst foo = new vault.okta.AuthBackendGroup(\"foo\", {\n    path: example.path,\n    groupName: \"foo\",\n    policies: [\n        \"one\",\n        \"two\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.okta.AuthBackend(\"example\",\n    path=\"group_okta\",\n    organization=\"dummy\")\nfoo = vault.okta.AuthBackendGroup(\"foo\",\n    path=example.path,\n    group_name=\"foo\",\n    policies=[\n        \"one\",\n        \"two\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Vault.Okta.AuthBackend(\"example\", new()\n    {\n        Path = \"group_okta\",\n        Organization = \"dummy\",\n    });\n\n    var foo = new Vault.Okta.AuthBackendGroup(\"foo\", new()\n    {\n        Path = example.Path,\n        GroupName = \"foo\",\n        Policies = new[]\n        {\n            \"one\",\n            \"two\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/okta\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := okta.NewAuthBackend(ctx, \"example\", \u0026okta.AuthBackendArgs{\n\t\t\tPath:         pulumi.String(\"group_okta\"),\n\t\t\tOrganization: pulumi.String(\"dummy\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = okta.NewAuthBackendGroup(ctx, \"foo\", \u0026okta.AuthBackendGroupArgs{\n\t\t\tPath:      example.Path,\n\t\t\tGroupName: pulumi.String(\"foo\"),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"one\"),\n\t\t\t\tpulumi.String(\"two\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.okta.AuthBackend;\nimport com.pulumi.vault.okta.AuthBackendArgs;\nimport com.pulumi.vault.okta.AuthBackendGroup;\nimport com.pulumi.vault.okta.AuthBackendGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new AuthBackend(\"example\", AuthBackendArgs.builder()        \n            .path(\"group_okta\")\n            .organization(\"dummy\")\n            .build());\n\n        var foo = new AuthBackendGroup(\"foo\", AuthBackendGroupArgs.builder()        \n            .path(example.path())\n            .groupName(\"foo\")\n            .policies(            \n                \"one\",\n                \"two\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: vault:okta:AuthBackend\n    properties:\n      path: group_okta\n      organization: dummy\n  foo:\n    type: vault:okta:AuthBackendGroup\n    properties:\n      path: ${example.path}\n      groupName: foo\n      policies:\n        - one\n        - two\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nOkta authentication backend groups can be imported using the format `backend/groupName` e.g.\n\n```sh\n $ pulumi import vault:okta/authBackendGroup:AuthBackendGroup foo okta/foo\n```\n\n ",
            "properties": {
                "groupName": {
                    "type": "string",
                    "description": "Name of the group within the Okta\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path where the Okta auth backend is mounted\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Vault policies to associate with this group\n"
                }
            },
            "required": [
                "groupName",
                "path"
            ],
            "inputProperties": {
                "groupName": {
                    "type": "string",
                    "description": "Name of the group within the Okta\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "The path where the Okta auth backend is mounted\n",
                    "willReplaceOnChanges": true
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Vault policies to associate with this group\n"
                }
            },
            "requiredInputs": [
                "groupName",
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendGroup resources.\n",
                "properties": {
                    "groupName": {
                        "type": "string",
                        "description": "Name of the group within the Okta\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "The path where the Okta auth backend is mounted\n",
                        "willReplaceOnChanges": true
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Vault policies to associate with this group\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:okta/authBackendUser:AuthBackendUser": {
            "description": "Provides a resource to create a user in an\n[Okta auth backend within Vault](https://www.vaultproject.io/docs/auth/okta.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.okta.AuthBackend(\"example\", {\n    path: \"user_okta\",\n    organization: \"dummy\",\n});\nconst foo = new vault.okta.AuthBackendUser(\"foo\", {\n    path: example.path,\n    username: \"foo\",\n    groups: [\n        \"one\",\n        \"two\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.okta.AuthBackend(\"example\",\n    path=\"user_okta\",\n    organization=\"dummy\")\nfoo = vault.okta.AuthBackendUser(\"foo\",\n    path=example.path,\n    username=\"foo\",\n    groups=[\n        \"one\",\n        \"two\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Vault.Okta.AuthBackend(\"example\", new()\n    {\n        Path = \"user_okta\",\n        Organization = \"dummy\",\n    });\n\n    var foo = new Vault.Okta.AuthBackendUser(\"foo\", new()\n    {\n        Path = example.Path,\n        Username = \"foo\",\n        Groups = new[]\n        {\n            \"one\",\n            \"two\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/okta\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := okta.NewAuthBackend(ctx, \"example\", \u0026okta.AuthBackendArgs{\n\t\t\tPath:         pulumi.String(\"user_okta\"),\n\t\t\tOrganization: pulumi.String(\"dummy\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = okta.NewAuthBackendUser(ctx, \"foo\", \u0026okta.AuthBackendUserArgs{\n\t\t\tPath:     example.Path,\n\t\t\tUsername: pulumi.String(\"foo\"),\n\t\t\tGroups: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"one\"),\n\t\t\t\tpulumi.String(\"two\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.okta.AuthBackend;\nimport com.pulumi.vault.okta.AuthBackendArgs;\nimport com.pulumi.vault.okta.AuthBackendUser;\nimport com.pulumi.vault.okta.AuthBackendUserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new AuthBackend(\"example\", AuthBackendArgs.builder()        \n            .path(\"user_okta\")\n            .organization(\"dummy\")\n            .build());\n\n        var foo = new AuthBackendUser(\"foo\", AuthBackendUserArgs.builder()        \n            .path(example.path())\n            .username(\"foo\")\n            .groups(            \n                \"one\",\n                \"two\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: vault:okta:AuthBackend\n    properties:\n      path: user_okta\n      organization: dummy\n  foo:\n    type: vault:okta:AuthBackendUser\n    properties:\n      path: ${example.path}\n      username: foo\n      groups:\n        - one\n        - two\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nOkta authentication backend users can be imported using its `path/user` ID format, e.g.\n\n```sh\n $ pulumi import vault:okta/authBackendUser:AuthBackendUser example okta/foo\n```\n\n ",
            "properties": {
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Okta groups to associate with this user\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path where the Okta auth backend is mounted\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Vault policies to associate with this user\n"
                },
                "username": {
                    "type": "string",
                    "description": "Name of the user within Okta\n"
                }
            },
            "required": [
                "path",
                "username"
            ],
            "inputProperties": {
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Okta groups to associate with this user\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "The path where the Okta auth backend is mounted\n",
                    "willReplaceOnChanges": true
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Vault policies to associate with this user\n"
                },
                "username": {
                    "type": "string",
                    "description": "Name of the user within Okta\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "path",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendUser resources.\n",
                "properties": {
                    "groups": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Okta groups to associate with this user\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "The path where the Okta auth backend is mounted\n",
                        "willReplaceOnChanges": true
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Vault policies to associate with this user\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Name of the user within Okta\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendCert:SecretBackendCert": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst app = new vault.pkisecret.SecretBackendCert(\"app\", {\n    backend: vault_mount.intermediate.path,\n    commonName: \"app.my.domain\",\n}, {\n    dependsOn: [vault_pki_secret_backend_role.admin],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\napp = vault.pki_secret.SecretBackendCert(\"app\",\n    backend=vault_mount[\"intermediate\"][\"path\"],\n    common_name=\"app.my.domain\",\n    opts=pulumi.ResourceOptions(depends_on=[vault_pki_secret_backend_role[\"admin\"]]))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var app = new Vault.PkiSecret.SecretBackendCert(\"app\", new()\n    {\n        Backend = vault_mount.Intermediate.Path,\n        CommonName = \"app.my.domain\",\n    }, new CustomResourceOptions\n    {\n        DependsOn = new[]\n        {\n            vault_pki_secret_backend_role.Admin,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/pkiSecret\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := pkiSecret.NewSecretBackendCert(ctx, \"app\", \u0026pkiSecret.SecretBackendCertArgs{\n\t\t\tBackend:    pulumi.Any(vault_mount.Intermediate.Path),\n\t\t\tCommonName: pulumi.String(\"app.my.domain\"),\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\tvault_pki_secret_backend_role.Admin,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.pkiSecret.SecretBackendCert;\nimport com.pulumi.vault.pkiSecret.SecretBackendCertArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var app = new SecretBackendCert(\"app\", SecretBackendCertArgs.builder()        \n            .backend(vault_mount.intermediate().path())\n            .commonName(\"app.my.domain\")\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(vault_pki_secret_backend_role.admin())\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  app:\n    type: vault:pkiSecret:SecretBackendCert\n    properties:\n      backend: ${vault_mount.intermediate.path}\n      commonName: app.my.domain\n    options:\n      dependson:\n        - ${vault_pki_secret_backend_role.admin}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "autoRenew": {
                    "type": "boolean",
                    "description": "If set to `true`, certs will be renewed if the expiration is within `min_seconds_remaining`. Default `false`\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "caChain": {
                    "type": "string",
                    "description": "The CA chain\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The certificate\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of certificate to create\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "expiration": {
                    "type": "integer",
                    "description": "The expiration date of the certificate in unix epoch format\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "issuingCa": {
                    "type": "string",
                    "description": "The issuing CA\n"
                },
                "minSecondsRemaining": {
                    "type": "integer",
                    "description": "Generate a new certificate when the expiration is within this number of seconds, default is 604800 (7 days)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the role to create the certificate against\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "The private key\n",
                    "secret": true
                },
                "privateKeyFormat": {
                    "type": "string",
                    "description": "The private key format\n"
                },
                "privateKeyType": {
                    "type": "string",
                    "description": "The private key type\n"
                },
                "renewPending": {
                    "type": "boolean",
                    "description": "`true` if the current time (during refresh) is after the start of the early renewal window declared by `min_seconds_remaining`, and `false` otherwise; if `auto_renew` is set to `true` then the provider will plan to replace the certificate once renewal is pending.\n"
                },
                "revoke": {
                    "type": "boolean",
                    "description": "If set to `true`, the certificate will be revoked on resource destruction.\n"
                },
                "serialNumber": {
                    "type": "string",
                    "description": "The serial number\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n"
                }
            },
            "required": [
                "backend",
                "caChain",
                "certificate",
                "commonName",
                "expiration",
                "issuingCa",
                "name",
                "privateKey",
                "privateKeyType",
                "renewPending",
                "serialNumber"
            ],
            "inputProperties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n",
                    "willReplaceOnChanges": true
                },
                "autoRenew": {
                    "type": "boolean",
                    "description": "If set to `true`, certs will be renewed if the expiration is within `min_seconds_remaining`. Default `false`\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n",
                    "willReplaceOnChanges": true
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of certificate to create\n",
                    "willReplaceOnChanges": true
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n",
                    "willReplaceOnChanges": true
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n",
                    "willReplaceOnChanges": true
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n",
                    "willReplaceOnChanges": true
                },
                "minSecondsRemaining": {
                    "type": "integer",
                    "description": "Generate a new certificate when the expiration is within this number of seconds, default is 604800 (7 days)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the role to create the certificate against\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n",
                    "willReplaceOnChanges": true
                },
                "privateKeyFormat": {
                    "type": "string",
                    "description": "The private key format\n",
                    "willReplaceOnChanges": true
                },
                "revoke": {
                    "type": "boolean",
                    "description": "If set to `true`, the certificate will be revoked on resource destruction.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "backend",
                "commonName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendCert resources.\n",
                "properties": {
                    "altNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative names\n",
                        "willReplaceOnChanges": true
                    },
                    "autoRenew": {
                        "type": "boolean",
                        "description": "If set to `true`, certs will be renewed if the expiration is within `min_seconds_remaining`. Default `false`\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The PKI secret backend the resource belongs to.\n",
                        "willReplaceOnChanges": true
                    },
                    "caChain": {
                        "type": "string",
                        "description": "The CA chain\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "The certificate\n"
                    },
                    "commonName": {
                        "type": "string",
                        "description": "CN of certificate to create\n",
                        "willReplaceOnChanges": true
                    },
                    "excludeCnFromSans": {
                        "type": "boolean",
                        "description": "Flag to exclude CN from SANs\n",
                        "willReplaceOnChanges": true
                    },
                    "expiration": {
                        "type": "integer",
                        "description": "The expiration date of the certificate in unix epoch format\n"
                    },
                    "format": {
                        "type": "string",
                        "description": "The format of data\n",
                        "willReplaceOnChanges": true
                    },
                    "ipSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative IPs\n",
                        "willReplaceOnChanges": true
                    },
                    "issuingCa": {
                        "type": "string",
                        "description": "The issuing CA\n"
                    },
                    "minSecondsRemaining": {
                        "type": "integer",
                        "description": "Generate a new certificate when the expiration is within this number of seconds, default is 604800 (7 days)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the role to create the certificate against\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "otherSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of other SANs\n",
                        "willReplaceOnChanges": true
                    },
                    "privateKey": {
                        "type": "string",
                        "description": "The private key\n",
                        "secret": true
                    },
                    "privateKeyFormat": {
                        "type": "string",
                        "description": "The private key format\n",
                        "willReplaceOnChanges": true
                    },
                    "privateKeyType": {
                        "type": "string",
                        "description": "The private key type\n"
                    },
                    "renewPending": {
                        "type": "boolean",
                        "description": "`true` if the current time (during refresh) is after the start of the early renewal window declared by `min_seconds_remaining`, and `false` otherwise; if `auto_renew` is set to `true` then the provider will plan to replace the certificate once renewal is pending.\n"
                    },
                    "revoke": {
                        "type": "boolean",
                        "description": "If set to `true`, the certificate will be revoked on resource destruction.\n"
                    },
                    "serialNumber": {
                        "type": "string",
                        "description": "The serial number\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Time to live\n"
                    },
                    "uriSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative URIs\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendConfigCa:SecretBackendConfigCa": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst intermediate = new vault.pkisecret.SecretBackendConfigCa(\"intermediate\", {\n    backend: vault_mount.intermediate.path,\n    pemBundle: `-----BEGIN RSA PRIVATE KEY-----\nMIIEowIBAAKCAQEAwvEHeJCXnFgi88rE1dTX6FHdBPK0wSjedh0ywVnCZxLWbBv/\n5PytjTcCPdrfW7g2sfbPwOge/WF3X2KeYSP8SxZA0czmz6QDspeG921JkZWtyp5o\n++N0leLTIUAhq339p3O1onAOUO1k4sHfmCwfrDpTn2hcx4URa5Pzzb1fHigusjIH\n1mcGdncaA6Z2CzO1w4E8kPOUukIDrcZT4faOZrWUIQZKQw2JzTyKJ+ZMDCZq2TFz\nWwpL3eG48wB7J7mibFQ/9nFvxpIflBjDAZ8QiqkwYr5N0DNsTxcfTCSeubfJDCUf\nIWwFZhLitzwOxazazUQKXX/SPMQ1l/L9o3nnHwIDAQABAoIBAAQidJQcDPsl62fc\nTxxx7TpiMhvewfKu2TkMGX18V+EzxxR364+BxHSQTB3fvIkHeTGBGJrw0WdyX8PI\nJa/NwZYeHLXWcLbKtcFd8WDiEoNh91Oq1HMzOc/MBcpYv94RSAX7MEkHs2YIAvHE\nRufFV86hVhC1d/JLYjkz5CHi+Fd9XTYjBK78tHhJd4IJPu5LYvwlmzC1zeS7s1Tg\nQW1FQuVDV8tWa4PMTrQHwfaGqn95AKc+tbg+ubpCiWl5bBNI3Ghuh4sAC9dMdAkd\nw27i29O9/Y3XJSSGUZlZqDBP4YU388RgHpzLDUxgRcaQt9vdeEz6frULPW67e9D2\nmPPDzjECgYEA4aPOwvnSwGoOKsS6vANGy4Ajsq09PR+1ltMJUR5kDlXGuZWI72eX\n3/GAnovDuCp0tbYt0r7Fmkfel0Ore7SYM18TH5QGpPddcZLvKUf7AchCIOYY0Te3\npS9+7S1lEGrLXyuox4N26Ov6wHVrmZTcQoZsDWbjYxNNsNACsiQNjGMCgYEA3SvQ\nJets9e9SgNVvao2TijX+/vcNKRfcWB71T9Xc4BuSNEu5+ZLtptlwaSnVCVu1Xilk\nsWDh+3EhByl4EteENPvE/7A2s1sfcDOprvg0r52aBZKeTp0AukrT8+Ad4hap7g1x\n2Lz11MFDkhRqt2KqQaIL+5Mq5WfptbBJ0YI7ARUCgYAD6iSfK1hlsDFYupsGwgPL\nagi0g97pHZC38idaOe3AdeqBs79xb9mpr/XsSj52Bn6J3IRFALxK5e5Nr4XdGo/9\nbCvXw2iuGgCMBOGTVMVdDY1gJr3Ne2r7Oay5Dq2PMFsg5pACDhzVA6sRBbh9LKD5\non1jaiKNyHrzk1hIoOl/QwKBgA+Ov2uLbfS2yvTpDpdOMiyss603r6NOXF+Ofe8J\nuinBhr1K/mAB59muveuH18Z6vv1KqByaFgtb39jjH+Eja9dWRns95/sh08pOuAbo\nyrv3uBfgQmaBQMXZ8aLcBv4aXgWyyGlYkWpP1fL2oLMZq6RGQ9WEeqX8c0ImjmrA\nYGopAoGBAJZPFlZi2Rfq4MfFZp/X1/zM09hphZwkxkSI+RnsjDUjTgB8CuQul5ep\nKWE98yLw4C25Cqw5fKKQ2addizLnZCAIfJKVNRjYLWlWyGQydDEUzqwXlSLS9LVX\nLxLkWDajIyjeFn21Ttb42L9pBo3TAQIxUenom/lP2SQTvCKBiPai\n-----END RSA PRIVATE KEY-----\n-----BEGIN CERTIFICATE-----\nMIIDazCCAlOgAwIBAgIUahce2sCO7Bom/Rznd5HsNAlr1NgwDQYJKoZIhvcNAQEL\nBQAwRTELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUxITAfBgNVBAoM\nGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDAeFw0xODEyMDIwMTAxNDRaFw00NjEy\nMTUwMTAxNDRaMEUxCzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEw\nHwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQwggEiMA0GCSqGSIb3DQEB\nAQUAA4IBDwAwggEKAoIBAQDC8Qd4kJecWCLzysTV1NfoUd0E8rTBKN52HTLBWcJn\nEtZsG//k/K2NNwI92t9buDax9s/A6B79YXdfYp5hI/xLFkDRzObPpAOyl4b3bUmR\nla3Knmj743SV4tMhQCGrff2nc7WicA5Q7WTiwd+YLB+sOlOfaFzHhRFrk/PNvV8e\nKC6yMgfWZwZ2dxoDpnYLM7XDgTyQ85S6QgOtxlPh9o5mtZQhBkpDDYnNPIon5kwM\nJmrZMXNbCkvd4bjzAHsnuaJsVD/2cW/Gkh+UGMMBnxCKqTBivk3QM2xPFx9MJJ65\nt8kMJR8hbAVmEuK3PA7FrNrNRApdf9I8xDWX8v2jeecfAgMBAAGjUzBRMB0GA1Ud\nDgQWBBQXGfrns8OqxTGKsXG5pDZS/WyyYDAfBgNVHSMEGDAWgBQXGfrns8OqxTGK\nsXG5pDZS/WyyYDAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEBCwUAA4IBAQCt\n8aUX26cl2PgdIEByZSHAX5G+2b0IEtTclPkl4uDyyKRY4dVq6gK3ueVSU5eUmBip\nJbV5aRetovGOcV//8vbxkZm/ntQ8Oo+2sfGR5lIzd0UdlOr5pkD6g3bFy/zJ+4DR\nDAe8fklUacfz6CFmD+H8GyHm+fKmF+mjr4oOGQW6OegRDJHuiipUk2lJyuXdlPSa\nFpNRO2sGbjn000ANinFgnFiVzGDnx0/G1Kii/6GWrI6rrdVmXioQzF+8AloWckeB\n+hbmbwkwQa/JrLb5SWcBDOXSgtn1Li3XF5AQQBBjA3pOlyBXqnI94Irw89Lv9uPT\nMUR4qFxeUOW/GJGccMUd\n-----END CERTIFICATE-----\n`,\n}, {\n    dependsOn: [vault_mount.intermediate],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nintermediate = vault.pki_secret.SecretBackendConfigCa(\"intermediate\",\n    backend=vault_mount[\"intermediate\"][\"path\"],\n    pem_bundle=\"\"\"-----BEGIN RSA PRIVATE KEY-----\nMIIEowIBAAKCAQEAwvEHeJCXnFgi88rE1dTX6FHdBPK0wSjedh0ywVnCZxLWbBv/\n5PytjTcCPdrfW7g2sfbPwOge/WF3X2KeYSP8SxZA0czmz6QDspeG921JkZWtyp5o\n++N0leLTIUAhq339p3O1onAOUO1k4sHfmCwfrDpTn2hcx4URa5Pzzb1fHigusjIH\n1mcGdncaA6Z2CzO1w4E8kPOUukIDrcZT4faOZrWUIQZKQw2JzTyKJ+ZMDCZq2TFz\nWwpL3eG48wB7J7mibFQ/9nFvxpIflBjDAZ8QiqkwYr5N0DNsTxcfTCSeubfJDCUf\nIWwFZhLitzwOxazazUQKXX/SPMQ1l/L9o3nnHwIDAQABAoIBAAQidJQcDPsl62fc\nTxxx7TpiMhvewfKu2TkMGX18V+EzxxR364+BxHSQTB3fvIkHeTGBGJrw0WdyX8PI\nJa/NwZYeHLXWcLbKtcFd8WDiEoNh91Oq1HMzOc/MBcpYv94RSAX7MEkHs2YIAvHE\nRufFV86hVhC1d/JLYjkz5CHi+Fd9XTYjBK78tHhJd4IJPu5LYvwlmzC1zeS7s1Tg\nQW1FQuVDV8tWa4PMTrQHwfaGqn95AKc+tbg+ubpCiWl5bBNI3Ghuh4sAC9dMdAkd\nw27i29O9/Y3XJSSGUZlZqDBP4YU388RgHpzLDUxgRcaQt9vdeEz6frULPW67e9D2\nmPPDzjECgYEA4aPOwvnSwGoOKsS6vANGy4Ajsq09PR+1ltMJUR5kDlXGuZWI72eX\n3/GAnovDuCp0tbYt0r7Fmkfel0Ore7SYM18TH5QGpPddcZLvKUf7AchCIOYY0Te3\npS9+7S1lEGrLXyuox4N26Ov6wHVrmZTcQoZsDWbjYxNNsNACsiQNjGMCgYEA3SvQ\nJets9e9SgNVvao2TijX+/vcNKRfcWB71T9Xc4BuSNEu5+ZLtptlwaSnVCVu1Xilk\nsWDh+3EhByl4EteENPvE/7A2s1sfcDOprvg0r52aBZKeTp0AukrT8+Ad4hap7g1x\n2Lz11MFDkhRqt2KqQaIL+5Mq5WfptbBJ0YI7ARUCgYAD6iSfK1hlsDFYupsGwgPL\nagi0g97pHZC38idaOe3AdeqBs79xb9mpr/XsSj52Bn6J3IRFALxK5e5Nr4XdGo/9\nbCvXw2iuGgCMBOGTVMVdDY1gJr3Ne2r7Oay5Dq2PMFsg5pACDhzVA6sRBbh9LKD5\non1jaiKNyHrzk1hIoOl/QwKBgA+Ov2uLbfS2yvTpDpdOMiyss603r6NOXF+Ofe8J\nuinBhr1K/mAB59muveuH18Z6vv1KqByaFgtb39jjH+Eja9dWRns95/sh08pOuAbo\nyrv3uBfgQmaBQMXZ8aLcBv4aXgWyyGlYkWpP1fL2oLMZq6RGQ9WEeqX8c0ImjmrA\nYGopAoGBAJZPFlZi2Rfq4MfFZp/X1/zM09hphZwkxkSI+RnsjDUjTgB8CuQul5ep\nKWE98yLw4C25Cqw5fKKQ2addizLnZCAIfJKVNRjYLWlWyGQydDEUzqwXlSLS9LVX\nLxLkWDajIyjeFn21Ttb42L9pBo3TAQIxUenom/lP2SQTvCKBiPai\n-----END RSA PRIVATE KEY-----\n-----BEGIN CERTIFICATE-----\nMIIDazCCAlOgAwIBAgIUahce2sCO7Bom/Rznd5HsNAlr1NgwDQYJKoZIhvcNAQEL\nBQAwRTELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUxITAfBgNVBAoM\nGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDAeFw0xODEyMDIwMTAxNDRaFw00NjEy\nMTUwMTAxNDRaMEUxCzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEw\nHwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQwggEiMA0GCSqGSIb3DQEB\nAQUAA4IBDwAwggEKAoIBAQDC8Qd4kJecWCLzysTV1NfoUd0E8rTBKN52HTLBWcJn\nEtZsG//k/K2NNwI92t9buDax9s/A6B79YXdfYp5hI/xLFkDRzObPpAOyl4b3bUmR\nla3Knmj743SV4tMhQCGrff2nc7WicA5Q7WTiwd+YLB+sOlOfaFzHhRFrk/PNvV8e\nKC6yMgfWZwZ2dxoDpnYLM7XDgTyQ85S6QgOtxlPh9o5mtZQhBkpDDYnNPIon5kwM\nJmrZMXNbCkvd4bjzAHsnuaJsVD/2cW/Gkh+UGMMBnxCKqTBivk3QM2xPFx9MJJ65\nt8kMJR8hbAVmEuK3PA7FrNrNRApdf9I8xDWX8v2jeecfAgMBAAGjUzBRMB0GA1Ud\nDgQWBBQXGfrns8OqxTGKsXG5pDZS/WyyYDAfBgNVHSMEGDAWgBQXGfrns8OqxTGK\nsXG5pDZS/WyyYDAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEBCwUAA4IBAQCt\n8aUX26cl2PgdIEByZSHAX5G+2b0IEtTclPkl4uDyyKRY4dVq6gK3ueVSU5eUmBip\nJbV5aRetovGOcV//8vbxkZm/ntQ8Oo+2sfGR5lIzd0UdlOr5pkD6g3bFy/zJ+4DR\nDAe8fklUacfz6CFmD+H8GyHm+fKmF+mjr4oOGQW6OegRDJHuiipUk2lJyuXdlPSa\nFpNRO2sGbjn000ANinFgnFiVzGDnx0/G1Kii/6GWrI6rrdVmXioQzF+8AloWckeB\n+hbmbwkwQa/JrLb5SWcBDOXSgtn1Li3XF5AQQBBjA3pOlyBXqnI94Irw89Lv9uPT\nMUR4qFxeUOW/GJGccMUd\n-----END CERTIFICATE-----\n\"\"\",\n    opts=pulumi.ResourceOptions(depends_on=[vault_mount[\"intermediate\"]]))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var intermediate = new Vault.PkiSecret.SecretBackendConfigCa(\"intermediate\", new()\n    {\n        Backend = vault_mount.Intermediate.Path,\n        PemBundle = @\"-----BEGIN RSA PRIVATE KEY-----\nMIIEowIBAAKCAQEAwvEHeJCXnFgi88rE1dTX6FHdBPK0wSjedh0ywVnCZxLWbBv/\n5PytjTcCPdrfW7g2sfbPwOge/WF3X2KeYSP8SxZA0czmz6QDspeG921JkZWtyp5o\n++N0leLTIUAhq339p3O1onAOUO1k4sHfmCwfrDpTn2hcx4URa5Pzzb1fHigusjIH\n1mcGdncaA6Z2CzO1w4E8kPOUukIDrcZT4faOZrWUIQZKQw2JzTyKJ+ZMDCZq2TFz\nWwpL3eG48wB7J7mibFQ/9nFvxpIflBjDAZ8QiqkwYr5N0DNsTxcfTCSeubfJDCUf\nIWwFZhLitzwOxazazUQKXX/SPMQ1l/L9o3nnHwIDAQABAoIBAAQidJQcDPsl62fc\nTxxx7TpiMhvewfKu2TkMGX18V+EzxxR364+BxHSQTB3fvIkHeTGBGJrw0WdyX8PI\nJa/NwZYeHLXWcLbKtcFd8WDiEoNh91Oq1HMzOc/MBcpYv94RSAX7MEkHs2YIAvHE\nRufFV86hVhC1d/JLYjkz5CHi+Fd9XTYjBK78tHhJd4IJPu5LYvwlmzC1zeS7s1Tg\nQW1FQuVDV8tWa4PMTrQHwfaGqn95AKc+tbg+ubpCiWl5bBNI3Ghuh4sAC9dMdAkd\nw27i29O9/Y3XJSSGUZlZqDBP4YU388RgHpzLDUxgRcaQt9vdeEz6frULPW67e9D2\nmPPDzjECgYEA4aPOwvnSwGoOKsS6vANGy4Ajsq09PR+1ltMJUR5kDlXGuZWI72eX\n3/GAnovDuCp0tbYt0r7Fmkfel0Ore7SYM18TH5QGpPddcZLvKUf7AchCIOYY0Te3\npS9+7S1lEGrLXyuox4N26Ov6wHVrmZTcQoZsDWbjYxNNsNACsiQNjGMCgYEA3SvQ\nJets9e9SgNVvao2TijX+/vcNKRfcWB71T9Xc4BuSNEu5+ZLtptlwaSnVCVu1Xilk\nsWDh+3EhByl4EteENPvE/7A2s1sfcDOprvg0r52aBZKeTp0AukrT8+Ad4hap7g1x\n2Lz11MFDkhRqt2KqQaIL+5Mq5WfptbBJ0YI7ARUCgYAD6iSfK1hlsDFYupsGwgPL\nagi0g97pHZC38idaOe3AdeqBs79xb9mpr/XsSj52Bn6J3IRFALxK5e5Nr4XdGo/9\nbCvXw2iuGgCMBOGTVMVdDY1gJr3Ne2r7Oay5Dq2PMFsg5pACDhzVA6sRBbh9LKD5\non1jaiKNyHrzk1hIoOl/QwKBgA+Ov2uLbfS2yvTpDpdOMiyss603r6NOXF+Ofe8J\nuinBhr1K/mAB59muveuH18Z6vv1KqByaFgtb39jjH+Eja9dWRns95/sh08pOuAbo\nyrv3uBfgQmaBQMXZ8aLcBv4aXgWyyGlYkWpP1fL2oLMZq6RGQ9WEeqX8c0ImjmrA\nYGopAoGBAJZPFlZi2Rfq4MfFZp/X1/zM09hphZwkxkSI+RnsjDUjTgB8CuQul5ep\nKWE98yLw4C25Cqw5fKKQ2addizLnZCAIfJKVNRjYLWlWyGQydDEUzqwXlSLS9LVX\nLxLkWDajIyjeFn21Ttb42L9pBo3TAQIxUenom/lP2SQTvCKBiPai\n-----END RSA PRIVATE KEY-----\n-----BEGIN CERTIFICATE-----\nMIIDazCCAlOgAwIBAgIUahce2sCO7Bom/Rznd5HsNAlr1NgwDQYJKoZIhvcNAQEL\nBQAwRTELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUxITAfBgNVBAoM\nGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDAeFw0xODEyMDIwMTAxNDRaFw00NjEy\nMTUwMTAxNDRaMEUxCzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEw\nHwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQwggEiMA0GCSqGSIb3DQEB\nAQUAA4IBDwAwggEKAoIBAQDC8Qd4kJecWCLzysTV1NfoUd0E8rTBKN52HTLBWcJn\nEtZsG//k/K2NNwI92t9buDax9s/A6B79YXdfYp5hI/xLFkDRzObPpAOyl4b3bUmR\nla3Knmj743SV4tMhQCGrff2nc7WicA5Q7WTiwd+YLB+sOlOfaFzHhRFrk/PNvV8e\nKC6yMgfWZwZ2dxoDpnYLM7XDgTyQ85S6QgOtxlPh9o5mtZQhBkpDDYnNPIon5kwM\nJmrZMXNbCkvd4bjzAHsnuaJsVD/2cW/Gkh+UGMMBnxCKqTBivk3QM2xPFx9MJJ65\nt8kMJR8hbAVmEuK3PA7FrNrNRApdf9I8xDWX8v2jeecfAgMBAAGjUzBRMB0GA1Ud\nDgQWBBQXGfrns8OqxTGKsXG5pDZS/WyyYDAfBgNVHSMEGDAWgBQXGfrns8OqxTGK\nsXG5pDZS/WyyYDAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEBCwUAA4IBAQCt\n8aUX26cl2PgdIEByZSHAX5G+2b0IEtTclPkl4uDyyKRY4dVq6gK3ueVSU5eUmBip\nJbV5aRetovGOcV//8vbxkZm/ntQ8Oo+2sfGR5lIzd0UdlOr5pkD6g3bFy/zJ+4DR\nDAe8fklUacfz6CFmD+H8GyHm+fKmF+mjr4oOGQW6OegRDJHuiipUk2lJyuXdlPSa\nFpNRO2sGbjn000ANinFgnFiVzGDnx0/G1Kii/6GWrI6rrdVmXioQzF+8AloWckeB\n+hbmbwkwQa/JrLb5SWcBDOXSgtn1Li3XF5AQQBBjA3pOlyBXqnI94Irw89Lv9uPT\nMUR4qFxeUOW/GJGccMUd\n-----END CERTIFICATE-----\n\",\n    }, new CustomResourceOptions\n    {\n        DependsOn = new[]\n        {\n            vault_mount.Intermediate,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/pkiSecret\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := pkiSecret.NewSecretBackendConfigCa(ctx, \"intermediate\", \u0026pkiSecret.SecretBackendConfigCaArgs{\n\t\t\tBackend:   pulumi.Any(vault_mount.Intermediate.Path),\n\t\t\tPemBundle: pulumi.String(\"-----BEGIN RSA PRIVATE KEY-----\\nMIIEowIBAAKCAQEAwvEHeJCXnFgi88rE1dTX6FHdBPK0wSjedh0ywVnCZxLWbBv/\\n5PytjTcCPdrfW7g2sfbPwOge/WF3X2KeYSP8SxZA0czmz6QDspeG921JkZWtyp5o\\n++N0leLTIUAhq339p3O1onAOUO1k4sHfmCwfrDpTn2hcx4URa5Pzzb1fHigusjIH\\n1mcGdncaA6Z2CzO1w4E8kPOUukIDrcZT4faOZrWUIQZKQw2JzTyKJ+ZMDCZq2TFz\\nWwpL3eG48wB7J7mibFQ/9nFvxpIflBjDAZ8QiqkwYr5N0DNsTxcfTCSeubfJDCUf\\nIWwFZhLitzwOxazazUQKXX/SPMQ1l/L9o3nnHwIDAQABAoIBAAQidJQcDPsl62fc\\nTxxx7TpiMhvewfKu2TkMGX18V+EzxxR364+BxHSQTB3fvIkHeTGBGJrw0WdyX8PI\\nJa/NwZYeHLXWcLbKtcFd8WDiEoNh91Oq1HMzOc/MBcpYv94RSAX7MEkHs2YIAvHE\\nRufFV86hVhC1d/JLYjkz5CHi+Fd9XTYjBK78tHhJd4IJPu5LYvwlmzC1zeS7s1Tg\\nQW1FQuVDV8tWa4PMTrQHwfaGqn95AKc+tbg+ubpCiWl5bBNI3Ghuh4sAC9dMdAkd\\nw27i29O9/Y3XJSSGUZlZqDBP4YU388RgHpzLDUxgRcaQt9vdeEz6frULPW67e9D2\\nmPPDzjECgYEA4aPOwvnSwGoOKsS6vANGy4Ajsq09PR+1ltMJUR5kDlXGuZWI72eX\\n3/GAnovDuCp0tbYt0r7Fmkfel0Ore7SYM18TH5QGpPddcZLvKUf7AchCIOYY0Te3\\npS9+7S1lEGrLXyuox4N26Ov6wHVrmZTcQoZsDWbjYxNNsNACsiQNjGMCgYEA3SvQ\\nJets9e9SgNVvao2TijX+/vcNKRfcWB71T9Xc4BuSNEu5+ZLtptlwaSnVCVu1Xilk\\nsWDh+3EhByl4EteENPvE/7A2s1sfcDOprvg0r52aBZKeTp0AukrT8+Ad4hap7g1x\\n2Lz11MFDkhRqt2KqQaIL+5Mq5WfptbBJ0YI7ARUCgYAD6iSfK1hlsDFYupsGwgPL\\nagi0g97pHZC38idaOe3AdeqBs79xb9mpr/XsSj52Bn6J3IRFALxK5e5Nr4XdGo/9\\nbCvXw2iuGgCMBOGTVMVdDY1gJr3Ne2r7Oay5Dq2PMFsg5pACDhzVA6sRBbh9LKD5\\non1jaiKNyHrzk1hIoOl/QwKBgA+Ov2uLbfS2yvTpDpdOMiyss603r6NOXF+Ofe8J\\nuinBhr1K/mAB59muveuH18Z6vv1KqByaFgtb39jjH+Eja9dWRns95/sh08pOuAbo\\nyrv3uBfgQmaBQMXZ8aLcBv4aXgWyyGlYkWpP1fL2oLMZq6RGQ9WEeqX8c0ImjmrA\\nYGopAoGBAJZPFlZi2Rfq4MfFZp/X1/zM09hphZwkxkSI+RnsjDUjTgB8CuQul5ep\\nKWE98yLw4C25Cqw5fKKQ2addizLnZCAIfJKVNRjYLWlWyGQydDEUzqwXlSLS9LVX\\nLxLkWDajIyjeFn21Ttb42L9pBo3TAQIxUenom/lP2SQTvCKBiPai\\n-----END RSA PRIVATE KEY-----\\n-----BEGIN CERTIFICATE-----\\nMIIDazCCAlOgAwIBAgIUahce2sCO7Bom/Rznd5HsNAlr1NgwDQYJKoZIhvcNAQEL\\nBQAwRTELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUxITAfBgNVBAoM\\nGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDAeFw0xODEyMDIwMTAxNDRaFw00NjEy\\nMTUwMTAxNDRaMEUxCzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEw\\nHwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQwggEiMA0GCSqGSIb3DQEB\\nAQUAA4IBDwAwggEKAoIBAQDC8Qd4kJecWCLzysTV1NfoUd0E8rTBKN52HTLBWcJn\\nEtZsG//k/K2NNwI92t9buDax9s/A6B79YXdfYp5hI/xLFkDRzObPpAOyl4b3bUmR\\nla3Knmj743SV4tMhQCGrff2nc7WicA5Q7WTiwd+YLB+sOlOfaFzHhRFrk/PNvV8e\\nKC6yMgfWZwZ2dxoDpnYLM7XDgTyQ85S6QgOtxlPh9o5mtZQhBkpDDYnNPIon5kwM\\nJmrZMXNbCkvd4bjzAHsnuaJsVD/2cW/Gkh+UGMMBnxCKqTBivk3QM2xPFx9MJJ65\\nt8kMJR8hbAVmEuK3PA7FrNrNRApdf9I8xDWX8v2jeecfAgMBAAGjUzBRMB0GA1Ud\\nDgQWBBQXGfrns8OqxTGKsXG5pDZS/WyyYDAfBgNVHSMEGDAWgBQXGfrns8OqxTGK\\nsXG5pDZS/WyyYDAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEBCwUAA4IBAQCt\\n8aUX26cl2PgdIEByZSHAX5G+2b0IEtTclPkl4uDyyKRY4dVq6gK3ueVSU5eUmBip\\nJbV5aRetovGOcV//8vbxkZm/ntQ8Oo+2sfGR5lIzd0UdlOr5pkD6g3bFy/zJ+4DR\\nDAe8fklUacfz6CFmD+H8GyHm+fKmF+mjr4oOGQW6OegRDJHuiipUk2lJyuXdlPSa\\nFpNRO2sGbjn000ANinFgnFiVzGDnx0/G1Kii/6GWrI6rrdVmXioQzF+8AloWckeB\\n+hbmbwkwQa/JrLb5SWcBDOXSgtn1Li3XF5AQQBBjA3pOlyBXqnI94Irw89Lv9uPT\\nMUR4qFxeUOW/GJGccMUd\\n-----END CERTIFICATE-----\\n\"),\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\tvault_mount.Intermediate,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.pkiSecret.SecretBackendConfigCa;\nimport com.pulumi.vault.pkiSecret.SecretBackendConfigCaArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var intermediate = new SecretBackendConfigCa(\"intermediate\", SecretBackendConfigCaArgs.builder()        \n            .backend(vault_mount.intermediate().path())\n            .pemBundle(\"\"\"\n-----BEGIN RSA PRIVATE KEY-----\nMIIEowIBAAKCAQEAwvEHeJCXnFgi88rE1dTX6FHdBPK0wSjedh0ywVnCZxLWbBv/\n5PytjTcCPdrfW7g2sfbPwOge/WF3X2KeYSP8SxZA0czmz6QDspeG921JkZWtyp5o\n++N0leLTIUAhq339p3O1onAOUO1k4sHfmCwfrDpTn2hcx4URa5Pzzb1fHigusjIH\n1mcGdncaA6Z2CzO1w4E8kPOUukIDrcZT4faOZrWUIQZKQw2JzTyKJ+ZMDCZq2TFz\nWwpL3eG48wB7J7mibFQ/9nFvxpIflBjDAZ8QiqkwYr5N0DNsTxcfTCSeubfJDCUf\nIWwFZhLitzwOxazazUQKXX/SPMQ1l/L9o3nnHwIDAQABAoIBAAQidJQcDPsl62fc\nTxxx7TpiMhvewfKu2TkMGX18V+EzxxR364+BxHSQTB3fvIkHeTGBGJrw0WdyX8PI\nJa/NwZYeHLXWcLbKtcFd8WDiEoNh91Oq1HMzOc/MBcpYv94RSAX7MEkHs2YIAvHE\nRufFV86hVhC1d/JLYjkz5CHi+Fd9XTYjBK78tHhJd4IJPu5LYvwlmzC1zeS7s1Tg\nQW1FQuVDV8tWa4PMTrQHwfaGqn95AKc+tbg+ubpCiWl5bBNI3Ghuh4sAC9dMdAkd\nw27i29O9/Y3XJSSGUZlZqDBP4YU388RgHpzLDUxgRcaQt9vdeEz6frULPW67e9D2\nmPPDzjECgYEA4aPOwvnSwGoOKsS6vANGy4Ajsq09PR+1ltMJUR5kDlXGuZWI72eX\n3/GAnovDuCp0tbYt0r7Fmkfel0Ore7SYM18TH5QGpPddcZLvKUf7AchCIOYY0Te3\npS9+7S1lEGrLXyuox4N26Ov6wHVrmZTcQoZsDWbjYxNNsNACsiQNjGMCgYEA3SvQ\nJets9e9SgNVvao2TijX+/vcNKRfcWB71T9Xc4BuSNEu5+ZLtptlwaSnVCVu1Xilk\nsWDh+3EhByl4EteENPvE/7A2s1sfcDOprvg0r52aBZKeTp0AukrT8+Ad4hap7g1x\n2Lz11MFDkhRqt2KqQaIL+5Mq5WfptbBJ0YI7ARUCgYAD6iSfK1hlsDFYupsGwgPL\nagi0g97pHZC38idaOe3AdeqBs79xb9mpr/XsSj52Bn6J3IRFALxK5e5Nr4XdGo/9\nbCvXw2iuGgCMBOGTVMVdDY1gJr3Ne2r7Oay5Dq2PMFsg5pACDhzVA6sRBbh9LKD5\non1jaiKNyHrzk1hIoOl/QwKBgA+Ov2uLbfS2yvTpDpdOMiyss603r6NOXF+Ofe8J\nuinBhr1K/mAB59muveuH18Z6vv1KqByaFgtb39jjH+Eja9dWRns95/sh08pOuAbo\nyrv3uBfgQmaBQMXZ8aLcBv4aXgWyyGlYkWpP1fL2oLMZq6RGQ9WEeqX8c0ImjmrA\nYGopAoGBAJZPFlZi2Rfq4MfFZp/X1/zM09hphZwkxkSI+RnsjDUjTgB8CuQul5ep\nKWE98yLw4C25Cqw5fKKQ2addizLnZCAIfJKVNRjYLWlWyGQydDEUzqwXlSLS9LVX\nLxLkWDajIyjeFn21Ttb42L9pBo3TAQIxUenom/lP2SQTvCKBiPai\n-----END RSA PRIVATE KEY-----\n-----BEGIN CERTIFICATE-----\nMIIDazCCAlOgAwIBAgIUahce2sCO7Bom/Rznd5HsNAlr1NgwDQYJKoZIhvcNAQEL\nBQAwRTELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUxITAfBgNVBAoM\nGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDAeFw0xODEyMDIwMTAxNDRaFw00NjEy\nMTUwMTAxNDRaMEUxCzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEw\nHwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQwggEiMA0GCSqGSIb3DQEB\nAQUAA4IBDwAwggEKAoIBAQDC8Qd4kJecWCLzysTV1NfoUd0E8rTBKN52HTLBWcJn\nEtZsG//k/K2NNwI92t9buDax9s/A6B79YXdfYp5hI/xLFkDRzObPpAOyl4b3bUmR\nla3Knmj743SV4tMhQCGrff2nc7WicA5Q7WTiwd+YLB+sOlOfaFzHhRFrk/PNvV8e\nKC6yMgfWZwZ2dxoDpnYLM7XDgTyQ85S6QgOtxlPh9o5mtZQhBkpDDYnNPIon5kwM\nJmrZMXNbCkvd4bjzAHsnuaJsVD/2cW/Gkh+UGMMBnxCKqTBivk3QM2xPFx9MJJ65\nt8kMJR8hbAVmEuK3PA7FrNrNRApdf9I8xDWX8v2jeecfAgMBAAGjUzBRMB0GA1Ud\nDgQWBBQXGfrns8OqxTGKsXG5pDZS/WyyYDAfBgNVHSMEGDAWgBQXGfrns8OqxTGK\nsXG5pDZS/WyyYDAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEBCwUAA4IBAQCt\n8aUX26cl2PgdIEByZSHAX5G+2b0IEtTclPkl4uDyyKRY4dVq6gK3ueVSU5eUmBip\nJbV5aRetovGOcV//8vbxkZm/ntQ8Oo+2sfGR5lIzd0UdlOr5pkD6g3bFy/zJ+4DR\nDAe8fklUacfz6CFmD+H8GyHm+fKmF+mjr4oOGQW6OegRDJHuiipUk2lJyuXdlPSa\nFpNRO2sGbjn000ANinFgnFiVzGDnx0/G1Kii/6GWrI6rrdVmXioQzF+8AloWckeB\n+hbmbwkwQa/JrLb5SWcBDOXSgtn1Li3XF5AQQBBjA3pOlyBXqnI94Irw89Lv9uPT\nMUR4qFxeUOW/GJGccMUd\n-----END CERTIFICATE-----\n            \"\"\")\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(vault_mount.intermediate())\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  intermediate:\n    type: vault:pkiSecret:SecretBackendConfigCa\n    properties:\n      backend: ${vault_mount.intermediate.path}\n      pemBundle: |\n        -----BEGIN RSA PRIVATE KEY-----\n        MIIEowIBAAKCAQEAwvEHeJCXnFgi88rE1dTX6FHdBPK0wSjedh0ywVnCZxLWbBv/\n        5PytjTcCPdrfW7g2sfbPwOge/WF3X2KeYSP8SxZA0czmz6QDspeG921JkZWtyp5o\n        ++N0leLTIUAhq339p3O1onAOUO1k4sHfmCwfrDpTn2hcx4URa5Pzzb1fHigusjIH\n        1mcGdncaA6Z2CzO1w4E8kPOUukIDrcZT4faOZrWUIQZKQw2JzTyKJ+ZMDCZq2TFz\n        WwpL3eG48wB7J7mibFQ/9nFvxpIflBjDAZ8QiqkwYr5N0DNsTxcfTCSeubfJDCUf\n        IWwFZhLitzwOxazazUQKXX/SPMQ1l/L9o3nnHwIDAQABAoIBAAQidJQcDPsl62fc\n        Txxx7TpiMhvewfKu2TkMGX18V+EzxxR364+BxHSQTB3fvIkHeTGBGJrw0WdyX8PI\n        Ja/NwZYeHLXWcLbKtcFd8WDiEoNh91Oq1HMzOc/MBcpYv94RSAX7MEkHs2YIAvHE\n        RufFV86hVhC1d/JLYjkz5CHi+Fd9XTYjBK78tHhJd4IJPu5LYvwlmzC1zeS7s1Tg\n        QW1FQuVDV8tWa4PMTrQHwfaGqn95AKc+tbg+ubpCiWl5bBNI3Ghuh4sAC9dMdAkd\n        w27i29O9/Y3XJSSGUZlZqDBP4YU388RgHpzLDUxgRcaQt9vdeEz6frULPW67e9D2\n        mPPDzjECgYEA4aPOwvnSwGoOKsS6vANGy4Ajsq09PR+1ltMJUR5kDlXGuZWI72eX\n        3/GAnovDuCp0tbYt0r7Fmkfel0Ore7SYM18TH5QGpPddcZLvKUf7AchCIOYY0Te3\n        pS9+7S1lEGrLXyuox4N26Ov6wHVrmZTcQoZsDWbjYxNNsNACsiQNjGMCgYEA3SvQ\n        Jets9e9SgNVvao2TijX+/vcNKRfcWB71T9Xc4BuSNEu5+ZLtptlwaSnVCVu1Xilk\n        sWDh+3EhByl4EteENPvE/7A2s1sfcDOprvg0r52aBZKeTp0AukrT8+Ad4hap7g1x\n        2Lz11MFDkhRqt2KqQaIL+5Mq5WfptbBJ0YI7ARUCgYAD6iSfK1hlsDFYupsGwgPL\n        agi0g97pHZC38idaOe3AdeqBs79xb9mpr/XsSj52Bn6J3IRFALxK5e5Nr4XdGo/9\n        bCvXw2iuGgCMBOGTVMVdDY1gJr3Ne2r7Oay5Dq2PMFsg5pACDhzVA6sRBbh9LKD5\n        on1jaiKNyHrzk1hIoOl/QwKBgA+Ov2uLbfS2yvTpDpdOMiyss603r6NOXF+Ofe8J\n        uinBhr1K/mAB59muveuH18Z6vv1KqByaFgtb39jjH+Eja9dWRns95/sh08pOuAbo\n        yrv3uBfgQmaBQMXZ8aLcBv4aXgWyyGlYkWpP1fL2oLMZq6RGQ9WEeqX8c0ImjmrA\n        YGopAoGBAJZPFlZi2Rfq4MfFZp/X1/zM09hphZwkxkSI+RnsjDUjTgB8CuQul5ep\n        KWE98yLw4C25Cqw5fKKQ2addizLnZCAIfJKVNRjYLWlWyGQydDEUzqwXlSLS9LVX\n        LxLkWDajIyjeFn21Ttb42L9pBo3TAQIxUenom/lP2SQTvCKBiPai\n        -----END RSA PRIVATE KEY-----\n        -----BEGIN CERTIFICATE-----\n        MIIDazCCAlOgAwIBAgIUahce2sCO7Bom/Rznd5HsNAlr1NgwDQYJKoZIhvcNAQEL\n        BQAwRTELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUxITAfBgNVBAoM\n        GEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDAeFw0xODEyMDIwMTAxNDRaFw00NjEy\n        MTUwMTAxNDRaMEUxCzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEw\n        HwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQwggEiMA0GCSqGSIb3DQEB\n        AQUAA4IBDwAwggEKAoIBAQDC8Qd4kJecWCLzysTV1NfoUd0E8rTBKN52HTLBWcJn\n        EtZsG//k/K2NNwI92t9buDax9s/A6B79YXdfYp5hI/xLFkDRzObPpAOyl4b3bUmR\n        la3Knmj743SV4tMhQCGrff2nc7WicA5Q7WTiwd+YLB+sOlOfaFzHhRFrk/PNvV8e\n        KC6yMgfWZwZ2dxoDpnYLM7XDgTyQ85S6QgOtxlPh9o5mtZQhBkpDDYnNPIon5kwM\n        JmrZMXNbCkvd4bjzAHsnuaJsVD/2cW/Gkh+UGMMBnxCKqTBivk3QM2xPFx9MJJ65\n        t8kMJR8hbAVmEuK3PA7FrNrNRApdf9I8xDWX8v2jeecfAgMBAAGjUzBRMB0GA1Ud\n        DgQWBBQXGfrns8OqxTGKsXG5pDZS/WyyYDAfBgNVHSMEGDAWgBQXGfrns8OqxTGK\n        sXG5pDZS/WyyYDAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEBCwUAA4IBAQCt\n        8aUX26cl2PgdIEByZSHAX5G+2b0IEtTclPkl4uDyyKRY4dVq6gK3ueVSU5eUmBip\n        JbV5aRetovGOcV//8vbxkZm/ntQ8Oo+2sfGR5lIzd0UdlOr5pkD6g3bFy/zJ+4DR\n        DAe8fklUacfz6CFmD+H8GyHm+fKmF+mjr4oOGQW6OegRDJHuiipUk2lJyuXdlPSa\n        FpNRO2sGbjn000ANinFgnFiVzGDnx0/G1Kii/6GWrI6rrdVmXioQzF+8AloWckeB\n        +hbmbwkwQa/JrLb5SWcBDOXSgtn1Li3XF5AQQBBjA3pOlyBXqnI94Irw89Lv9uPT\n        MUR4qFxeUOW/GJGccMUd\n        -----END CERTIFICATE-----\n    options:\n      dependson:\n        - ${vault_mount.intermediate}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "pemBundle": {
                    "type": "string",
                    "description": "The key and certificate PEM bundle\n",
                    "secret": true
                }
            },
            "required": [
                "backend",
                "pemBundle"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "pemBundle": {
                    "type": "string",
                    "description": "The key and certificate PEM bundle\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "backend",
                "pemBundle"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendConfigCa resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The PKI secret backend the resource belongs to.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "pemBundle": {
                        "type": "string",
                        "description": "The key and certificate PEM bundle\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendConfigUrls:SecretBackendConfigUrls": {
            "description": "Allows setting the issuing certificate endpoints, CRL distribution points, and OCSP server endpoints that will be encoded into issued certificates.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst root = new vault.Mount(\"root\", {\n    path: \"pki-root\",\n    type: \"pki\",\n    description: \"root PKI\",\n    defaultLeaseTtlSeconds: 8640000,\n    maxLeaseTtlSeconds: 8640000,\n});\nconst example = new vault.pkisecret.SecretBackendConfigUrls(\"example\", {\n    backend: root.path,\n    issuingCertificates: [\"http://127.0.0.1:8200/v1/pki/ca\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nroot = vault.Mount(\"root\",\n    path=\"pki-root\",\n    type=\"pki\",\n    description=\"root PKI\",\n    default_lease_ttl_seconds=8640000,\n    max_lease_ttl_seconds=8640000)\nexample = vault.pki_secret.SecretBackendConfigUrls(\"example\",\n    backend=root.path,\n    issuing_certificates=[\"http://127.0.0.1:8200/v1/pki/ca\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var root = new Vault.Mount(\"root\", new()\n    {\n        Path = \"pki-root\",\n        Type = \"pki\",\n        Description = \"root PKI\",\n        DefaultLeaseTtlSeconds = 8640000,\n        MaxLeaseTtlSeconds = 8640000,\n    });\n\n    var example = new Vault.PkiSecret.SecretBackendConfigUrls(\"example\", new()\n    {\n        Backend = root.Path,\n        IssuingCertificates = new[]\n        {\n            \"http://127.0.0.1:8200/v1/pki/ca\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/pkiSecret\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\troot, err := vault.NewMount(ctx, \"root\", \u0026vault.MountArgs{\n\t\t\tPath:                   pulumi.String(\"pki-root\"),\n\t\t\tType:                   pulumi.String(\"pki\"),\n\t\t\tDescription:            pulumi.String(\"root PKI\"),\n\t\t\tDefaultLeaseTtlSeconds: pulumi.Int(8640000),\n\t\t\tMaxLeaseTtlSeconds:     pulumi.Int(8640000),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = pkiSecret.NewSecretBackendConfigUrls(ctx, \"example\", \u0026pkiSecret.SecretBackendConfigUrlsArgs{\n\t\t\tBackend: root.Path,\n\t\t\tIssuingCertificates: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://127.0.0.1:8200/v1/pki/ca\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Mount;\nimport com.pulumi.vault.MountArgs;\nimport com.pulumi.vault.pkiSecret.SecretBackendConfigUrls;\nimport com.pulumi.vault.pkiSecret.SecretBackendConfigUrlsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var root = new Mount(\"root\", MountArgs.builder()        \n            .path(\"pki-root\")\n            .type(\"pki\")\n            .description(\"root PKI\")\n            .defaultLeaseTtlSeconds(8640000)\n            .maxLeaseTtlSeconds(8640000)\n            .build());\n\n        var example = new SecretBackendConfigUrls(\"example\", SecretBackendConfigUrlsArgs.builder()        \n            .backend(root.path())\n            .issuingCertificates(\"http://127.0.0.1:8200/v1/pki/ca\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  root:\n    type: vault:Mount\n    properties:\n      path: pki-root\n      type: pki\n      description: root PKI\n      defaultLeaseTtlSeconds: 8.64e+06\n      maxLeaseTtlSeconds: 8.64e+06\n  example:\n    type: vault:pkiSecret:SecretBackendConfigUrls\n    properties:\n      backend: ${root.path}\n      issuingCertificates:\n        - http://127.0.0.1:8200/v1/pki/ca\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nThe PKI config URLs can be imported using the resource's `id`.\n\nIn the case of the example above the `id` would be `pki-root/config/urls`,\n\nwhere the `pki-root` component is the resource's `backend`, e.g.\n\n```sh\n $ pulumi import vault:pkiSecret/secretBackendConfigUrls:SecretBackendConfigUrls example pki-root/config/urls\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "crlDistributionPoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the URL values for the CRL Distribution Points field.\n"
                },
                "issuingCertificates": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the URL values for the Issuing Certificate field.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "ocspServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the URL values for the OCSP Servers field.\n"
                }
            },
            "required": [
                "backend"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "crlDistributionPoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the URL values for the CRL Distribution Points field.\n"
                },
                "issuingCertificates": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the URL values for the Issuing Certificate field.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "ocspServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the URL values for the OCSP Servers field.\n"
                }
            },
            "requiredInputs": [
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendConfigUrls resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                    },
                    "crlDistributionPoints": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the URL values for the CRL Distribution Points field.\n"
                    },
                    "issuingCertificates": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the URL values for the Issuing Certificate field.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "ocspServers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the URL values for the OCSP Servers field.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendCrlConfig:SecretBackendCrlConfig": {
            "description": "Allows setting the duration for which the generated CRL should be marked valid. If the CRL is disabled, it will return a signed but zero-length CRL for any request. If enabled, it will re-build the CRL.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst pki = new vault.Mount(\"pki\", {\n    path: \"%s\",\n    type: \"pki\",\n    defaultLeaseTtlSeconds: 3600,\n    maxLeaseTtlSeconds: 86400,\n});\nconst crlConfig = new vault.pkisecret.SecretBackendCrlConfig(\"crlConfig\", {\n    backend: pki.path,\n    expiry: \"72h\",\n    disable: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\npki = vault.Mount(\"pki\",\n    path=\"%s\",\n    type=\"pki\",\n    default_lease_ttl_seconds=3600,\n    max_lease_ttl_seconds=86400)\ncrl_config = vault.pki_secret.SecretBackendCrlConfig(\"crlConfig\",\n    backend=pki.path,\n    expiry=\"72h\",\n    disable=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var pki = new Vault.Mount(\"pki\", new()\n    {\n        Path = \"%s\",\n        Type = \"pki\",\n        DefaultLeaseTtlSeconds = 3600,\n        MaxLeaseTtlSeconds = 86400,\n    });\n\n    var crlConfig = new Vault.PkiSecret.SecretBackendCrlConfig(\"crlConfig\", new()\n    {\n        Backend = pki.Path,\n        Expiry = \"72h\",\n        Disable = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/pkiSecret\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tpki, err := vault.NewMount(ctx, \"pki\", \u0026vault.MountArgs{\n\t\t\tPath:                   pulumi.String(\"%s\"),\n\t\t\tType:                   pulumi.String(\"pki\"),\n\t\t\tDefaultLeaseTtlSeconds: pulumi.Int(3600),\n\t\t\tMaxLeaseTtlSeconds:     pulumi.Int(86400),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = pkiSecret.NewSecretBackendCrlConfig(ctx, \"crlConfig\", \u0026pkiSecret.SecretBackendCrlConfigArgs{\n\t\t\tBackend: pki.Path,\n\t\t\tExpiry:  pulumi.String(\"72h\"),\n\t\t\tDisable: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Mount;\nimport com.pulumi.vault.MountArgs;\nimport com.pulumi.vault.pkiSecret.SecretBackendCrlConfig;\nimport com.pulumi.vault.pkiSecret.SecretBackendCrlConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var pki = new Mount(\"pki\", MountArgs.builder()        \n            .path(\"%s\")\n            .type(\"pki\")\n            .defaultLeaseTtlSeconds(3600)\n            .maxLeaseTtlSeconds(86400)\n            .build());\n\n        var crlConfig = new SecretBackendCrlConfig(\"crlConfig\", SecretBackendCrlConfigArgs.builder()        \n            .backend(pki.path())\n            .expiry(\"72h\")\n            .disable(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  pki:\n    type: vault:Mount\n    properties:\n      path: '%s'\n      type: pki\n      defaultLeaseTtlSeconds: 3600\n      maxLeaseTtlSeconds: 86400\n  crlConfig:\n    type: vault:pkiSecret:SecretBackendCrlConfig\n    properties:\n      backend: ${pki.path}\n      expiry: 72h\n      disable: false\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "autoRebuild": {
                    "type": "boolean",
                    "description": "Enables periodic rebuilding of the CRL upon expiry. **Vault 1.12+**\n"
                },
                "autoRebuildGracePeriod": {
                    "type": "string",
                    "description": "Grace period before CRL expiry to attempt rebuild of CRL. **Vault 1.12+**\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "crossClusterRevocation": {
                    "type": "boolean",
                    "description": "Enable cross-cluster revocation request queues. **Vault 1.13+**\n"
                },
                "deltaRebuildInterval": {
                    "type": "string",
                    "description": "Interval to check for new revocations on, to regenerate the delta CRL.\n"
                },
                "disable": {
                    "type": "boolean",
                    "description": "Disables or enables CRL building.\n"
                },
                "enableDelta": {
                    "type": "boolean",
                    "description": "Enables building of delta CRLs with up-to-date revocation information, \naugmenting the last complete CRL.  **Vault 1.12+**\n"
                },
                "expiry": {
                    "type": "string",
                    "description": "Specifies the time until expiration.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "ocspDisable": {
                    "type": "boolean",
                    "description": "Disables the OCSP responder in Vault. **Vault 1.12+**\n"
                },
                "ocspExpiry": {
                    "type": "string",
                    "description": "The amount of time an OCSP response can be cached for, useful for OCSP stapling \nrefresh durations. **Vault 1.12+**\n"
                },
                "unifiedCrl": {
                    "type": "boolean",
                    "description": "Enables unified CRL and OCSP building. **Vault 1.13+**\n"
                },
                "unifiedCrlOnExistingPaths": {
                    "type": "boolean",
                    "description": "Enables serving the unified CRL and OCSP on the existing, previously\ncluster-local paths. **Vault 1.13+**\n"
                }
            },
            "required": [
                "autoRebuildGracePeriod",
                "backend",
                "crossClusterRevocation",
                "deltaRebuildInterval",
                "ocspExpiry",
                "unifiedCrl",
                "unifiedCrlOnExistingPaths"
            ],
            "inputProperties": {
                "autoRebuild": {
                    "type": "boolean",
                    "description": "Enables periodic rebuilding of the CRL upon expiry. **Vault 1.12+**\n"
                },
                "autoRebuildGracePeriod": {
                    "type": "string",
                    "description": "Grace period before CRL expiry to attempt rebuild of CRL. **Vault 1.12+**\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n",
                    "willReplaceOnChanges": true
                },
                "crossClusterRevocation": {
                    "type": "boolean",
                    "description": "Enable cross-cluster revocation request queues. **Vault 1.13+**\n"
                },
                "deltaRebuildInterval": {
                    "type": "string",
                    "description": "Interval to check for new revocations on, to regenerate the delta CRL.\n"
                },
                "disable": {
                    "type": "boolean",
                    "description": "Disables or enables CRL building.\n"
                },
                "enableDelta": {
                    "type": "boolean",
                    "description": "Enables building of delta CRLs with up-to-date revocation information, \naugmenting the last complete CRL.  **Vault 1.12+**\n"
                },
                "expiry": {
                    "type": "string",
                    "description": "Specifies the time until expiration.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "ocspDisable": {
                    "type": "boolean",
                    "description": "Disables the OCSP responder in Vault. **Vault 1.12+**\n"
                },
                "ocspExpiry": {
                    "type": "string",
                    "description": "The amount of time an OCSP response can be cached for, useful for OCSP stapling \nrefresh durations. **Vault 1.12+**\n"
                },
                "unifiedCrl": {
                    "type": "boolean",
                    "description": "Enables unified CRL and OCSP building. **Vault 1.13+**\n"
                },
                "unifiedCrlOnExistingPaths": {
                    "type": "boolean",
                    "description": "Enables serving the unified CRL and OCSP on the existing, previously\ncluster-local paths. **Vault 1.13+**\n"
                }
            },
            "requiredInputs": [
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendCrlConfig resources.\n",
                "properties": {
                    "autoRebuild": {
                        "type": "boolean",
                        "description": "Enables periodic rebuilding of the CRL upon expiry. **Vault 1.12+**\n"
                    },
                    "autoRebuildGracePeriod": {
                        "type": "string",
                        "description": "Grace period before CRL expiry to attempt rebuild of CRL. **Vault 1.12+**\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n",
                        "willReplaceOnChanges": true
                    },
                    "crossClusterRevocation": {
                        "type": "boolean",
                        "description": "Enable cross-cluster revocation request queues. **Vault 1.13+**\n"
                    },
                    "deltaRebuildInterval": {
                        "type": "string",
                        "description": "Interval to check for new revocations on, to regenerate the delta CRL.\n"
                    },
                    "disable": {
                        "type": "boolean",
                        "description": "Disables or enables CRL building.\n"
                    },
                    "enableDelta": {
                        "type": "boolean",
                        "description": "Enables building of delta CRLs with up-to-date revocation information, \naugmenting the last complete CRL.  **Vault 1.12+**\n"
                    },
                    "expiry": {
                        "type": "string",
                        "description": "Specifies the time until expiration.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "ocspDisable": {
                        "type": "boolean",
                        "description": "Disables the OCSP responder in Vault. **Vault 1.12+**\n"
                    },
                    "ocspExpiry": {
                        "type": "string",
                        "description": "The amount of time an OCSP response can be cached for, useful for OCSP stapling \nrefresh durations. **Vault 1.12+**\n"
                    },
                    "unifiedCrl": {
                        "type": "boolean",
                        "description": "Enables unified CRL and OCSP building. **Vault 1.13+**\n"
                    },
                    "unifiedCrlOnExistingPaths": {
                        "type": "boolean",
                        "description": "Enables serving the unified CRL and OCSP on the existing, previously\ncluster-local paths. **Vault 1.13+**\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendIntermediateCertRequest:SecretBackendIntermediateCertRequest": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst test = new vault.pkisecret.SecretBackendIntermediateCertRequest(\"test\", {\n    backend: vault_mount.pki.path,\n    type: \"internal\",\n    commonName: \"app.my.domain\",\n}, {\n    dependsOn: [vault_mount.pki],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntest = vault.pki_secret.SecretBackendIntermediateCertRequest(\"test\",\n    backend=vault_mount[\"pki\"][\"path\"],\n    type=\"internal\",\n    common_name=\"app.my.domain\",\n    opts=pulumi.ResourceOptions(depends_on=[vault_mount[\"pki\"]]))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Vault.PkiSecret.SecretBackendIntermediateCertRequest(\"test\", new()\n    {\n        Backend = vault_mount.Pki.Path,\n        Type = \"internal\",\n        CommonName = \"app.my.domain\",\n    }, new CustomResourceOptions\n    {\n        DependsOn = new[]\n        {\n            vault_mount.Pki,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/pkiSecret\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := pkiSecret.NewSecretBackendIntermediateCertRequest(ctx, \"test\", \u0026pkiSecret.SecretBackendIntermediateCertRequestArgs{\n\t\t\tBackend:    pulumi.Any(vault_mount.Pki.Path),\n\t\t\tType:       pulumi.String(\"internal\"),\n\t\t\tCommonName: pulumi.String(\"app.my.domain\"),\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\tvault_mount.Pki,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.pkiSecret.SecretBackendIntermediateCertRequest;\nimport com.pulumi.vault.pkiSecret.SecretBackendIntermediateCertRequestArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new SecretBackendIntermediateCertRequest(\"test\", SecretBackendIntermediateCertRequestArgs.builder()        \n            .backend(vault_mount.pki().path())\n            .type(\"internal\")\n            .commonName(\"app.my.domain\")\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(vault_mount.pki())\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: vault:pkiSecret:SecretBackendIntermediateCertRequest\n    properties:\n      backend: ${vault_mount.pki.path}\n      type: internal\n      commonName: app.my.domain\n    options:\n      dependson:\n        - ${vault_mount.pki}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "addBasicConstraints": {
                    "type": "boolean",
                    "description": "Adds a Basic Constraints extension with 'CA: true'.\nOnly needed as a workaround in some compatibility scenarios with Active Directory\nCertificate Services\n"
                },
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of intermediate to create\n"
                },
                "country": {
                    "type": "string",
                    "description": "The country\n"
                },
                "csr": {
                    "type": "string",
                    "description": "The CSR\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "keyBits": {
                    "type": "integer",
                    "description": "The number of bits to use\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "The desired key type\n"
                },
                "locality": {
                    "type": "string",
                    "description": "The locality\n"
                },
                "managedKeyId": {
                    "type": "string",
                    "description": "The ID of the previously configured managed key. This field is\nrequired if `type` is `kms` and it conflicts with `managed_key_name`\n"
                },
                "managedKeyName": {
                    "type": "string",
                    "description": "The name of the previously configured managed key. This field is\nrequired if `type` is `kms`  and it conflicts with `managed_key_id`\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "ou": {
                    "type": "string",
                    "description": "The organization unit\n"
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "The private key\n",
                    "secret": true
                },
                "privateKeyFormat": {
                    "type": "string",
                    "description": "The private key format\n"
                },
                "privateKeyType": {
                    "type": "string",
                    "description": "The private key type\n"
                },
                "province": {
                    "type": "string",
                    "description": "The province\n"
                },
                "streetAddress": {
                    "type": "string",
                    "description": "The street address\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of intermediate to create. Must be either \\\"exported\\\" or \\\"internal\\\"\nor \\\"kms\\\"\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n"
                }
            },
            "required": [
                "backend",
                "commonName",
                "csr",
                "privateKey",
                "privateKeyType",
                "type"
            ],
            "inputProperties": {
                "addBasicConstraints": {
                    "type": "boolean",
                    "description": "Adds a Basic Constraints extension with 'CA: true'.\nOnly needed as a workaround in some compatibility scenarios with Active Directory\nCertificate Services\n",
                    "willReplaceOnChanges": true
                },
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n",
                    "willReplaceOnChanges": true
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n",
                    "willReplaceOnChanges": true
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of intermediate to create\n",
                    "willReplaceOnChanges": true
                },
                "country": {
                    "type": "string",
                    "description": "The country\n",
                    "willReplaceOnChanges": true
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n",
                    "willReplaceOnChanges": true
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n",
                    "willReplaceOnChanges": true
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n",
                    "willReplaceOnChanges": true
                },
                "keyBits": {
                    "type": "integer",
                    "description": "The number of bits to use\n",
                    "willReplaceOnChanges": true
                },
                "keyType": {
                    "type": "string",
                    "description": "The desired key type\n",
                    "willReplaceOnChanges": true
                },
                "locality": {
                    "type": "string",
                    "description": "The locality\n",
                    "willReplaceOnChanges": true
                },
                "managedKeyId": {
                    "type": "string",
                    "description": "The ID of the previously configured managed key. This field is\nrequired if `type` is `kms` and it conflicts with `managed_key_name`\n",
                    "willReplaceOnChanges": true
                },
                "managedKeyName": {
                    "type": "string",
                    "description": "The name of the previously configured managed key. This field is\nrequired if `type` is `kms`  and it conflicts with `managed_key_id`\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "organization": {
                    "type": "string",
                    "description": "The organization\n",
                    "willReplaceOnChanges": true
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n",
                    "willReplaceOnChanges": true
                },
                "ou": {
                    "type": "string",
                    "description": "The organization unit\n",
                    "willReplaceOnChanges": true
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code\n",
                    "willReplaceOnChanges": true
                },
                "privateKeyFormat": {
                    "type": "string",
                    "description": "The private key format\n",
                    "willReplaceOnChanges": true
                },
                "province": {
                    "type": "string",
                    "description": "The province\n",
                    "willReplaceOnChanges": true
                },
                "streetAddress": {
                    "type": "string",
                    "description": "The street address\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "Type of intermediate to create. Must be either \\\"exported\\\" or \\\"internal\\\"\nor \\\"kms\\\"\n",
                    "willReplaceOnChanges": true
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "backend",
                "commonName",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendIntermediateCertRequest resources.\n",
                "properties": {
                    "addBasicConstraints": {
                        "type": "boolean",
                        "description": "Adds a Basic Constraints extension with 'CA: true'.\nOnly needed as a workaround in some compatibility scenarios with Active Directory\nCertificate Services\n",
                        "willReplaceOnChanges": true
                    },
                    "altNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative names\n",
                        "willReplaceOnChanges": true
                    },
                    "backend": {
                        "type": "string",
                        "description": "The PKI secret backend the resource belongs to.\n",
                        "willReplaceOnChanges": true
                    },
                    "commonName": {
                        "type": "string",
                        "description": "CN of intermediate to create\n",
                        "willReplaceOnChanges": true
                    },
                    "country": {
                        "type": "string",
                        "description": "The country\n",
                        "willReplaceOnChanges": true
                    },
                    "csr": {
                        "type": "string",
                        "description": "The CSR\n"
                    },
                    "excludeCnFromSans": {
                        "type": "boolean",
                        "description": "Flag to exclude CN from SANs\n",
                        "willReplaceOnChanges": true
                    },
                    "format": {
                        "type": "string",
                        "description": "The format of data\n",
                        "willReplaceOnChanges": true
                    },
                    "ipSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative IPs\n",
                        "willReplaceOnChanges": true
                    },
                    "keyBits": {
                        "type": "integer",
                        "description": "The number of bits to use\n",
                        "willReplaceOnChanges": true
                    },
                    "keyType": {
                        "type": "string",
                        "description": "The desired key type\n",
                        "willReplaceOnChanges": true
                    },
                    "locality": {
                        "type": "string",
                        "description": "The locality\n",
                        "willReplaceOnChanges": true
                    },
                    "managedKeyId": {
                        "type": "string",
                        "description": "The ID of the previously configured managed key. This field is\nrequired if `type` is `kms` and it conflicts with `managed_key_name`\n",
                        "willReplaceOnChanges": true
                    },
                    "managedKeyName": {
                        "type": "string",
                        "description": "The name of the previously configured managed key. This field is\nrequired if `type` is `kms`  and it conflicts with `managed_key_id`\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "organization": {
                        "type": "string",
                        "description": "The organization\n",
                        "willReplaceOnChanges": true
                    },
                    "otherSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of other SANs\n",
                        "willReplaceOnChanges": true
                    },
                    "ou": {
                        "type": "string",
                        "description": "The organization unit\n",
                        "willReplaceOnChanges": true
                    },
                    "postalCode": {
                        "type": "string",
                        "description": "The postal code\n",
                        "willReplaceOnChanges": true
                    },
                    "privateKey": {
                        "type": "string",
                        "description": "The private key\n",
                        "secret": true
                    },
                    "privateKeyFormat": {
                        "type": "string",
                        "description": "The private key format\n",
                        "willReplaceOnChanges": true
                    },
                    "privateKeyType": {
                        "type": "string",
                        "description": "The private key type\n"
                    },
                    "province": {
                        "type": "string",
                        "description": "The province\n",
                        "willReplaceOnChanges": true
                    },
                    "streetAddress": {
                        "type": "string",
                        "description": "The street address\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of intermediate to create. Must be either \\\"exported\\\" or \\\"internal\\\"\nor \\\"kms\\\"\n",
                        "willReplaceOnChanges": true
                    },
                    "uriSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative URIs\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendIntermediateSetSigned:SecretBackendIntermediateSetSigned": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst root = new vault.Mount(\"root\", {\n    path: \"pki-root\",\n    type: \"pki\",\n    description: \"root\",\n    defaultLeaseTtlSeconds: 8640000,\n    maxLeaseTtlSeconds: 8640000,\n});\nconst intermediate = new vault.Mount(\"intermediate\", {\n    path: \"pki-int\",\n    type: root.type,\n    description: \"intermediate\",\n    defaultLeaseTtlSeconds: 86400,\n    maxLeaseTtlSeconds: 86400,\n});\nconst exampleSecretBackendRootCert = new vault.pkisecret.SecretBackendRootCert(\"exampleSecretBackendRootCert\", {\n    backend: root.path,\n    type: \"internal\",\n    commonName: \"RootOrg Root CA\",\n    ttl: \"86400\",\n    format: \"pem\",\n    privateKeyFormat: \"der\",\n    keyType: \"rsa\",\n    keyBits: 4096,\n    excludeCnFromSans: true,\n    ou: \"Organizational Unit\",\n    organization: \"RootOrg\",\n    country: \"US\",\n    locality: \"San Francisco\",\n    province: \"CA\",\n});\nconst exampleSecretBackendIntermediateCertRequest = new vault.pkisecret.SecretBackendIntermediateCertRequest(\"exampleSecretBackendIntermediateCertRequest\", {\n    backend: intermediate.path,\n    type: exampleSecretBackendRootCert.type,\n    commonName: \"SubOrg Intermediate CA\",\n});\nconst exampleSecretBackendRootSignIntermediate = new vault.pkisecret.SecretBackendRootSignIntermediate(\"exampleSecretBackendRootSignIntermediate\", {\n    backend: root.path,\n    csr: exampleSecretBackendIntermediateCertRequest.csr,\n    commonName: \"SubOrg Intermediate CA\",\n    excludeCnFromSans: true,\n    ou: \"SubUnit\",\n    organization: \"SubOrg\",\n    country: \"US\",\n    locality: \"San Francisco\",\n    province: \"CA\",\n    revoke: true,\n});\nconst exampleSecretBackendIntermediateSetSigned = new vault.pkisecret.SecretBackendIntermediateSetSigned(\"exampleSecretBackendIntermediateSetSigned\", {\n    backend: intermediate.path,\n    certificate: exampleSecretBackendRootSignIntermediate.certificate,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nroot = vault.Mount(\"root\",\n    path=\"pki-root\",\n    type=\"pki\",\n    description=\"root\",\n    default_lease_ttl_seconds=8640000,\n    max_lease_ttl_seconds=8640000)\nintermediate = vault.Mount(\"intermediate\",\n    path=\"pki-int\",\n    type=root.type,\n    description=\"intermediate\",\n    default_lease_ttl_seconds=86400,\n    max_lease_ttl_seconds=86400)\nexample_secret_backend_root_cert = vault.pki_secret.SecretBackendRootCert(\"exampleSecretBackendRootCert\",\n    backend=root.path,\n    type=\"internal\",\n    common_name=\"RootOrg Root CA\",\n    ttl=\"86400\",\n    format=\"pem\",\n    private_key_format=\"der\",\n    key_type=\"rsa\",\n    key_bits=4096,\n    exclude_cn_from_sans=True,\n    ou=\"Organizational Unit\",\n    organization=\"RootOrg\",\n    country=\"US\",\n    locality=\"San Francisco\",\n    province=\"CA\")\nexample_secret_backend_intermediate_cert_request = vault.pki_secret.SecretBackendIntermediateCertRequest(\"exampleSecretBackendIntermediateCertRequest\",\n    backend=intermediate.path,\n    type=example_secret_backend_root_cert.type,\n    common_name=\"SubOrg Intermediate CA\")\nexample_secret_backend_root_sign_intermediate = vault.pki_secret.SecretBackendRootSignIntermediate(\"exampleSecretBackendRootSignIntermediate\",\n    backend=root.path,\n    csr=example_secret_backend_intermediate_cert_request.csr,\n    common_name=\"SubOrg Intermediate CA\",\n    exclude_cn_from_sans=True,\n    ou=\"SubUnit\",\n    organization=\"SubOrg\",\n    country=\"US\",\n    locality=\"San Francisco\",\n    province=\"CA\",\n    revoke=True)\nexample_secret_backend_intermediate_set_signed = vault.pki_secret.SecretBackendIntermediateSetSigned(\"exampleSecretBackendIntermediateSetSigned\",\n    backend=intermediate.path,\n    certificate=example_secret_backend_root_sign_intermediate.certificate)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var root = new Vault.Mount(\"root\", new()\n    {\n        Path = \"pki-root\",\n        Type = \"pki\",\n        Description = \"root\",\n        DefaultLeaseTtlSeconds = 8640000,\n        MaxLeaseTtlSeconds = 8640000,\n    });\n\n    var intermediate = new Vault.Mount(\"intermediate\", new()\n    {\n        Path = \"pki-int\",\n        Type = root.Type,\n        Description = \"intermediate\",\n        DefaultLeaseTtlSeconds = 86400,\n        MaxLeaseTtlSeconds = 86400,\n    });\n\n    var exampleSecretBackendRootCert = new Vault.PkiSecret.SecretBackendRootCert(\"exampleSecretBackendRootCert\", new()\n    {\n        Backend = root.Path,\n        Type = \"internal\",\n        CommonName = \"RootOrg Root CA\",\n        Ttl = \"86400\",\n        Format = \"pem\",\n        PrivateKeyFormat = \"der\",\n        KeyType = \"rsa\",\n        KeyBits = 4096,\n        ExcludeCnFromSans = true,\n        Ou = \"Organizational Unit\",\n        Organization = \"RootOrg\",\n        Country = \"US\",\n        Locality = \"San Francisco\",\n        Province = \"CA\",\n    });\n\n    var exampleSecretBackendIntermediateCertRequest = new Vault.PkiSecret.SecretBackendIntermediateCertRequest(\"exampleSecretBackendIntermediateCertRequest\", new()\n    {\n        Backend = intermediate.Path,\n        Type = exampleSecretBackendRootCert.Type,\n        CommonName = \"SubOrg Intermediate CA\",\n    });\n\n    var exampleSecretBackendRootSignIntermediate = new Vault.PkiSecret.SecretBackendRootSignIntermediate(\"exampleSecretBackendRootSignIntermediate\", new()\n    {\n        Backend = root.Path,\n        Csr = exampleSecretBackendIntermediateCertRequest.Csr,\n        CommonName = \"SubOrg Intermediate CA\",\n        ExcludeCnFromSans = true,\n        Ou = \"SubUnit\",\n        Organization = \"SubOrg\",\n        Country = \"US\",\n        Locality = \"San Francisco\",\n        Province = \"CA\",\n        Revoke = true,\n    });\n\n    var exampleSecretBackendIntermediateSetSigned = new Vault.PkiSecret.SecretBackendIntermediateSetSigned(\"exampleSecretBackendIntermediateSetSigned\", new()\n    {\n        Backend = intermediate.Path,\n        Certificate = exampleSecretBackendRootSignIntermediate.Certificate,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/pkiSecret\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\troot, err := vault.NewMount(ctx, \"root\", \u0026vault.MountArgs{\n\t\t\tPath:                   pulumi.String(\"pki-root\"),\n\t\t\tType:                   pulumi.String(\"pki\"),\n\t\t\tDescription:            pulumi.String(\"root\"),\n\t\t\tDefaultLeaseTtlSeconds: pulumi.Int(8640000),\n\t\t\tMaxLeaseTtlSeconds:     pulumi.Int(8640000),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tintermediate, err := vault.NewMount(ctx, \"intermediate\", \u0026vault.MountArgs{\n\t\t\tPath:                   pulumi.String(\"pki-int\"),\n\t\t\tType:                   root.Type,\n\t\t\tDescription:            pulumi.String(\"intermediate\"),\n\t\t\tDefaultLeaseTtlSeconds: pulumi.Int(86400),\n\t\t\tMaxLeaseTtlSeconds:     pulumi.Int(86400),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleSecretBackendRootCert, err := pkiSecret.NewSecretBackendRootCert(ctx, \"exampleSecretBackendRootCert\", \u0026pkiSecret.SecretBackendRootCertArgs{\n\t\t\tBackend:           root.Path,\n\t\t\tType:              pulumi.String(\"internal\"),\n\t\t\tCommonName:        pulumi.String(\"RootOrg Root CA\"),\n\t\t\tTtl:               pulumi.String(\"86400\"),\n\t\t\tFormat:            pulumi.String(\"pem\"),\n\t\t\tPrivateKeyFormat:  pulumi.String(\"der\"),\n\t\t\tKeyType:           pulumi.String(\"rsa\"),\n\t\t\tKeyBits:           pulumi.Int(4096),\n\t\t\tExcludeCnFromSans: pulumi.Bool(true),\n\t\t\tOu:                pulumi.String(\"Organizational Unit\"),\n\t\t\tOrganization:      pulumi.String(\"RootOrg\"),\n\t\t\tCountry:           pulumi.String(\"US\"),\n\t\t\tLocality:          pulumi.String(\"San Francisco\"),\n\t\t\tProvince:          pulumi.String(\"CA\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleSecretBackendIntermediateCertRequest, err := pkiSecret.NewSecretBackendIntermediateCertRequest(ctx, \"exampleSecretBackendIntermediateCertRequest\", \u0026pkiSecret.SecretBackendIntermediateCertRequestArgs{\n\t\t\tBackend:    intermediate.Path,\n\t\t\tType:       exampleSecretBackendRootCert.Type,\n\t\t\tCommonName: pulumi.String(\"SubOrg Intermediate CA\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleSecretBackendRootSignIntermediate, err := pkiSecret.NewSecretBackendRootSignIntermediate(ctx, \"exampleSecretBackendRootSignIntermediate\", \u0026pkiSecret.SecretBackendRootSignIntermediateArgs{\n\t\t\tBackend:           root.Path,\n\t\t\tCsr:               exampleSecretBackendIntermediateCertRequest.Csr,\n\t\t\tCommonName:        pulumi.String(\"SubOrg Intermediate CA\"),\n\t\t\tExcludeCnFromSans: pulumi.Bool(true),\n\t\t\tOu:                pulumi.String(\"SubUnit\"),\n\t\t\tOrganization:      pulumi.String(\"SubOrg\"),\n\t\t\tCountry:           pulumi.String(\"US\"),\n\t\t\tLocality:          pulumi.String(\"San Francisco\"),\n\t\t\tProvince:          pulumi.String(\"CA\"),\n\t\t\tRevoke:            pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = pkiSecret.NewSecretBackendIntermediateSetSigned(ctx, \"exampleSecretBackendIntermediateSetSigned\", \u0026pkiSecret.SecretBackendIntermediateSetSignedArgs{\n\t\t\tBackend:     intermediate.Path,\n\t\t\tCertificate: exampleSecretBackendRootSignIntermediate.Certificate,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Mount;\nimport com.pulumi.vault.MountArgs;\nimport com.pulumi.vault.pkiSecret.SecretBackendRootCert;\nimport com.pulumi.vault.pkiSecret.SecretBackendRootCertArgs;\nimport com.pulumi.vault.pkiSecret.SecretBackendIntermediateCertRequest;\nimport com.pulumi.vault.pkiSecret.SecretBackendIntermediateCertRequestArgs;\nimport com.pulumi.vault.pkiSecret.SecretBackendRootSignIntermediate;\nimport com.pulumi.vault.pkiSecret.SecretBackendRootSignIntermediateArgs;\nimport com.pulumi.vault.pkiSecret.SecretBackendIntermediateSetSigned;\nimport com.pulumi.vault.pkiSecret.SecretBackendIntermediateSetSignedArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var root = new Mount(\"root\", MountArgs.builder()        \n            .path(\"pki-root\")\n            .type(\"pki\")\n            .description(\"root\")\n            .defaultLeaseTtlSeconds(8640000)\n            .maxLeaseTtlSeconds(8640000)\n            .build());\n\n        var intermediate = new Mount(\"intermediate\", MountArgs.builder()        \n            .path(\"pki-int\")\n            .type(root.type())\n            .description(\"intermediate\")\n            .defaultLeaseTtlSeconds(86400)\n            .maxLeaseTtlSeconds(86400)\n            .build());\n\n        var exampleSecretBackendRootCert = new SecretBackendRootCert(\"exampleSecretBackendRootCert\", SecretBackendRootCertArgs.builder()        \n            .backend(root.path())\n            .type(\"internal\")\n            .commonName(\"RootOrg Root CA\")\n            .ttl(86400)\n            .format(\"pem\")\n            .privateKeyFormat(\"der\")\n            .keyType(\"rsa\")\n            .keyBits(4096)\n            .excludeCnFromSans(true)\n            .ou(\"Organizational Unit\")\n            .organization(\"RootOrg\")\n            .country(\"US\")\n            .locality(\"San Francisco\")\n            .province(\"CA\")\n            .build());\n\n        var exampleSecretBackendIntermediateCertRequest = new SecretBackendIntermediateCertRequest(\"exampleSecretBackendIntermediateCertRequest\", SecretBackendIntermediateCertRequestArgs.builder()        \n            .backend(intermediate.path())\n            .type(exampleSecretBackendRootCert.type())\n            .commonName(\"SubOrg Intermediate CA\")\n            .build());\n\n        var exampleSecretBackendRootSignIntermediate = new SecretBackendRootSignIntermediate(\"exampleSecretBackendRootSignIntermediate\", SecretBackendRootSignIntermediateArgs.builder()        \n            .backend(root.path())\n            .csr(exampleSecretBackendIntermediateCertRequest.csr())\n            .commonName(\"SubOrg Intermediate CA\")\n            .excludeCnFromSans(true)\n            .ou(\"SubUnit\")\n            .organization(\"SubOrg\")\n            .country(\"US\")\n            .locality(\"San Francisco\")\n            .province(\"CA\")\n            .revoke(true)\n            .build());\n\n        var exampleSecretBackendIntermediateSetSigned = new SecretBackendIntermediateSetSigned(\"exampleSecretBackendIntermediateSetSigned\", SecretBackendIntermediateSetSignedArgs.builder()        \n            .backend(intermediate.path())\n            .certificate(exampleSecretBackendRootSignIntermediate.certificate())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  root:\n    type: vault:Mount\n    properties:\n      path: pki-root\n      type: pki\n      description: root\n      defaultLeaseTtlSeconds: 8.64e+06\n      maxLeaseTtlSeconds: 8.64e+06\n  intermediate:\n    type: vault:Mount\n    properties:\n      path: pki-int\n      type: ${root.type}\n      description: intermediate\n      defaultLeaseTtlSeconds: 86400\n      maxLeaseTtlSeconds: 86400\n  exampleSecretBackendRootCert:\n    type: vault:pkiSecret:SecretBackendRootCert\n    properties:\n      backend: ${root.path}\n      type: internal\n      commonName: RootOrg Root CA\n      ttl: 86400\n      format: pem\n      privateKeyFormat: der\n      keyType: rsa\n      keyBits: 4096\n      excludeCnFromSans: true\n      ou: Organizational Unit\n      organization: RootOrg\n      country: US\n      locality: San Francisco\n      province: CA\n  exampleSecretBackendIntermediateCertRequest:\n    type: vault:pkiSecret:SecretBackendIntermediateCertRequest\n    properties:\n      backend: ${intermediate.path}\n      type: ${exampleSecretBackendRootCert.type}\n      commonName: SubOrg Intermediate CA\n  exampleSecretBackendRootSignIntermediate:\n    type: vault:pkiSecret:SecretBackendRootSignIntermediate\n    properties:\n      backend: ${root.path}\n      csr: ${exampleSecretBackendIntermediateCertRequest.csr}\n      commonName: SubOrg Intermediate CA\n      excludeCnFromSans: true\n      ou: SubUnit\n      organization: SubOrg\n      country: US\n      locality: San Francisco\n      province: CA\n      revoke: true\n  exampleSecretBackendIntermediateSetSigned:\n    type: vault:pkiSecret:SecretBackendIntermediateSetSigned\n    properties:\n      backend: ${intermediate.path}\n      certificate: ${exampleSecretBackendRootSignIntermediate.certificate}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "Specifies the PEM encoded certificate. May optionally append additional\nCA certificates to populate the whole chain, which will then enable returning the full chain from\nissue and sign operations.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                }
            },
            "required": [
                "backend",
                "certificate"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n",
                    "willReplaceOnChanges": true
                },
                "certificate": {
                    "type": "string",
                    "description": "Specifies the PEM encoded certificate. May optionally append additional\nCA certificates to populate the whole chain, which will then enable returning the full chain from\nissue and sign operations.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "backend",
                "certificate"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendIntermediateSetSigned resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The PKI secret backend the resource belongs to.\n",
                        "willReplaceOnChanges": true
                    },
                    "certificate": {
                        "type": "string",
                        "description": "Specifies the PEM encoded certificate. May optionally append additional\nCA certificates to populate the whole chain, which will then enable returning the full chain from\nissue and sign operations.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendRole:SecretBackendRole": {
            "description": "Creates a role on an PKI Secret Backend for Vault.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst pki = new vault.Mount(\"pki\", {\n    path: \"pki\",\n    type: \"pki\",\n    defaultLeaseTtlSeconds: 3600,\n    maxLeaseTtlSeconds: 86400,\n});\nconst role = new vault.pkisecret.SecretBackendRole(\"role\", {\n    backend: pki.path,\n    ttl: \"3600\",\n    allowIpSans: true,\n    keyType: \"rsa\",\n    keyBits: 4096,\n    allowedDomains: [\n        \"example.com\",\n        \"my.domain\",\n    ],\n    allowSubdomains: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\npki = vault.Mount(\"pki\",\n    path=\"pki\",\n    type=\"pki\",\n    default_lease_ttl_seconds=3600,\n    max_lease_ttl_seconds=86400)\nrole = vault.pki_secret.SecretBackendRole(\"role\",\n    backend=pki.path,\n    ttl=\"3600\",\n    allow_ip_sans=True,\n    key_type=\"rsa\",\n    key_bits=4096,\n    allowed_domains=[\n        \"example.com\",\n        \"my.domain\",\n    ],\n    allow_subdomains=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var pki = new Vault.Mount(\"pki\", new()\n    {\n        Path = \"pki\",\n        Type = \"pki\",\n        DefaultLeaseTtlSeconds = 3600,\n        MaxLeaseTtlSeconds = 86400,\n    });\n\n    var role = new Vault.PkiSecret.SecretBackendRole(\"role\", new()\n    {\n        Backend = pki.Path,\n        Ttl = \"3600\",\n        AllowIpSans = true,\n        KeyType = \"rsa\",\n        KeyBits = 4096,\n        AllowedDomains = new[]\n        {\n            \"example.com\",\n            \"my.domain\",\n        },\n        AllowSubdomains = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/pkiSecret\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tpki, err := vault.NewMount(ctx, \"pki\", \u0026vault.MountArgs{\n\t\t\tPath:                   pulumi.String(\"pki\"),\n\t\t\tType:                   pulumi.String(\"pki\"),\n\t\t\tDefaultLeaseTtlSeconds: pulumi.Int(3600),\n\t\t\tMaxLeaseTtlSeconds:     pulumi.Int(86400),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = pkiSecret.NewSecretBackendRole(ctx, \"role\", \u0026pkiSecret.SecretBackendRoleArgs{\n\t\t\tBackend:     pki.Path,\n\t\t\tTtl:         pulumi.String(\"3600\"),\n\t\t\tAllowIpSans: pulumi.Bool(true),\n\t\t\tKeyType:     pulumi.String(\"rsa\"),\n\t\t\tKeyBits:     pulumi.Int(4096),\n\t\t\tAllowedDomains: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"example.com\"),\n\t\t\t\tpulumi.String(\"my.domain\"),\n\t\t\t},\n\t\t\tAllowSubdomains: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Mount;\nimport com.pulumi.vault.MountArgs;\nimport com.pulumi.vault.pkiSecret.SecretBackendRole;\nimport com.pulumi.vault.pkiSecret.SecretBackendRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var pki = new Mount(\"pki\", MountArgs.builder()        \n            .path(\"pki\")\n            .type(\"pki\")\n            .defaultLeaseTtlSeconds(3600)\n            .maxLeaseTtlSeconds(86400)\n            .build());\n\n        var role = new SecretBackendRole(\"role\", SecretBackendRoleArgs.builder()        \n            .backend(pki.path())\n            .ttl(3600)\n            .allowIpSans(true)\n            .keyType(\"rsa\")\n            .keyBits(4096)\n            .allowedDomains(            \n                \"example.com\",\n                \"my.domain\")\n            .allowSubdomains(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  pki:\n    type: vault:Mount\n    properties:\n      path: pki\n      type: pki\n      defaultLeaseTtlSeconds: 3600\n      maxLeaseTtlSeconds: 86400\n  role:\n    type: vault:pkiSecret:SecretBackendRole\n    properties:\n      backend: ${pki.path}\n      ttl: 3600\n      allowIpSans: true\n      keyType: rsa\n      keyBits: 4096\n      allowedDomains:\n        - example.com\n        - my.domain\n      allowSubdomains: true\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nPKI secret backend roles can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:pkiSecret/secretBackendRole:SecretBackendRole role pki/roles/my_role\n```\n\n ",
            "properties": {
                "allowAnyName": {
                    "type": "boolean",
                    "description": "Flag to allow any name\n"
                },
                "allowBareDomains": {
                    "type": "boolean",
                    "description": "Flag to allow certificates matching the actual domain\n"
                },
                "allowGlobDomains": {
                    "type": "boolean",
                    "description": "Flag to allow names containing glob patterns.\n"
                },
                "allowIpSans": {
                    "type": "boolean",
                    "description": "Flag to allow IP SANs\n"
                },
                "allowLocalhost": {
                    "type": "boolean",
                    "description": "Flag to allow certificates for localhost\n"
                },
                "allowSubdomains": {
                    "type": "boolean",
                    "description": "Flag to allow certificates matching subdomains\n"
                },
                "allowedDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of allowed domains for certificates\n"
                },
                "allowedDomainsTemplate": {
                    "type": "boolean",
                    "description": "Flag, if set, `allowed_domains` can be specified using identity template expressions such as `{{identity.entity.aliases.\u003cmount accessor\u003e.name}}`.\n"
                },
                "allowedOtherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Defines allowed custom SANs\n"
                },
                "allowedSerialNumbers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of allowed serial numbers to put in Subject\n"
                },
                "allowedUriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Defines allowed URI SANs\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "basicConstraintsValidForNonCa": {
                    "type": "boolean",
                    "description": "Flag to mark basic constraints valid when issuing non-CA certificates\n"
                },
                "clientFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for client use\n"
                },
                "codeSigningFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for code signing use\n"
                },
                "countries": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The country of generated certificates\n"
                },
                "emailProtectionFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for email protection use\n"
                },
                "enforceHostnames": {
                    "type": "boolean",
                    "description": "Flag to allow only valid host names\n"
                },
                "extKeyUsages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify the allowed extended key usage constraint on issued certificates\n"
                },
                "generateLease": {
                    "type": "boolean",
                    "description": "Flag to generate leases with certificates\n"
                },
                "keyBits": {
                    "type": "integer",
                    "description": "The number of bits of generated keys\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "The generated key type, choices: `rsa`, `ec`, `ed25519`, `any`  \nDefaults to `rsa`\n"
                },
                "keyUsages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify the allowed key usage constraint on issued certificates\n"
                },
                "localities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The locality of generated certificates\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "The maximum lease TTL, in seconds, for the role.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this role within the backend. Must be unique within the backend.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "noStore": {
                    "type": "boolean",
                    "description": "Flag to not store certificates in the storage backend\n"
                },
                "notBeforeDuration": {
                    "type": "string",
                    "description": "Specifies the duration by which to backdate the NotBefore property.\n"
                },
                "organizationUnit": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The organization unit of generated certificates\n"
                },
                "organizations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The organization of generated certificates\n"
                },
                "policyIdentifiers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify the list of allowed policies OIDs. Use with Vault 1.10 or before. For Vault 1.11+, use `policy_identifier` blocks instead\n"
                },
                "postalCodes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The postal code of generated certificates\n"
                },
                "provinces": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The province of generated certificates\n"
                },
                "requireCn": {
                    "type": "boolean",
                    "description": "Flag to force CN usage\n"
                },
                "serverFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for server use\n"
                },
                "streetAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The street address of generated certificates\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "The TTL, in seconds, for any certificate issued against this role.\n"
                },
                "useCsrCommonName": {
                    "type": "boolean",
                    "description": "Flag to use the CN in the CSR\n"
                },
                "useCsrSans": {
                    "type": "boolean",
                    "description": "Flag to use the SANs in the CSR\n"
                }
            },
            "required": [
                "backend",
                "keyUsages",
                "maxTtl",
                "name",
                "notBeforeDuration",
                "ttl"
            ],
            "inputProperties": {
                "allowAnyName": {
                    "type": "boolean",
                    "description": "Flag to allow any name\n"
                },
                "allowBareDomains": {
                    "type": "boolean",
                    "description": "Flag to allow certificates matching the actual domain\n"
                },
                "allowGlobDomains": {
                    "type": "boolean",
                    "description": "Flag to allow names containing glob patterns.\n"
                },
                "allowIpSans": {
                    "type": "boolean",
                    "description": "Flag to allow IP SANs\n"
                },
                "allowLocalhost": {
                    "type": "boolean",
                    "description": "Flag to allow certificates for localhost\n"
                },
                "allowSubdomains": {
                    "type": "boolean",
                    "description": "Flag to allow certificates matching subdomains\n"
                },
                "allowedDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of allowed domains for certificates\n"
                },
                "allowedDomainsTemplate": {
                    "type": "boolean",
                    "description": "Flag, if set, `allowed_domains` can be specified using identity template expressions such as `{{identity.entity.aliases.\u003cmount accessor\u003e.name}}`.\n"
                },
                "allowedOtherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Defines allowed custom SANs\n"
                },
                "allowedSerialNumbers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of allowed serial numbers to put in Subject\n"
                },
                "allowedUriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Defines allowed URI SANs\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n",
                    "willReplaceOnChanges": true
                },
                "basicConstraintsValidForNonCa": {
                    "type": "boolean",
                    "description": "Flag to mark basic constraints valid when issuing non-CA certificates\n"
                },
                "clientFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for client use\n"
                },
                "codeSigningFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for code signing use\n"
                },
                "countries": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The country of generated certificates\n"
                },
                "emailProtectionFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for email protection use\n"
                },
                "enforceHostnames": {
                    "type": "boolean",
                    "description": "Flag to allow only valid host names\n"
                },
                "extKeyUsages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify the allowed extended key usage constraint on issued certificates\n"
                },
                "generateLease": {
                    "type": "boolean",
                    "description": "Flag to generate leases with certificates\n"
                },
                "keyBits": {
                    "type": "integer",
                    "description": "The number of bits of generated keys\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "The generated key type, choices: `rsa`, `ec`, `ed25519`, `any`  \nDefaults to `rsa`\n"
                },
                "keyUsages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify the allowed key usage constraint on issued certificates\n"
                },
                "localities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The locality of generated certificates\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "The maximum lease TTL, in seconds, for the role.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this role within the backend. Must be unique within the backend.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "noStore": {
                    "type": "boolean",
                    "description": "Flag to not store certificates in the storage backend\n"
                },
                "notBeforeDuration": {
                    "type": "string",
                    "description": "Specifies the duration by which to backdate the NotBefore property.\n"
                },
                "organizationUnit": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The organization unit of generated certificates\n"
                },
                "organizations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The organization of generated certificates\n"
                },
                "policyIdentifiers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify the list of allowed policies OIDs. Use with Vault 1.10 or before. For Vault 1.11+, use `policy_identifier` blocks instead\n"
                },
                "postalCodes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The postal code of generated certificates\n"
                },
                "provinces": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The province of generated certificates\n"
                },
                "requireCn": {
                    "type": "boolean",
                    "description": "Flag to force CN usage\n"
                },
                "serverFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for server use\n"
                },
                "streetAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The street address of generated certificates\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "The TTL, in seconds, for any certificate issued against this role.\n"
                },
                "useCsrCommonName": {
                    "type": "boolean",
                    "description": "Flag to use the CN in the CSR\n"
                },
                "useCsrSans": {
                    "type": "boolean",
                    "description": "Flag to use the SANs in the CSR\n"
                }
            },
            "requiredInputs": [
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRole resources.\n",
                "properties": {
                    "allowAnyName": {
                        "type": "boolean",
                        "description": "Flag to allow any name\n"
                    },
                    "allowBareDomains": {
                        "type": "boolean",
                        "description": "Flag to allow certificates matching the actual domain\n"
                    },
                    "allowGlobDomains": {
                        "type": "boolean",
                        "description": "Flag to allow names containing glob patterns.\n"
                    },
                    "allowIpSans": {
                        "type": "boolean",
                        "description": "Flag to allow IP SANs\n"
                    },
                    "allowLocalhost": {
                        "type": "boolean",
                        "description": "Flag to allow certificates for localhost\n"
                    },
                    "allowSubdomains": {
                        "type": "boolean",
                        "description": "Flag to allow certificates matching subdomains\n"
                    },
                    "allowedDomains": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of allowed domains for certificates\n"
                    },
                    "allowedDomainsTemplate": {
                        "type": "boolean",
                        "description": "Flag, if set, `allowed_domains` can be specified using identity template expressions such as `{{identity.entity.aliases.\u003cmount accessor\u003e.name}}`.\n"
                    },
                    "allowedOtherSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Defines allowed custom SANs\n"
                    },
                    "allowedSerialNumbers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of allowed serial numbers to put in Subject\n"
                    },
                    "allowedUriSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Defines allowed URI SANs\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n",
                        "willReplaceOnChanges": true
                    },
                    "basicConstraintsValidForNonCa": {
                        "type": "boolean",
                        "description": "Flag to mark basic constraints valid when issuing non-CA certificates\n"
                    },
                    "clientFlag": {
                        "type": "boolean",
                        "description": "Flag to specify certificates for client use\n"
                    },
                    "codeSigningFlag": {
                        "type": "boolean",
                        "description": "Flag to specify certificates for code signing use\n"
                    },
                    "countries": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The country of generated certificates\n"
                    },
                    "emailProtectionFlag": {
                        "type": "boolean",
                        "description": "Flag to specify certificates for email protection use\n"
                    },
                    "enforceHostnames": {
                        "type": "boolean",
                        "description": "Flag to allow only valid host names\n"
                    },
                    "extKeyUsages": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specify the allowed extended key usage constraint on issued certificates\n"
                    },
                    "generateLease": {
                        "type": "boolean",
                        "description": "Flag to generate leases with certificates\n"
                    },
                    "keyBits": {
                        "type": "integer",
                        "description": "The number of bits of generated keys\n"
                    },
                    "keyType": {
                        "type": "string",
                        "description": "The generated key type, choices: `rsa`, `ec`, `ed25519`, `any`  \nDefaults to `rsa`\n"
                    },
                    "keyUsages": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specify the allowed key usage constraint on issued certificates\n"
                    },
                    "localities": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The locality of generated certificates\n"
                    },
                    "maxTtl": {
                        "type": "string",
                        "description": "The maximum lease TTL, in seconds, for the role.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name to identify this role within the backend. Must be unique within the backend.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "noStore": {
                        "type": "boolean",
                        "description": "Flag to not store certificates in the storage backend\n"
                    },
                    "notBeforeDuration": {
                        "type": "string",
                        "description": "Specifies the duration by which to backdate the NotBefore property.\n"
                    },
                    "organizationUnit": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The organization unit of generated certificates\n"
                    },
                    "organizations": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The organization of generated certificates\n"
                    },
                    "policyIdentifiers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specify the list of allowed policies OIDs. Use with Vault 1.10 or before. For Vault 1.11+, use `policy_identifier` blocks instead\n"
                    },
                    "postalCodes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The postal code of generated certificates\n"
                    },
                    "provinces": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The province of generated certificates\n"
                    },
                    "requireCn": {
                        "type": "boolean",
                        "description": "Flag to force CN usage\n"
                    },
                    "serverFlag": {
                        "type": "boolean",
                        "description": "Flag to specify certificates for server use\n"
                    },
                    "streetAddresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The street address of generated certificates\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "The TTL, in seconds, for any certificate issued against this role.\n"
                    },
                    "useCsrCommonName": {
                        "type": "boolean",
                        "description": "Flag to use the CN in the CSR\n"
                    },
                    "useCsrSans": {
                        "type": "boolean",
                        "description": "Flag to use the SANs in the CSR\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendRootCert:SecretBackendRootCert": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst test = new vault.pkisecret.SecretBackendRootCert(\"test\", {\n    backend: vault_mount.pki.path,\n    type: \"internal\",\n    commonName: \"Root CA\",\n    ttl: \"315360000\",\n    format: \"pem\",\n    privateKeyFormat: \"der\",\n    keyType: \"rsa\",\n    keyBits: 4096,\n    excludeCnFromSans: true,\n    ou: \"My OU\",\n    organization: \"My organization\",\n}, {\n    dependsOn: [vault_mount.pki],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntest = vault.pki_secret.SecretBackendRootCert(\"test\",\n    backend=vault_mount[\"pki\"][\"path\"],\n    type=\"internal\",\n    common_name=\"Root CA\",\n    ttl=\"315360000\",\n    format=\"pem\",\n    private_key_format=\"der\",\n    key_type=\"rsa\",\n    key_bits=4096,\n    exclude_cn_from_sans=True,\n    ou=\"My OU\",\n    organization=\"My organization\",\n    opts=pulumi.ResourceOptions(depends_on=[vault_mount[\"pki\"]]))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Vault.PkiSecret.SecretBackendRootCert(\"test\", new()\n    {\n        Backend = vault_mount.Pki.Path,\n        Type = \"internal\",\n        CommonName = \"Root CA\",\n        Ttl = \"315360000\",\n        Format = \"pem\",\n        PrivateKeyFormat = \"der\",\n        KeyType = \"rsa\",\n        KeyBits = 4096,\n        ExcludeCnFromSans = true,\n        Ou = \"My OU\",\n        Organization = \"My organization\",\n    }, new CustomResourceOptions\n    {\n        DependsOn = new[]\n        {\n            vault_mount.Pki,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/pkiSecret\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := pkiSecret.NewSecretBackendRootCert(ctx, \"test\", \u0026pkiSecret.SecretBackendRootCertArgs{\n\t\t\tBackend:           pulumi.Any(vault_mount.Pki.Path),\n\t\t\tType:              pulumi.String(\"internal\"),\n\t\t\tCommonName:        pulumi.String(\"Root CA\"),\n\t\t\tTtl:               pulumi.String(\"315360000\"),\n\t\t\tFormat:            pulumi.String(\"pem\"),\n\t\t\tPrivateKeyFormat:  pulumi.String(\"der\"),\n\t\t\tKeyType:           pulumi.String(\"rsa\"),\n\t\t\tKeyBits:           pulumi.Int(4096),\n\t\t\tExcludeCnFromSans: pulumi.Bool(true),\n\t\t\tOu:                pulumi.String(\"My OU\"),\n\t\t\tOrganization:      pulumi.String(\"My organization\"),\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\tvault_mount.Pki,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.pkiSecret.SecretBackendRootCert;\nimport com.pulumi.vault.pkiSecret.SecretBackendRootCertArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new SecretBackendRootCert(\"test\", SecretBackendRootCertArgs.builder()        \n            .backend(vault_mount.pki().path())\n            .type(\"internal\")\n            .commonName(\"Root CA\")\n            .ttl(\"315360000\")\n            .format(\"pem\")\n            .privateKeyFormat(\"der\")\n            .keyType(\"rsa\")\n            .keyBits(4096)\n            .excludeCnFromSans(true)\n            .ou(\"My OU\")\n            .organization(\"My organization\")\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(vault_mount.pki())\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: vault:pkiSecret:SecretBackendRootCert\n    properties:\n      backend: ${vault_mount.pki.path}\n      type: internal\n      commonName: Root CA\n      ttl: 315360000\n      format: pem\n      privateKeyFormat: der\n      keyType: rsa\n      keyBits: 4096\n      excludeCnFromSans: true\n      ou: My OU\n      organization: My organization\n    options:\n      dependson:\n        - ${vault_mount.pki}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The certificate.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of intermediate to create\n"
                },
                "country": {
                    "type": "string",
                    "description": "The country\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "issuingCa": {
                    "type": "string",
                    "description": "The issuing CA certificate.\n"
                },
                "keyBits": {
                    "type": "integer",
                    "description": "The number of bits to use\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "The desired key type\n"
                },
                "locality": {
                    "type": "string",
                    "description": "The locality\n"
                },
                "managedKeyId": {
                    "type": "string",
                    "description": "The ID of the previously configured managed key. This field is\nrequired if `type` is `kms` and it conflicts with `managed_key_name`\n"
                },
                "managedKeyName": {
                    "type": "string",
                    "description": "The name of the previously configured managed key. This field is\nrequired if `type` is `kms`  and it conflicts with `managed_key_id`\n"
                },
                "maxPathLength": {
                    "type": "integer",
                    "description": "The maximum path length to encode in the generated certificate\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "ou": {
                    "type": "string",
                    "description": "The organization unit\n"
                },
                "permittedDnsDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of domains for which certificates are allowed to be issued\n"
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code\n"
                },
                "privateKeyFormat": {
                    "type": "string",
                    "description": "The private key format\n"
                },
                "province": {
                    "type": "string",
                    "description": "The province\n"
                },
                "serial": {
                    "type": "string",
                    "description": "Deprecated, use `serial_number` instead.\n",
                    "deprecationMessage": "Use serial_number instead"
                },
                "serialNumber": {
                    "type": "string",
                    "description": "The certificate's serial number, hex formatted.\n"
                },
                "streetAddress": {
                    "type": "string",
                    "description": "The street address\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of intermediate to create. Must be either \\\"exported\\\", \\\"internal\\\"\nor \\\"kms\\\"\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n"
                }
            },
            "required": [
                "backend",
                "certificate",
                "commonName",
                "issuingCa",
                "managedKeyId",
                "managedKeyName",
                "serial",
                "serialNumber",
                "type"
            ],
            "inputProperties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n",
                    "willReplaceOnChanges": true
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n",
                    "willReplaceOnChanges": true
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of intermediate to create\n",
                    "willReplaceOnChanges": true
                },
                "country": {
                    "type": "string",
                    "description": "The country\n",
                    "willReplaceOnChanges": true
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n",
                    "willReplaceOnChanges": true
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n",
                    "willReplaceOnChanges": true
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n",
                    "willReplaceOnChanges": true
                },
                "keyBits": {
                    "type": "integer",
                    "description": "The number of bits to use\n",
                    "willReplaceOnChanges": true
                },
                "keyType": {
                    "type": "string",
                    "description": "The desired key type\n",
                    "willReplaceOnChanges": true
                },
                "locality": {
                    "type": "string",
                    "description": "The locality\n",
                    "willReplaceOnChanges": true
                },
                "managedKeyId": {
                    "type": "string",
                    "description": "The ID of the previously configured managed key. This field is\nrequired if `type` is `kms` and it conflicts with `managed_key_name`\n",
                    "willReplaceOnChanges": true
                },
                "managedKeyName": {
                    "type": "string",
                    "description": "The name of the previously configured managed key. This field is\nrequired if `type` is `kms`  and it conflicts with `managed_key_id`\n",
                    "willReplaceOnChanges": true
                },
                "maxPathLength": {
                    "type": "integer",
                    "description": "The maximum path length to encode in the generated certificate\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "organization": {
                    "type": "string",
                    "description": "The organization\n",
                    "willReplaceOnChanges": true
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n",
                    "willReplaceOnChanges": true
                },
                "ou": {
                    "type": "string",
                    "description": "The organization unit\n",
                    "willReplaceOnChanges": true
                },
                "permittedDnsDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of domains for which certificates are allowed to be issued\n",
                    "willReplaceOnChanges": true
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code\n",
                    "willReplaceOnChanges": true
                },
                "privateKeyFormat": {
                    "type": "string",
                    "description": "The private key format\n",
                    "willReplaceOnChanges": true
                },
                "province": {
                    "type": "string",
                    "description": "The province\n",
                    "willReplaceOnChanges": true
                },
                "streetAddress": {
                    "type": "string",
                    "description": "The street address\n",
                    "willReplaceOnChanges": true
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of intermediate to create. Must be either \\\"exported\\\", \\\"internal\\\"\nor \\\"kms\\\"\n",
                    "willReplaceOnChanges": true
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "backend",
                "commonName",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRootCert resources.\n",
                "properties": {
                    "altNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative names\n",
                        "willReplaceOnChanges": true
                    },
                    "backend": {
                        "type": "string",
                        "description": "The PKI secret backend the resource belongs to.\n",
                        "willReplaceOnChanges": true
                    },
                    "certificate": {
                        "type": "string",
                        "description": "The certificate.\n"
                    },
                    "commonName": {
                        "type": "string",
                        "description": "CN of intermediate to create\n",
                        "willReplaceOnChanges": true
                    },
                    "country": {
                        "type": "string",
                        "description": "The country\n",
                        "willReplaceOnChanges": true
                    },
                    "excludeCnFromSans": {
                        "type": "boolean",
                        "description": "Flag to exclude CN from SANs\n",
                        "willReplaceOnChanges": true
                    },
                    "format": {
                        "type": "string",
                        "description": "The format of data\n",
                        "willReplaceOnChanges": true
                    },
                    "ipSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative IPs\n",
                        "willReplaceOnChanges": true
                    },
                    "issuingCa": {
                        "type": "string",
                        "description": "The issuing CA certificate.\n"
                    },
                    "keyBits": {
                        "type": "integer",
                        "description": "The number of bits to use\n",
                        "willReplaceOnChanges": true
                    },
                    "keyType": {
                        "type": "string",
                        "description": "The desired key type\n",
                        "willReplaceOnChanges": true
                    },
                    "locality": {
                        "type": "string",
                        "description": "The locality\n",
                        "willReplaceOnChanges": true
                    },
                    "managedKeyId": {
                        "type": "string",
                        "description": "The ID of the previously configured managed key. This field is\nrequired if `type` is `kms` and it conflicts with `managed_key_name`\n",
                        "willReplaceOnChanges": true
                    },
                    "managedKeyName": {
                        "type": "string",
                        "description": "The name of the previously configured managed key. This field is\nrequired if `type` is `kms`  and it conflicts with `managed_key_id`\n",
                        "willReplaceOnChanges": true
                    },
                    "maxPathLength": {
                        "type": "integer",
                        "description": "The maximum path length to encode in the generated certificate\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "organization": {
                        "type": "string",
                        "description": "The organization\n",
                        "willReplaceOnChanges": true
                    },
                    "otherSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of other SANs\n",
                        "willReplaceOnChanges": true
                    },
                    "ou": {
                        "type": "string",
                        "description": "The organization unit\n",
                        "willReplaceOnChanges": true
                    },
                    "permittedDnsDomains": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of domains for which certificates are allowed to be issued\n",
                        "willReplaceOnChanges": true
                    },
                    "postalCode": {
                        "type": "string",
                        "description": "The postal code\n",
                        "willReplaceOnChanges": true
                    },
                    "privateKeyFormat": {
                        "type": "string",
                        "description": "The private key format\n",
                        "willReplaceOnChanges": true
                    },
                    "province": {
                        "type": "string",
                        "description": "The province\n",
                        "willReplaceOnChanges": true
                    },
                    "serial": {
                        "type": "string",
                        "description": "Deprecated, use `serial_number` instead.\n",
                        "deprecationMessage": "Use serial_number instead"
                    },
                    "serialNumber": {
                        "type": "string",
                        "description": "The certificate's serial number, hex formatted.\n"
                    },
                    "streetAddress": {
                        "type": "string",
                        "description": "The street address\n",
                        "willReplaceOnChanges": true
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Time to live\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of intermediate to create. Must be either \\\"exported\\\", \\\"internal\\\"\nor \\\"kms\\\"\n",
                        "willReplaceOnChanges": true
                    },
                    "uriSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative URIs\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendRootSignIntermediate:SecretBackendRootSignIntermediate": {
            "description": "Creates PKI certificate.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst root = new vault.pkisecret.SecretBackendRootSignIntermediate(\"root\", {\n    backend: vault_mount.root.path,\n    csr: vault_pki_secret_backend_intermediate_cert_request.intermediate.csr,\n    commonName: \"Intermediate CA\",\n    excludeCnFromSans: true,\n    ou: \"My OU\",\n    organization: \"My organization\",\n}, {\n    dependsOn: [vault_pki_secret_backend_intermediate_cert_request.intermediate],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nroot = vault.pki_secret.SecretBackendRootSignIntermediate(\"root\",\n    backend=vault_mount[\"root\"][\"path\"],\n    csr=vault_pki_secret_backend_intermediate_cert_request[\"intermediate\"][\"csr\"],\n    common_name=\"Intermediate CA\",\n    exclude_cn_from_sans=True,\n    ou=\"My OU\",\n    organization=\"My organization\",\n    opts=pulumi.ResourceOptions(depends_on=[vault_pki_secret_backend_intermediate_cert_request[\"intermediate\"]]))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var root = new Vault.PkiSecret.SecretBackendRootSignIntermediate(\"root\", new()\n    {\n        Backend = vault_mount.Root.Path,\n        Csr = vault_pki_secret_backend_intermediate_cert_request.Intermediate.Csr,\n        CommonName = \"Intermediate CA\",\n        ExcludeCnFromSans = true,\n        Ou = \"My OU\",\n        Organization = \"My organization\",\n    }, new CustomResourceOptions\n    {\n        DependsOn = new[]\n        {\n            vault_pki_secret_backend_intermediate_cert_request.Intermediate,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/pkiSecret\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := pkiSecret.NewSecretBackendRootSignIntermediate(ctx, \"root\", \u0026pkiSecret.SecretBackendRootSignIntermediateArgs{\n\t\t\tBackend:           pulumi.Any(vault_mount.Root.Path),\n\t\t\tCsr:               pulumi.Any(vault_pki_secret_backend_intermediate_cert_request.Intermediate.Csr),\n\t\t\tCommonName:        pulumi.String(\"Intermediate CA\"),\n\t\t\tExcludeCnFromSans: pulumi.Bool(true),\n\t\t\tOu:                pulumi.String(\"My OU\"),\n\t\t\tOrganization:      pulumi.String(\"My organization\"),\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\tvault_pki_secret_backend_intermediate_cert_request.Intermediate,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.pkiSecret.SecretBackendRootSignIntermediate;\nimport com.pulumi.vault.pkiSecret.SecretBackendRootSignIntermediateArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var root = new SecretBackendRootSignIntermediate(\"root\", SecretBackendRootSignIntermediateArgs.builder()        \n            .backend(vault_mount.root().path())\n            .csr(vault_pki_secret_backend_intermediate_cert_request.intermediate().csr())\n            .commonName(\"Intermediate CA\")\n            .excludeCnFromSans(true)\n            .ou(\"My OU\")\n            .organization(\"My organization\")\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(vault_pki_secret_backend_intermediate_cert_request.intermediate())\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  root:\n    type: vault:pkiSecret:SecretBackendRootSignIntermediate\n    properties:\n      backend: ${vault_mount.root.path}\n      csr: ${vault_pki_secret_backend_intermediate_cert_request.intermediate.csr}\n      commonName: Intermediate CA\n      excludeCnFromSans: true\n      ou: My OU\n      organization: My organization\n    options:\n      dependson:\n        - ${vault_pki_secret_backend_intermediate_cert_request.intermediate}\n```\n{{% /example %}}\n{{% /examples %}}\n## Deprecations\n\n* `serial` - Use `serial_number` instead.\n",
            "properties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "caChains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of the issuing and intermediate CA certificates in the `format` specified.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The intermediate CA certificate in the `format` specified.\n"
                },
                "certificateBundle": {
                    "type": "string",
                    "description": "The concatenation of the intermediate CA and the issuing CA certificates (PEM encoded). \nRequires the `format` to be set to any of: pem, pem_bundle. The value will be empty for all other formats.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of intermediate to create\n"
                },
                "country": {
                    "type": "string",
                    "description": "The country\n"
                },
                "csr": {
                    "type": "string",
                    "description": "The CSR\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "issuingCa": {
                    "type": "string",
                    "description": "The issuing CA certificate in the `format` specified.\n"
                },
                "locality": {
                    "type": "string",
                    "description": "The locality\n"
                },
                "maxPathLength": {
                    "type": "integer",
                    "description": "The maximum path length to encode in the generated certificate\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "ou": {
                    "type": "string",
                    "description": "The organization unit\n"
                },
                "permittedDnsDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of domains for which certificates are allowed to be issued\n"
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code\n"
                },
                "province": {
                    "type": "string",
                    "description": "The province\n"
                },
                "revoke": {
                    "type": "boolean",
                    "description": "If set to `true`, the certificate will be revoked on resource destruction.\n"
                },
                "serial": {
                    "type": "string",
                    "description": "The serial number.\n",
                    "deprecationMessage": "Use serial_number instead"
                },
                "serialNumber": {
                    "type": "string",
                    "description": "The certificate's serial number, hex formatted.\n"
                },
                "streetAddress": {
                    "type": "string",
                    "description": "The street address\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n"
                },
                "useCsrValues": {
                    "type": "boolean",
                    "description": "Preserve CSR values\n"
                }
            },
            "required": [
                "backend",
                "caChains",
                "certificate",
                "certificateBundle",
                "commonName",
                "csr",
                "issuingCa",
                "serial",
                "serialNumber"
            ],
            "inputProperties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n",
                    "willReplaceOnChanges": true
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n",
                    "willReplaceOnChanges": true
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of intermediate to create\n",
                    "willReplaceOnChanges": true
                },
                "country": {
                    "type": "string",
                    "description": "The country\n",
                    "willReplaceOnChanges": true
                },
                "csr": {
                    "type": "string",
                    "description": "The CSR\n",
                    "willReplaceOnChanges": true
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n",
                    "willReplaceOnChanges": true
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n",
                    "willReplaceOnChanges": true
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n",
                    "willReplaceOnChanges": true
                },
                "locality": {
                    "type": "string",
                    "description": "The locality\n",
                    "willReplaceOnChanges": true
                },
                "maxPathLength": {
                    "type": "integer",
                    "description": "The maximum path length to encode in the generated certificate\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "organization": {
                    "type": "string",
                    "description": "The organization\n",
                    "willReplaceOnChanges": true
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n",
                    "willReplaceOnChanges": true
                },
                "ou": {
                    "type": "string",
                    "description": "The organization unit\n",
                    "willReplaceOnChanges": true
                },
                "permittedDnsDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of domains for which certificates are allowed to be issued\n",
                    "willReplaceOnChanges": true
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code\n",
                    "willReplaceOnChanges": true
                },
                "province": {
                    "type": "string",
                    "description": "The province\n",
                    "willReplaceOnChanges": true
                },
                "revoke": {
                    "type": "boolean",
                    "description": "If set to `true`, the certificate will be revoked on resource destruction.\n"
                },
                "streetAddress": {
                    "type": "string",
                    "description": "The street address\n",
                    "willReplaceOnChanges": true
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n",
                    "willReplaceOnChanges": true
                },
                "useCsrValues": {
                    "type": "boolean",
                    "description": "Preserve CSR values\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "backend",
                "commonName",
                "csr"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRootSignIntermediate resources.\n",
                "properties": {
                    "altNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative names\n",
                        "willReplaceOnChanges": true
                    },
                    "backend": {
                        "type": "string",
                        "description": "The PKI secret backend the resource belongs to.\n",
                        "willReplaceOnChanges": true
                    },
                    "caChains": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of the issuing and intermediate CA certificates in the `format` specified.\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "The intermediate CA certificate in the `format` specified.\n"
                    },
                    "certificateBundle": {
                        "type": "string",
                        "description": "The concatenation of the intermediate CA and the issuing CA certificates (PEM encoded). \nRequires the `format` to be set to any of: pem, pem_bundle. The value will be empty for all other formats.\n"
                    },
                    "commonName": {
                        "type": "string",
                        "description": "CN of intermediate to create\n",
                        "willReplaceOnChanges": true
                    },
                    "country": {
                        "type": "string",
                        "description": "The country\n",
                        "willReplaceOnChanges": true
                    },
                    "csr": {
                        "type": "string",
                        "description": "The CSR\n",
                        "willReplaceOnChanges": true
                    },
                    "excludeCnFromSans": {
                        "type": "boolean",
                        "description": "Flag to exclude CN from SANs\n",
                        "willReplaceOnChanges": true
                    },
                    "format": {
                        "type": "string",
                        "description": "The format of data\n",
                        "willReplaceOnChanges": true
                    },
                    "ipSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative IPs\n",
                        "willReplaceOnChanges": true
                    },
                    "issuingCa": {
                        "type": "string",
                        "description": "The issuing CA certificate in the `format` specified.\n"
                    },
                    "locality": {
                        "type": "string",
                        "description": "The locality\n",
                        "willReplaceOnChanges": true
                    },
                    "maxPathLength": {
                        "type": "integer",
                        "description": "The maximum path length to encode in the generated certificate\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "organization": {
                        "type": "string",
                        "description": "The organization\n",
                        "willReplaceOnChanges": true
                    },
                    "otherSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of other SANs\n",
                        "willReplaceOnChanges": true
                    },
                    "ou": {
                        "type": "string",
                        "description": "The organization unit\n",
                        "willReplaceOnChanges": true
                    },
                    "permittedDnsDomains": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of domains for which certificates are allowed to be issued\n",
                        "willReplaceOnChanges": true
                    },
                    "postalCode": {
                        "type": "string",
                        "description": "The postal code\n",
                        "willReplaceOnChanges": true
                    },
                    "province": {
                        "type": "string",
                        "description": "The province\n",
                        "willReplaceOnChanges": true
                    },
                    "revoke": {
                        "type": "boolean",
                        "description": "If set to `true`, the certificate will be revoked on resource destruction.\n"
                    },
                    "serial": {
                        "type": "string",
                        "description": "The serial number.\n",
                        "deprecationMessage": "Use serial_number instead"
                    },
                    "serialNumber": {
                        "type": "string",
                        "description": "The certificate's serial number, hex formatted.\n"
                    },
                    "streetAddress": {
                        "type": "string",
                        "description": "The street address\n",
                        "willReplaceOnChanges": true
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Time to live\n"
                    },
                    "uriSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative URIs\n",
                        "willReplaceOnChanges": true
                    },
                    "useCsrValues": {
                        "type": "boolean",
                        "description": "Preserve CSR values\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendSign:SecretBackendSign": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst test = new vault.pkisecret.SecretBackendSign(\"test\", {\n    backend: vault_mount.pki.path,\n    csr: `-----BEGIN CERTIFICATE REQUEST-----\nMIIEqDCCApACAQAwYzELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUx\nITAfBgNVBAoMGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDEcMBoGA1UEAwwTY2Vy\ndC50ZXN0Lm15LmRvbWFpbjCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIB\nAJupYCQ8UVCWII1Zof1c6YcSSaM9hEaDU78cfKP5RoSeH10BvrWRfT+mzCONVpNP\nCW9Iabtvk6hm0ot6ilnndEyVJbc0g7hdDLBX5BM25D+DGZGJRKUz1V+uBrWmXtIt\nVonj7JTDTe7ViH0GDsB7CvqXFGXO2a2cDYBchLkL6vQiFPshxvUsLtwxuy/qdYgy\nX6ya+AUoZcoQGy1XxNjfH6cPtWSWQGEp1oPR6vL9hU3laTZb3C+VV4jZem+he8/0\nV+qV6fLG92WTXm2hmf8nrtUqqJ+C7mW/RJod+TviviBadIX0OHXW7k5HVsZood01\nte8vMRUNJNiZfa9EMIK5oncbQn0LcM3Wo9VrjpL7jREb/4HCS2gswYGv7hzk9cCS\nkVY4rDucchKbApuI3kfzmO7GFOF5eiSkYZpY/czNn7VVM3WCu6dpOX4+3rhgrZQw\nkY14L930DaLVRUgve/zKVP2D2GHdEOs+MbV7s96UgigT9pXly/yHPj+1sSYqmnaD\n5b7jSeJusmzO/nrwXVGLsnezR87VzHl9Ux9g5s6zh+R+PrZuVxYsLvoUpaasH47O\ngIcBzSb/6pSGZKAUizmYsHsR1k88dAvsQ+FsUDaNokdi9VndEB4QPmiFmjyLV+0I\n1TFoXop4sW11NPz1YCq+IxnYrEaIN3PyhY0GvBJDFY1/AgMBAAGgADANBgkqhkiG\n9w0BAQsFAAOCAgEActuqnqS8Y9UF7e08w7tR3FPzGecWreuvxILrlFEZJxiLPFqL\nIt7uJvtypCVQvz6UQzKdBYO7tMpRaWViB8DrWzXNZjLMrg+QHcpveg8C0Ett4scG\nfnvLk6fTDFYrnGvwHTqiHos5i0y3bFLyS1BGwSpdLAykGtvC+VM8mRyw/Y7CPcKN\n77kebY/9xduW1g2uxWLr0x90RuQDv9psPojT+59tRLGSp5Kt0IeD3QtnAZEFE4aN\nvt+Pd69eg3BgZ8ZeDgoqAw3yppvOkpAFiE5pw2qPZaM4SRphl4d2Lek2zNIMyZqv\ndo5zh356HOgXtDaSg0POnRGrN/Ua+LMCRTg6GEPUnx9uQb/zt8Zu0hIexDGyykp1\nOGqtWlv/Nc8UYuS38v0BeB6bMPeoqQUjkqs8nHlAEFn0KlgYdtDC+7SdQx6wS4te\ndBKRNDfC4lS3jYJgs55jHqonZgkpSi3bamlxpfpW0ukGBcmq91wRe4bOw/4uD/vf\nUwqMWOdCYcU3mdYNjTWy22ORW3SGFQxMBwpUEURCSoeqWr6aJeQ7KAYkx1PrB5T8\nOTEc13lWf+B0PU9UJuGTsmpIuImPDVd0EVDayr3mT5dDbqTVDbe8ppf2IswABmf0\no3DybUeUmknYjl109rdSf+76nuREICHatxXgN3xCMFuBaN4WLO+ksd6Y1Ys=\n-----END CERTIFICATE REQUEST-----\n`,\n    commonName: \"test.my.domain\",\n}, {\n    dependsOn: [vault_pki_secret_backend_role.admin],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntest = vault.pki_secret.SecretBackendSign(\"test\",\n    backend=vault_mount[\"pki\"][\"path\"],\n    csr=\"\"\"-----BEGIN CERTIFICATE REQUEST-----\nMIIEqDCCApACAQAwYzELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUx\nITAfBgNVBAoMGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDEcMBoGA1UEAwwTY2Vy\ndC50ZXN0Lm15LmRvbWFpbjCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIB\nAJupYCQ8UVCWII1Zof1c6YcSSaM9hEaDU78cfKP5RoSeH10BvrWRfT+mzCONVpNP\nCW9Iabtvk6hm0ot6ilnndEyVJbc0g7hdDLBX5BM25D+DGZGJRKUz1V+uBrWmXtIt\nVonj7JTDTe7ViH0GDsB7CvqXFGXO2a2cDYBchLkL6vQiFPshxvUsLtwxuy/qdYgy\nX6ya+AUoZcoQGy1XxNjfH6cPtWSWQGEp1oPR6vL9hU3laTZb3C+VV4jZem+he8/0\nV+qV6fLG92WTXm2hmf8nrtUqqJ+C7mW/RJod+TviviBadIX0OHXW7k5HVsZood01\nte8vMRUNJNiZfa9EMIK5oncbQn0LcM3Wo9VrjpL7jREb/4HCS2gswYGv7hzk9cCS\nkVY4rDucchKbApuI3kfzmO7GFOF5eiSkYZpY/czNn7VVM3WCu6dpOX4+3rhgrZQw\nkY14L930DaLVRUgve/zKVP2D2GHdEOs+MbV7s96UgigT9pXly/yHPj+1sSYqmnaD\n5b7jSeJusmzO/nrwXVGLsnezR87VzHl9Ux9g5s6zh+R+PrZuVxYsLvoUpaasH47O\ngIcBzSb/6pSGZKAUizmYsHsR1k88dAvsQ+FsUDaNokdi9VndEB4QPmiFmjyLV+0I\n1TFoXop4sW11NPz1YCq+IxnYrEaIN3PyhY0GvBJDFY1/AgMBAAGgADANBgkqhkiG\n9w0BAQsFAAOCAgEActuqnqS8Y9UF7e08w7tR3FPzGecWreuvxILrlFEZJxiLPFqL\nIt7uJvtypCVQvz6UQzKdBYO7tMpRaWViB8DrWzXNZjLMrg+QHcpveg8C0Ett4scG\nfnvLk6fTDFYrnGvwHTqiHos5i0y3bFLyS1BGwSpdLAykGtvC+VM8mRyw/Y7CPcKN\n77kebY/9xduW1g2uxWLr0x90RuQDv9psPojT+59tRLGSp5Kt0IeD3QtnAZEFE4aN\nvt+Pd69eg3BgZ8ZeDgoqAw3yppvOkpAFiE5pw2qPZaM4SRphl4d2Lek2zNIMyZqv\ndo5zh356HOgXtDaSg0POnRGrN/Ua+LMCRTg6GEPUnx9uQb/zt8Zu0hIexDGyykp1\nOGqtWlv/Nc8UYuS38v0BeB6bMPeoqQUjkqs8nHlAEFn0KlgYdtDC+7SdQx6wS4te\ndBKRNDfC4lS3jYJgs55jHqonZgkpSi3bamlxpfpW0ukGBcmq91wRe4bOw/4uD/vf\nUwqMWOdCYcU3mdYNjTWy22ORW3SGFQxMBwpUEURCSoeqWr6aJeQ7KAYkx1PrB5T8\nOTEc13lWf+B0PU9UJuGTsmpIuImPDVd0EVDayr3mT5dDbqTVDbe8ppf2IswABmf0\no3DybUeUmknYjl109rdSf+76nuREICHatxXgN3xCMFuBaN4WLO+ksd6Y1Ys=\n-----END CERTIFICATE REQUEST-----\n\"\"\",\n    common_name=\"test.my.domain\",\n    opts=pulumi.ResourceOptions(depends_on=[vault_pki_secret_backend_role[\"admin\"]]))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Vault.PkiSecret.SecretBackendSign(\"test\", new()\n    {\n        Backend = vault_mount.Pki.Path,\n        Csr = @\"-----BEGIN CERTIFICATE REQUEST-----\nMIIEqDCCApACAQAwYzELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUx\nITAfBgNVBAoMGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDEcMBoGA1UEAwwTY2Vy\ndC50ZXN0Lm15LmRvbWFpbjCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIB\nAJupYCQ8UVCWII1Zof1c6YcSSaM9hEaDU78cfKP5RoSeH10BvrWRfT+mzCONVpNP\nCW9Iabtvk6hm0ot6ilnndEyVJbc0g7hdDLBX5BM25D+DGZGJRKUz1V+uBrWmXtIt\nVonj7JTDTe7ViH0GDsB7CvqXFGXO2a2cDYBchLkL6vQiFPshxvUsLtwxuy/qdYgy\nX6ya+AUoZcoQGy1XxNjfH6cPtWSWQGEp1oPR6vL9hU3laTZb3C+VV4jZem+he8/0\nV+qV6fLG92WTXm2hmf8nrtUqqJ+C7mW/RJod+TviviBadIX0OHXW7k5HVsZood01\nte8vMRUNJNiZfa9EMIK5oncbQn0LcM3Wo9VrjpL7jREb/4HCS2gswYGv7hzk9cCS\nkVY4rDucchKbApuI3kfzmO7GFOF5eiSkYZpY/czNn7VVM3WCu6dpOX4+3rhgrZQw\nkY14L930DaLVRUgve/zKVP2D2GHdEOs+MbV7s96UgigT9pXly/yHPj+1sSYqmnaD\n5b7jSeJusmzO/nrwXVGLsnezR87VzHl9Ux9g5s6zh+R+PrZuVxYsLvoUpaasH47O\ngIcBzSb/6pSGZKAUizmYsHsR1k88dAvsQ+FsUDaNokdi9VndEB4QPmiFmjyLV+0I\n1TFoXop4sW11NPz1YCq+IxnYrEaIN3PyhY0GvBJDFY1/AgMBAAGgADANBgkqhkiG\n9w0BAQsFAAOCAgEActuqnqS8Y9UF7e08w7tR3FPzGecWreuvxILrlFEZJxiLPFqL\nIt7uJvtypCVQvz6UQzKdBYO7tMpRaWViB8DrWzXNZjLMrg+QHcpveg8C0Ett4scG\nfnvLk6fTDFYrnGvwHTqiHos5i0y3bFLyS1BGwSpdLAykGtvC+VM8mRyw/Y7CPcKN\n77kebY/9xduW1g2uxWLr0x90RuQDv9psPojT+59tRLGSp5Kt0IeD3QtnAZEFE4aN\nvt+Pd69eg3BgZ8ZeDgoqAw3yppvOkpAFiE5pw2qPZaM4SRphl4d2Lek2zNIMyZqv\ndo5zh356HOgXtDaSg0POnRGrN/Ua+LMCRTg6GEPUnx9uQb/zt8Zu0hIexDGyykp1\nOGqtWlv/Nc8UYuS38v0BeB6bMPeoqQUjkqs8nHlAEFn0KlgYdtDC+7SdQx6wS4te\ndBKRNDfC4lS3jYJgs55jHqonZgkpSi3bamlxpfpW0ukGBcmq91wRe4bOw/4uD/vf\nUwqMWOdCYcU3mdYNjTWy22ORW3SGFQxMBwpUEURCSoeqWr6aJeQ7KAYkx1PrB5T8\nOTEc13lWf+B0PU9UJuGTsmpIuImPDVd0EVDayr3mT5dDbqTVDbe8ppf2IswABmf0\no3DybUeUmknYjl109rdSf+76nuREICHatxXgN3xCMFuBaN4WLO+ksd6Y1Ys=\n-----END CERTIFICATE REQUEST-----\n\",\n        CommonName = \"test.my.domain\",\n    }, new CustomResourceOptions\n    {\n        DependsOn = new[]\n        {\n            vault_pki_secret_backend_role.Admin,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/pkiSecret\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := pkiSecret.NewSecretBackendSign(ctx, \"test\", \u0026pkiSecret.SecretBackendSignArgs{\n\t\t\tBackend:    pulumi.Any(vault_mount.Pki.Path),\n\t\t\tCsr:        pulumi.String(\"-----BEGIN CERTIFICATE REQUEST-----\\nMIIEqDCCApACAQAwYzELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUx\\nITAfBgNVBAoMGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDEcMBoGA1UEAwwTY2Vy\\ndC50ZXN0Lm15LmRvbWFpbjCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIB\\nAJupYCQ8UVCWII1Zof1c6YcSSaM9hEaDU78cfKP5RoSeH10BvrWRfT+mzCONVpNP\\nCW9Iabtvk6hm0ot6ilnndEyVJbc0g7hdDLBX5BM25D+DGZGJRKUz1V+uBrWmXtIt\\nVonj7JTDTe7ViH0GDsB7CvqXFGXO2a2cDYBchLkL6vQiFPshxvUsLtwxuy/qdYgy\\nX6ya+AUoZcoQGy1XxNjfH6cPtWSWQGEp1oPR6vL9hU3laTZb3C+VV4jZem+he8/0\\nV+qV6fLG92WTXm2hmf8nrtUqqJ+C7mW/RJod+TviviBadIX0OHXW7k5HVsZood01\\nte8vMRUNJNiZfa9EMIK5oncbQn0LcM3Wo9VrjpL7jREb/4HCS2gswYGv7hzk9cCS\\nkVY4rDucchKbApuI3kfzmO7GFOF5eiSkYZpY/czNn7VVM3WCu6dpOX4+3rhgrZQw\\nkY14L930DaLVRUgve/zKVP2D2GHdEOs+MbV7s96UgigT9pXly/yHPj+1sSYqmnaD\\n5b7jSeJusmzO/nrwXVGLsnezR87VzHl9Ux9g5s6zh+R+PrZuVxYsLvoUpaasH47O\\ngIcBzSb/6pSGZKAUizmYsHsR1k88dAvsQ+FsUDaNokdi9VndEB4QPmiFmjyLV+0I\\n1TFoXop4sW11NPz1YCq+IxnYrEaIN3PyhY0GvBJDFY1/AgMBAAGgADANBgkqhkiG\\n9w0BAQsFAAOCAgEActuqnqS8Y9UF7e08w7tR3FPzGecWreuvxILrlFEZJxiLPFqL\\nIt7uJvtypCVQvz6UQzKdBYO7tMpRaWViB8DrWzXNZjLMrg+QHcpveg8C0Ett4scG\\nfnvLk6fTDFYrnGvwHTqiHos5i0y3bFLyS1BGwSpdLAykGtvC+VM8mRyw/Y7CPcKN\\n77kebY/9xduW1g2uxWLr0x90RuQDv9psPojT+59tRLGSp5Kt0IeD3QtnAZEFE4aN\\nvt+Pd69eg3BgZ8ZeDgoqAw3yppvOkpAFiE5pw2qPZaM4SRphl4d2Lek2zNIMyZqv\\ndo5zh356HOgXtDaSg0POnRGrN/Ua+LMCRTg6GEPUnx9uQb/zt8Zu0hIexDGyykp1\\nOGqtWlv/Nc8UYuS38v0BeB6bMPeoqQUjkqs8nHlAEFn0KlgYdtDC+7SdQx6wS4te\\ndBKRNDfC4lS3jYJgs55jHqonZgkpSi3bamlxpfpW0ukGBcmq91wRe4bOw/4uD/vf\\nUwqMWOdCYcU3mdYNjTWy22ORW3SGFQxMBwpUEURCSoeqWr6aJeQ7KAYkx1PrB5T8\\nOTEc13lWf+B0PU9UJuGTsmpIuImPDVd0EVDayr3mT5dDbqTVDbe8ppf2IswABmf0\\no3DybUeUmknYjl109rdSf+76nuREICHatxXgN3xCMFuBaN4WLO+ksd6Y1Ys=\\n-----END CERTIFICATE REQUEST-----\\n\"),\n\t\t\tCommonName: pulumi.String(\"test.my.domain\"),\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\tvault_pki_secret_backend_role.Admin,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.pkiSecret.SecretBackendSign;\nimport com.pulumi.vault.pkiSecret.SecretBackendSignArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new SecretBackendSign(\"test\", SecretBackendSignArgs.builder()        \n            .backend(vault_mount.pki().path())\n            .csr(\"\"\"\n-----BEGIN CERTIFICATE REQUEST-----\nMIIEqDCCApACAQAwYzELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUx\nITAfBgNVBAoMGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDEcMBoGA1UEAwwTY2Vy\ndC50ZXN0Lm15LmRvbWFpbjCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIB\nAJupYCQ8UVCWII1Zof1c6YcSSaM9hEaDU78cfKP5RoSeH10BvrWRfT+mzCONVpNP\nCW9Iabtvk6hm0ot6ilnndEyVJbc0g7hdDLBX5BM25D+DGZGJRKUz1V+uBrWmXtIt\nVonj7JTDTe7ViH0GDsB7CvqXFGXO2a2cDYBchLkL6vQiFPshxvUsLtwxuy/qdYgy\nX6ya+AUoZcoQGy1XxNjfH6cPtWSWQGEp1oPR6vL9hU3laTZb3C+VV4jZem+he8/0\nV+qV6fLG92WTXm2hmf8nrtUqqJ+C7mW/RJod+TviviBadIX0OHXW7k5HVsZood01\nte8vMRUNJNiZfa9EMIK5oncbQn0LcM3Wo9VrjpL7jREb/4HCS2gswYGv7hzk9cCS\nkVY4rDucchKbApuI3kfzmO7GFOF5eiSkYZpY/czNn7VVM3WCu6dpOX4+3rhgrZQw\nkY14L930DaLVRUgve/zKVP2D2GHdEOs+MbV7s96UgigT9pXly/yHPj+1sSYqmnaD\n5b7jSeJusmzO/nrwXVGLsnezR87VzHl9Ux9g5s6zh+R+PrZuVxYsLvoUpaasH47O\ngIcBzSb/6pSGZKAUizmYsHsR1k88dAvsQ+FsUDaNokdi9VndEB4QPmiFmjyLV+0I\n1TFoXop4sW11NPz1YCq+IxnYrEaIN3PyhY0GvBJDFY1/AgMBAAGgADANBgkqhkiG\n9w0BAQsFAAOCAgEActuqnqS8Y9UF7e08w7tR3FPzGecWreuvxILrlFEZJxiLPFqL\nIt7uJvtypCVQvz6UQzKdBYO7tMpRaWViB8DrWzXNZjLMrg+QHcpveg8C0Ett4scG\nfnvLk6fTDFYrnGvwHTqiHos5i0y3bFLyS1BGwSpdLAykGtvC+VM8mRyw/Y7CPcKN\n77kebY/9xduW1g2uxWLr0x90RuQDv9psPojT+59tRLGSp5Kt0IeD3QtnAZEFE4aN\nvt+Pd69eg3BgZ8ZeDgoqAw3yppvOkpAFiE5pw2qPZaM4SRphl4d2Lek2zNIMyZqv\ndo5zh356HOgXtDaSg0POnRGrN/Ua+LMCRTg6GEPUnx9uQb/zt8Zu0hIexDGyykp1\nOGqtWlv/Nc8UYuS38v0BeB6bMPeoqQUjkqs8nHlAEFn0KlgYdtDC+7SdQx6wS4te\ndBKRNDfC4lS3jYJgs55jHqonZgkpSi3bamlxpfpW0ukGBcmq91wRe4bOw/4uD/vf\nUwqMWOdCYcU3mdYNjTWy22ORW3SGFQxMBwpUEURCSoeqWr6aJeQ7KAYkx1PrB5T8\nOTEc13lWf+B0PU9UJuGTsmpIuImPDVd0EVDayr3mT5dDbqTVDbe8ppf2IswABmf0\no3DybUeUmknYjl109rdSf+76nuREICHatxXgN3xCMFuBaN4WLO+ksd6Y1Ys=\n-----END CERTIFICATE REQUEST-----\n            \"\"\")\n            .commonName(\"test.my.domain\")\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(vault_pki_secret_backend_role.admin())\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: vault:pkiSecret:SecretBackendSign\n    properties:\n      backend: ${vault_mount.pki.path}\n      csr: |\n        -----BEGIN CERTIFICATE REQUEST-----\n        MIIEqDCCApACAQAwYzELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUx\n        ITAfBgNVBAoMGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDEcMBoGA1UEAwwTY2Vy\n        dC50ZXN0Lm15LmRvbWFpbjCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIB\n        AJupYCQ8UVCWII1Zof1c6YcSSaM9hEaDU78cfKP5RoSeH10BvrWRfT+mzCONVpNP\n        CW9Iabtvk6hm0ot6ilnndEyVJbc0g7hdDLBX5BM25D+DGZGJRKUz1V+uBrWmXtIt\n        Vonj7JTDTe7ViH0GDsB7CvqXFGXO2a2cDYBchLkL6vQiFPshxvUsLtwxuy/qdYgy\n        X6ya+AUoZcoQGy1XxNjfH6cPtWSWQGEp1oPR6vL9hU3laTZb3C+VV4jZem+he8/0\n        V+qV6fLG92WTXm2hmf8nrtUqqJ+C7mW/RJod+TviviBadIX0OHXW7k5HVsZood01\n        te8vMRUNJNiZfa9EMIK5oncbQn0LcM3Wo9VrjpL7jREb/4HCS2gswYGv7hzk9cCS\n        kVY4rDucchKbApuI3kfzmO7GFOF5eiSkYZpY/czNn7VVM3WCu6dpOX4+3rhgrZQw\n        kY14L930DaLVRUgve/zKVP2D2GHdEOs+MbV7s96UgigT9pXly/yHPj+1sSYqmnaD\n        5b7jSeJusmzO/nrwXVGLsnezR87VzHl9Ux9g5s6zh+R+PrZuVxYsLvoUpaasH47O\n        gIcBzSb/6pSGZKAUizmYsHsR1k88dAvsQ+FsUDaNokdi9VndEB4QPmiFmjyLV+0I\n        1TFoXop4sW11NPz1YCq+IxnYrEaIN3PyhY0GvBJDFY1/AgMBAAGgADANBgkqhkiG\n        9w0BAQsFAAOCAgEActuqnqS8Y9UF7e08w7tR3FPzGecWreuvxILrlFEZJxiLPFqL\n        It7uJvtypCVQvz6UQzKdBYO7tMpRaWViB8DrWzXNZjLMrg+QHcpveg8C0Ett4scG\n        fnvLk6fTDFYrnGvwHTqiHos5i0y3bFLyS1BGwSpdLAykGtvC+VM8mRyw/Y7CPcKN\n        77kebY/9xduW1g2uxWLr0x90RuQDv9psPojT+59tRLGSp5Kt0IeD3QtnAZEFE4aN\n        vt+Pd69eg3BgZ8ZeDgoqAw3yppvOkpAFiE5pw2qPZaM4SRphl4d2Lek2zNIMyZqv\n        do5zh356HOgXtDaSg0POnRGrN/Ua+LMCRTg6GEPUnx9uQb/zt8Zu0hIexDGyykp1\n        OGqtWlv/Nc8UYuS38v0BeB6bMPeoqQUjkqs8nHlAEFn0KlgYdtDC+7SdQx6wS4te\n        dBKRNDfC4lS3jYJgs55jHqonZgkpSi3bamlxpfpW0ukGBcmq91wRe4bOw/4uD/vf\n        UwqMWOdCYcU3mdYNjTWy22ORW3SGFQxMBwpUEURCSoeqWr6aJeQ7KAYkx1PrB5T8\n        OTEc13lWf+B0PU9UJuGTsmpIuImPDVd0EVDayr3mT5dDbqTVDbe8ppf2IswABmf0\n        o3DybUeUmknYjl109rdSf+76nuREICHatxXgN3xCMFuBaN4WLO+ksd6Y1Ys=\n        -----END CERTIFICATE REQUEST-----\n      commonName: test.my.domain\n    options:\n      dependson:\n        - ${vault_pki_secret_backend_role.admin}\n```\n{{% /example %}}\n{{% /examples %}}\n## Deprecations\n\n* `serial` - Use `serial_number` instead.\n",
            "properties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "autoRenew": {
                    "type": "boolean",
                    "description": "If set to `true`, certs will be renewed if the expiration is within `min_seconds_remaining`. Default `false`\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "caChains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The CA chain\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The certificate\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of certificate to create\n"
                },
                "csr": {
                    "type": "string",
                    "description": "The CSR\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "expiration": {
                    "type": "integer",
                    "description": "The expiration date of the certificate in unix epoch format\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "issuingCa": {
                    "type": "string",
                    "description": "The issuing CA\n"
                },
                "minSecondsRemaining": {
                    "type": "integer",
                    "description": "Generate a new certificate when the expiration is within this number of seconds, default is 604800 (7 days)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the role to create the certificate against\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "renewPending": {
                    "type": "boolean",
                    "description": "`true` if the current time (during refresh) is after the start of the early renewal window declared by `min_seconds_remaining`, and `false` otherwise; if `auto_renew` is set to `true` then the provider will plan to replace the certificate once renewal is pending.\n"
                },
                "serial": {
                    "type": "string",
                    "description": "The serial number.\n",
                    "deprecationMessage": "Use serial_number instead"
                },
                "serialNumber": {
                    "type": "string",
                    "description": "The certificate's serial number, hex formatted.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n"
                }
            },
            "required": [
                "backend",
                "caChains",
                "certificate",
                "commonName",
                "csr",
                "expiration",
                "issuingCa",
                "name",
                "renewPending",
                "serial",
                "serialNumber"
            ],
            "inputProperties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n",
                    "willReplaceOnChanges": true
                },
                "autoRenew": {
                    "type": "boolean",
                    "description": "If set to `true`, certs will be renewed if the expiration is within `min_seconds_remaining`. Default `false`\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n",
                    "willReplaceOnChanges": true
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of certificate to create\n",
                    "willReplaceOnChanges": true
                },
                "csr": {
                    "type": "string",
                    "description": "The CSR\n",
                    "willReplaceOnChanges": true
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n",
                    "willReplaceOnChanges": true
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n",
                    "willReplaceOnChanges": true
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n",
                    "willReplaceOnChanges": true
                },
                "minSecondsRemaining": {
                    "type": "integer",
                    "description": "Generate a new certificate when the expiration is within this number of seconds, default is 604800 (7 days)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the role to create the certificate against\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n",
                    "willReplaceOnChanges": true
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "backend",
                "commonName",
                "csr"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendSign resources.\n",
                "properties": {
                    "altNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative names\n",
                        "willReplaceOnChanges": true
                    },
                    "autoRenew": {
                        "type": "boolean",
                        "description": "If set to `true`, certs will be renewed if the expiration is within `min_seconds_remaining`. Default `false`\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The PKI secret backend the resource belongs to.\n",
                        "willReplaceOnChanges": true
                    },
                    "caChains": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The CA chain\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "The certificate\n"
                    },
                    "commonName": {
                        "type": "string",
                        "description": "CN of certificate to create\n",
                        "willReplaceOnChanges": true
                    },
                    "csr": {
                        "type": "string",
                        "description": "The CSR\n",
                        "willReplaceOnChanges": true
                    },
                    "excludeCnFromSans": {
                        "type": "boolean",
                        "description": "Flag to exclude CN from SANs\n",
                        "willReplaceOnChanges": true
                    },
                    "expiration": {
                        "type": "integer",
                        "description": "The expiration date of the certificate in unix epoch format\n"
                    },
                    "format": {
                        "type": "string",
                        "description": "The format of data\n",
                        "willReplaceOnChanges": true
                    },
                    "ipSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative IPs\n",
                        "willReplaceOnChanges": true
                    },
                    "issuingCa": {
                        "type": "string",
                        "description": "The issuing CA\n"
                    },
                    "minSecondsRemaining": {
                        "type": "integer",
                        "description": "Generate a new certificate when the expiration is within this number of seconds, default is 604800 (7 days)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the role to create the certificate against\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "otherSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of other SANs\n",
                        "willReplaceOnChanges": true
                    },
                    "renewPending": {
                        "type": "boolean",
                        "description": "`true` if the current time (during refresh) is after the start of the early renewal window declared by `min_seconds_remaining`, and `false` otherwise; if `auto_renew` is set to `true` then the provider will plan to replace the certificate once renewal is pending.\n"
                    },
                    "serial": {
                        "type": "string",
                        "description": "The serial number.\n",
                        "deprecationMessage": "Use serial_number instead"
                    },
                    "serialNumber": {
                        "type": "string",
                        "description": "The certificate's serial number, hex formatted.\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Time to live\n"
                    },
                    "uriSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative URIs\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:rabbitMq/secretBackend:SecretBackend": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst rabbitmq = new vault.rabbitMq.SecretBackend(\"rabbitmq\", {\n    connectionUri: \"https://.....\",\n    password: \"password\",\n    username: \"user\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nrabbitmq = vault.rabbit_mq.SecretBackend(\"rabbitmq\",\n    connection_uri=\"https://.....\",\n    password=\"password\",\n    username=\"user\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var rabbitmq = new Vault.RabbitMQ.SecretBackend(\"rabbitmq\", new()\n    {\n        ConnectionUri = \"https://.....\",\n        Password = \"password\",\n        Username = \"user\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/rabbitMq\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := rabbitMq.NewSecretBackend(ctx, \"rabbitmq\", \u0026rabbitMq.SecretBackendArgs{\n\t\t\tConnectionUri: pulumi.String(\"https://.....\"),\n\t\t\tPassword:      pulumi.String(\"password\"),\n\t\t\tUsername:      pulumi.String(\"user\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.rabbitMq.SecretBackend;\nimport com.pulumi.vault.rabbitMq.SecretBackendArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var rabbitmq = new SecretBackend(\"rabbitmq\", SecretBackendArgs.builder()        \n            .connectionUri(\"https://.....\")\n            .password(\"password\")\n            .username(\"user\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  rabbitmq:\n    type: vault:rabbitMq:SecretBackend\n    properties:\n      connectionUri: https://.....\n      password: password\n      username: user\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nRabbitMQ secret backends can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:rabbitMq/secretBackend:SecretBackend rabbitmq rabbitmq\n```\n\n ",
            "properties": {
                "connectionUri": {
                    "type": "string",
                    "description": "Specifies the RabbitMQ connection URI.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials\nissued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Specifies the RabbitMQ management administrator password.\n",
                    "secret": true
                },
                "passwordPolicy": {
                    "type": "string",
                    "description": "Specifies a password policy to use when creating dynamic credentials. Defaults to generating an alphanumeric password if not set.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `rabbitmq`.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Specifies the RabbitMQ management administrator username.\n",
                    "secret": true
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "Template describing how dynamic usernames are generated.\n"
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Specifies whether to verify connection URI, username, and password.\nDefaults to `true`.\n"
                }
            },
            "required": [
                "connectionUri",
                "defaultLeaseTtlSeconds",
                "maxLeaseTtlSeconds",
                "password",
                "username"
            ],
            "inputProperties": {
                "connectionUri": {
                    "type": "string",
                    "description": "Specifies the RabbitMQ connection URI.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials\nissued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "password": {
                    "type": "string",
                    "description": "Specifies the RabbitMQ management administrator password.\n",
                    "secret": true
                },
                "passwordPolicy": {
                    "type": "string",
                    "description": "Specifies a password policy to use when creating dynamic credentials. Defaults to generating an alphanumeric password if not set.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `rabbitmq`.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Specifies the RabbitMQ management administrator username.\n",
                    "secret": true
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "Template describing how dynamic usernames are generated.\n"
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Specifies whether to verify connection URI, username, and password.\nDefaults to `true`.\n"
                }
            },
            "requiredInputs": [
                "connectionUri",
                "password",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackend resources.\n",
                "properties": {
                    "connectionUri": {
                        "type": "string",
                        "description": "Specifies the RabbitMQ connection URI.\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The default TTL for credentials\nissued by this backend.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A human-friendly description for this backend.\n"
                    },
                    "disableRemount": {
                        "type": "boolean",
                        "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "password": {
                        "type": "string",
                        "description": "Specifies the RabbitMQ management administrator password.\n",
                        "secret": true
                    },
                    "passwordPolicy": {
                        "type": "string",
                        "description": "Specifies a password policy to use when creating dynamic credentials. Defaults to generating an alphanumeric password if not set.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `rabbitmq`.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Specifies the RabbitMQ management administrator username.\n",
                        "secret": true
                    },
                    "usernameTemplate": {
                        "type": "string",
                        "description": "Template describing how dynamic usernames are generated.\n"
                    },
                    "verifyConnection": {
                        "type": "boolean",
                        "description": "Specifies whether to verify connection URI, username, and password.\nDefaults to `true`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:rabbitMq/secretBackendRole:SecretBackendRole": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst rabbitmq = new vault.rabbitmq.SecretBackend(\"rabbitmq\", {\n    connectionUri: \"https://.....\",\n    username: \"user\",\n    password: \"password\",\n});\nconst role = new vault.rabbitmq.SecretBackendRole(\"role\", {\n    backend: rabbitmq.path,\n    tags: \"tag1,tag2\",\n    vhosts: [{\n        host: \"/\",\n        configure: \"\",\n        read: \".*\",\n        write: \"\",\n    }],\n    vhostTopics: [{\n        vhosts: [{\n            topic: \"amq.topic\",\n            read: \".*\",\n            write: \"\",\n        }],\n        host: \"/\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nrabbitmq = vault.rabbit_mq.SecretBackend(\"rabbitmq\",\n    connection_uri=\"https://.....\",\n    username=\"user\",\n    password=\"password\")\nrole = vault.rabbit_mq.SecretBackendRole(\"role\",\n    backend=rabbitmq.path,\n    tags=\"tag1,tag2\",\n    vhosts=[vault.rabbit_mq.SecretBackendRoleVhostArgs(\n        host=\"/\",\n        configure=\"\",\n        read=\".*\",\n        write=\"\",\n    )],\n    vhost_topics=[vault.rabbit_mq.SecretBackendRoleVhostTopicArgs(\n        vhosts=[vault.rabbit_mq.SecretBackendRoleVhostTopicVhostArgs(\n            topic=\"amq.topic\",\n            read=\".*\",\n            write=\"\",\n        )],\n        host=\"/\",\n    )])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var rabbitmq = new Vault.RabbitMQ.SecretBackend(\"rabbitmq\", new()\n    {\n        ConnectionUri = \"https://.....\",\n        Username = \"user\",\n        Password = \"password\",\n    });\n\n    var role = new Vault.RabbitMQ.SecretBackendRole(\"role\", new()\n    {\n        Backend = rabbitmq.Path,\n        Tags = \"tag1,tag2\",\n        Vhosts = new[]\n        {\n            new Vault.RabbitMQ.Inputs.SecretBackendRoleVhostArgs\n            {\n                Host = \"/\",\n                Configure = \"\",\n                Read = \".*\",\n                Write = \"\",\n            },\n        },\n        VhostTopics = new[]\n        {\n            new Vault.RabbitMQ.Inputs.SecretBackendRoleVhostTopicArgs\n            {\n                Vhosts = new[]\n                {\n                    new Vault.RabbitMQ.Inputs.SecretBackendRoleVhostTopicVhostArgs\n                    {\n                        Topic = \"amq.topic\",\n                        Read = \".*\",\n                        Write = \"\",\n                    },\n                },\n                Host = \"/\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/rabbitMq\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trabbitmq, err := rabbitMq.NewSecretBackend(ctx, \"rabbitmq\", \u0026rabbitMq.SecretBackendArgs{\n\t\t\tConnectionUri: pulumi.String(\"https://.....\"),\n\t\t\tUsername:      pulumi.String(\"user\"),\n\t\t\tPassword:      pulumi.String(\"password\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = rabbitMq.NewSecretBackendRole(ctx, \"role\", \u0026rabbitMq.SecretBackendRoleArgs{\n\t\t\tBackend: rabbitmq.Path,\n\t\t\tTags:    pulumi.String(\"tag1,tag2\"),\n\t\t\tVhosts: rabbitmq.SecretBackendRoleVhostArray{\n\t\t\t\t\u0026rabbitmq.SecretBackendRoleVhostArgs{\n\t\t\t\t\tHost:      pulumi.String(\"/\"),\n\t\t\t\t\tConfigure: pulumi.String(\"\"),\n\t\t\t\t\tRead:      pulumi.String(\".*\"),\n\t\t\t\t\tWrite:     pulumi.String(\"\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tVhostTopics: rabbitmq.SecretBackendRoleVhostTopicArray{\n\t\t\t\t\u0026rabbitmq.SecretBackendRoleVhostTopicArgs{\n\t\t\t\t\tVhosts: rabbitmq.SecretBackendRoleVhostTopicVhostArray{\n\t\t\t\t\t\t\u0026rabbitmq.SecretBackendRoleVhostTopicVhostArgs{\n\t\t\t\t\t\t\tTopic: pulumi.String(\"amq.topic\"),\n\t\t\t\t\t\t\tRead:  pulumi.String(\".*\"),\n\t\t\t\t\t\t\tWrite: pulumi.String(\"\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tHost: pulumi.String(\"/\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.rabbitMq.SecretBackend;\nimport com.pulumi.vault.rabbitMq.SecretBackendArgs;\nimport com.pulumi.vault.rabbitMq.SecretBackendRole;\nimport com.pulumi.vault.rabbitMq.SecretBackendRoleArgs;\nimport com.pulumi.vault.rabbitMq.inputs.SecretBackendRoleVhostArgs;\nimport com.pulumi.vault.rabbitMq.inputs.SecretBackendRoleVhostTopicArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var rabbitmq = new SecretBackend(\"rabbitmq\", SecretBackendArgs.builder()        \n            .connectionUri(\"https://.....\")\n            .username(\"user\")\n            .password(\"password\")\n            .build());\n\n        var role = new SecretBackendRole(\"role\", SecretBackendRoleArgs.builder()        \n            .backend(rabbitmq.path())\n            .tags(\"tag1,tag2\")\n            .vhosts(SecretBackendRoleVhostArgs.builder()\n                .host(\"/\")\n                .configure(\"\")\n                .read(\".*\")\n                .write(\"\")\n                .build())\n            .vhostTopics(SecretBackendRoleVhostTopicArgs.builder()\n                .vhosts(SecretBackendRoleVhostTopicVhostArgs.builder()\n                    .topic(\"amq.topic\")\n                    .read(\".*\")\n                    .write(\"\")\n                    .build())\n                .host(\"/\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  rabbitmq:\n    type: vault:rabbitMq:SecretBackend\n    properties:\n      connectionUri: https://.....\n      username: user\n      password: password\n  role:\n    type: vault:rabbitMq:SecretBackendRole\n    properties:\n      backend: ${rabbitmq.path}\n      tags: tag1,tag2\n      vhosts:\n        - host: /\n          configure:\n          read: .*\n          write:\n      vhostTopics:\n        - vhosts:\n            - topic: amq.topic\n              read: .*\n              write:\n          host: /\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nRabbitMQ secret backend roles can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:rabbitMq/secretBackendRole:SecretBackendRole role rabbitmq/roles/deploy\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path the RabbitMQ secret backend is mounted at,\nwith no leading or trailing `/`s.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "tags": {
                    "type": "string",
                    "description": "Specifies a comma-separated RabbitMQ management tags.\n"
                },
                "vhostTopics": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:rabbitMq/SecretBackendRoleVhostTopic:SecretBackendRoleVhostTopic"
                    },
                    "description": "Specifies a map of virtual hosts and exchanges to topic permissions. This option requires RabbitMQ 3.7.0 or later.\n"
                },
                "vhosts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:rabbitMq/SecretBackendRoleVhost:SecretBackendRoleVhost"
                    },
                    "description": "Specifies a map of virtual hosts to permissions.\n"
                }
            },
            "required": [
                "backend",
                "name"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path the RabbitMQ secret backend is mounted at,\nwith no leading or trailing `/`s.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "tags": {
                    "type": "string",
                    "description": "Specifies a comma-separated RabbitMQ management tags.\n"
                },
                "vhostTopics": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:rabbitMq/SecretBackendRoleVhostTopic:SecretBackendRoleVhostTopic"
                    },
                    "description": "Specifies a map of virtual hosts and exchanges to topic permissions. This option requires RabbitMQ 3.7.0 or later.\n"
                },
                "vhosts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:rabbitMq/SecretBackendRoleVhost:SecretBackendRoleVhost"
                    },
                    "description": "Specifies a map of virtual hosts to permissions.\n"
                }
            },
            "requiredInputs": [
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the RabbitMQ secret backend is mounted at,\nwith no leading or trailing `/`s.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "tags": {
                        "type": "string",
                        "description": "Specifies a comma-separated RabbitMQ management tags.\n"
                    },
                    "vhostTopics": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:rabbitMq/SecretBackendRoleVhostTopic:SecretBackendRoleVhostTopic"
                        },
                        "description": "Specifies a map of virtual hosts and exchanges to topic permissions. This option requires RabbitMQ 3.7.0 or later.\n"
                    },
                    "vhosts": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:rabbitMq/SecretBackendRoleVhost:SecretBackendRoleVhost"
                        },
                        "description": "Specifies a map of virtual hosts to permissions.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:ssh/secretBackendCa:SecretBackendCa": {
            "description": "Provides a resource to manage CA information in an SSH secret backend\n[SSH secret backend within Vault](https://www.vaultproject.io/docs/secrets/ssh/index.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.Mount(\"example\", {type: \"ssh\"});\nconst foo = new vault.ssh.SecretBackendCa(\"foo\", {backend: example.path});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.Mount(\"example\", type=\"ssh\")\nfoo = vault.ssh.SecretBackendCa(\"foo\", backend=example.path)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Vault.Mount(\"example\", new()\n    {\n        Type = \"ssh\",\n    });\n\n    var foo = new Vault.Ssh.SecretBackendCa(\"foo\", new()\n    {\n        Backend = example.Path,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/ssh\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := vault.NewMount(ctx, \"example\", \u0026vault.MountArgs{\n\t\t\tType: pulumi.String(\"ssh\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ssh.NewSecretBackendCa(ctx, \"foo\", \u0026ssh.SecretBackendCaArgs{\n\t\t\tBackend: example.Path,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Mount;\nimport com.pulumi.vault.MountArgs;\nimport com.pulumi.vault.ssh.SecretBackendCa;\nimport com.pulumi.vault.ssh.SecretBackendCaArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Mount(\"example\", MountArgs.builder()        \n            .type(\"ssh\")\n            .build());\n\n        var foo = new SecretBackendCa(\"foo\", SecretBackendCaArgs.builder()        \n            .backend(example.path())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: vault:Mount\n    properties:\n      type: ssh\n  foo:\n    type: vault:ssh:SecretBackendCa\n    properties:\n      backend: ${example.path}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nSSH secret backend CAs can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:ssh/secretBackendCa:SecretBackendCa foo ssh\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path where the SSH secret backend is mounted. Defaults to 'ssh'\n"
                },
                "generateSigningKey": {
                    "type": "boolean",
                    "description": "Whether Vault should generate the signing key pair internally. Defaults to true\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "The private key part the SSH CA key pair; required if generate_signing_key is false.\n",
                    "secret": true
                },
                "publicKey": {
                    "type": "string",
                    "description": "The public key part the SSH CA key pair; required if generate_signing_key is false.\n"
                }
            },
            "required": [
                "privateKey",
                "publicKey"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path where the SSH secret backend is mounted. Defaults to 'ssh'\n",
                    "willReplaceOnChanges": true
                },
                "generateSigningKey": {
                    "type": "boolean",
                    "description": "Whether Vault should generate the signing key pair internally. Defaults to true\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "privateKey": {
                    "type": "string",
                    "description": "The private key part the SSH CA key pair; required if generate_signing_key is false.\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                },
                "publicKey": {
                    "type": "string",
                    "description": "The public key part the SSH CA key pair; required if generate_signing_key is false.\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendCa resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path where the SSH secret backend is mounted. Defaults to 'ssh'\n",
                        "willReplaceOnChanges": true
                    },
                    "generateSigningKey": {
                        "type": "boolean",
                        "description": "Whether Vault should generate the signing key pair internally. Defaults to true\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "privateKey": {
                        "type": "string",
                        "description": "The private key part the SSH CA key pair; required if generate_signing_key is false.\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "The public key part the SSH CA key pair; required if generate_signing_key is false.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:ssh/secretBackendRole:SecretBackendRole": {
            "description": "Provides a resource to manage roles in an SSH secret backend\n[SSH secret backend within Vault](https://www.vaultproject.io/docs/secrets/ssh/index.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.Mount(\"example\", {type: \"ssh\"});\nconst foo = new vault.ssh.SecretBackendRole(\"foo\", {\n    backend: example.path,\n    keyType: \"ca\",\n    allowUserCertificates: true,\n});\nconst bar = new vault.ssh.SecretBackendRole(\"bar\", {\n    backend: example.path,\n    keyType: \"otp\",\n    defaultUser: \"default\",\n    allowedUsers: \"default,baz\",\n    cidrList: \"0.0.0.0/0\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.Mount(\"example\", type=\"ssh\")\nfoo = vault.ssh.SecretBackendRole(\"foo\",\n    backend=example.path,\n    key_type=\"ca\",\n    allow_user_certificates=True)\nbar = vault.ssh.SecretBackendRole(\"bar\",\n    backend=example.path,\n    key_type=\"otp\",\n    default_user=\"default\",\n    allowed_users=\"default,baz\",\n    cidr_list=\"0.0.0.0/0\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Vault.Mount(\"example\", new()\n    {\n        Type = \"ssh\",\n    });\n\n    var foo = new Vault.Ssh.SecretBackendRole(\"foo\", new()\n    {\n        Backend = example.Path,\n        KeyType = \"ca\",\n        AllowUserCertificates = true,\n    });\n\n    var bar = new Vault.Ssh.SecretBackendRole(\"bar\", new()\n    {\n        Backend = example.Path,\n        KeyType = \"otp\",\n        DefaultUser = \"default\",\n        AllowedUsers = \"default,baz\",\n        CidrList = \"0.0.0.0/0\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/ssh\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := vault.NewMount(ctx, \"example\", \u0026vault.MountArgs{\n\t\t\tType: pulumi.String(\"ssh\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ssh.NewSecretBackendRole(ctx, \"foo\", \u0026ssh.SecretBackendRoleArgs{\n\t\t\tBackend:               example.Path,\n\t\t\tKeyType:               pulumi.String(\"ca\"),\n\t\t\tAllowUserCertificates: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ssh.NewSecretBackendRole(ctx, \"bar\", \u0026ssh.SecretBackendRoleArgs{\n\t\t\tBackend:      example.Path,\n\t\t\tKeyType:      pulumi.String(\"otp\"),\n\t\t\tDefaultUser:  pulumi.String(\"default\"),\n\t\t\tAllowedUsers: pulumi.String(\"default,baz\"),\n\t\t\tCidrList:     pulumi.String(\"0.0.0.0/0\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Mount;\nimport com.pulumi.vault.MountArgs;\nimport com.pulumi.vault.ssh.SecretBackendRole;\nimport com.pulumi.vault.ssh.SecretBackendRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Mount(\"example\", MountArgs.builder()        \n            .type(\"ssh\")\n            .build());\n\n        var foo = new SecretBackendRole(\"foo\", SecretBackendRoleArgs.builder()        \n            .backend(example.path())\n            .keyType(\"ca\")\n            .allowUserCertificates(true)\n            .build());\n\n        var bar = new SecretBackendRole(\"bar\", SecretBackendRoleArgs.builder()        \n            .backend(example.path())\n            .keyType(\"otp\")\n            .defaultUser(\"default\")\n            .allowedUsers(\"default,baz\")\n            .cidrList(\"0.0.0.0/0\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: vault:Mount\n    properties:\n      type: ssh\n  foo:\n    type: vault:ssh:SecretBackendRole\n    properties:\n      backend: ${example.path}\n      keyType: ca\n      allowUserCertificates: true\n  bar:\n    type: vault:ssh:SecretBackendRole\n    properties:\n      backend: ${example.path}\n      keyType: otp\n      defaultUser: default\n      allowedUsers: default,baz\n      cidrList: 0.0.0.0/0\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nSSH secret backend roles can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:ssh/secretBackendRole:SecretBackendRole foo ssh/roles/my-role\n```\n\n ",
            "properties": {
                "algorithmSigner": {
                    "type": "string",
                    "description": "When supplied, this value specifies a signing algorithm for the key. Possible values: ssh-rsa, rsa-sha2-256, rsa-sha2-512.\n"
                },
                "allowBareDomains": {
                    "type": "boolean",
                    "description": "Specifies if host certificates that are requested are allowed to use the base domains listed in `allowed_domains`.\n"
                },
                "allowHostCertificates": {
                    "type": "boolean",
                    "description": "Specifies if certificates are allowed to be signed for use as a 'host'.\n"
                },
                "allowSubdomains": {
                    "type": "boolean",
                    "description": "Specifies if host certificates that are requested are allowed to be subdomains of those listed in `allowed_domains`.\n"
                },
                "allowUserCertificates": {
                    "type": "boolean",
                    "description": "Specifies if certificates are allowed to be signed for use as a 'user'.\n"
                },
                "allowUserKeyIds": {
                    "type": "boolean",
                    "description": "Specifies if users can override the key ID for a signed certificate with the `key_id` field.\n"
                },
                "allowedCriticalOptions": {
                    "type": "string",
                    "description": "Specifies a comma-separated list of critical options that certificates can have when signed.\n"
                },
                "allowedDomains": {
                    "type": "string",
                    "description": "The list of domains for which a client can request a host certificate.\n"
                },
                "allowedDomainsTemplate": {
                    "type": "boolean",
                    "description": "Specifies if `allowed_domains` can be declared using\nidentity template policies. Non-templated domains are also permitted.\n"
                },
                "allowedExtensions": {
                    "type": "string",
                    "description": "Specifies a comma-separated list of extensions that certificates can have when signed.\n"
                },
                "allowedUserKeyConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:ssh/SecretBackendRoleAllowedUserKeyConfig:SecretBackendRoleAllowedUserKeyConfig"
                    },
                    "description": "Set of configuration blocks to define allowed  \nuser key configuration, like key type and their lengths. Can be specified multiple times.\n*See Configuration-Options for more info*\n"
                },
                "allowedUserKeyLengths": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "integer"
                    },
                    "description": "Specifies a map of ssh key types and their expected sizes which \nare allowed to be signed by the CA type.\n*Deprecated: use* allowed_user_key_config *instead*\n",
                    "deprecationMessage": "Set in allowed_user_key_config"
                },
                "allowedUsers": {
                    "type": "string",
                    "description": "Specifies a comma-separated list of usernames that are to be allowed, only if certain usernames are to be allowed.\n"
                },
                "allowedUsersTemplate": {
                    "type": "boolean",
                    "description": "Specifies if `allowed_users` can be declared using identity template policies. Non-templated users are also permitted.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path where the SSH secret backend is mounted.\n"
                },
                "cidrList": {
                    "type": "string",
                    "description": "The comma-separated string of CIDR blocks for which this role is applicable.\n"
                },
                "defaultCriticalOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies a map of critical options that certificates have when signed.\n"
                },
                "defaultExtensions": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies a map of extensions that certificates have when signed.\n"
                },
                "defaultUser": {
                    "type": "string",
                    "description": "Specifies the default username for which a credential will be generated.\n"
                },
                "defaultUserTemplate": {
                    "type": "boolean",
                    "description": "If set, `default_users` can be specified using identity template values. A non-templated user is also permitted.\n"
                },
                "keyIdFormat": {
                    "type": "string",
                    "description": "Specifies a custom format for the key id of a signed certificate.\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "Specifies the type of credentials generated by this role. This can be either `otp`, `dynamic` or `ca`.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Specifies the maximum Time To Live value.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the role to create.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Specifies the Time To Live value.\n"
                }
            },
            "required": [
                "algorithmSigner",
                "allowedDomainsTemplate",
                "backend",
                "keyType",
                "maxTtl",
                "name",
                "ttl"
            ],
            "inputProperties": {
                "algorithmSigner": {
                    "type": "string",
                    "description": "When supplied, this value specifies a signing algorithm for the key. Possible values: ssh-rsa, rsa-sha2-256, rsa-sha2-512.\n"
                },
                "allowBareDomains": {
                    "type": "boolean",
                    "description": "Specifies if host certificates that are requested are allowed to use the base domains listed in `allowed_domains`.\n"
                },
                "allowHostCertificates": {
                    "type": "boolean",
                    "description": "Specifies if certificates are allowed to be signed for use as a 'host'.\n"
                },
                "allowSubdomains": {
                    "type": "boolean",
                    "description": "Specifies if host certificates that are requested are allowed to be subdomains of those listed in `allowed_domains`.\n"
                },
                "allowUserCertificates": {
                    "type": "boolean",
                    "description": "Specifies if certificates are allowed to be signed for use as a 'user'.\n"
                },
                "allowUserKeyIds": {
                    "type": "boolean",
                    "description": "Specifies if users can override the key ID for a signed certificate with the `key_id` field.\n"
                },
                "allowedCriticalOptions": {
                    "type": "string",
                    "description": "Specifies a comma-separated list of critical options that certificates can have when signed.\n"
                },
                "allowedDomains": {
                    "type": "string",
                    "description": "The list of domains for which a client can request a host certificate.\n"
                },
                "allowedDomainsTemplate": {
                    "type": "boolean",
                    "description": "Specifies if `allowed_domains` can be declared using\nidentity template policies. Non-templated domains are also permitted.\n"
                },
                "allowedExtensions": {
                    "type": "string",
                    "description": "Specifies a comma-separated list of extensions that certificates can have when signed.\n"
                },
                "allowedUserKeyConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:ssh/SecretBackendRoleAllowedUserKeyConfig:SecretBackendRoleAllowedUserKeyConfig"
                    },
                    "description": "Set of configuration blocks to define allowed  \nuser key configuration, like key type and their lengths. Can be specified multiple times.\n*See Configuration-Options for more info*\n"
                },
                "allowedUserKeyLengths": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "integer"
                    },
                    "description": "Specifies a map of ssh key types and their expected sizes which \nare allowed to be signed by the CA type.\n*Deprecated: use* allowed_user_key_config *instead*\n",
                    "deprecationMessage": "Set in allowed_user_key_config"
                },
                "allowedUsers": {
                    "type": "string",
                    "description": "Specifies a comma-separated list of usernames that are to be allowed, only if certain usernames are to be allowed.\n"
                },
                "allowedUsersTemplate": {
                    "type": "boolean",
                    "description": "Specifies if `allowed_users` can be declared using identity template policies. Non-templated users are also permitted.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path where the SSH secret backend is mounted.\n",
                    "willReplaceOnChanges": true
                },
                "cidrList": {
                    "type": "string",
                    "description": "The comma-separated string of CIDR blocks for which this role is applicable.\n"
                },
                "defaultCriticalOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies a map of critical options that certificates have when signed.\n"
                },
                "defaultExtensions": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies a map of extensions that certificates have when signed.\n"
                },
                "defaultUser": {
                    "type": "string",
                    "description": "Specifies the default username for which a credential will be generated.\n"
                },
                "defaultUserTemplate": {
                    "type": "boolean",
                    "description": "If set, `default_users` can be specified using identity template values. A non-templated user is also permitted.\n"
                },
                "keyIdFormat": {
                    "type": "string",
                    "description": "Specifies a custom format for the key id of a signed certificate.\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "Specifies the type of credentials generated by this role. This can be either `otp`, `dynamic` or `ca`.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Specifies the maximum Time To Live value.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the role to create.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "ttl": {
                    "type": "string",
                    "description": "Specifies the Time To Live value.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "keyType"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRole resources.\n",
                "properties": {
                    "algorithmSigner": {
                        "type": "string",
                        "description": "When supplied, this value specifies a signing algorithm for the key. Possible values: ssh-rsa, rsa-sha2-256, rsa-sha2-512.\n"
                    },
                    "allowBareDomains": {
                        "type": "boolean",
                        "description": "Specifies if host certificates that are requested are allowed to use the base domains listed in `allowed_domains`.\n"
                    },
                    "allowHostCertificates": {
                        "type": "boolean",
                        "description": "Specifies if certificates are allowed to be signed for use as a 'host'.\n"
                    },
                    "allowSubdomains": {
                        "type": "boolean",
                        "description": "Specifies if host certificates that are requested are allowed to be subdomains of those listed in `allowed_domains`.\n"
                    },
                    "allowUserCertificates": {
                        "type": "boolean",
                        "description": "Specifies if certificates are allowed to be signed for use as a 'user'.\n"
                    },
                    "allowUserKeyIds": {
                        "type": "boolean",
                        "description": "Specifies if users can override the key ID for a signed certificate with the `key_id` field.\n"
                    },
                    "allowedCriticalOptions": {
                        "type": "string",
                        "description": "Specifies a comma-separated list of critical options that certificates can have when signed.\n"
                    },
                    "allowedDomains": {
                        "type": "string",
                        "description": "The list of domains for which a client can request a host certificate.\n"
                    },
                    "allowedDomainsTemplate": {
                        "type": "boolean",
                        "description": "Specifies if `allowed_domains` can be declared using\nidentity template policies. Non-templated domains are also permitted.\n"
                    },
                    "allowedExtensions": {
                        "type": "string",
                        "description": "Specifies a comma-separated list of extensions that certificates can have when signed.\n"
                    },
                    "allowedUserKeyConfigs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:ssh/SecretBackendRoleAllowedUserKeyConfig:SecretBackendRoleAllowedUserKeyConfig"
                        },
                        "description": "Set of configuration blocks to define allowed  \nuser key configuration, like key type and their lengths. Can be specified multiple times.\n*See Configuration-Options for more info*\n"
                    },
                    "allowedUserKeyLengths": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "integer"
                        },
                        "description": "Specifies a map of ssh key types and their expected sizes which \nare allowed to be signed by the CA type.\n*Deprecated: use* allowed_user_key_config *instead*\n",
                        "deprecationMessage": "Set in allowed_user_key_config"
                    },
                    "allowedUsers": {
                        "type": "string",
                        "description": "Specifies a comma-separated list of usernames that are to be allowed, only if certain usernames are to be allowed.\n"
                    },
                    "allowedUsersTemplate": {
                        "type": "boolean",
                        "description": "Specifies if `allowed_users` can be declared using identity template policies. Non-templated users are also permitted.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path where the SSH secret backend is mounted.\n",
                        "willReplaceOnChanges": true
                    },
                    "cidrList": {
                        "type": "string",
                        "description": "The comma-separated string of CIDR blocks for which this role is applicable.\n"
                    },
                    "defaultCriticalOptions": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Specifies a map of critical options that certificates have when signed.\n"
                    },
                    "defaultExtensions": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Specifies a map of extensions that certificates have when signed.\n"
                    },
                    "defaultUser": {
                        "type": "string",
                        "description": "Specifies the default username for which a credential will be generated.\n"
                    },
                    "defaultUserTemplate": {
                        "type": "boolean",
                        "description": "If set, `default_users` can be specified using identity template values. A non-templated user is also permitted.\n"
                    },
                    "keyIdFormat": {
                        "type": "string",
                        "description": "Specifies a custom format for the key id of a signed certificate.\n"
                    },
                    "keyType": {
                        "type": "string",
                        "description": "Specifies the type of credentials generated by this role. This can be either `otp`, `dynamic` or `ca`.\n"
                    },
                    "maxTtl": {
                        "type": "string",
                        "description": "Specifies the maximum Time To Live value.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the name of the role to create.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Specifies the Time To Live value.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:terraformcloud/secretBackend:SecretBackend": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst test = new vault.terraformcloud.SecretBackend(\"test\", {\n    backend: \"terraform\",\n    description: \"Manages the Terraform Cloud backend\",\n    token: \"V0idfhi2iksSDU234ucdbi2nidsi...\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntest = vault.terraformcloud.SecretBackend(\"test\",\n    backend=\"terraform\",\n    description=\"Manages the Terraform Cloud backend\",\n    token=\"V0idfhi2iksSDU234ucdbi2nidsi...\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Vault.TerraformCloud.SecretBackend(\"test\", new()\n    {\n        Backend = \"terraform\",\n        Description = \"Manages the Terraform Cloud backend\",\n        Token = \"V0idfhi2iksSDU234ucdbi2nidsi...\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/terraformcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := terraformcloud.NewSecretBackend(ctx, \"test\", \u0026terraformcloud.SecretBackendArgs{\n\t\t\tBackend:     pulumi.String(\"terraform\"),\n\t\t\tDescription: pulumi.String(\"Manages the Terraform Cloud backend\"),\n\t\t\tToken:       pulumi.String(\"V0idfhi2iksSDU234ucdbi2nidsi...\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.terraformcloud.SecretBackend;\nimport com.pulumi.vault.terraformcloud.SecretBackendArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new SecretBackend(\"test\", SecretBackendArgs.builder()        \n            .backend(\"terraform\")\n            .description(\"Manages the Terraform Cloud backend\")\n            .token(\"V0idfhi2iksSDU234ucdbi2nidsi...\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: vault:terraformcloud:SecretBackend\n    properties:\n      backend: terraform\n      description: Manages the Terraform Cloud backend\n      token: V0idfhi2iksSDU234ucdbi2nidsi...\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nTerraform Cloud secret backends can be imported using the `backend`, e.g.\n\n```sh\n $ pulumi import vault:terraformcloud/secretBackend:SecretBackend example terraform\n```\n\n ",
            "properties": {
                "address": {
                    "type": "string",
                    "description": "Specifies the address of the Terraform Cloud instance, provided as \"host:port\" like \"127.0.0.1:8500\".\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Unique name of the Vault Terraform Cloud mount to configure\n"
                },
                "basePath": {
                    "type": "string",
                    "description": "Specifies the base path for the Terraform Cloud or Enterprise API.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials issued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n"
                },
                "token": {
                    "type": "string",
                    "description": "Specifies the Terraform Cloud access token to use.\n",
                    "secret": true
                }
            },
            "inputProperties": {
                "address": {
                    "type": "string",
                    "description": "Specifies the address of the Terraform Cloud instance, provided as \"host:port\" like \"127.0.0.1:8500\".\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Unique name of the Vault Terraform Cloud mount to configure\n"
                },
                "basePath": {
                    "type": "string",
                    "description": "Specifies the base path for the Terraform Cloud or Enterprise API.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials issued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "disableRemount": {
                    "type": "boolean",
                    "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "token": {
                    "type": "string",
                    "description": "Specifies the Terraform Cloud access token to use.\n",
                    "secret": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackend resources.\n",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "Specifies the address of the Terraform Cloud instance, provided as \"host:port\" like \"127.0.0.1:8500\".\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "Unique name of the Vault Terraform Cloud mount to configure\n"
                    },
                    "basePath": {
                        "type": "string",
                        "description": "Specifies the base path for the Terraform Cloud or Enterprise API.\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The default TTL for credentials issued by this backend.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A human-friendly description for this backend.\n"
                    },
                    "disableRemount": {
                        "type": "boolean",
                        "description": "If set, opts out of mount migration on path updates.\nSee here for more info on [Mount Migration](https://www.vaultproject.io/docs/concepts/mount-migration)\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "token": {
                        "type": "string",
                        "description": "Specifies the Terraform Cloud access token to use.\n",
                        "secret": true
                    }
                },
                "type": "object"
            }
        },
        "vault:terraformcloud/secretCreds:SecretCreds": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst test = new vault.terraformcloud.SecretBackend(\"test\", {\n    backend: \"terraform\",\n    description: \"Manages the Terraform Cloud backend\",\n    token: \"V0idfhi2iksSDU234ucdbi2nidsi...\",\n});\nconst example = new vault.terraformcloud.SecretRole(\"example\", {\n    backend: test.backend,\n    organization: \"example-organization-name\",\n    teamId: \"team-ieF4isC...\",\n});\nconst token = new vault.terraformcloud.SecretCreds(\"token\", {\n    backend: test.backend,\n    role: example.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntest = vault.terraformcloud.SecretBackend(\"test\",\n    backend=\"terraform\",\n    description=\"Manages the Terraform Cloud backend\",\n    token=\"V0idfhi2iksSDU234ucdbi2nidsi...\")\nexample = vault.terraformcloud.SecretRole(\"example\",\n    backend=test.backend,\n    organization=\"example-organization-name\",\n    team_id=\"team-ieF4isC...\")\ntoken = vault.terraformcloud.SecretCreds(\"token\",\n    backend=test.backend,\n    role=example.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Vault.TerraformCloud.SecretBackend(\"test\", new()\n    {\n        Backend = \"terraform\",\n        Description = \"Manages the Terraform Cloud backend\",\n        Token = \"V0idfhi2iksSDU234ucdbi2nidsi...\",\n    });\n\n    var example = new Vault.TerraformCloud.SecretRole(\"example\", new()\n    {\n        Backend = test.Backend,\n        Organization = \"example-organization-name\",\n        TeamId = \"team-ieF4isC...\",\n    });\n\n    var token = new Vault.TerraformCloud.SecretCreds(\"token\", new()\n    {\n        Backend = test.Backend,\n        Role = example.Name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/terraformcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := terraformcloud.NewSecretBackend(ctx, \"test\", \u0026terraformcloud.SecretBackendArgs{\n\t\t\tBackend:     pulumi.String(\"terraform\"),\n\t\t\tDescription: pulumi.String(\"Manages the Terraform Cloud backend\"),\n\t\t\tToken:       pulumi.String(\"V0idfhi2iksSDU234ucdbi2nidsi...\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texample, err := terraformcloud.NewSecretRole(ctx, \"example\", \u0026terraformcloud.SecretRoleArgs{\n\t\t\tBackend:      test.Backend,\n\t\t\tOrganization: pulumi.String(\"example-organization-name\"),\n\t\t\tTeamId:       pulumi.String(\"team-ieF4isC...\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = terraformcloud.NewSecretCreds(ctx, \"token\", \u0026terraformcloud.SecretCredsArgs{\n\t\t\tBackend: test.Backend,\n\t\t\tRole:    example.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.terraformcloud.SecretBackend;\nimport com.pulumi.vault.terraformcloud.SecretBackendArgs;\nimport com.pulumi.vault.terraformcloud.SecretRole;\nimport com.pulumi.vault.terraformcloud.SecretRoleArgs;\nimport com.pulumi.vault.terraformcloud.SecretCreds;\nimport com.pulumi.vault.terraformcloud.SecretCredsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new SecretBackend(\"test\", SecretBackendArgs.builder()        \n            .backend(\"terraform\")\n            .description(\"Manages the Terraform Cloud backend\")\n            .token(\"V0idfhi2iksSDU234ucdbi2nidsi...\")\n            .build());\n\n        var example = new SecretRole(\"example\", SecretRoleArgs.builder()        \n            .backend(test.backend())\n            .organization(\"example-organization-name\")\n            .teamId(\"team-ieF4isC...\")\n            .build());\n\n        var token = new SecretCreds(\"token\", SecretCredsArgs.builder()        \n            .backend(test.backend())\n            .role(example.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: vault:terraformcloud:SecretBackend\n    properties:\n      backend: terraform\n      description: Manages the Terraform Cloud backend\n      token: V0idfhi2iksSDU234ucdbi2nidsi...\n  example:\n    type: vault:terraformcloud:SecretRole\n    properties:\n      backend: ${test.backend}\n      organization: example-organization-name\n      teamId: team-ieF4isC...\n  token:\n    type: vault:terraformcloud:SecretCreds\n    properties:\n      backend: ${test.backend}\n      role: ${example.name}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Terraform Cloud secret backend to generate tokens from\n"
                },
                "leaseId": {
                    "type": "string",
                    "description": "The lease associated with the token. Only user tokens will have a \nVault lease associated with them.\n",
                    "secret": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization associated with the token provided.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the role.\n"
                },
                "teamId": {
                    "type": "string",
                    "description": "The team id associated with the token provided.\n"
                },
                "token": {
                    "type": "string",
                    "description": "The actual token that was generated and can be used with API calls\nto identify the user of the call.\n",
                    "secret": true
                },
                "tokenId": {
                    "type": "string",
                    "description": "The public identifier for a specific token. It can be used \nto look up information about a token or to revoke a token.\n"
                }
            },
            "required": [
                "backend",
                "leaseId",
                "organization",
                "role",
                "teamId",
                "token",
                "tokenId"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Terraform Cloud secret backend to generate tokens from\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "role": {
                    "type": "string",
                    "description": "Name of the role.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "backend",
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretCreds resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Terraform Cloud secret backend to generate tokens from\n"
                    },
                    "leaseId": {
                        "type": "string",
                        "description": "The lease associated with the token. Only user tokens will have a \nVault lease associated with them.\n",
                        "secret": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "organization": {
                        "type": "string",
                        "description": "The organization associated with the token provided.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "Name of the role.\n",
                        "willReplaceOnChanges": true
                    },
                    "teamId": {
                        "type": "string",
                        "description": "The team id associated with the token provided.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "The actual token that was generated and can be used with API calls\nto identify the user of the call.\n",
                        "secret": true
                    },
                    "tokenId": {
                        "type": "string",
                        "description": "The public identifier for a specific token. It can be used \nto look up information about a token or to revoke a token.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:terraformcloud/secretRole:SecretRole": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst test = new vault.terraformcloud.SecretBackend(\"test\", {\n    backend: \"terraform\",\n    description: \"Manages the Terraform Cloud backend\",\n    token: \"V0idfhi2iksSDU234ucdbi2nidsi...\",\n});\nconst example = new vault.terraformcloud.SecretRole(\"example\", {\n    backend: test.backend,\n    organization: \"example-organization-name\",\n    teamId: \"team-ieF4isC...\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntest = vault.terraformcloud.SecretBackend(\"test\",\n    backend=\"terraform\",\n    description=\"Manages the Terraform Cloud backend\",\n    token=\"V0idfhi2iksSDU234ucdbi2nidsi...\")\nexample = vault.terraformcloud.SecretRole(\"example\",\n    backend=test.backend,\n    organization=\"example-organization-name\",\n    team_id=\"team-ieF4isC...\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Vault.TerraformCloud.SecretBackend(\"test\", new()\n    {\n        Backend = \"terraform\",\n        Description = \"Manages the Terraform Cloud backend\",\n        Token = \"V0idfhi2iksSDU234ucdbi2nidsi...\",\n    });\n\n    var example = new Vault.TerraformCloud.SecretRole(\"example\", new()\n    {\n        Backend = test.Backend,\n        Organization = \"example-organization-name\",\n        TeamId = \"team-ieF4isC...\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/terraformcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := terraformcloud.NewSecretBackend(ctx, \"test\", \u0026terraformcloud.SecretBackendArgs{\n\t\t\tBackend:     pulumi.String(\"terraform\"),\n\t\t\tDescription: pulumi.String(\"Manages the Terraform Cloud backend\"),\n\t\t\tToken:       pulumi.String(\"V0idfhi2iksSDU234ucdbi2nidsi...\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = terraformcloud.NewSecretRole(ctx, \"example\", \u0026terraformcloud.SecretRoleArgs{\n\t\t\tBackend:      test.Backend,\n\t\t\tOrganization: pulumi.String(\"example-organization-name\"),\n\t\t\tTeamId:       pulumi.String(\"team-ieF4isC...\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.terraformcloud.SecretBackend;\nimport com.pulumi.vault.terraformcloud.SecretBackendArgs;\nimport com.pulumi.vault.terraformcloud.SecretRole;\nimport com.pulumi.vault.terraformcloud.SecretRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new SecretBackend(\"test\", SecretBackendArgs.builder()        \n            .backend(\"terraform\")\n            .description(\"Manages the Terraform Cloud backend\")\n            .token(\"V0idfhi2iksSDU234ucdbi2nidsi...\")\n            .build());\n\n        var example = new SecretRole(\"example\", SecretRoleArgs.builder()        \n            .backend(test.backend())\n            .organization(\"example-organization-name\")\n            .teamId(\"team-ieF4isC...\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: vault:terraformcloud:SecretBackend\n    properties:\n      backend: terraform\n      description: Manages the Terraform Cloud backend\n      token: V0idfhi2iksSDU234ucdbi2nidsi...\n  example:\n    type: vault:terraformcloud:SecretRole\n    properties:\n      backend: ${test.backend}\n      organization: example-organization-name\n      teamId: team-ieF4isC...\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nTerraform Cloud secret backend roles can be imported using the `backend`, `/roles/`, and the `name` e.g.\n\n```sh\n $ pulumi import vault:terraformcloud/secretRole:SecretRole example terraform/roles/my-role\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path of the Terraform Cloud Secret Backend the role belongs to.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "Maximum TTL for leases associated with this role, in seconds.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of an existing role against which to create this Terraform Cloud credential\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "organization": {
                    "type": "string",
                    "description": "Name of the Terraform Cloud or Enterprise organization\n"
                },
                "teamId": {
                    "type": "string",
                    "description": "ID of the Terraform Cloud or Enterprise team under organization (e.g., settings/teams/team-xxxxxxxxxxxxx)\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "Specifies the TTL for this role.\n"
                },
                "userId": {
                    "type": "string",
                    "description": "ID of the Terraform Cloud or Enterprise user (e.g., user-xxxxxxxxxxxxxxxx)\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path of the Terraform Cloud Secret Backend the role belongs to.\n",
                    "willReplaceOnChanges": true
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "Maximum TTL for leases associated with this role, in seconds.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of an existing role against which to create this Terraform Cloud credential\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "organization": {
                    "type": "string",
                    "description": "Name of the Terraform Cloud or Enterprise organization\n"
                },
                "teamId": {
                    "type": "string",
                    "description": "ID of the Terraform Cloud or Enterprise team under organization (e.g., settings/teams/team-xxxxxxxxxxxxx)\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "Specifies the TTL for this role.\n"
                },
                "userId": {
                    "type": "string",
                    "description": "ID of the Terraform Cloud or Enterprise user (e.g., user-xxxxxxxxxxxxxxxx)\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path of the Terraform Cloud Secret Backend the role belongs to.\n",
                        "willReplaceOnChanges": true
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "Maximum TTL for leases associated with this role, in seconds.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of an existing role against which to create this Terraform Cloud credential\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "organization": {
                        "type": "string",
                        "description": "Name of the Terraform Cloud or Enterprise organization\n"
                    },
                    "teamId": {
                        "type": "string",
                        "description": "ID of the Terraform Cloud or Enterprise team under organization (e.g., settings/teams/team-xxxxxxxxxxxxx)\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "Specifies the TTL for this role.\n"
                    },
                    "userId": {
                        "type": "string",
                        "description": "ID of the Terraform Cloud or Enterprise user (e.g., user-xxxxxxxxxxxxxxxx)\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:tokenauth/authBackendRole:AuthBackendRole": {
            "description": "Manages Token auth backend role in a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/token.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.tokenauth.AuthBackendRole(\"example\", {\n    allowedEntityAliases: [\"test_entity\"],\n    allowedPolicies: [\n        \"dev\",\n        \"test\",\n    ],\n    disallowedPolicies: [\"default\"],\n    orphan: true,\n    pathSuffix: \"path-suffix\",\n    renewable: true,\n    roleName: \"my-role\",\n    tokenExplicitMaxTtl: 115200,\n    tokenPeriod: 86400,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.tokenauth.AuthBackendRole(\"example\",\n    allowed_entity_aliases=[\"test_entity\"],\n    allowed_policies=[\n        \"dev\",\n        \"test\",\n    ],\n    disallowed_policies=[\"default\"],\n    orphan=True,\n    path_suffix=\"path-suffix\",\n    renewable=True,\n    role_name=\"my-role\",\n    token_explicit_max_ttl=115200,\n    token_period=86400)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Vault.TokenAuth.AuthBackendRole(\"example\", new()\n    {\n        AllowedEntityAliases = new[]\n        {\n            \"test_entity\",\n        },\n        AllowedPolicies = new[]\n        {\n            \"dev\",\n            \"test\",\n        },\n        DisallowedPolicies = new[]\n        {\n            \"default\",\n        },\n        Orphan = true,\n        PathSuffix = \"path-suffix\",\n        Renewable = true,\n        RoleName = \"my-role\",\n        TokenExplicitMaxTtl = 115200,\n        TokenPeriod = 86400,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/tokenauth\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := tokenauth.NewAuthBackendRole(ctx, \"example\", \u0026tokenauth.AuthBackendRoleArgs{\n\t\t\tAllowedEntityAliases: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"test_entity\"),\n\t\t\t},\n\t\t\tAllowedPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tDisallowedPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t},\n\t\t\tOrphan:              pulumi.Bool(true),\n\t\t\tPathSuffix:          pulumi.String(\"path-suffix\"),\n\t\t\tRenewable:           pulumi.Bool(true),\n\t\t\tRoleName:            pulumi.String(\"my-role\"),\n\t\t\tTokenExplicitMaxTtl: pulumi.Int(115200),\n\t\t\tTokenPeriod:         pulumi.Int(86400),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.tokenauth.AuthBackendRole;\nimport com.pulumi.vault.tokenauth.AuthBackendRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new AuthBackendRole(\"example\", AuthBackendRoleArgs.builder()        \n            .allowedEntityAliases(\"test_entity\")\n            .allowedPolicies(            \n                \"dev\",\n                \"test\")\n            .disallowedPolicies(\"default\")\n            .orphan(true)\n            .pathSuffix(\"path-suffix\")\n            .renewable(true)\n            .roleName(\"my-role\")\n            .tokenExplicitMaxTtl(\"115200\")\n            .tokenPeriod(\"86400\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: vault:tokenauth:AuthBackendRole\n    properties:\n      allowedEntityAliases:\n        - test_entity\n      allowedPolicies:\n        - dev\n        - test\n      disallowedPolicies:\n        - default\n      orphan: true\n      pathSuffix: path-suffix\n      renewable: true\n      roleName: my-role\n      tokenExplicitMaxTtl: 115200\n      tokenPeriod: 86400\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nToken auth backend roles can be imported with `auth/token/roles/` followed by the `role_name`, e.g.\n\n```sh\n $ pulumi import vault:tokenauth/authBackendRole:AuthBackendRole example auth/token/roles/my-role\n```\n\n ",
            "properties": {
                "allowedEntityAliases": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of allowed entity aliases.\n"
                },
                "allowedPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of allowed policies for given role.\n"
                },
                "allowedPoliciesGlobs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of allowed policies with glob match for given role.\n"
                },
                "disallowedPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of disallowed policies for given role.\n"
                },
                "disallowedPoliciesGlobs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of disallowed policies with glob match for given role.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "orphan": {
                    "type": "boolean",
                    "description": "If true, tokens created against this policy will be orphan tokens.\n"
                },
                "pathSuffix": {
                    "type": "string",
                    "description": "Tokens created against this role will have the given suffix as part of their path in addition to the role name.\n"
                },
                "renewable": {
                    "type": "boolean",
                    "description": "Whether to disable the ability of the token to be renewed past its initial TTL.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The [maximum number](https://www.vaultproject.io/api-docs/token#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "required": [
                "roleName"
            ],
            "inputProperties": {
                "allowedEntityAliases": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of allowed entity aliases.\n"
                },
                "allowedPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of allowed policies for given role.\n"
                },
                "allowedPoliciesGlobs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of allowed policies with glob match for given role.\n"
                },
                "disallowedPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of disallowed policies for given role.\n"
                },
                "disallowedPoliciesGlobs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of disallowed policies with glob match for given role.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "orphan": {
                    "type": "boolean",
                    "description": "If true, tokens created against this policy will be orphan tokens.\n"
                },
                "pathSuffix": {
                    "type": "string",
                    "description": "Tokens created against this role will have the given suffix as part of their path in addition to the role name.\n"
                },
                "renewable": {
                    "type": "boolean",
                    "description": "Whether to disable the ability of the token to be renewed past its initial TTL.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role.\n",
                    "willReplaceOnChanges": true
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The [maximum number](https://www.vaultproject.io/api-docs/token#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "requiredInputs": [
                "roleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "allowedEntityAliases": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of allowed entity aliases.\n"
                    },
                    "allowedPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of allowed policies for given role.\n"
                    },
                    "allowedPoliciesGlobs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of allowed policies with glob match for given role.\n"
                    },
                    "disallowedPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of disallowed policies for given role.\n"
                    },
                    "disallowedPoliciesGlobs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of disallowed policies with glob match for given role.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "orphan": {
                        "type": "boolean",
                        "description": "If true, tokens created against this policy will be orphan tokens.\n"
                    },
                    "pathSuffix": {
                        "type": "string",
                        "description": "Tokens created against this role will have the given suffix as part of their path in addition to the role name.\n"
                    },
                    "renewable": {
                        "type": "boolean",
                        "description": "Whether to disable the ability of the token to be renewed past its initial TTL.\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role.\n",
                        "willReplaceOnChanges": true
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The [maximum number](https://www.vaultproject.io/api-docs/token#token_num_uses)\nof times a generated token may be used (within its lifetime); 0 means unlimited.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Generated Token's Policies\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:transform/alphabet:Alphabet": {
            "description": "This resource supports the \"/transform/alphabet/{name}\" Vault endpoint.\n\nIt queries an existing alphabet by the given name.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst mountTransform = new vault.Mount(\"mountTransform\", {\n    path: \"transform\",\n    type: \"transform\",\n});\nconst test = new vault.transform.Alphabet(\"test\", {\n    path: mountTransform.path,\n    alphabet: \"0123456789\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nmount_transform = vault.Mount(\"mountTransform\",\n    path=\"transform\",\n    type=\"transform\")\ntest = vault.transform.Alphabet(\"test\",\n    path=mount_transform.path,\n    alphabet=\"0123456789\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var mountTransform = new Vault.Mount(\"mountTransform\", new()\n    {\n        Path = \"transform\",\n        Type = \"transform\",\n    });\n\n    var test = new Vault.Transform.Alphabet(\"test\", new()\n    {\n        Path = mountTransform.Path,\n        AlphabetSet = \"0123456789\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/transform\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmountTransform, err := vault.NewMount(ctx, \"mountTransform\", \u0026vault.MountArgs{\n\t\t\tPath: pulumi.String(\"transform\"),\n\t\t\tType: pulumi.String(\"transform\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = transform.NewAlphabet(ctx, \"test\", \u0026transform.AlphabetArgs{\n\t\t\tPath:     mountTransform.Path,\n\t\t\tAlphabet: pulumi.String(\"0123456789\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Mount;\nimport com.pulumi.vault.MountArgs;\nimport com.pulumi.vault.transform.Alphabet;\nimport com.pulumi.vault.transform.AlphabetArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var mountTransform = new Mount(\"mountTransform\", MountArgs.builder()        \n            .path(\"transform\")\n            .type(\"transform\")\n            .build());\n\n        var test = new Alphabet(\"test\", AlphabetArgs.builder()        \n            .path(mountTransform.path())\n            .alphabet(\"0123456789\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  mountTransform:\n    type: vault:Mount\n    properties:\n      path: transform\n      type: transform\n  test:\n    type: vault:transform:Alphabet\n    properties:\n      path: ${mountTransform.path}\n      alphabet: 0123456789\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "alphabet": {
                    "type": "string",
                    "description": "A string of characters that contains the alphabet set.\n",
                    "language": {
                        "csharp": {
                            "name": "AlphabetSet"
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of the alphabet.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to where the back-end is mounted within Vault.\n"
                }
            },
            "required": [
                "name",
                "path"
            ],
            "inputProperties": {
                "alphabet": {
                    "type": "string",
                    "description": "A string of characters that contains the alphabet set.\n",
                    "language": {
                        "csharp": {
                            "name": "AlphabetSet"
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of the alphabet.\n",
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "Path to where the back-end is mounted within Vault.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Alphabet resources.\n",
                "properties": {
                    "alphabet": {
                        "type": "string",
                        "description": "A string of characters that contains the alphabet set.\n",
                        "language": {
                            "csharp": {
                                "name": "AlphabetSet"
                            }
                        }
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the alphabet.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "Path to where the back-end is mounted within Vault.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:transform/role:Role": {
            "description": "This resource supports the \"/transform/role/{name}\" Vault endpoint.\n\nIt creates or updates the role with the given name. If a role with the name does not exist, it will be created.\nIf the role exists, it will be updated with the new attributes.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst mountTransform = new vault.Mount(\"mountTransform\", {\n    path: \"transform\",\n    type: \"transform\",\n});\nconst test = new vault.transform.Role(\"test\", {\n    path: mountTransform.path,\n    transformations: [\"ccn-fpe\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nmount_transform = vault.Mount(\"mountTransform\",\n    path=\"transform\",\n    type=\"transform\")\ntest = vault.transform.Role(\"test\",\n    path=mount_transform.path,\n    transformations=[\"ccn-fpe\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var mountTransform = new Vault.Mount(\"mountTransform\", new()\n    {\n        Path = \"transform\",\n        Type = \"transform\",\n    });\n\n    var test = new Vault.Transform.Role(\"test\", new()\n    {\n        Path = mountTransform.Path,\n        Transformations = new[]\n        {\n            \"ccn-fpe\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/transform\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmountTransform, err := vault.NewMount(ctx, \"mountTransform\", \u0026vault.MountArgs{\n\t\t\tPath: pulumi.String(\"transform\"),\n\t\t\tType: pulumi.String(\"transform\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = transform.NewRole(ctx, \"test\", \u0026transform.RoleArgs{\n\t\t\tPath: mountTransform.Path,\n\t\t\tTransformations: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"ccn-fpe\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Mount;\nimport com.pulumi.vault.MountArgs;\nimport com.pulumi.vault.transform.Role;\nimport com.pulumi.vault.transform.RoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var mountTransform = new Mount(\"mountTransform\", MountArgs.builder()        \n            .path(\"transform\")\n            .type(\"transform\")\n            .build());\n\n        var test = new Role(\"test\", RoleArgs.builder()        \n            .path(mountTransform.path())\n            .transformations(\"ccn-fpe\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  mountTransform:\n    type: vault:Mount\n    properties:\n      path: transform\n      type: transform\n  test:\n    type: vault:transform:Role\n    properties:\n      path: ${mountTransform.path}\n      transformations:\n        - ccn-fpe\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to where the back-end is mounted within Vault.\n"
                },
                "transformations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A comma separated string or slice of transformations to use.\n"
                }
            },
            "required": [
                "name",
                "path"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "The name of the role.\n",
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "Path to where the back-end is mounted within Vault.\n",
                    "willReplaceOnChanges": true
                },
                "transformations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A comma separated string or slice of transformations to use.\n"
                }
            },
            "requiredInputs": [
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Role resources.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the role.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "Path to where the back-end is mounted within Vault.\n",
                        "willReplaceOnChanges": true
                    },
                    "transformations": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A comma separated string or slice of transformations to use.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:transform/template:Template": {
            "properties": {
                "alphabet": {
                    "type": "string",
                    "description": "The alphabet to use for this template. This is only used during FPE transformations.\n"
                },
                "decodeFormats": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "- Optional mapping of name to regular expression template, used to customize\nthe decoded output. (requires Vault Enterprise 1.9+)\n"
                },
                "encodeFormat": {
                    "type": "string",
                    "description": "- The regular expression template used to format encoded values.\n(requires Vault Enterprise 1.9+)\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the template.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to where the back-end is mounted within Vault.\n"
                },
                "pattern": {
                    "type": "string",
                    "description": "The pattern used for matching. Currently, only regular expression pattern is supported.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The pattern type to use for match detection. Currently, only regex is supported.\n"
                }
            },
            "required": [
                "name",
                "path"
            ],
            "inputProperties": {
                "alphabet": {
                    "type": "string",
                    "description": "The alphabet to use for this template. This is only used during FPE transformations.\n"
                },
                "decodeFormats": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "- Optional mapping of name to regular expression template, used to customize\nthe decoded output. (requires Vault Enterprise 1.9+)\n"
                },
                "encodeFormat": {
                    "type": "string",
                    "description": "- The regular expression template used to format encoded values.\n(requires Vault Enterprise 1.9+)\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the template.\n",
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "Path to where the back-end is mounted within Vault.\n",
                    "willReplaceOnChanges": true
                },
                "pattern": {
                    "type": "string",
                    "description": "The pattern used for matching. Currently, only regular expression pattern is supported.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The pattern type to use for match detection. Currently, only regex is supported.\n"
                }
            },
            "requiredInputs": [
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Template resources.\n",
                "properties": {
                    "alphabet": {
                        "type": "string",
                        "description": "The alphabet to use for this template. This is only used during FPE transformations.\n"
                    },
                    "decodeFormats": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "- Optional mapping of name to regular expression template, used to customize\nthe decoded output. (requires Vault Enterprise 1.9+)\n"
                    },
                    "encodeFormat": {
                        "type": "string",
                        "description": "- The regular expression template used to format encoded values.\n(requires Vault Enterprise 1.9+)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the template.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "Path to where the back-end is mounted within Vault.\n",
                        "willReplaceOnChanges": true
                    },
                    "pattern": {
                        "type": "string",
                        "description": "The pattern used for matching. Currently, only regular expression pattern is supported.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The pattern type to use for match detection. Currently, only regex is supported.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:transform/transformation:Transformation": {
            "properties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The set of roles allowed to perform this transformation.\n"
                },
                "deletionAllowed": {
                    "type": "boolean",
                    "description": "If true, this transform can be deleted.\nOtherwise, deletion is blocked while this value remains false. Default: `false`\n*Only supported on vault-1.12+*\n"
                },
                "maskingCharacter": {
                    "type": "string",
                    "description": "The character used to replace data when in masking mode\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the transformation.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to where the back-end is mounted within Vault.\n"
                },
                "template": {
                    "type": "string",
                    "description": "The name of the template to use.\n"
                },
                "templates": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Templates configured for transformation.\n"
                },
                "tweakSource": {
                    "type": "string",
                    "description": "The source of where the tweak value comes from. Only valid when in FPE mode.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of transformation to perform.\n"
                }
            },
            "required": [
                "name",
                "path",
                "templates"
            ],
            "inputProperties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The set of roles allowed to perform this transformation.\n"
                },
                "deletionAllowed": {
                    "type": "boolean",
                    "description": "If true, this transform can be deleted.\nOtherwise, deletion is blocked while this value remains false. Default: `false`\n*Only supported on vault-1.12+*\n"
                },
                "maskingCharacter": {
                    "type": "string",
                    "description": "The character used to replace data when in masking mode\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the transformation.\n",
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "Path to where the back-end is mounted within Vault.\n",
                    "willReplaceOnChanges": true
                },
                "template": {
                    "type": "string",
                    "description": "The name of the template to use.\n"
                },
                "templates": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Templates configured for transformation.\n"
                },
                "tweakSource": {
                    "type": "string",
                    "description": "The source of where the tweak value comes from. Only valid when in FPE mode.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of transformation to perform.\n"
                }
            },
            "requiredInputs": [
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Transformation resources.\n",
                "properties": {
                    "allowedRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The set of roles allowed to perform this transformation.\n"
                    },
                    "deletionAllowed": {
                        "type": "boolean",
                        "description": "If true, this transform can be deleted.\nOtherwise, deletion is blocked while this value remains false. Default: `false`\n*Only supported on vault-1.12+*\n"
                    },
                    "maskingCharacter": {
                        "type": "string",
                        "description": "The character used to replace data when in masking mode\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the transformation.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "Path to where the back-end is mounted within Vault.\n",
                        "willReplaceOnChanges": true
                    },
                    "template": {
                        "type": "string",
                        "description": "The name of the template to use.\n"
                    },
                    "templates": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Templates configured for transformation.\n"
                    },
                    "tweakSource": {
                        "type": "string",
                        "description": "The source of where the tweak value comes from. Only valid when in FPE mode.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of transformation to perform.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:transit/secretBackendKey:SecretBackendKey": {
            "description": "Creates an Encryption Keyring on a Transit Secret Backend for Vault.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst transit = new vault.Mount(\"transit\", {\n    path: \"transit\",\n    type: \"transit\",\n    description: \"Example description\",\n    defaultLeaseTtlSeconds: 3600,\n    maxLeaseTtlSeconds: 86400,\n});\nconst key = new vault.transit.SecretBackendKey(\"key\", {backend: transit.path});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntransit = vault.Mount(\"transit\",\n    path=\"transit\",\n    type=\"transit\",\n    description=\"Example description\",\n    default_lease_ttl_seconds=3600,\n    max_lease_ttl_seconds=86400)\nkey = vault.transit.SecretBackendKey(\"key\", backend=transit.path)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var transit = new Vault.Mount(\"transit\", new()\n    {\n        Path = \"transit\",\n        Type = \"transit\",\n        Description = \"Example description\",\n        DefaultLeaseTtlSeconds = 3600,\n        MaxLeaseTtlSeconds = 86400,\n    });\n\n    var key = new Vault.Transit.SecretBackendKey(\"key\", new()\n    {\n        Backend = transit.Path,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/transit\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttransit, err := vault.NewMount(ctx, \"transit\", \u0026vault.MountArgs{\n\t\t\tPath:                   pulumi.String(\"transit\"),\n\t\t\tType:                   pulumi.String(\"transit\"),\n\t\t\tDescription:            pulumi.String(\"Example description\"),\n\t\t\tDefaultLeaseTtlSeconds: pulumi.Int(3600),\n\t\t\tMaxLeaseTtlSeconds:     pulumi.Int(86400),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = transit.NewSecretBackendKey(ctx, \"key\", \u0026transit.SecretBackendKeyArgs{\n\t\t\tBackend: transit.Path,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Mount;\nimport com.pulumi.vault.MountArgs;\nimport com.pulumi.vault.transit.SecretBackendKey;\nimport com.pulumi.vault.transit.SecretBackendKeyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var transit = new Mount(\"transit\", MountArgs.builder()        \n            .path(\"transit\")\n            .type(\"transit\")\n            .description(\"Example description\")\n            .defaultLeaseTtlSeconds(3600)\n            .maxLeaseTtlSeconds(86400)\n            .build());\n\n        var key = new SecretBackendKey(\"key\", SecretBackendKeyArgs.builder()        \n            .backend(transit.path())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  transit:\n    type: vault:Mount\n    properties:\n      path: transit\n      type: transit\n      description: Example description\n      defaultLeaseTtlSeconds: 3600\n      maxLeaseTtlSeconds: 86400\n  key:\n    type: vault:transit:SecretBackendKey\n    properties:\n      backend: ${transit.path}\n```\n{{% /example %}}\n{{% /examples %}}\n## Deprecations\n\n* `auto_rotate_interval` - Replaced by `auto_rotate_period`.\n\n\n## Import\n\nTransit secret backend keys can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:transit/secretBackendKey:SecretBackendKey key transit/keys/my_key\n```\n\n ",
            "properties": {
                "allowPlaintextBackup": {
                    "type": "boolean",
                    "description": "Enables taking backup of entire keyring in the plaintext format. Once set, this cannot be disabled.\n* Refer to Vault API documentation on key backups for more information: [Backup Key](https://www.vaultproject.io/api-docs/secret/transit#backup-key)\n"
                },
                "autoRotateInterval": {
                    "type": "integer",
                    "description": "Amount of time the key should live before being automatically rotated. A value of 0 disables automatic rotation for the\nkey.\n",
                    "deprecationMessage": "Use auto_rotate_period instead"
                },
                "autoRotatePeriod": {
                    "type": "integer",
                    "description": "Amount of time the key should live before being automatically rotated.\nA value of 0 disables automatic rotation for the key.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the transit secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "convergentEncryption": {
                    "type": "boolean",
                    "description": "Whether or not to support convergent encryption, where the same plaintext creates the same ciphertext. This requires `derived` to be set to `true`.\n"
                },
                "deletionAllowed": {
                    "type": "boolean",
                    "description": "Specifies if the key is allowed to be deleted.\n"
                },
                "derived": {
                    "type": "boolean",
                    "description": "Specifies if key derivation is to be used. If enabled, all encrypt/decrypt requests to this key must provide a context which is used for key derivation.\n"
                },
                "exportable": {
                    "type": "boolean",
                    "description": "Enables keys to be exportable. This allows for all valid private keys in the keyring to be exported. Once set, this cannot be disabled.\n"
                },
                "keys": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "description": "List of key versions in the keyring. This attribute is zero-indexed and will contain a map of values depending on the `type` of the encryption key.\n* for key types `aes128-gcm96`, `aes256-gcm96` and `chacha20-poly1305`, each key version will be a map of a single value `id` which is just a hash of the key's metadata.\n* for key types `ed25519`, `ecdsa-p256`, `ecdsa-p384`, `ecdsa-p521`, `rsa-2048`, `rsa-3072` and `rsa-4096`, each key version will be a map of the following:\n"
                },
                "latestVersion": {
                    "type": "integer",
                    "description": "Latest key version available. This value is 1-indexed, so if `latest_version` is `1`, then the key's information can be referenced from `keys` by selecting element `0`\n"
                },
                "minAvailableVersion": {
                    "type": "integer",
                    "description": "Minimum key version available for use. If keys have been archived by increasing `min_decryption_version`, this attribute will reflect that change.\n"
                },
                "minDecryptionVersion": {
                    "type": "integer",
                    "description": "Minimum key version to use for decryption.\n"
                },
                "minEncryptionVersion": {
                    "type": "integer",
                    "description": "Minimum key version to use for encryption\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this key within the backend. Must be unique within the backend.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "supportsDecryption": {
                    "type": "boolean",
                    "description": "Whether or not the key supports decryption, based on key type.\n"
                },
                "supportsDerivation": {
                    "type": "boolean",
                    "description": "Whether or not the key supports derivation, based on key type.\n"
                },
                "supportsEncryption": {
                    "type": "boolean",
                    "description": "Whether or not the key supports encryption, based on key type.\n"
                },
                "supportsSigning": {
                    "type": "boolean",
                    "description": "Whether or not the key supports signing, based on key type.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Specifies the type of key to create. The currently-supported types are: `aes128-gcm96`, `aes256-gcm96` (default), `chacha20-poly1305`, `ed25519`, `ecdsa-p256`, `ecdsa-p384`, `ecdsa-p521`, `rsa-2048`, `rsa-3072` and `rsa-4096`. \n* Refer to the Vault documentation on transit key types for more information: [Key Types](https://www.vaultproject.io/docs/secrets/transit#key-types)\n"
                }
            },
            "required": [
                "autoRotateInterval",
                "autoRotatePeriod",
                "backend",
                "keys",
                "latestVersion",
                "minAvailableVersion",
                "name",
                "supportsDecryption",
                "supportsDerivation",
                "supportsEncryption",
                "supportsSigning"
            ],
            "inputProperties": {
                "allowPlaintextBackup": {
                    "type": "boolean",
                    "description": "Enables taking backup of entire keyring in the plaintext format. Once set, this cannot be disabled.\n* Refer to Vault API documentation on key backups for more information: [Backup Key](https://www.vaultproject.io/api-docs/secret/transit#backup-key)\n"
                },
                "autoRotateInterval": {
                    "type": "integer",
                    "description": "Amount of time the key should live before being automatically rotated. A value of 0 disables automatic rotation for the\nkey.\n",
                    "deprecationMessage": "Use auto_rotate_period instead"
                },
                "autoRotatePeriod": {
                    "type": "integer",
                    "description": "Amount of time the key should live before being automatically rotated.\nA value of 0 disables automatic rotation for the key.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the transit secret backend is mounted at, with no leading or trailing `/`s.\n",
                    "willReplaceOnChanges": true
                },
                "convergentEncryption": {
                    "type": "boolean",
                    "description": "Whether or not to support convergent encryption, where the same plaintext creates the same ciphertext. This requires `derived` to be set to `true`.\n",
                    "willReplaceOnChanges": true
                },
                "deletionAllowed": {
                    "type": "boolean",
                    "description": "Specifies if the key is allowed to be deleted.\n"
                },
                "derived": {
                    "type": "boolean",
                    "description": "Specifies if key derivation is to be used. If enabled, all encrypt/decrypt requests to this key must provide a context which is used for key derivation.\n",
                    "willReplaceOnChanges": true
                },
                "exportable": {
                    "type": "boolean",
                    "description": "Enables keys to be exportable. This allows for all valid private keys in the keyring to be exported. Once set, this cannot be disabled.\n"
                },
                "minDecryptionVersion": {
                    "type": "integer",
                    "description": "Minimum key version to use for decryption.\n"
                },
                "minEncryptionVersion": {
                    "type": "integer",
                    "description": "Minimum key version to use for encryption\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this key within the backend. Must be unique within the backend.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "Specifies the type of key to create. The currently-supported types are: `aes128-gcm96`, `aes256-gcm96` (default), `chacha20-poly1305`, `ed25519`, `ecdsa-p256`, `ecdsa-p384`, `ecdsa-p521`, `rsa-2048`, `rsa-3072` and `rsa-4096`. \n* Refer to the Vault documentation on transit key types for more information: [Key Types](https://www.vaultproject.io/docs/secrets/transit#key-types)\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendKey resources.\n",
                "properties": {
                    "allowPlaintextBackup": {
                        "type": "boolean",
                        "description": "Enables taking backup of entire keyring in the plaintext format. Once set, this cannot be disabled.\n* Refer to Vault API documentation on key backups for more information: [Backup Key](https://www.vaultproject.io/api-docs/secret/transit#backup-key)\n"
                    },
                    "autoRotateInterval": {
                        "type": "integer",
                        "description": "Amount of time the key should live before being automatically rotated. A value of 0 disables automatic rotation for the\nkey.\n",
                        "deprecationMessage": "Use auto_rotate_period instead"
                    },
                    "autoRotatePeriod": {
                        "type": "integer",
                        "description": "Amount of time the key should live before being automatically rotated.\nA value of 0 disables automatic rotation for the key.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path the transit secret backend is mounted at, with no leading or trailing `/`s.\n",
                        "willReplaceOnChanges": true
                    },
                    "convergentEncryption": {
                        "type": "boolean",
                        "description": "Whether or not to support convergent encryption, where the same plaintext creates the same ciphertext. This requires `derived` to be set to `true`.\n",
                        "willReplaceOnChanges": true
                    },
                    "deletionAllowed": {
                        "type": "boolean",
                        "description": "Specifies if the key is allowed to be deleted.\n"
                    },
                    "derived": {
                        "type": "boolean",
                        "description": "Specifies if key derivation is to be used. If enabled, all encrypt/decrypt requests to this key must provide a context which is used for key derivation.\n",
                        "willReplaceOnChanges": true
                    },
                    "exportable": {
                        "type": "boolean",
                        "description": "Enables keys to be exportable. This allows for all valid private keys in the keyring to be exported. Once set, this cannot be disabled.\n"
                    },
                    "keys": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        },
                        "description": "List of key versions in the keyring. This attribute is zero-indexed and will contain a map of values depending on the `type` of the encryption key.\n* for key types `aes128-gcm96`, `aes256-gcm96` and `chacha20-poly1305`, each key version will be a map of a single value `id` which is just a hash of the key's metadata.\n* for key types `ed25519`, `ecdsa-p256`, `ecdsa-p384`, `ecdsa-p521`, `rsa-2048`, `rsa-3072` and `rsa-4096`, each key version will be a map of the following:\n"
                    },
                    "latestVersion": {
                        "type": "integer",
                        "description": "Latest key version available. This value is 1-indexed, so if `latest_version` is `1`, then the key's information can be referenced from `keys` by selecting element `0`\n"
                    },
                    "minAvailableVersion": {
                        "type": "integer",
                        "description": "Minimum key version available for use. If keys have been archived by increasing `min_decryption_version`, this attribute will reflect that change.\n"
                    },
                    "minDecryptionVersion": {
                        "type": "integer",
                        "description": "Minimum key version to use for decryption.\n"
                    },
                    "minEncryptionVersion": {
                        "type": "integer",
                        "description": "Minimum key version to use for encryption\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name to identify this key within the backend. Must be unique within the backend.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "supportsDecryption": {
                        "type": "boolean",
                        "description": "Whether or not the key supports decryption, based on key type.\n"
                    },
                    "supportsDerivation": {
                        "type": "boolean",
                        "description": "Whether or not the key supports derivation, based on key type.\n"
                    },
                    "supportsEncryption": {
                        "type": "boolean",
                        "description": "Whether or not the key supports encryption, based on key type.\n"
                    },
                    "supportsSigning": {
                        "type": "boolean",
                        "description": "Whether or not the key supports signing, based on key type.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Specifies the type of key to create. The currently-supported types are: `aes128-gcm96`, `aes256-gcm96` (default), `chacha20-poly1305`, `ed25519`, `ecdsa-p256`, `ecdsa-p384`, `ecdsa-p521`, `rsa-2048`, `rsa-3072` and `rsa-4096`. \n* Refer to the Vault documentation on transit key types for more information: [Key Types](https://www.vaultproject.io/docs/secrets/transit#key-types)\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vault:transit/secretCacheConfig:SecretCacheConfig": {
            "description": "Configure the cache for the Transit Secret Backend in Vault.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst transit = new vault.Mount(\"transit\", {\n    path: \"transit\",\n    type: \"transit\",\n    description: \"Example description\",\n    defaultLeaseTtlSeconds: 3600,\n    maxLeaseTtlSeconds: 86400,\n});\nconst cfg = new vault.transit.SecretCacheConfig(\"cfg\", {\n    backend: transit.path,\n    size: 500,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntransit = vault.Mount(\"transit\",\n    path=\"transit\",\n    type=\"transit\",\n    description=\"Example description\",\n    default_lease_ttl_seconds=3600,\n    max_lease_ttl_seconds=86400)\ncfg = vault.transit.SecretCacheConfig(\"cfg\",\n    backend=transit.path,\n    size=500)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var transit = new Vault.Mount(\"transit\", new()\n    {\n        Path = \"transit\",\n        Type = \"transit\",\n        Description = \"Example description\",\n        DefaultLeaseTtlSeconds = 3600,\n        MaxLeaseTtlSeconds = 86400,\n    });\n\n    var cfg = new Vault.Transit.SecretCacheConfig(\"cfg\", new()\n    {\n        Backend = transit.Path,\n        Size = 500,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/transit\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttransit, err := vault.NewMount(ctx, \"transit\", \u0026vault.MountArgs{\n\t\t\tPath:                   pulumi.String(\"transit\"),\n\t\t\tType:                   pulumi.String(\"transit\"),\n\t\t\tDescription:            pulumi.String(\"Example description\"),\n\t\t\tDefaultLeaseTtlSeconds: pulumi.Int(3600),\n\t\t\tMaxLeaseTtlSeconds:     pulumi.Int(86400),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = transit.NewSecretCacheConfig(ctx, \"cfg\", \u0026transit.SecretCacheConfigArgs{\n\t\t\tBackend: transit.Path,\n\t\t\tSize:    pulumi.Int(500),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Mount;\nimport com.pulumi.vault.MountArgs;\nimport com.pulumi.vault.transit.SecretCacheConfig;\nimport com.pulumi.vault.transit.SecretCacheConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var transit = new Mount(\"transit\", MountArgs.builder()        \n            .path(\"transit\")\n            .type(\"transit\")\n            .description(\"Example description\")\n            .defaultLeaseTtlSeconds(3600)\n            .maxLeaseTtlSeconds(86400)\n            .build());\n\n        var cfg = new SecretCacheConfig(\"cfg\", SecretCacheConfigArgs.builder()        \n            .backend(transit.path())\n            .size(500)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  transit:\n    type: vault:Mount\n    properties:\n      path: transit\n      type: transit\n      description: Example description\n      defaultLeaseTtlSeconds: 3600\n      maxLeaseTtlSeconds: 86400\n  cfg:\n    type: vault:transit:SecretCacheConfig\n    properties:\n      backend: ${transit.path}\n      size: 500\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path the transit secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "The number of cache entries. 0 means unlimited.\n"
                }
            },
            "required": [
                "backend",
                "size"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path the transit secret backend is mounted at, with no leading or trailing `/`s.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                    "willReplaceOnChanges": true
                },
                "size": {
                    "type": "integer",
                    "description": "The number of cache entries. 0 means unlimited.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "size"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretCacheConfig resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the transit secret backend is mounted at, with no leading or trailing `/`s.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "size": {
                        "type": "integer",
                        "description": "The number of cache entries. 0 means unlimited.\n"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "vault:ad/getAccessCredentials:getAccessCredentials": {
            "inputs": {
                "description": "A collection of arguments for invoking getAccessCredentials.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path to the AD secret backend to\nread credentials from, with no leading or trailing `/`s.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace of the target resource.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the AD secret backend role to read\ncredentials from, with no leading or trailing `/`s.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "role"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAccessCredentials.\n",
                "properties": {
                    "backend": {
                        "type": "string"
                    },
                    "currentPassword": {
                        "type": "string",
                        "description": "The current set password on the Active Directory service account.\n",
                        "secret": true
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "lastPassword": {
                        "type": "string",
                        "description": "The current set password on the Active Directory service account, provided because AD is eventually consistent.\n",
                        "secret": true
                    },
                    "namespace": {
                        "type": "string"
                    },
                    "role": {
                        "type": "string"
                    },
                    "username": {
                        "type": "string",
                        "description": "The Active Directory service account username.\n"
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "currentPassword",
                    "lastPassword",
                    "role",
                    "username",
                    "id"
                ]
            }
        },
        "vault:appRole/getAuthBackendRoleId:getAuthBackendRoleId": {
            "description": "Reads the Role ID of an AppRole from a Vault server.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nexport = async () =\u003e {\n    const role = await vault.appRole.getAuthBackendRoleId({\n        backend: \"my-approle-backend\",\n        roleName: \"my-role\",\n    });\n    const role_id = role.roleId;\n    return {\n        \"role-id\": role_id,\n    };\n}\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nrole = vault.appRole.get_auth_backend_role_id(backend=\"my-approle-backend\",\n    role_name=\"my-role\")\npulumi.export(\"role-id\", role.role_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var role = Vault.AppRole.GetAuthBackendRoleId.Invoke(new()\n    {\n        Backend = \"my-approle-backend\",\n        RoleName = \"my-role\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"role-id\"] = role.Apply(getAuthBackendRoleIdResult =\u003e getAuthBackendRoleIdResult.RoleId),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/appRole\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trole, err := appRole.GetAuthBackendRoleId(ctx, \u0026approle.GetAuthBackendRoleIdArgs{\n\t\t\tBackend:  pulumi.StringRef(\"my-approle-backend\"),\n\t\t\tRoleName: \"my-role\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"role-id\", role.RoleId)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.appRole.AppRoleFunctions;\nimport com.pulumi.vault.appRole.inputs.GetAuthBackendRoleIdArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var role = AppRoleFunctions.getAuthBackendRoleId(GetAuthBackendRoleIdArgs.builder()\n            .backend(\"my-approle-backend\")\n            .roleName(\"my-role\")\n            .build());\n\n        ctx.export(\"role-id\", role.applyValue(getAuthBackendRoleIdResult -\u003e getAuthBackendRoleIdResult.roleId()));\n    }\n}\n```\n```yaml\nvariables:\n  role:\n    Fn::Invoke:\n      Function: vault:appRole:getAuthBackendRoleId\n      Arguments:\n        backend: my-approle-backend\n        roleName: my-role\noutputs:\n  role-id: ${role.roleId}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getAuthBackendRoleId.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The unique name for the AppRole backend the role to\nretrieve a RoleID for resides in. Defaults to \"approle\".\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace of the target resource.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role to retrieve the Role ID for.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "roleName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAuthBackendRoleId.\n",
                "properties": {
                    "backend": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "namespace": {
                        "type": "string"
                    },
                    "roleId": {
                        "type": "string",
                        "description": "The RoleID of the role.\n"
                    },
                    "roleName": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "roleId",
                    "roleName",
                    "id"
                ]
            }
        },
        "vault:aws/getAccessCredentials:getAccessCredentials": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.aws.SecretBackend;\nimport com.pulumi.vault.aws.SecretBackendArgs;\nimport com.pulumi.vault.aws.SecretBackendRole;\nimport com.pulumi.vault.aws.SecretBackendRoleArgs;\nimport com.pulumi.vault.aws.AwsFunctions;\nimport com.pulumi.vault.ad.inputs.GetAccessCredentialsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var aws = new SecretBackend(\"aws\", SecretBackendArgs.builder()        \n            .accessKey(\"AKIA.....\")\n            .secretKey(\"SECRETKEYFROMAWS\")\n            .build());\n\n        var role = new SecretBackendRole(\"role\", SecretBackendRoleArgs.builder()        \n            .backend(aws.path())\n            .policy(\"\"\"\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": \"iam:*\",\n      \"Resource\": \"*\"\n    }\n  ]\n}\n            \"\"\")\n            .build());\n\n        final var creds = AwsFunctions.getAccessCredentials(GetAccessCredentialsArgs.builder()\n            .backend(aws.path())\n            .role(role.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  aws:\n    type: vault:aws:SecretBackend\n    properties:\n      accessKey: AKIA.....\n      secretKey: SECRETKEYFROMAWS\n  role:\n    type: vault:aws:SecretBackendRole\n    properties:\n      backend: ${aws.path}\n      policy: |\n        {\n          \"Version\": \"2012-10-17\",\n          \"Statement\": [\n            {\n              \"Effect\": \"Allow\",\n              \"Action\": \"iam:*\",\n              \"Resource\": \"*\"\n            }\n          ]\n        }\nvariables:\n  creds:\n    Fn::Invoke:\n      Function: vault:aws:getAccessCredentials\n      Arguments:\n        backend: ${aws.path}\n        role: ${role.name}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getAccessCredentials.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path to the AWS secret backend to\nread credentials from, with no leading or trailing `/`s.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace of the target resource.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "region": {
                        "type": "string",
                        "description": "The region the read credentials belong to.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the AWS secret backend role to read\ncredentials from, with no leading or trailing `/`s.\n"
                    },
                    "roleArn": {
                        "type": "string",
                        "description": "The specific AWS ARN to use\nfrom the configured role. If the role does not have multiple ARNs, this does\nnot need to be specified.\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Specifies the TTL for the use of the STS token. This\nis specified as a string with a duration suffix. Valid only when\n`credential_type` of the connected `vault.aws.SecretBackendRole` resource is `assumed_role` or `federation_token`\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of credentials to read. Defaults\nto `\"creds\"`, which just returns an AWS Access Key ID and Secret\nKey. Can also be set to `\"sts\"`, which will return a security token\nin addition to the keys.\n"
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "role"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAccessCredentials.\n",
                "properties": {
                    "accessKey": {
                        "type": "string",
                        "description": "The AWS Access Key ID returned by Vault.\n",
                        "secret": true
                    },
                    "backend": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "leaseDuration": {
                        "type": "integer",
                        "description": "The duration of the secret lease, in seconds relative\nto the time the data was requested. Once this time has passed any plan\ngenerated with this data may fail to apply.\n"
                    },
                    "leaseId": {
                        "type": "string",
                        "description": "The lease identifier assigned by Vault.\n"
                    },
                    "leaseRenewable": {
                        "type": "boolean"
                    },
                    "leaseStartTime": {
                        "type": "string"
                    },
                    "namespace": {
                        "type": "string"
                    },
                    "region": {
                        "type": "string"
                    },
                    "role": {
                        "type": "string"
                    },
                    "roleArn": {
                        "type": "string"
                    },
                    "secretKey": {
                        "type": "string",
                        "description": "The AWS Secret Key returned by Vault.\n",
                        "secret": true
                    },
                    "securityToken": {
                        "type": "string",
                        "description": "The STS token returned by Vault, if any.\n",
                        "secret": true
                    },
                    "ttl": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "accessKey",
                    "backend",
                    "leaseDuration",
                    "leaseId",
                    "leaseRenewable",
                    "leaseStartTime",
                    "role",
                    "secretKey",
                    "securityToken",
                    "id"
                ]
            }
        },
        "vault:azure/getAccessCredentials:getAccessCredentials": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst creds = vault.azure.getAccessCredentials({\n    role: \"my-role\",\n    validateCreds: true,\n    numSequentialSuccesses: 8,\n    numSecondsBetweenTests: 1,\n    maxCredValidationSeconds: 300,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ncreds = vault.azure.get_access_credentials(role=\"my-role\",\n    validate_creds=True,\n    num_sequential_successes=8,\n    num_seconds_between_tests=1,\n    max_cred_validation_seconds=300)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var creds = Vault.Azure.GetAccessCredentials.Invoke(new()\n    {\n        Role = \"my-role\",\n        ValidateCreds = true,\n        NumSequentialSuccesses = 8,\n        NumSecondsBetweenTests = 1,\n        MaxCredValidationSeconds = 300,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/azure\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := azure.GetAccessCredentials(ctx, \u0026azure.GetAccessCredentialsArgs{\n\t\t\tRole:                     \"my-role\",\n\t\t\tValidateCreds:            pulumi.BoolRef(true),\n\t\t\tNumSequentialSuccesses:   pulumi.IntRef(8),\n\t\t\tNumSecondsBetweenTests:   pulumi.IntRef(1),\n\t\t\tMaxCredValidationSeconds: pulumi.IntRef(300),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.azure.AzureFunctions;\nimport com.pulumi.vault.ad.inputs.GetAccessCredentialsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var creds = AzureFunctions.getAccessCredentials(GetAccessCredentialsArgs.builder()\n            .role(\"my-role\")\n            .validateCreds(true)\n            .numSequentialSuccesses(8)\n            .numSecondsBetweenTests(1)\n            .maxCredValidationSeconds(300)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  creds:\n    Fn::Invoke:\n      Function: vault:azure:getAccessCredentials\n      Arguments:\n        role: my-role\n        validateCreds: true\n        numSequentialSuccesses: 8\n        numSecondsBetweenTests: 1\n        maxCredValidationSeconds: 300\n```\n{{% /example %}}\n{{% /examples %}}\n## Caveats\n\nThe `validate_creds` option requires read-access to the `backend` config endpoint.\nIf the effective Vault role does not have the required permissions then valid values \nare required to be set for: `subscription_id`, `tenant_id`, `environment`.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAccessCredentials.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path to the Azure secret backend to\nread credentials from, with no leading or trailing `/`s.\n"
                    },
                    "environment": {
                        "type": "string",
                        "description": "The Azure environment to use during credential validation.\nDefaults to the environment configured in the Vault backend.\nSome possible values: `AzurePublicCloud`, `AzureGovernmentCloud`\n*See the caveats section for more information on this field.*\n"
                    },
                    "maxCredValidationSeconds": {
                        "type": "integer",
                        "description": "If 'validate_creds' is true, \nthe number of seconds after which to give up validating credentials. Defaults\nto 300.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace of the target resource.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "numSecondsBetweenTests": {
                        "type": "integer",
                        "description": "If 'validate_creds' is true, \nthe number of seconds to wait between each test of generated credentials.\nDefaults to 1.\n"
                    },
                    "numSequentialSuccesses": {
                        "type": "integer",
                        "description": "If 'validate_creds' is true, \nthe number of sequential successes required to validate generated\ncredentials. Defaults to 8.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the Azure secret backend role to read\ncredentials from, with no leading or trailing `/`s.\n"
                    },
                    "subscriptionId": {
                        "type": "string",
                        "description": "The subscription ID to use during credential\nvalidation. Defaults to the subscription ID configured in the Vault `backend`.\n*See the caveats section for more information on this field.*\n"
                    },
                    "tenantId": {
                        "type": "string",
                        "description": "The tenant ID to use during credential validation.\nDefaults to the tenant ID configured in the Vault `backend`.\n*See the caveats section for more information on this field.*\n"
                    },
                    "validateCreds": {
                        "type": "boolean",
                        "description": "Whether generated credentials should be \nvalidated before being returned. Defaults to `false`, which returns\ncredentials without checking whether they have fully propagated throughout\nAzure Active Directory. Designating `true` activates testing.\n"
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "role"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAccessCredentials.\n",
                "properties": {
                    "backend": {
                        "type": "string"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client id for credentials to query the Azure APIs.\n"
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "The client secret for credentials to query the Azure APIs.\n",
                        "secret": true
                    },
                    "environment": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "leaseDuration": {
                        "type": "integer",
                        "description": "The duration of the secret lease, in seconds relative\nto the time the data was requested. Once this time has passed any plan\ngenerated with this data may fail to apply.\n"
                    },
                    "leaseId": {
                        "type": "string",
                        "description": "The lease identifier assigned by Vault.\n"
                    },
                    "leaseRenewable": {
                        "type": "boolean"
                    },
                    "leaseStartTime": {
                        "type": "string"
                    },
                    "maxCredValidationSeconds": {
                        "type": "integer"
                    },
                    "namespace": {
                        "type": "string"
                    },
                    "numSecondsBetweenTests": {
                        "type": "integer"
                    },
                    "numSequentialSuccesses": {
                        "type": "integer"
                    },
                    "role": {
                        "type": "string"
                    },
                    "subscriptionId": {
                        "type": "string"
                    },
                    "tenantId": {
                        "type": "string"
                    },
                    "validateCreds": {
                        "type": "boolean"
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "clientId",
                    "clientSecret",
                    "leaseDuration",
                    "leaseId",
                    "leaseRenewable",
                    "leaseStartTime",
                    "role",
                    "id"
                ]
            }
        },
        "vault:gcp/getAuthBackendRole:getAuthBackendRole": {
            "description": "Reads a GCP auth role from a Vault server.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst role = pulumi.output(vault.gcp.getAuthBackendRole({\n    backend: \"my-gcp-backend\",\n    roleName: \"my-role\",\n}));\n\nexport const role_id = role.roleId;\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nrole = vault.gcp.get_auth_backend_role(backend=\"my-gcp-backend\",\n    role_name=\"my-role\")\npulumi.export(\"role-id\", role.role_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var role = Vault.Gcp.GetAuthBackendRole.Invoke(new()\n    {\n        Backend = \"my-gcp-backend\",\n        RoleName = \"my-role\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"role-id\"] = role.Apply(getAuthBackendRoleResult =\u003e getAuthBackendRoleResult.RoleId),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/gcp\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trole, err := gcp.LookupAuthBackendRole(ctx, \u0026gcp.LookupAuthBackendRoleArgs{\n\t\t\tBackend:  pulumi.StringRef(\"my-gcp-backend\"),\n\t\t\tRoleName: \"my-role\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"role-id\", role.RoleId)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.gcp.GcpFunctions;\nimport com.pulumi.vault.gcp.inputs.GetAuthBackendRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var role = GcpFunctions.getAuthBackendRole(GetAuthBackendRoleArgs.builder()\n            .backend(\"my-gcp-backend\")\n            .roleName(\"my-role\")\n            .build());\n\n        ctx.export(\"role-id\", role.applyValue(getAuthBackendRoleResult -\u003e getAuthBackendRoleResult.roleId()));\n    }\n}\n```\n```yaml\nvariables:\n  role:\n    Fn::Invoke:\n      Function: vault:gcp:getAuthBackendRole\n      Arguments:\n        backend: my-gcp-backend\n        roleName: my-role\noutputs:\n  role-id: ${role.roleId}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getAuthBackendRole.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The unique name for the GCP backend from which to fetch the role. Defaults to \"gcp\".\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace of the target resource.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role to retrieve the Role ID for.\n",
                        "willReplaceOnChanges": true
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "(Optional) If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    }
                },
                "type": "object",
                "required": [
                    "roleName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAuthBackendRole.\n",
                "properties": {
                    "backend": {
                        "type": "string"
                    },
                    "boundInstanceGroups": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "GCP regions bound to the role. Returned when `type` is `gce`.\n"
                    },
                    "boundLabels": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "GCP labels bound to the role. Returned when `type` is `gce`.\n"
                    },
                    "boundProjects": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "GCP projects bound to the role.\n"
                    },
                    "boundRegions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "GCP regions bound to the role. Returned when `type` is `gce`.\n"
                    },
                    "boundServiceAccounts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "GCP service accounts bound to the role. Returned when `type` is `iam`.\n"
                    },
                    "boundZones": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "GCP zones bound to the role. Returned when `type` is `gce`.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "namespace": {
                        "type": "string"
                    },
                    "roleId": {
                        "type": "string",
                        "description": "The RoleID of the GCP role.\n"
                    },
                    "roleName": {
                        "type": "string"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "(Optional) If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of GCP role. Expected values are `iam` or `gce`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "boundInstanceGroups",
                    "boundLabels",
                    "boundProjects",
                    "boundRegions",
                    "boundServiceAccounts",
                    "boundZones",
                    "roleId",
                    "roleName",
                    "type",
                    "id"
                ]
            }
        },
        "vault:generic/getSecret:getSecret": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n### Generic secret\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst rundeckAuth = vault.generic.getSecret({\n    path: \"secret/rundeck_auth\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nrundeck_auth = vault.generic.get_secret(path=\"secret/rundeck_auth\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var rundeckAuth = Vault.Generic.GetSecret.Invoke(new()\n    {\n        Path = \"secret/rundeck_auth\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/generic\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := generic.LookupSecret(ctx, \u0026generic.LookupSecretArgs{\n\t\t\tPath: \"secret/rundeck_auth\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.generic.GenericFunctions;\nimport com.pulumi.vault.generic.inputs.GetSecretArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var rundeckAuth = GenericFunctions.getSecret(GetSecretArgs.builder()\n            .path(\"secret/rundeck_auth\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  rundeckAuth: # Rundeck Provider, for example\n  # For this example, in Vault there is a key named \"auth_token\" and the value is the token we need to keep secret.\n  # In general usage, replace \"auth_token\" with the key you wish to extract from Vault.\n    Fn::Invoke:\n      Function: vault:generic:getSecret\n      Arguments:\n        path: secret/rundeck_auth\n```\n{{% /example %}}\n{{% /examples %}}\n## Required Vault Capabilities\n\nUse of this resource requires the `read` capability on the given path.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getSecret.\n",
                "properties": {
                    "namespace": {
                        "type": "string",
                        "description": "The namespace of the target resource.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "The full logical path from which to request data.\nTo read data from the \"generic\" secret backend mounted in Vault by\ndefault, this should be prefixed with `secret/`. Reading from other backends\nwith this data source is possible; consult each backend's documentation\nto see which endpoints support the `GET` method.\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": "The version of the secret to read. This is used by the\nVault KV secrets engine - version 2 to indicate which version of the secret\nto read.\n"
                    },
                    "withLeaseStartTime": {
                        "type": "boolean"
                    }
                },
                "type": "object",
                "required": [
                    "path"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSecret.\n",
                "properties": {
                    "data": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A mapping whose keys are the top-level data keys returned from\nVault and whose values are the corresponding values. This map can only\nrepresent string data, so any non-string values returned from Vault are\nserialized as JSON.\n",
                        "secret": true
                    },
                    "dataJson": {
                        "type": "string",
                        "description": "A string containing the full data payload retrieved from\nVault, serialized in JSON format.\n",
                        "secret": true
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "leaseDuration": {
                        "type": "integer",
                        "description": "The duration of the secret lease, in seconds relative\nto the time the data was requested. Once this time has passed any plan\ngenerated with this data may fail to apply.\n"
                    },
                    "leaseId": {
                        "type": "string",
                        "description": "The lease identifier assigned by Vault, if any.\n"
                    },
                    "leaseRenewable": {
                        "type": "boolean"
                    },
                    "leaseStartTime": {
                        "type": "string"
                    },
                    "namespace": {
                        "type": "string"
                    },
                    "path": {
                        "type": "string"
                    },
                    "version": {
                        "type": "integer"
                    },
                    "withLeaseStartTime": {
                        "type": "boolean"
                    }
                },
                "type": "object",
                "required": [
                    "data",
                    "dataJson",
                    "leaseDuration",
                    "leaseId",
                    "leaseRenewable",
                    "leaseStartTime",
                    "path",
                    "id"
                ]
            }
        },
        "vault:identity/getEntity:getEntity": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst entity = pulumi.output(vault.identity.getEntity({\n    entityName: \"entity_12345\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nentity = vault.identity.get_entity(entity_name=\"entity_12345\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var entity = Vault.Identity.GetEntity.Invoke(new()\n    {\n        EntityName = \"entity_12345\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := identity.LookupEntity(ctx, \u0026identity.LookupEntityArgs{\n\t\t\tEntityName: pulumi.StringRef(\"entity_12345\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.IdentityFunctions;\nimport com.pulumi.vault.identity.inputs.GetEntityArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var entity = IdentityFunctions.getEntity(GetEntityArgs.builder()\n            .entityName(\"entity_12345\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  entity:\n    Fn::Invoke:\n      Function: vault:identity:getEntity\n      Arguments:\n        entityName: entity_12345\n```\n{{% /example %}}\n{{% /examples %}}\n## Required Vault Capabilities\n\nUse of this resource requires the `create` capability on `/identity/lookup/entity`.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getEntity.\n",
                "properties": {
                    "aliasId": {
                        "type": "string",
                        "description": "ID of the alias.\n"
                    },
                    "aliasMountAccessor": {
                        "type": "string",
                        "description": "Accessor of the mount to which the alias belongs to.\nThis should be supplied in conjunction with `alias_name`.\n"
                    },
                    "aliasName": {
                        "type": "string",
                        "description": "Name of the alias. This should be supplied in conjunction with\n`alias_mount_accessor`.\n"
                    },
                    "entityId": {
                        "type": "string",
                        "description": "ID of the entity.\n"
                    },
                    "entityName": {
                        "type": "string",
                        "description": "Name of the entity.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace of the target resource.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getEntity.\n",
                "properties": {
                    "aliasId": {
                        "type": "string"
                    },
                    "aliasMountAccessor": {
                        "type": "string"
                    },
                    "aliasName": {
                        "type": "string"
                    },
                    "aliases": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:identity/getEntityAlias:getEntityAlias"
                        },
                        "description": "A list of entity alias. Structure is documented below.\n"
                    },
                    "creationTime": {
                        "type": "string",
                        "description": "Creation time of the Alias\n"
                    },
                    "dataJson": {
                        "type": "string",
                        "description": "A string containing the full data payload retrieved from\nVault, serialized in JSON format.\n"
                    },
                    "directGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Group IDs of which the entity is directly a member of\n"
                    },
                    "disabled": {
                        "type": "boolean",
                        "description": "Whether the entity is disabled\n"
                    },
                    "entityId": {
                        "type": "string"
                    },
                    "entityName": {
                        "type": "string"
                    },
                    "groupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of all Group IDs of which the entity is a member of\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "inheritedGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of all Group IDs of which the entity is a member of transitively\n"
                    },
                    "lastUpdateTime": {
                        "type": "string",
                        "description": "Last update time of the alias\n"
                    },
                    "mergedEntityIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Other entity IDs which is merged with this entity\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Arbitrary metadata\n"
                    },
                    "namespace": {
                        "type": "string"
                    },
                    "namespaceId": {
                        "type": "string",
                        "description": "Namespace of which the entity is part of\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies attached to the entity\n"
                    }
                },
                "type": "object",
                "required": [
                    "aliasId",
                    "aliasMountAccessor",
                    "aliasName",
                    "aliases",
                    "creationTime",
                    "dataJson",
                    "directGroupIds",
                    "disabled",
                    "entityId",
                    "entityName",
                    "groupIds",
                    "inheritedGroupIds",
                    "lastUpdateTime",
                    "mergedEntityIds",
                    "metadata",
                    "namespaceId",
                    "policies",
                    "id"
                ]
            }
        },
        "vault:identity/getGroup:getGroup": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst group = pulumi.output(vault.identity.getGroup({\n    groupName: \"user\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ngroup = vault.identity.get_group(group_name=\"user\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @group = Vault.Identity.GetGroup.Invoke(new()\n    {\n        GroupName = \"user\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := identity.LookupGroup(ctx, \u0026identity.LookupGroupArgs{\n\t\t\tGroupName: pulumi.StringRef(\"user\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.IdentityFunctions;\nimport com.pulumi.vault.identity.inputs.GetGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var group = IdentityFunctions.getGroup(GetGroupArgs.builder()\n            .groupName(\"user\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  group:\n    Fn::Invoke:\n      Function: vault:identity:getGroup\n      Arguments:\n        groupName: user\n```\n{{% /example %}}\n{{% /examples %}}\n## Required Vault Capabilities\n\nUse of this resource requires the `create` capability on `/identity/lookup/group`.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGroup.\n",
                "properties": {
                    "aliasId": {
                        "type": "string",
                        "description": "ID of the alias.\n"
                    },
                    "aliasMountAccessor": {
                        "type": "string",
                        "description": "Accessor of the mount to which the alias belongs to.\nThis should be supplied in conjunction with `alias_name`.\n"
                    },
                    "aliasName": {
                        "type": "string",
                        "description": "Name of the alias. This should be supplied in conjunction with\n`alias_mount_accessor`.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "ID of the group.\n"
                    },
                    "groupName": {
                        "type": "string",
                        "description": "Name of the group.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace of the target resource.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getGroup.\n",
                "properties": {
                    "aliasCanonicalId": {
                        "type": "string",
                        "description": "Canonical ID of the Alias\n"
                    },
                    "aliasCreationTime": {
                        "type": "string",
                        "description": "Creation time of the Alias\n"
                    },
                    "aliasId": {
                        "type": "string"
                    },
                    "aliasLastUpdateTime": {
                        "type": "string",
                        "description": "Last update time of the alias\n"
                    },
                    "aliasMergedFromCanonicalIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of canonical IDs merged with this alias\n"
                    },
                    "aliasMetadata": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Arbitrary metadata\n"
                    },
                    "aliasMountAccessor": {
                        "type": "string"
                    },
                    "aliasMountPath": {
                        "type": "string",
                        "description": "Authentication mount path which this alias belongs to\n"
                    },
                    "aliasMountType": {
                        "type": "string",
                        "description": "Authentication mount type which this alias belongs to\n"
                    },
                    "aliasName": {
                        "type": "string"
                    },
                    "creationTime": {
                        "type": "string",
                        "description": "Creation timestamp of the group\n"
                    },
                    "dataJson": {
                        "type": "string",
                        "description": "A string containing the full data payload retrieved from\nVault, serialized in JSON format.\n"
                    },
                    "groupId": {
                        "type": "string"
                    },
                    "groupName": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "lastUpdateTime": {
                        "type": "string",
                        "description": "Last updated time of the group\n"
                    },
                    "memberEntityIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Entity IDs which are members of this group\n"
                    },
                    "memberGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Group IDs which are members of this group\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Arbitrary metadata\n"
                    },
                    "modifyIndex": {
                        "type": "integer",
                        "description": "Modify index of the group\n"
                    },
                    "namespace": {
                        "type": "string"
                    },
                    "namespaceId": {
                        "type": "string",
                        "description": "Namespace of which the group is part of\n"
                    },
                    "parentGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Group IDs which are parents of this group.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies attached to the group\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of group\n"
                    }
                },
                "type": "object",
                "required": [
                    "aliasCanonicalId",
                    "aliasCreationTime",
                    "aliasId",
                    "aliasLastUpdateTime",
                    "aliasMergedFromCanonicalIds",
                    "aliasMetadata",
                    "aliasMountAccessor",
                    "aliasMountPath",
                    "aliasMountType",
                    "aliasName",
                    "creationTime",
                    "dataJson",
                    "groupId",
                    "groupName",
                    "lastUpdateTime",
                    "memberEntityIds",
                    "memberGroupIds",
                    "metadata",
                    "modifyIndex",
                    "namespaceId",
                    "parentGroupIds",
                    "policies",
                    "type",
                    "id"
                ]
            }
        },
        "vault:identity/getOidcClientCreds:getOidcClientCreds": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst app = new vault.identity.OidcClient(\"app\", {\n    redirectUris: [\n        \"http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\",\n        \"http://127.0.0.1:8251/callback\",\n        \"http://127.0.0.1:8080/callback\",\n    ],\n    idTokenTtl: 2400,\n    accessTokenTtl: 7200,\n});\nconst creds = vault.identity.getOidcClientCredsOutput({\n    name: app.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\napp = vault.identity.OidcClient(\"app\",\n    redirect_uris=[\n        \"http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\",\n        \"http://127.0.0.1:8251/callback\",\n        \"http://127.0.0.1:8080/callback\",\n    ],\n    id_token_ttl=2400,\n    access_token_ttl=7200)\ncreds = vault.identity.get_oidc_client_creds_output(name=app.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var app = new Vault.Identity.OidcClient(\"app\", new()\n    {\n        RedirectUris = new[]\n        {\n            \"http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\",\n            \"http://127.0.0.1:8251/callback\",\n            \"http://127.0.0.1:8080/callback\",\n        },\n        IdTokenTtl = 2400,\n        AccessTokenTtl = 7200,\n    });\n\n    var creds = Vault.Identity.GetOidcClientCreds.Invoke(new()\n    {\n        Name = app.Name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tapp, err := identity.NewOidcClient(ctx, \"app\", \u0026identity.OidcClientArgs{\n\t\t\tRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\"),\n\t\t\t\tpulumi.String(\"http://127.0.0.1:8251/callback\"),\n\t\t\t\tpulumi.String(\"http://127.0.0.1:8080/callback\"),\n\t\t\t},\n\t\t\tIdTokenTtl:     pulumi.Int(2400),\n\t\t\tAccessTokenTtl: pulumi.Int(7200),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = identity.GetOidcClientCredsOutput(ctx, identity.GetOidcClientCredsOutputArgs{\n\t\t\tName: app.Name,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.OidcClient;\nimport com.pulumi.vault.identity.OidcClientArgs;\nimport com.pulumi.vault.identity.IdentityFunctions;\nimport com.pulumi.vault.identity.inputs.GetOidcClientCredsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var app = new OidcClient(\"app\", OidcClientArgs.builder()        \n            .redirectUris(            \n                \"http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\",\n                \"http://127.0.0.1:8251/callback\",\n                \"http://127.0.0.1:8080/callback\")\n            .idTokenTtl(2400)\n            .accessTokenTtl(7200)\n            .build());\n\n        final var creds = IdentityFunctions.getOidcClientCreds(GetOidcClientCredsArgs.builder()\n            .name(app.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  app:\n    type: vault:identity:OidcClient\n    properties:\n      redirectUris:\n        - http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\n        - http://127.0.0.1:8251/callback\n        - http://127.0.0.1:8080/callback\n      idTokenTtl: 2400\n      accessTokenTtl: 7200\nvariables:\n  creds:\n    Fn::Invoke:\n      Function: vault:identity:getOidcClientCreds\n      Arguments:\n        name: ${app.name}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getOidcClientCreds.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the OIDC Client in Vault.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace of the target resource.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getOidcClientCreds.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The Client ID returned by Vault.\n"
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "The Client Secret Key returned by Vault.\n",
                        "secret": true
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "namespace": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "clientId",
                    "clientSecret",
                    "name",
                    "id"
                ]
            }
        },
        "vault:identity/getOidcOpenidConfig:getOidcOpenidConfig": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst key = new vault.identity.OidcKey(\"key\", {\n    allowedClientIds: [\"*\"],\n    rotationPeriod: 3600,\n    verificationTtl: 3600,\n});\nconst app = new vault.identity.OidcClient(\"app\", {\n    key: key.name,\n    redirectUris: [\n        \"http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\",\n        \"http://127.0.0.1:8251/callback\",\n        \"http://127.0.0.1:8080/callback\",\n    ],\n    idTokenTtl: 2400,\n    accessTokenTtl: 7200,\n});\nconst provider = new vault.identity.OidcProvider(\"provider\", {allowedClientIds: [vault_identity_oidc_client.test.client_id]});\nconst config = vault.identity.getOidcOpenidConfigOutput({\n    name: provider.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nkey = vault.identity.OidcKey(\"key\",\n    allowed_client_ids=[\"*\"],\n    rotation_period=3600,\n    verification_ttl=3600)\napp = vault.identity.OidcClient(\"app\",\n    key=key.name,\n    redirect_uris=[\n        \"http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\",\n        \"http://127.0.0.1:8251/callback\",\n        \"http://127.0.0.1:8080/callback\",\n    ],\n    id_token_ttl=2400,\n    access_token_ttl=7200)\nprovider = vault.identity.OidcProvider(\"provider\", allowed_client_ids=[vault_identity_oidc_client[\"test\"][\"client_id\"]])\nconfig = vault.identity.get_oidc_openid_config_output(name=provider.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var key = new Vault.Identity.OidcKey(\"key\", new()\n    {\n        AllowedClientIds = new[]\n        {\n            \"*\",\n        },\n        RotationPeriod = 3600,\n        VerificationTtl = 3600,\n    });\n\n    var app = new Vault.Identity.OidcClient(\"app\", new()\n    {\n        Key = key.Name,\n        RedirectUris = new[]\n        {\n            \"http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\",\n            \"http://127.0.0.1:8251/callback\",\n            \"http://127.0.0.1:8080/callback\",\n        },\n        IdTokenTtl = 2400,\n        AccessTokenTtl = 7200,\n    });\n\n    var provider = new Vault.Identity.OidcProvider(\"provider\", new()\n    {\n        AllowedClientIds = new[]\n        {\n            vault_identity_oidc_client.Test.Client_id,\n        },\n    });\n\n    var config = Vault.Identity.GetOidcOpenidConfig.Invoke(new()\n    {\n        Name = provider.Name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tkey, err := identity.NewOidcKey(ctx, \"key\", \u0026identity.OidcKeyArgs{\n\t\t\tAllowedClientIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"*\"),\n\t\t\t},\n\t\t\tRotationPeriod:  pulumi.Int(3600),\n\t\t\tVerificationTtl: pulumi.Int(3600),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewOidcClient(ctx, \"app\", \u0026identity.OidcClientArgs{\n\t\t\tKey: key.Name,\n\t\t\tRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\"),\n\t\t\t\tpulumi.String(\"http://127.0.0.1:8251/callback\"),\n\t\t\t\tpulumi.String(\"http://127.0.0.1:8080/callback\"),\n\t\t\t},\n\t\t\tIdTokenTtl:     pulumi.Int(2400),\n\t\t\tAccessTokenTtl: pulumi.Int(7200),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprovider, err := identity.NewOidcProvider(ctx, \"provider\", \u0026identity.OidcProviderArgs{\n\t\t\tAllowedClientIds: pulumi.StringArray{\n\t\t\t\tpulumi.Any(vault_identity_oidc_client.Test.Client_id),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = identity.GetOidcOpenidConfigOutput(ctx, identity.GetOidcOpenidConfigOutputArgs{\n\t\t\tName: provider.Name,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.OidcKey;\nimport com.pulumi.vault.identity.OidcKeyArgs;\nimport com.pulumi.vault.identity.OidcClient;\nimport com.pulumi.vault.identity.OidcClientArgs;\nimport com.pulumi.vault.identity.OidcProvider;\nimport com.pulumi.vault.identity.OidcProviderArgs;\nimport com.pulumi.vault.identity.IdentityFunctions;\nimport com.pulumi.vault.identity.inputs.GetOidcOpenidConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var key = new OidcKey(\"key\", OidcKeyArgs.builder()        \n            .allowedClientIds(\"*\")\n            .rotationPeriod(3600)\n            .verificationTtl(3600)\n            .build());\n\n        var app = new OidcClient(\"app\", OidcClientArgs.builder()        \n            .key(key.name())\n            .redirectUris(            \n                \"http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\",\n                \"http://127.0.0.1:8251/callback\",\n                \"http://127.0.0.1:8080/callback\")\n            .idTokenTtl(2400)\n            .accessTokenTtl(7200)\n            .build());\n\n        var provider = new OidcProvider(\"provider\", OidcProviderArgs.builder()        \n            .allowedClientIds(vault_identity_oidc_client.test().client_id())\n            .build());\n\n        final var config = IdentityFunctions.getOidcOpenidConfig(GetOidcOpenidConfigArgs.builder()\n            .name(provider.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  key:\n    type: vault:identity:OidcKey\n    properties:\n      allowedClientIds:\n        - '*'\n      rotationPeriod: 3600\n      verificationTtl: 3600\n  app:\n    type: vault:identity:OidcClient\n    properties:\n      key: ${key.name}\n      redirectUris:\n        - http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\n        - http://127.0.0.1:8251/callback\n        - http://127.0.0.1:8080/callback\n      idTokenTtl: 2400\n      accessTokenTtl: 7200\n  provider:\n    type: vault:identity:OidcProvider\n    properties:\n      allowedClientIds:\n        - ${vault_identity_oidc_client.test.client_id}\nvariables:\n  config:\n    Fn::Invoke:\n      Function: vault:identity:getOidcOpenidConfig\n      Arguments:\n        name: ${provider.name}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getOidcOpenidConfig.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the OIDC Provider in Vault.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace of the target resource.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getOidcOpenidConfig.\n",
                "properties": {
                    "authorizationEndpoint": {
                        "type": "string",
                        "description": "The Authorization Endpoint for the provider.\n"
                    },
                    "grantTypesSupporteds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The grant types supported by the provider.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "idTokenSigningAlgValuesSupporteds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The signing algorithms supported by \nthe provider.\n"
                    },
                    "issuer": {
                        "type": "string",
                        "description": "The URL of the issuer for the provider.\n"
                    },
                    "jwksUri": {
                        "type": "string",
                        "description": "The well known keys URI for the provider.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "namespace": {
                        "type": "string"
                    },
                    "requestUriParameterSupported": {
                        "type": "boolean",
                        "description": "Specifies whether Request URI Parameter is \nsupported by the provider.\n"
                    },
                    "responseTypesSupporteds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The response types supported by the provider.\n"
                    },
                    "scopesSupporteds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The scopes supported by the provider.\n"
                    },
                    "subjectTypesSupporteds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The subject types supported by the provider.\n"
                    },
                    "tokenEndpoint": {
                        "type": "string",
                        "description": "The Token Endpoint for the provider.\n"
                    },
                    "tokenEndpointAuthMethodsSupporteds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The token endpoint auth methods supported by the provider.\n"
                    },
                    "userinfoEndpoint": {
                        "type": "string",
                        "description": "The User Info Endpoint for the provider\n"
                    }
                },
                "type": "object",
                "required": [
                    "authorizationEndpoint",
                    "grantTypesSupporteds",
                    "idTokenSigningAlgValuesSupporteds",
                    "issuer",
                    "jwksUri",
                    "name",
                    "requestUriParameterSupported",
                    "responseTypesSupporteds",
                    "scopesSupporteds",
                    "subjectTypesSupporteds",
                    "tokenEndpoint",
                    "tokenEndpointAuthMethodsSupporteds",
                    "userinfoEndpoint",
                    "id"
                ]
            }
        },
        "vault:identity/getOidcPublicKeys:getOidcPublicKeys": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst key = new vault.identity.OidcKey(\"key\", {\n    allowedClientIds: [\"*\"],\n    rotationPeriod: 3600,\n    verificationTtl: 3600,\n});\nconst app = new vault.identity.OidcClient(\"app\", {\n    key: key.name,\n    redirectUris: [\n        \"http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\",\n        \"http://127.0.0.1:8251/callback\",\n        \"http://127.0.0.1:8080/callback\",\n    ],\n    idTokenTtl: 2400,\n    accessTokenTtl: 7200,\n});\nconst provider = new vault.identity.OidcProvider(\"provider\", {allowedClientIds: [vault_identity_oidc_client.test.client_id]});\nconst publicKeys = vault.identity.getOidcPublicKeysOutput({\n    name: provider.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nkey = vault.identity.OidcKey(\"key\",\n    allowed_client_ids=[\"*\"],\n    rotation_period=3600,\n    verification_ttl=3600)\napp = vault.identity.OidcClient(\"app\",\n    key=key.name,\n    redirect_uris=[\n        \"http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\",\n        \"http://127.0.0.1:8251/callback\",\n        \"http://127.0.0.1:8080/callback\",\n    ],\n    id_token_ttl=2400,\n    access_token_ttl=7200)\nprovider = vault.identity.OidcProvider(\"provider\", allowed_client_ids=[vault_identity_oidc_client[\"test\"][\"client_id\"]])\npublic_keys = vault.identity.get_oidc_public_keys_output(name=provider.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var key = new Vault.Identity.OidcKey(\"key\", new()\n    {\n        AllowedClientIds = new[]\n        {\n            \"*\",\n        },\n        RotationPeriod = 3600,\n        VerificationTtl = 3600,\n    });\n\n    var app = new Vault.Identity.OidcClient(\"app\", new()\n    {\n        Key = key.Name,\n        RedirectUris = new[]\n        {\n            \"http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\",\n            \"http://127.0.0.1:8251/callback\",\n            \"http://127.0.0.1:8080/callback\",\n        },\n        IdTokenTtl = 2400,\n        AccessTokenTtl = 7200,\n    });\n\n    var provider = new Vault.Identity.OidcProvider(\"provider\", new()\n    {\n        AllowedClientIds = new[]\n        {\n            vault_identity_oidc_client.Test.Client_id,\n        },\n    });\n\n    var publicKeys = Vault.Identity.GetOidcPublicKeys.Invoke(new()\n    {\n        Name = provider.Name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tkey, err := identity.NewOidcKey(ctx, \"key\", \u0026identity.OidcKeyArgs{\n\t\t\tAllowedClientIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"*\"),\n\t\t\t},\n\t\t\tRotationPeriod:  pulumi.Int(3600),\n\t\t\tVerificationTtl: pulumi.Int(3600),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewOidcClient(ctx, \"app\", \u0026identity.OidcClientArgs{\n\t\t\tKey: key.Name,\n\t\t\tRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\"),\n\t\t\t\tpulumi.String(\"http://127.0.0.1:8251/callback\"),\n\t\t\t\tpulumi.String(\"http://127.0.0.1:8080/callback\"),\n\t\t\t},\n\t\t\tIdTokenTtl:     pulumi.Int(2400),\n\t\t\tAccessTokenTtl: pulumi.Int(7200),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprovider, err := identity.NewOidcProvider(ctx, \"provider\", \u0026identity.OidcProviderArgs{\n\t\t\tAllowedClientIds: pulumi.StringArray{\n\t\t\t\tpulumi.Any(vault_identity_oidc_client.Test.Client_id),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = identity.GetOidcPublicKeysOutput(ctx, identity.GetOidcPublicKeysOutputArgs{\n\t\t\tName: provider.Name,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.identity.OidcKey;\nimport com.pulumi.vault.identity.OidcKeyArgs;\nimport com.pulumi.vault.identity.OidcClient;\nimport com.pulumi.vault.identity.OidcClientArgs;\nimport com.pulumi.vault.identity.OidcProvider;\nimport com.pulumi.vault.identity.OidcProviderArgs;\nimport com.pulumi.vault.identity.IdentityFunctions;\nimport com.pulumi.vault.identity.inputs.GetOidcPublicKeysArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var key = new OidcKey(\"key\", OidcKeyArgs.builder()        \n            .allowedClientIds(\"*\")\n            .rotationPeriod(3600)\n            .verificationTtl(3600)\n            .build());\n\n        var app = new OidcClient(\"app\", OidcClientArgs.builder()        \n            .key(key.name())\n            .redirectUris(            \n                \"http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\",\n                \"http://127.0.0.1:8251/callback\",\n                \"http://127.0.0.1:8080/callback\")\n            .idTokenTtl(2400)\n            .accessTokenTtl(7200)\n            .build());\n\n        var provider = new OidcProvider(\"provider\", OidcProviderArgs.builder()        \n            .allowedClientIds(vault_identity_oidc_client.test().client_id())\n            .build());\n\n        final var publicKeys = IdentityFunctions.getOidcPublicKeys(GetOidcPublicKeysArgs.builder()\n            .name(provider.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  key:\n    type: vault:identity:OidcKey\n    properties:\n      allowedClientIds:\n        - '*'\n      rotationPeriod: 3600\n      verificationTtl: 3600\n  app:\n    type: vault:identity:OidcClient\n    properties:\n      key: ${key.name}\n      redirectUris:\n        - http://127.0.0.1:9200/v1/auth-methods/oidc:authenticate:callback\n        - http://127.0.0.1:8251/callback\n        - http://127.0.0.1:8080/callback\n      idTokenTtl: 2400\n      accessTokenTtl: 7200\n  provider:\n    type: vault:identity:OidcProvider\n    properties:\n      allowedClientIds:\n        - ${vault_identity_oidc_client.test.client_id}\nvariables:\n  publicKeys:\n    Fn::Invoke:\n      Function: vault:identity:getOidcPublicKeys\n      Arguments:\n        name: ${provider.name}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getOidcPublicKeys.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the OIDC Provider in Vault.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace of the target resource.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getOidcPublicKeys.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "keys": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        },
                        "description": "The public portion of keys for an OIDC provider. \nClients can use them to validate the authenticity of an identity token.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "namespace": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "keys",
                    "name",
                    "id"
                ]
            }
        },
        "vault:index/getAuthBackend:getAuthBackend": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = pulumi.output(vault.getAuthBackend({\n    path: \"userpass\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.get_auth_backend(path=\"userpass\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Vault.GetAuthBackend.Invoke(new()\n    {\n        Path = \"userpass\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.LookupAuthBackend(ctx, \u0026GetAuthBackendArgs{\n\t\t\tPath: \"userpass\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.VaultFunctions;\nimport com.pulumi.vault.inputs.GetAuthBackendArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = VaultFunctions.getAuthBackend(GetAuthBackendArgs.builder()\n            .path(\"userpass\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    Fn::Invoke:\n      Function: vault:getAuthBackend\n      Arguments:\n        path: userpass\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getAuthBackend.\n",
                "properties": {
                    "namespace": {
                        "type": "string",
                        "description": "The namespace of the target resource.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "The auth backend mount point.\n"
                    }
                },
                "type": "object",
                "required": [
                    "path"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAuthBackend.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The accessor for this auth method.\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The default lease duration in seconds.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description of the auth method.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "listingVisibility": {
                        "type": "string",
                        "description": "Specifies whether to show this mount in the UI-specific listing endpoint.\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Specifies if the auth method is local only.\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The maximum lease duration in seconds.\n"
                    },
                    "namespace": {
                        "type": "string"
                    },
                    "path": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string",
                        "description": "The name of the auth method type.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accessor",
                    "defaultLeaseTtlSeconds",
                    "description",
                    "listingVisibility",
                    "local",
                    "maxLeaseTtlSeconds",
                    "path",
                    "type",
                    "id"
                ]
            }
        },
        "vault:index/getNomadAccessToken:getNomadAccessToken": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst config = new vault.NomadSecretBackend(\"config\", {\n    backend: \"nomad\",\n    description: \"test description\",\n    defaultLeaseTtlSeconds: 3600,\n    maxLeaseTtlSeconds: 7200,\n    address: \"https://127.0.0.1:4646\",\n    token: \"ae20ceaa-...\",\n});\nconst test = new vault.NomadSecretRole(\"test\", {\n    backend: config.backend,\n    role: \"test\",\n    type: \"client\",\n    policies: [\"readonly\"],\n});\nconst token = pulumi.all([config.backend, test.role]).apply(([backend, role]) =\u003e vault.getNomadAccessTokenOutput({\n    backend: backend,\n    role: role,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nconfig = vault.NomadSecretBackend(\"config\",\n    backend=\"nomad\",\n    description=\"test description\",\n    default_lease_ttl_seconds=3600,\n    max_lease_ttl_seconds=7200,\n    address=\"https://127.0.0.1:4646\",\n    token=\"ae20ceaa-...\")\ntest = vault.NomadSecretRole(\"test\",\n    backend=config.backend,\n    role=\"test\",\n    type=\"client\",\n    policies=[\"readonly\"])\ntoken = pulumi.Output.all(config.backend, test.role).apply(lambda backend, role: vault.get_nomad_access_token_output(backend=backend,\n    role=role))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Vault.NomadSecretBackend(\"config\", new()\n    {\n        Backend = \"nomad\",\n        Description = \"test description\",\n        DefaultLeaseTtlSeconds = 3600,\n        MaxLeaseTtlSeconds = 7200,\n        Address = \"https://127.0.0.1:4646\",\n        Token = \"ae20ceaa-...\",\n    });\n\n    var test = new Vault.NomadSecretRole(\"test\", new()\n    {\n        Backend = config.Backend,\n        Role = \"test\",\n        Type = \"client\",\n        Policies = new[]\n        {\n            \"readonly\",\n        },\n    });\n\n    var token = Vault.GetNomadAccessToken.Invoke(new()\n    {\n        Backend = config.Backend,\n        Role = test.Role,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfig, err := vault.NewNomadSecretBackend(ctx, \"config\", \u0026vault.NomadSecretBackendArgs{\n\t\t\tBackend:                pulumi.String(\"nomad\"),\n\t\t\tDescription:            pulumi.String(\"test description\"),\n\t\t\tDefaultLeaseTtlSeconds: pulumi.Int(3600),\n\t\t\tMaxLeaseTtlSeconds:     pulumi.Int(7200),\n\t\t\tAddress:                pulumi.String(\"https://127.0.0.1:4646\"),\n\t\t\tToken:                  pulumi.String(\"ae20ceaa-...\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttest, err := vault.NewNomadSecretRole(ctx, \"test\", \u0026vault.NomadSecretRoleArgs{\n\t\t\tBackend: config.Backend,\n\t\t\tRole:    pulumi.String(\"test\"),\n\t\t\tType:    pulumi.String(\"client\"),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"readonly\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.NomadSecretBackend;\nimport com.pulumi.vault.NomadSecretBackendArgs;\nimport com.pulumi.vault.NomadSecretRole;\nimport com.pulumi.vault.NomadSecretRoleArgs;\nimport com.pulumi.vault.VaultFunctions;\nimport com.pulumi.vault.inputs.GetNomadAccessTokenArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var config = new NomadSecretBackend(\"config\", NomadSecretBackendArgs.builder()        \n            .backend(\"nomad\")\n            .description(\"test description\")\n            .defaultLeaseTtlSeconds(\"3600\")\n            .maxLeaseTtlSeconds(\"7200\")\n            .address(\"https://127.0.0.1:4646\")\n            .token(\"ae20ceaa-...\")\n            .build());\n\n        var test = new NomadSecretRole(\"test\", NomadSecretRoleArgs.builder()        \n            .backend(config.backend())\n            .role(\"test\")\n            .type(\"client\")\n            .policies(\"readonly\")\n            .build());\n\n        final var token = VaultFunctions.getNomadAccessToken(GetNomadAccessTokenArgs.builder()\n            .backend(config.backend())\n            .role(test.role())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  config:\n    type: vault:NomadSecretBackend\n    properties:\n      backend: nomad\n      description: test description\n      defaultLeaseTtlSeconds: 3600\n      maxLeaseTtlSeconds: 7200\n      address: https://127.0.0.1:4646\n      token: ae20ceaa-...\n  test:\n    type: vault:NomadSecretRole\n    properties:\n      backend: ${config.backend}\n      role: test\n      type: client\n      policies:\n        - readonly\nvariables:\n  token:\n    Fn::Invoke:\n      Function: vault:getNomadAccessToken\n      Arguments:\n        backend: ${config.backend}\n        role: ${test.role}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getNomadAccessToken.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path to the Nomad secret backend to\nread credentials from, with no leading or trailing `/`s.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace of the target resource.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the Nomad secret backend role to generate\na token for, with no leading or trailing `/`s.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "role"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNomadAccessToken.\n",
                "properties": {
                    "accessorId": {
                        "type": "string",
                        "description": "The public identifier for a specific token. It can be used \nto look up information about a token or to revoke a token.\n"
                    },
                    "backend": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "namespace": {
                        "type": "string"
                    },
                    "role": {
                        "type": "string"
                    },
                    "secretId": {
                        "type": "string",
                        "description": "The token to be used when making requests to Nomad and should be kept private.\n",
                        "secret": true
                    }
                },
                "type": "object",
                "required": [
                    "accessorId",
                    "backend",
                    "role",
                    "secretId",
                    "id"
                ]
            }
        },
        "vault:index/getPolicyDocument:getPolicyDocument": {
            "description": "This is a data source which can be used to construct a HCL representation of an Vault policy document, for use with resources which expect policy documents, such as the `vault.Policy` resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst examplePolicyDocument = vault.getPolicyDocument({\n    rules: [{\n        path: \"secret/*\",\n        capabilities: [\n            \"create\",\n            \"read\",\n            \"update\",\n            \"delete\",\n            \"list\",\n        ],\n        description: \"allow all on secrets\",\n    }],\n});\nconst examplePolicy = new vault.Policy(\"examplePolicy\", {policy: examplePolicyDocument.then(examplePolicyDocument =\u003e examplePolicyDocument.hcl)});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample_policy_document = vault.get_policy_document(rules=[vault.GetPolicyDocumentRuleArgs(\n    path=\"secret/*\",\n    capabilities=[\n        \"create\",\n        \"read\",\n        \"update\",\n        \"delete\",\n        \"list\",\n    ],\n    description=\"allow all on secrets\",\n)])\nexample_policy = vault.Policy(\"examplePolicy\", policy=example_policy_document.hcl)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var examplePolicyDocument = Vault.GetPolicyDocument.Invoke(new()\n    {\n        Rules = new[]\n        {\n            new Vault.Inputs.GetPolicyDocumentRuleInputArgs\n            {\n                Path = \"secret/*\",\n                Capabilities = new[]\n                {\n                    \"create\",\n                    \"read\",\n                    \"update\",\n                    \"delete\",\n                    \"list\",\n                },\n                Description = \"allow all on secrets\",\n            },\n        },\n    });\n\n    var examplePolicy = new Vault.Policy(\"examplePolicy\", new()\n    {\n        PolicyContents = examplePolicyDocument.Apply(getPolicyDocumentResult =\u003e getPolicyDocumentResult.Hcl),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texamplePolicyDocument, err := vault.GetPolicyDocument(ctx, \u0026GetPolicyDocumentArgs{\n\t\t\tRules: []GetPolicyDocumentRule{\n\t\t\t\tGetPolicyDocumentRule{\n\t\t\t\t\tPath: \"secret/*\",\n\t\t\t\t\tCapabilities: []string{\n\t\t\t\t\t\t\"create\",\n\t\t\t\t\t\t\"read\",\n\t\t\t\t\t\t\"update\",\n\t\t\t\t\t\t\"delete\",\n\t\t\t\t\t\t\"list\",\n\t\t\t\t\t},\n\t\t\t\t\tDescription: pulumi.StringRef(\"allow all on secrets\"),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vault.NewPolicy(ctx, \"examplePolicy\", \u0026vault.PolicyArgs{\n\t\t\tPolicy: pulumi.String(examplePolicyDocument.Hcl),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.VaultFunctions;\nimport com.pulumi.vault.inputs.GetPolicyDocumentArgs;\nimport com.pulumi.vault.Policy;\nimport com.pulumi.vault.PolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var examplePolicyDocument = VaultFunctions.getPolicyDocument(GetPolicyDocumentArgs.builder()\n            .rules(GetPolicyDocumentRuleArgs.builder()\n                .path(\"secret/*\")\n                .capabilities(                \n                    \"create\",\n                    \"read\",\n                    \"update\",\n                    \"delete\",\n                    \"list\")\n                .description(\"allow all on secrets\")\n                .build())\n            .build());\n\n        var examplePolicy = new Policy(\"examplePolicy\", PolicyArgs.builder()        \n            .policy(examplePolicyDocument.applyValue(getPolicyDocumentResult -\u003e getPolicyDocumentResult.hcl()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  examplePolicy:\n    type: vault:Policy\n    properties:\n      policy: ${examplePolicyDocument.hcl}\nvariables:\n  examplePolicyDocument:\n    Fn::Invoke:\n      Function: vault:getPolicyDocument\n      Arguments:\n        rules:\n          - path: secret/*\n            capabilities:\n              - create\n              - read\n              - update\n              - delete\n              - list\n            description: allow all on secrets\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getPolicyDocument.\n",
                "properties": {
                    "namespace": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:index/getPolicyDocumentRule:getPolicyDocumentRule"
                        }
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getPolicyDocument.\n",
                "properties": {
                    "hcl": {
                        "type": "string",
                        "description": "The above arguments serialized as a standard Vault HCL policy document.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "namespace": {
                        "type": "string"
                    },
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:index/getPolicyDocumentRule:getPolicyDocumentRule"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "hcl",
                    "rules",
                    "id"
                ]
            }
        },
        "vault:kubernetes/getAuthBackendConfig:getAuthBackendConfig": {
            "description": "Reads the Role of an Kubernetes from a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/api-docs/auth/kubernetes#read-config) for more\ninformation.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAuthBackendConfig.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The unique name for the Kubernetes backend the config to\nretrieve Role attributes for resides in. Defaults to \"kubernetes\".\n",
                        "willReplaceOnChanges": true
                    },
                    "disableIssValidation": {
                        "type": "boolean"
                    },
                    "disableLocalCaJwt": {
                        "type": "boolean"
                    },
                    "issuer": {
                        "type": "string",
                        "description": "Optional JWT issuer. If no issuer is specified, `kubernetes.io/serviceaccount` will be used as the default issuer.\n"
                    },
                    "kubernetesCaCert": {
                        "type": "string",
                        "description": "PEM encoded CA cert for use by the TLS client used to talk with the Kubernetes API.\n"
                    },
                    "kubernetesHost": {
                        "type": "string",
                        "description": "Host must be a host string, a host:port pair, or a URL to the base of the Kubernetes API server.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace of the target resource.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "pemKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Optional list of PEM-formatted public keys or certificates used to verify the signatures of Kubernetes service account JWTs. If a certificate is given, its public key will be extracted. Not every installation of Kubernetes exposes these keys.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getAuthBackendConfig.\n",
                "properties": {
                    "backend": {
                        "type": "string"
                    },
                    "disableIssValidation": {
                        "type": "boolean"
                    },
                    "disableLocalCaJwt": {
                        "type": "boolean"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "issuer": {
                        "type": "string",
                        "description": "Optional JWT issuer. If no issuer is specified, `kubernetes.io/serviceaccount` will be used as the default issuer.\n"
                    },
                    "kubernetesCaCert": {
                        "type": "string",
                        "description": "PEM encoded CA cert for use by the TLS client used to talk with the Kubernetes API.\n"
                    },
                    "kubernetesHost": {
                        "type": "string",
                        "description": "Host must be a host string, a host:port pair, or a URL to the base of the Kubernetes API server.\n"
                    },
                    "namespace": {
                        "type": "string"
                    },
                    "pemKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Optional list of PEM-formatted public keys or certificates used to verify the signatures of Kubernetes service account JWTs. If a certificate is given, its public key will be extracted. Not every installation of Kubernetes exposes these keys.\n"
                    }
                },
                "type": "object",
                "required": [
                    "disableIssValidation",
                    "disableLocalCaJwt",
                    "issuer",
                    "kubernetesCaCert",
                    "kubernetesHost",
                    "pemKeys",
                    "id"
                ]
            }
        },
        "vault:kubernetes/getAuthBackendRole:getAuthBackendRole": {
            "description": "Reads the Role of an Kubernetes from a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/api-docs/auth/kubernetes#read-role) for more\ninformation.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAuthBackendRole.\n",
                "properties": {
                    "audience": {
                        "type": "string",
                        "description": "Audience claim to verify in the JWT.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The unique name for the Kubernetes backend the role to\nretrieve Role attributes for resides in. Defaults to \"kubernetes\".\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace of the target resource.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured namespace.\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role to retrieve the Role attributes for.\n",
                        "willReplaceOnChanges": true
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "(Optional) If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    }
                },
                "type": "object",
                "required": [
                    "roleName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAuthBackendRole.\n",
                "properties": {
                    "aliasNameSource": {
                        "type": "string",
                        "description": "Method used for generating identity aliases. (vault-1.9+)\n"
                    },
                    "audience": {
                        "type": "string",
                        "description": "Audience claim to verify in the JWT.\n"
                    },
                    "backend": {
                        "type": "string"
                    },
                    "boundServiceAccountNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of service account names able to access this role. If set to \"*\" all names are allowed, both this and bound_service_account_namespaces can not be \"*\".\n"
                    },
                    "boundServiceAccountNamespaces": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of namespaces allowed to access this role. If set to \"*\" all namespaces are allowed, both this and bound_service_account_names can not be set to \"*\".\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "namespace": {
                        "type": "string"
                    },
                    "roleName": {
                        "type": "string"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "(Optional) If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    }
                },
                "type": "object",
                "required": [
                    "aliasNameSource",
                    "boundServiceAccountNames",
                    "boundServiceAccountNamespaces",
                    "roleName",
                    "id"
                ]
            }
        },
        "vault:kubernetes/getServiceAccountToken:getServiceAccountToken": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as fs from \"fs\";\nimport * as vault from \"@pulumi/vault\";\n\nconst config = new vault.kubernetes.SecretBackend(\"config\", {\n    path: \"kubernetes\",\n    description: \"kubernetes secrets engine description\",\n    kubernetesHost: \"https://127.0.0.1:61233\",\n    kubernetesCaCert: fs.readFileSync(\"/path/to/cert\"),\n    serviceAccountJwt: fs.readFileSync(\"/path/to/token\"),\n    disableLocalCaJwt: false,\n});\nconst role = new vault.kubernetes.SecretBackendRole(\"role\", {\n    backend: config.path,\n    allowedKubernetesNamespaces: [\"*\"],\n    tokenMaxTtl: 43200,\n    tokenDefaultTtl: 21600,\n    serviceAccountName: \"test-service-account-with-generated-token\",\n    extraLabels: {\n        id: \"abc123\",\n        name: \"some_name\",\n    },\n    extraAnnotations: {\n        env: \"development\",\n        location: \"earth\",\n    },\n});\nconst token = vault.kubernetes.getServiceAccountTokenOutput({\n    backend: config.path,\n    role: role.name,\n    kubernetesNamespace: \"test\",\n    clusterRoleBinding: false,\n    ttl: \"1h\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nconfig = vault.kubernetes.SecretBackend(\"config\",\n    path=\"kubernetes\",\n    description=\"kubernetes secrets engine description\",\n    kubernetes_host=\"https://127.0.0.1:61233\",\n    kubernetes_ca_cert=(lambda path: open(path).read())(\"/path/to/cert\"),\n    service_account_jwt=(lambda path: open(path).read())(\"/path/to/token\"),\n    disable_local_ca_jwt=False)\nrole = vault.kubernetes.SecretBackendRole(\"role\",\n    backend=config.path,\n    allowed_kubernetes_namespaces=[\"*\"],\n    token_max_ttl=43200,\n    token_default_ttl=21600,\n    service_account_name=\"test-service-account-with-generated-token\",\n    extra_labels={\n        \"id\": \"abc123\",\n        \"name\": \"some_name\",\n    },\n    extra_annotations={\n        \"env\": \"development\",\n        \"location\": \"earth\",\n    })\ntoken = vault.kubernetes.get_service_account_token_output(backend=config.path,\n    role=role.name,\n    kubernetes_namespace=\"test\",\n    cluster_role_binding=False,\n    ttl=\"1h\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Vault.Kubernetes.SecretBackend(\"config\", new()\n    {\n        Path = \"kubernetes\",\n        Description = \"kubernetes secrets engine description\",\n        KubernetesHost = \"https://127.0.0.1:61233\",\n        KubernetesCaCert = File.ReadAllText(\"/path/to/cert\"),\n        ServiceAccountJwt = File.ReadAllText(\"/path/to/token\"),\n        DisableLocalCaJwt = false,\n    });\n\n    var role = new Vault.Kubernetes.SecretBackendRole(\"role\", new()\n    {\n        Backend = config.Path,\n        AllowedKubernetesNamespaces = new[]\n        {\n            \"*\",\n        },\n        TokenMaxTtl = 43200,\n        TokenDefaultTtl = 21600,\n        ServiceAccountName = \"test-service-account-with-generated-token\",\n        ExtraLabels = \n        {\n            { \"id\", \"abc123\" },\n            { \"name\", \"some_name\" },\n        },\n        ExtraAnnotations = \n        {\n            { \"env\", \"development\" },\n            { \"location\", \"earth\" },\n        },\n    });\n\n    var token = Vault.Kubernetes.GetServiceAccountToken.Invoke(new()\n    {\n        Backend = config.Path,\n        Role = role.Name,\n        KubernetesNamespace = \"test\",\n        ClusterRoleBinding = false,\n        Ttl = \"1h\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/kubernetes\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfig, err := kubernetes.NewSecretBackend(ctx, \"config\", \u0026kubernetes.SecretBackendArgs{\n\t\t\tPath:              pulumi.String(\"kubernetes\"),\n\t\t\tDescription:       pulumi.String(\"kubernetes secrets engine description\"),\n\t\t\tKubernetesHost:    pulumi.String(\"https://127.0.0.1:61233\"),\n\t\t\tKubernetesCaCert:  readFileOrPanic(\"/path/to/cert\"),\n\t\t\tServiceAccountJwt: readFileOrPanic(\"/path/to/token\"),\n\t\t\tDisableLocalCaJwt: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trole, err := kubernetes.NewSecretBackendRole(ctx, \"role\", \u0026kubernetes.SecretBackendRoleArgs{\n\t\t\tBackend: config.Path,\n\t\t\tAllowedKubernetesNamespaces: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"*\"),\n\t\t\t},\n\t\t\tTokenMaxTtl:        pulumi.Int(43200),\n\t\t\tTokenDefaultTtl:    pulumi.Int(21600),\n\t\t\tServiceAccountName: pulumi.String(\"test-service-account-with-generated-token\"),\n\t\t\tExtraLabels: pulumi.StringMap{\n\t\t\t\t\"id\":   pulumi.String(\"abc123\"),\n\t\t\t\t\"name\": pulumi.String(\"some_name\"),\n\t\t\t},\n\t\t\tExtraAnnotations: pulumi.StringMap{\n\t\t\t\t\"env\":      pulumi.String(\"development\"),\n\t\t\t\t\"location\": pulumi.String(\"earth\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = kubernetes.GetServiceAccountTokenOutput(ctx, kubernetes.GetServiceAccountTokenOutputArgs{\n\t\t\tBackend:             config.Path,\n\t\t\tRole:                role.Name,\n\t\t\tKubernetesNamespace: pulumi.String(\"test\"),\n\t\t\tClusterRoleBinding:  pulumi.Bool(false),\n\t\t\tTtl:                 pulumi.String(\"1h\"),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.kubernetes.SecretBackend;\nimport com.pulumi.vault.kubernetes.SecretBackendArgs;\nimport com.pulumi.vault.kubernetes.SecretBackendRole;\nimport com.pulumi.vault.kubernetes.SecretBackendRoleArgs;\nimport com.pulumi.vault.kubernetes.KubernetesFunctions;\nimport com.pulumi.vault.kubernetes.inputs.GetServiceAccountTokenArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var config = new SecretBackend(\"config\", SecretBackendArgs.builder()        \n            .path(\"kubernetes\")\n            .description(\"kubernetes secrets engine description\")\n            .kubernetesHost(\"https://127.0.0.1:61233\")\n            .kubernetesCaCert(Files.readString(Paths.get(\"/path/to/cert\")))\n            .serviceAccountJwt(Files.readString(Paths.get(\"/path/to/token\")))\n            .disableLocalCaJwt(false)\n            .build());\n\n        var role = new SecretBackendRole(\"role\", SecretBackendRoleArgs.builder()        \n            .backend(config.path())\n            .allowedKubernetesNamespaces(\"*\")\n            .tokenMaxTtl(43200)\n            .tokenDefaultTtl(21600)\n            .serviceAccountName(\"test-service-account-with-generated-token\")\n            .extraLabels(Map.ofEntries(\n                Map.entry(\"id\", \"abc123\"),\n                Map.entry(\"name\", \"some_name\")\n            ))\n            .extraAnnotations(Map.ofEntries(\n                Map.entry(\"env\", \"development\"),\n                Map.entry(\"location\", \"earth\")\n            ))\n            .build());\n\n        final var token = KubernetesFunctions.getServiceAccountToken(GetServiceAccountTokenArgs.builder()\n            .backend(config.path())\n            .role(role.name())\n            .kubernetesNamespace(\"test\")\n            .clusterRoleBinding(false)\n            .ttl(\"1h\")\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getServiceAccountToken.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The Kubernetes secret backend to generate service account \ntokens from.\n"
                    },
                    "clusterRoleBinding": {
                        "type": "boolean",
                        "description": "If true, generate a ClusterRoleBinding to grant \npermissions across the whole cluster instead of within a namespace.\n"
                    },
                    "kubernetesNamespace": {
                        "type": "string",
                        "description": "The name of the Kubernetes namespace in which to \ngenerate the credentials.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace of the target resource.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the Kubernetes secret backend role to generate service \naccount tokens from.\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "The TTL of the generated Kubernetes service account token, specified in \nseconds or as a Go duration format string.\n"
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "kubernetesNamespace",
                    "role"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getServiceAccountToken.\n",
                "properties": {
                    "backend": {
                        "type": "string"
                    },
                    "clusterRoleBinding": {
                        "type": "boolean"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "kubernetesNamespace": {
                        "type": "string"
                    },
                    "leaseDuration": {
                        "type": "integer",
                        "description": "The duration of the lease in seconds.\n"
                    },
                    "leaseId": {
                        "type": "string",
                        "description": "The lease identifier assigned by Vault.\n"
                    },
                    "leaseRenewable": {
                        "type": "boolean",
                        "description": "True if the duration of this lease can be extended through renewal.\n"
                    },
                    "namespace": {
                        "type": "string"
                    },
                    "role": {
                        "type": "string"
                    },
                    "serviceAccountName": {
                        "type": "string",
                        "description": "The name of the service account associated with the token.\n"
                    },
                    "serviceAccountNamespace": {
                        "type": "string",
                        "description": "The Kubernetes namespace that the service account resides in.\n"
                    },
                    "serviceAccountToken": {
                        "type": "string",
                        "description": "The Kubernetes service account token.\n",
                        "secret": true
                    },
                    "ttl": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "kubernetesNamespace",
                    "leaseDuration",
                    "leaseId",
                    "leaseRenewable",
                    "role",
                    "serviceAccountName",
                    "serviceAccountNamespace",
                    "serviceAccountToken",
                    "id"
                ]
            }
        },
        "vault:kv/getSecret:getSecret": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst kvv1 = new vault.Mount(\"kvv1\", {\n    path: \"kvv1\",\n    type: \"kv\",\n    options: {\n        version: \"1\",\n    },\n    description: \"KV Version 1 secret engine mount\",\n});\nconst secret = new vault.kv.Secret(\"secret\", {\n    path: pulumi.interpolate`${kvv1.path}/secret`,\n    dataJson: JSON.stringify({\n        zip: \"zap\",\n        foo: \"bar\",\n    }),\n});\nconst secretData = vault.kv.getSecretOutput({\n    path: secret.path,\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_vault as vault\n\nkvv1 = vault.Mount(\"kvv1\",\n    path=\"kvv1\",\n    type=\"kv\",\n    options={\n        \"version\": \"1\",\n    },\n    description=\"KV Version 1 secret engine mount\")\nsecret = vault.kv.Secret(\"secret\",\n    path=kvv1.path.apply(lambda path: f\"{path}/secret\"),\n    data_json=json.dumps({\n        \"zip\": \"zap\",\n        \"foo\": \"bar\",\n    }))\nsecret_data = vault.kv.get_secret_output(path=secret.path)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var kvv1 = new Vault.Mount(\"kvv1\", new()\n    {\n        Path = \"kvv1\",\n        Type = \"kv\",\n        Options = \n        {\n            { \"version\", \"1\" },\n        },\n        Description = \"KV Version 1 secret engine mount\",\n    });\n\n    var secret = new Vault.Kv.Secret(\"secret\", new()\n    {\n        Path = kvv1.Path.Apply(path =\u003e $\"{path}/secret\"),\n        DataJson = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"zip\"] = \"zap\",\n            [\"foo\"] = \"bar\",\n        }),\n    });\n\n    var secretData = Vault.kv.GetSecret.Invoke(new()\n    {\n        Path = secret.Path,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/kv\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tkvv1, err := vault.NewMount(ctx, \"kvv1\", \u0026vault.MountArgs{\n\t\t\tPath: pulumi.String(\"kvv1\"),\n\t\t\tType: pulumi.String(\"kv\"),\n\t\t\tOptions: pulumi.AnyMap{\n\t\t\t\t\"version\": pulumi.Any(\"1\"),\n\t\t\t},\n\t\t\tDescription: pulumi.String(\"KV Version 1 secret engine mount\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"zip\": \"zap\",\n\t\t\t\"foo\": \"bar\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\tsecret, err := kv.NewSecret(ctx, \"secret\", \u0026kv.SecretArgs{\n\t\t\tPath: kvv1.Path.ApplyT(func(path string) (string, error) {\n\t\t\t\treturn fmt.Sprintf(\"%v/secret\", path), nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t\tDataJson: pulumi.String(json0),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = kv.LookupSecretOutput(ctx, kv.GetSecretOutputArgs{\n\t\t\tPath: secret.Path,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Mount;\nimport com.pulumi.vault.MountArgs;\nimport com.pulumi.vault.kv.Secret;\nimport com.pulumi.vault.kv.SecretArgs;\nimport com.pulumi.vault.kv.KvFunctions;\nimport com.pulumi.vault.generic.inputs.GetSecretArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var kvv1 = new Mount(\"kvv1\", MountArgs.builder()        \n            .path(\"kvv1\")\n            .type(\"kv\")\n            .options(Map.of(\"version\", \"1\"))\n            .description(\"KV Version 1 secret engine mount\")\n            .build());\n\n        var secret = new Secret(\"secret\", SecretArgs.builder()        \n            .path(kvv1.path().applyValue(path -\u003e String.format(\"%s/secret\", path)))\n            .dataJson(serializeJson(\n                jsonObject(\n                    jsonProperty(\"zip\", \"zap\"),\n                    jsonProperty(\"foo\", \"bar\")\n                )))\n            .build());\n\n        final var secretData = KvFunctions.getSecret(GetSecretArgs.builder()\n            .path(secret.path())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  kvv1:\n    type: vault:Mount\n    properties:\n      path: kvv1\n      type: kv\n      options:\n        version: 1\n      description: KV Version 1 secret engine mount\n  secret:\n    type: vault:kv:Secret\n    properties:\n      path: ${kvv1.path}/secret\n      dataJson:\n        Fn::ToJSON:\n          zip: zap\n          foo: bar\nvariables:\n  secretData:\n    Fn::Invoke:\n      Function: vault:kv:getSecret\n      Arguments:\n        path: ${secret.path}\n```\n{{% /example %}}\n{{% /examples %}}\n## Required Vault Capabilities\n\nUse of this resource requires the `read` capability on the given path.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getSecret.\n",
                "properties": {
                    "namespace": {
                        "type": "string",
                        "description": "The namespace of the target resource.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "Full path of the KV-V1 secret.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "path"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSecret.\n",
                "properties": {
                    "data": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A mapping whose keys are the top-level data keys returned from\nVault and whose values are the corresponding values. This map can only\nrepresent string data, so any non-string values returned from Vault are\nserialized as JSON.\n",
                        "secret": true
                    },
                    "dataJson": {
                        "type": "string",
                        "description": "JSON-encoded string that that is\nread as the secret data at the given path.\n",
                        "secret": true
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "leaseDuration": {
                        "type": "integer",
                        "description": "The duration of the secret lease, in seconds. Once \nthis time has passed any plan generated with this data may fail to apply.\n"
                    },
                    "leaseId": {
                        "type": "string",
                        "description": "The lease identifier assigned by Vault, if any.\n"
                    },
                    "leaseRenewable": {
                        "type": "boolean",
                        "description": "True if the duration of this lease can be extended \nthrough renewal.\n"
                    },
                    "namespace": {
                        "type": "string"
                    },
                    "path": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "data",
                    "dataJson",
                    "leaseDuration",
                    "leaseId",
                    "leaseRenewable",
                    "path",
                    "id"
                ]
            }
        },
        "vault:kv/getSecretSubkeysV2:getSecretSubkeysV2": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst kvv2 = new vault.Mount(\"kvv2\", {\n    path: \"kvv2\",\n    type: \"kv\",\n    options: {\n        version: \"2\",\n    },\n    description: \"KV Version 2 secret engine mount\",\n});\nconst awsSecret = new vault.kv.SecretV2(\"awsSecret\", {\n    mount: kvv2.path,\n    dataJson: JSON.stringify({\n        zip: \"zap\",\n        foo: \"bar\",\n    }),\n});\nconst test = vault.kv.getSecretSubkeysV2Output({\n    mount: kvv2.path,\n    name: awsSecret.name,\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_vault as vault\n\nkvv2 = vault.Mount(\"kvv2\",\n    path=\"kvv2\",\n    type=\"kv\",\n    options={\n        \"version\": \"2\",\n    },\n    description=\"KV Version 2 secret engine mount\")\naws_secret = vault.kv.SecretV2(\"awsSecret\",\n    mount=kvv2.path,\n    data_json=json.dumps({\n        \"zip\": \"zap\",\n        \"foo\": \"bar\",\n    }))\ntest = vault.kv.get_secret_subkeys_v2_output(mount=kvv2.path,\n    name=aws_secret.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var kvv2 = new Vault.Mount(\"kvv2\", new()\n    {\n        Path = \"kvv2\",\n        Type = \"kv\",\n        Options = \n        {\n            { \"version\", \"2\" },\n        },\n        Description = \"KV Version 2 secret engine mount\",\n    });\n\n    var awsSecret = new Vault.Kv.SecretV2(\"awsSecret\", new()\n    {\n        Mount = kvv2.Path,\n        DataJson = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"zip\"] = \"zap\",\n            [\"foo\"] = \"bar\",\n        }),\n    });\n\n    var test = Vault.kv.GetSecretSubkeysV2.Invoke(new()\n    {\n        Mount = kvv2.Path,\n        Name = awsSecret.Name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/kv\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tkvv2, err := vault.NewMount(ctx, \"kvv2\", \u0026vault.MountArgs{\n\t\t\tPath: pulumi.String(\"kvv2\"),\n\t\t\tType: pulumi.String(\"kv\"),\n\t\t\tOptions: pulumi.AnyMap{\n\t\t\t\t\"version\": pulumi.Any(\"2\"),\n\t\t\t},\n\t\t\tDescription: pulumi.String(\"KV Version 2 secret engine mount\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"zip\": \"zap\",\n\t\t\t\"foo\": \"bar\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\tawsSecret, err := kv.NewSecretV2(ctx, \"awsSecret\", \u0026kv.SecretV2Args{\n\t\t\tMount:    kvv2.Path,\n\t\t\tDataJson: pulumi.String(json0),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = kv.GetSecretSubkeysV2Output(ctx, kv.GetSecretSubkeysV2OutputArgs{\n\t\t\tMount: kvv2.Path,\n\t\t\tName:  awsSecret.Name,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Mount;\nimport com.pulumi.vault.MountArgs;\nimport com.pulumi.vault.kv.SecretV2;\nimport com.pulumi.vault.kv.SecretV2Args;\nimport com.pulumi.vault.kv.KvFunctions;\nimport com.pulumi.vault.kv.inputs.GetSecretSubkeysV2Args;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var kvv2 = new Mount(\"kvv2\", MountArgs.builder()        \n            .path(\"kvv2\")\n            .type(\"kv\")\n            .options(Map.of(\"version\", \"2\"))\n            .description(\"KV Version 2 secret engine mount\")\n            .build());\n\n        var awsSecret = new SecretV2(\"awsSecret\", SecretV2Args.builder()        \n            .mount(kvv2.path())\n            .dataJson(serializeJson(\n                jsonObject(\n                    jsonProperty(\"zip\", \"zap\"),\n                    jsonProperty(\"foo\", \"bar\")\n                )))\n            .build());\n\n        final var test = KvFunctions.getSecretSubkeysV2(GetSecretSubkeysV2Args.builder()\n            .mount(kvv2.path())\n            .name(awsSecret.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  kvv2:\n    type: vault:Mount\n    properties:\n      path: kvv2\n      type: kv\n      options:\n        version: 2\n      description: KV Version 2 secret engine mount\n  awsSecret:\n    type: vault:kv:SecretV2\n    properties:\n      mount: ${kvv2.path}\n      dataJson:\n        Fn::ToJSON:\n          zip: zap\n          foo: bar\nvariables:\n  test:\n    Fn::Invoke:\n      Function: vault:kv:getSecretSubkeysV2\n      Arguments:\n        mount: ${kvv2.path}\n        name: ${awsSecret.name}\n```\n{{% /example %}}\n{{% /examples %}}\n## Required Vault Capabilities\n\nUse of this resource requires the `read` capability on the given path.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getSecretSubkeysV2.\n",
                "properties": {
                    "depth": {
                        "type": "integer",
                        "description": "Specifies the deepest nesting level to provide in the output.\nIf non-zero, keys that reside at the specified depth value will be\nartificially treated as leaves and will thus be `null` even if further\nunderlying sub-keys exist.\n"
                    },
                    "mount": {
                        "type": "string",
                        "description": "Path where KV-V2 engine is mounted.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Full name of the secret. For a nested secret\nthe name is the nested path excluding the mount and data\nprefix. For example, for a secret at `kvv2/data/foo/bar/baz`\nthe name is `foo/bar/baz`.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace of the target resource.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "version": {
                        "type": "integer",
                        "description": "Specifies the version to return. If not \nset the latest version is returned.\n"
                    }
                },
                "type": "object",
                "required": [
                    "mount",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSecretSubkeysV2.\n",
                "properties": {
                    "data": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Subkeys for the KV-V2 secret stored as a serialized map of strings.\n",
                        "secret": true
                    },
                    "dataJson": {
                        "type": "string",
                        "description": "Subkeys for the KV-V2 secret read from Vault.\n"
                    },
                    "depth": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "mount": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "namespace": {
                        "type": "string"
                    },
                    "path": {
                        "type": "string",
                        "description": "Full path where the KV-V2 secrets are listed.\n"
                    },
                    "version": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "data",
                    "dataJson",
                    "mount",
                    "name",
                    "path",
                    "id"
                ]
            }
        },
        "vault:kv/getSecretV2:getSecretV2": {
            "description": "## Required Vault Capabilities\n\nUse of this resource requires the `read` capability on the given path.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getSecretV2.\n",
                "properties": {
                    "mount": {
                        "type": "string",
                        "description": "Path where KV-V2 engine is mounted.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Full name of the secret. For a nested secret\nthe name is the nested path excluding the mount and data\nprefix. For example, for a secret at `kvv2/data/foo/bar/baz`\nthe name is `foo/bar/baz`.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace of the target resource.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "version": {
                        "type": "integer",
                        "description": "Version of the secret to retrieve.\n"
                    }
                },
                "type": "object",
                "required": [
                    "mount",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSecretV2.\n",
                "properties": {
                    "createdTime": {
                        "type": "string",
                        "description": "Time at which secret was created.\n"
                    },
                    "customMetadata": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Custom metadata for the secret.\n"
                    },
                    "data": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A mapping whose keys are the top-level data keys returned from\nVault and whose values are the corresponding values. This map can only\nrepresent string data, so any non-string values returned from Vault are\nserialized as JSON.\n",
                        "secret": true
                    },
                    "dataJson": {
                        "type": "string",
                        "description": "JSON-encoded string that that is\nread as the secret data at the given path.\n",
                        "secret": true
                    },
                    "deletionTime": {
                        "type": "string",
                        "description": "Deletion time for the secret.\n"
                    },
                    "destroyed": {
                        "type": "boolean",
                        "description": "Indicates whether the secret has been destroyed.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "mount": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "namespace": {
                        "type": "string"
                    },
                    "path": {
                        "type": "string",
                        "description": "Full path where the KVV2 secret is written.\n"
                    },
                    "version": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "createdTime",
                    "customMetadata",
                    "data",
                    "dataJson",
                    "deletionTime",
                    "destroyed",
                    "mount",
                    "name",
                    "path",
                    "id"
                ]
            }
        },
        "vault:kv/getSecretsList:getSecretsList": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst kvv1 = new vault.Mount(\"kvv1\", {\n    path: \"kvv1\",\n    type: \"kv\",\n    options: {\n        version: \"1\",\n    },\n    description: \"KV Version 1 secret engine mount\",\n});\nconst awsSecret = new vault.kv.Secret(\"awsSecret\", {\n    path: pulumi.interpolate`${kvv1.path}/aws-secret`,\n    dataJson: JSON.stringify({\n        zip: \"zap\",\n    }),\n});\nconst azureSecret = new vault.kv.Secret(\"azureSecret\", {\n    path: pulumi.interpolate`${kvv1.path}/azure-secret`,\n    dataJson: JSON.stringify({\n        foo: \"bar\",\n    }),\n});\nconst secrets = vault.kv.getSecretsListOutput({\n    path: kvv1.path,\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_vault as vault\n\nkvv1 = vault.Mount(\"kvv1\",\n    path=\"kvv1\",\n    type=\"kv\",\n    options={\n        \"version\": \"1\",\n    },\n    description=\"KV Version 1 secret engine mount\")\naws_secret = vault.kv.Secret(\"awsSecret\",\n    path=kvv1.path.apply(lambda path: f\"{path}/aws-secret\"),\n    data_json=json.dumps({\n        \"zip\": \"zap\",\n    }))\nazure_secret = vault.kv.Secret(\"azureSecret\",\n    path=kvv1.path.apply(lambda path: f\"{path}/azure-secret\"),\n    data_json=json.dumps({\n        \"foo\": \"bar\",\n    }))\nsecrets = vault.kv.get_secrets_list_output(path=kvv1.path)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var kvv1 = new Vault.Mount(\"kvv1\", new()\n    {\n        Path = \"kvv1\",\n        Type = \"kv\",\n        Options = \n        {\n            { \"version\", \"1\" },\n        },\n        Description = \"KV Version 1 secret engine mount\",\n    });\n\n    var awsSecret = new Vault.Kv.Secret(\"awsSecret\", new()\n    {\n        Path = kvv1.Path.Apply(path =\u003e $\"{path}/aws-secret\"),\n        DataJson = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"zip\"] = \"zap\",\n        }),\n    });\n\n    var azureSecret = new Vault.Kv.Secret(\"azureSecret\", new()\n    {\n        Path = kvv1.Path.Apply(path =\u003e $\"{path}/azure-secret\"),\n        DataJson = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"foo\"] = \"bar\",\n        }),\n    });\n\n    var secrets = Vault.kv.GetSecretsList.Invoke(new()\n    {\n        Path = kvv1.Path,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/kv\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tkvv1, err := vault.NewMount(ctx, \"kvv1\", \u0026vault.MountArgs{\n\t\t\tPath: pulumi.String(\"kvv1\"),\n\t\t\tType: pulumi.String(\"kv\"),\n\t\t\tOptions: pulumi.AnyMap{\n\t\t\t\t\"version\": pulumi.Any(\"1\"),\n\t\t\t},\n\t\t\tDescription: pulumi.String(\"KV Version 1 secret engine mount\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"zip\": \"zap\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\t_, err = kv.NewSecret(ctx, \"awsSecret\", \u0026kv.SecretArgs{\n\t\t\tPath: kvv1.Path.ApplyT(func(path string) (string, error) {\n\t\t\t\treturn fmt.Sprintf(\"%v/aws-secret\", path), nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t\tDataJson: pulumi.String(json0),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttmpJSON1, err := json.Marshal(map[string]interface{}{\n\t\t\t\"foo\": \"bar\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson1 := string(tmpJSON1)\n\t\t_, err = kv.NewSecret(ctx, \"azureSecret\", \u0026kv.SecretArgs{\n\t\t\tPath: kvv1.Path.ApplyT(func(path string) (string, error) {\n\t\t\t\treturn fmt.Sprintf(\"%v/azure-secret\", path), nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t\tDataJson: pulumi.String(json1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = kv.GetSecretsListOutput(ctx, kv.GetSecretsListOutputArgs{\n\t\t\tPath: kvv1.Path,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Mount;\nimport com.pulumi.vault.MountArgs;\nimport com.pulumi.vault.kv.Secret;\nimport com.pulumi.vault.kv.SecretArgs;\nimport com.pulumi.vault.kv.KvFunctions;\nimport com.pulumi.vault.kv.inputs.GetSecretsListArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var kvv1 = new Mount(\"kvv1\", MountArgs.builder()        \n            .path(\"kvv1\")\n            .type(\"kv\")\n            .options(Map.of(\"version\", \"1\"))\n            .description(\"KV Version 1 secret engine mount\")\n            .build());\n\n        var awsSecret = new Secret(\"awsSecret\", SecretArgs.builder()        \n            .path(kvv1.path().applyValue(path -\u003e String.format(\"%s/aws-secret\", path)))\n            .dataJson(serializeJson(\n                jsonObject(\n                    jsonProperty(\"zip\", \"zap\")\n                )))\n            .build());\n\n        var azureSecret = new Secret(\"azureSecret\", SecretArgs.builder()        \n            .path(kvv1.path().applyValue(path -\u003e String.format(\"%s/azure-secret\", path)))\n            .dataJson(serializeJson(\n                jsonObject(\n                    jsonProperty(\"foo\", \"bar\")\n                )))\n            .build());\n\n        final var secrets = KvFunctions.getSecretsList(GetSecretsListArgs.builder()\n            .path(kvv1.path())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  kvv1:\n    type: vault:Mount\n    properties:\n      path: kvv1\n      type: kv\n      options:\n        version: 1\n      description: KV Version 1 secret engine mount\n  awsSecret:\n    type: vault:kv:Secret\n    properties:\n      path: ${kvv1.path}/aws-secret\n      dataJson:\n        Fn::ToJSON:\n          zip: zap\n  azureSecret:\n    type: vault:kv:Secret\n    properties:\n      path: ${kvv1.path}/azure-secret\n      dataJson:\n        Fn::ToJSON:\n          foo: bar\nvariables:\n  secrets:\n    Fn::Invoke:\n      Function: vault:kv:getSecretsList\n      Arguments:\n        path: ${kvv1.path}\n```\n{{% /example %}}\n{{% /examples %}}\n## Required Vault Capabilities\n\nUse of this resource requires the `read` capability on the given path.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getSecretsList.\n",
                "properties": {
                    "namespace": {
                        "type": "string",
                        "description": "The namespace of the target resource.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "Full KV-V1 path where secrets will be listed.\n"
                    }
                },
                "type": "object",
                "required": [
                    "path"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSecretsList.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "names": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of all secret names listed under the given path.\n",
                        "secret": true
                    },
                    "namespace": {
                        "type": "string"
                    },
                    "path": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "names",
                    "path",
                    "id"
                ]
            }
        },
        "vault:kv/getSecretsListV2:getSecretsListV2": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst kvv2 = new vault.Mount(\"kvv2\", {\n    path: \"kvv2\",\n    type: \"kv\",\n    options: {\n        version: \"2\",\n    },\n    description: \"KV Version 2 secret engine mount\",\n});\nconst awsSecret = new vault.kv.SecretV2(\"awsSecret\", {\n    mount: kvv2.path,\n    dataJson: JSON.stringify({\n        zip: \"zap\",\n    }),\n});\nconst azureSecret = new vault.kv.SecretV2(\"azureSecret\", {\n    mount: kvv2.path,\n    dataJson: JSON.stringify({\n        foo: \"bar\",\n    }),\n});\nconst nestedSecret = new vault.kv.SecretV2(\"nestedSecret\", {\n    mount: kvv2.path,\n    dataJson: JSON.stringify({\n        password: \"test\",\n    }),\n});\nconst secrets = vault.kv.getSecretsListV2Output({\n    mount: kvv2.path,\n});\nconst nestedSecrets = kvv2.path.apply(path =\u003e vault.kv.getSecretsListV2Output({\n    mount: path,\n    name: vault_kv_secret_v2.test_2.name,\n}));\n```\n```python\nimport pulumi\nimport json\nimport pulumi_vault as vault\n\nkvv2 = vault.Mount(\"kvv2\",\n    path=\"kvv2\",\n    type=\"kv\",\n    options={\n        \"version\": \"2\",\n    },\n    description=\"KV Version 2 secret engine mount\")\naws_secret = vault.kv.SecretV2(\"awsSecret\",\n    mount=kvv2.path,\n    data_json=json.dumps({\n        \"zip\": \"zap\",\n    }))\nazure_secret = vault.kv.SecretV2(\"azureSecret\",\n    mount=kvv2.path,\n    data_json=json.dumps({\n        \"foo\": \"bar\",\n    }))\nnested_secret = vault.kv.SecretV2(\"nestedSecret\",\n    mount=kvv2.path,\n    data_json=json.dumps({\n        \"password\": \"test\",\n    }))\nsecrets = vault.kv.get_secrets_list_v2_output(mount=kvv2.path)\nnested_secrets = kvv2.path.apply(lambda path: vault.kv.get_secrets_list_v2_output(mount=path,\n    name=vault_kv_secret_v2[\"test_2\"][\"name\"]))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var kvv2 = new Vault.Mount(\"kvv2\", new()\n    {\n        Path = \"kvv2\",\n        Type = \"kv\",\n        Options = \n        {\n            { \"version\", \"2\" },\n        },\n        Description = \"KV Version 2 secret engine mount\",\n    });\n\n    var awsSecret = new Vault.Kv.SecretV2(\"awsSecret\", new()\n    {\n        Mount = kvv2.Path,\n        DataJson = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"zip\"] = \"zap\",\n        }),\n    });\n\n    var azureSecret = new Vault.Kv.SecretV2(\"azureSecret\", new()\n    {\n        Mount = kvv2.Path,\n        DataJson = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"foo\"] = \"bar\",\n        }),\n    });\n\n    var nestedSecret = new Vault.Kv.SecretV2(\"nestedSecret\", new()\n    {\n        Mount = kvv2.Path,\n        DataJson = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"password\"] = \"test\",\n        }),\n    });\n\n    var secrets = Vault.kv.GetSecretsListV2.Invoke(new()\n    {\n        Mount = kvv2.Path,\n    });\n\n    var nestedSecrets = Vault.kv.GetSecretsListV2.Invoke(new()\n    {\n        Mount = kvv2.Path,\n        Name = vault_kv_secret_v2.Test_2.Name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/kv\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tkvv2, err := vault.NewMount(ctx, \"kvv2\", \u0026vault.MountArgs{\n\t\t\tPath: pulumi.String(\"kvv2\"),\n\t\t\tType: pulumi.String(\"kv\"),\n\t\t\tOptions: pulumi.AnyMap{\n\t\t\t\t\"version\": pulumi.Any(\"2\"),\n\t\t\t},\n\t\t\tDescription: pulumi.String(\"KV Version 2 secret engine mount\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"zip\": \"zap\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\t_, err = kv.NewSecretV2(ctx, \"awsSecret\", \u0026kv.SecretV2Args{\n\t\t\tMount:    kvv2.Path,\n\t\t\tDataJson: pulumi.String(json0),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttmpJSON1, err := json.Marshal(map[string]interface{}{\n\t\t\t\"foo\": \"bar\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson1 := string(tmpJSON1)\n\t\t_, err = kv.NewSecretV2(ctx, \"azureSecret\", \u0026kv.SecretV2Args{\n\t\t\tMount:    kvv2.Path,\n\t\t\tDataJson: pulumi.String(json1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttmpJSON2, err := json.Marshal(map[string]interface{}{\n\t\t\t\"password\": \"test\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson2 := string(tmpJSON2)\n\t\t_, err = kv.NewSecretV2(ctx, \"nestedSecret\", \u0026kv.SecretV2Args{\n\t\t\tMount:    kvv2.Path,\n\t\t\tDataJson: pulumi.String(json2),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = kv.GetSecretsListV2Output(ctx, kv.GetSecretsListV2OutputArgs{\n\t\t\tMount: kvv2.Path,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.Mount;\nimport com.pulumi.vault.MountArgs;\nimport com.pulumi.vault.kv.SecretV2;\nimport com.pulumi.vault.kv.SecretV2Args;\nimport com.pulumi.vault.kv.KvFunctions;\nimport com.pulumi.vault.kv.inputs.GetSecretsListV2Args;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var kvv2 = new Mount(\"kvv2\", MountArgs.builder()        \n            .path(\"kvv2\")\n            .type(\"kv\")\n            .options(Map.of(\"version\", \"2\"))\n            .description(\"KV Version 2 secret engine mount\")\n            .build());\n\n        var awsSecret = new SecretV2(\"awsSecret\", SecretV2Args.builder()        \n            .mount(kvv2.path())\n            .dataJson(serializeJson(\n                jsonObject(\n                    jsonProperty(\"zip\", \"zap\")\n                )))\n            .build());\n\n        var azureSecret = new SecretV2(\"azureSecret\", SecretV2Args.builder()        \n            .mount(kvv2.path())\n            .dataJson(serializeJson(\n                jsonObject(\n                    jsonProperty(\"foo\", \"bar\")\n                )))\n            .build());\n\n        var nestedSecret = new SecretV2(\"nestedSecret\", SecretV2Args.builder()        \n            .mount(kvv2.path())\n            .dataJson(serializeJson(\n                jsonObject(\n                    jsonProperty(\"password\", \"test\")\n                )))\n            .build());\n\n        final var secrets = KvFunctions.getSecretsListV2(GetSecretsListV2Args.builder()\n            .mount(kvv2.path())\n            .build());\n\n        final var nestedSecrets = KvFunctions.getSecretsListV2(GetSecretsListV2Args.builder()\n            .mount(kvv2.path())\n            .name(vault_kv_secret_v2.test_2().name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  kvv2:\n    type: vault:Mount\n    properties:\n      path: kvv2\n      type: kv\n      options:\n        version: 2\n      description: KV Version 2 secret engine mount\n  awsSecret:\n    type: vault:kv:SecretV2\n    properties:\n      mount: ${kvv2.path}\n      dataJson:\n        Fn::ToJSON:\n          zip: zap\n  azureSecret:\n    type: vault:kv:SecretV2\n    properties:\n      mount: ${kvv2.path}\n      dataJson:\n        Fn::ToJSON:\n          foo: bar\n  nestedSecret:\n    type: vault:kv:SecretV2\n    properties:\n      mount: ${kvv2.path}\n      dataJson:\n        Fn::ToJSON:\n          password: test\nvariables:\n  secrets:\n    Fn::Invoke:\n      Function: vault:kv:getSecretsListV2\n      Arguments:\n        mount: ${kvv2.path}\n  nestedSecrets:\n    Fn::Invoke:\n      Function: vault:kv:getSecretsListV2\n      Arguments:\n        mount: ${kvv2.path}\n        name: ${vault_kv_secret_v2.test_2.name}\n```\n{{% /example %}}\n{{% /examples %}}\n## Required Vault Capabilities\n\nUse of this resource requires the `read` capability on the given path.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getSecretsListV2.\n",
                "properties": {
                    "mount": {
                        "type": "string",
                        "description": "Path where KV-V2 engine is mounted.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Full name of the secret. For a nested secret\nthe name is the nested path excluding the mount and data\nprefix. For example, for a secret at `kvv2/data/foo/bar/baz`\nthe name is `foo/bar/baz`.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace of the target resource.\nThe value should not contain leading or trailing forward slashes.\nThe `namespace` is always relative to the provider's configured [namespace](https://www.terraform.io/docs/providers/vault#namespace).\n*Available only for Vault Enterprise*.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "mount"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSecretsListV2.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "mount": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "names": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of all secret names listed under the given path.\n",
                        "secret": true
                    },
                    "namespace": {
                        "type": "string"
                    },
                    "path": {
                        "type": "string",
                        "description": "Full path where the KV-V2 secrets are listed.\n"
                    }
                },
                "type": "object",
                "required": [
                    "mount",
                    "names",
                    "path",
                    "id"
                ]
            }
        },
        "vault:transform/getDecode:getDecode": {
            "description": "This data source supports the \"/transform/decode/{role_name}\" Vault endpoint.\n\nIt decodes the provided value using a named role.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDecode.\n",
                "properties": {
                    "batchInputs": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        },
                        "description": "Specifies a list of items to be decoded in a single batch. If this parameter is set, the top-level parameters 'value', 'transformation' and 'tweak' will be ignored. Each batch item within the list can specify these parameters instead.\n"
                    },
                    "batchResults": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        },
                        "description": "The result of decoding a batch.\n"
                    },
                    "decodedValue": {
                        "type": "string",
                        "description": "The result of decoding a value.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Path to where the back-end is mounted within Vault.\n",
                        "willReplaceOnChanges": true
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role.\n",
                        "willReplaceOnChanges": true
                    },
                    "transformation": {
                        "type": "string",
                        "description": "The transformation to perform. If no value is provided and the role contains a single transformation, this value will be inferred from the role.\n"
                    },
                    "tweak": {
                        "type": "string",
                        "description": "The tweak value to use. Only applicable for FPE transformations\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "The value in which to decode.\n"
                    }
                },
                "type": "object",
                "required": [
                    "path",
                    "roleName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDecode.\n",
                "properties": {
                    "batchInputs": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        }
                    },
                    "batchResults": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        }
                    },
                    "decodedValue": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "path": {
                        "type": "string"
                    },
                    "roleName": {
                        "type": "string"
                    },
                    "transformation": {
                        "type": "string"
                    },
                    "tweak": {
                        "type": "string"
                    },
                    "value": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "batchResults",
                    "decodedValue",
                    "path",
                    "roleName",
                    "id"
                ]
            }
        },
        "vault:transform/getEncode:getEncode": {
            "description": "This data source supports the \"/transform/encode/{role_name}\" Vault endpoint.\n\nIt encodes the provided value using a named role.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getEncode.\n",
                "properties": {
                    "batchInputs": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        },
                        "description": "Specifies a list of items to be encoded in a single batch. If this parameter is set, the parameters 'value', 'transformation' and 'tweak' will be ignored. Each batch item within the list can specify these parameters instead.\n"
                    },
                    "batchResults": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        },
                        "description": "The result of encoding a batch.\n"
                    },
                    "encodedValue": {
                        "type": "string",
                        "description": "The result of encoding a value.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Path to where the back-end is mounted within Vault.\n",
                        "willReplaceOnChanges": true
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role.\n",
                        "willReplaceOnChanges": true
                    },
                    "transformation": {
                        "type": "string",
                        "description": "The transformation to perform. If no value is provided and the role contains a single transformation, this value will be inferred from the role.\n"
                    },
                    "tweak": {
                        "type": "string",
                        "description": "The tweak value to use. Only applicable for FPE transformations\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "The value in which to encode.\n"
                    }
                },
                "type": "object",
                "required": [
                    "path",
                    "roleName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getEncode.\n",
                "properties": {
                    "batchInputs": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        }
                    },
                    "batchResults": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        }
                    },
                    "encodedValue": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "path": {
                        "type": "string"
                    },
                    "roleName": {
                        "type": "string"
                    },
                    "transformation": {
                        "type": "string"
                    },
                    "tweak": {
                        "type": "string"
                    },
                    "value": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "batchResults",
                    "encodedValue",
                    "path",
                    "roleName",
                    "id"
                ]
            }
        },
        "vault:transit/getDecrypt:getDecrypt": {
            "description": "This is a data source which can be used to decrypt ciphertext using a Vault Transit key.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst test = pulumi.output(vault.transit.getDecrypt({\n    backend: \"transit\",\n    ciphertext: \"vault:v1:S3GtnJ5GUNCWV+/pdL9+g1Feu/nzAv+RlmTmE91Tu0rBkeIU8MEb2nSspC/1IQ==\",\n    key: \"test\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntest = vault.transit.get_decrypt(backend=\"transit\",\n    ciphertext=\"vault:v1:S3GtnJ5GUNCWV+/pdL9+g1Feu/nzAv+RlmTmE91Tu0rBkeIU8MEb2nSspC/1IQ==\",\n    key=\"test\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Vault.Transit.GetDecrypt.Invoke(new()\n    {\n        Backend = \"transit\",\n        Ciphertext = \"vault:v1:S3GtnJ5GUNCWV+/pdL9+g1Feu/nzAv+RlmTmE91Tu0rBkeIU8MEb2nSspC/1IQ==\",\n        Key = \"test\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/transit\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := transit.GetDecrypt(ctx, \u0026transit.GetDecryptArgs{\n\t\t\tBackend:    \"transit\",\n\t\t\tCiphertext: \"vault:v1:S3GtnJ5GUNCWV+/pdL9+g1Feu/nzAv+RlmTmE91Tu0rBkeIU8MEb2nSspC/1IQ==\",\n\t\t\tKey:        \"test\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vault.transit.TransitFunctions;\nimport com.pulumi.vault.transit.inputs.GetDecryptArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = TransitFunctions.getDecrypt(GetDecryptArgs.builder()\n            .backend(\"transit\")\n            .ciphertext(\"vault:v1:S3GtnJ5GUNCWV+/pdL9+g1Feu/nzAv+RlmTmE91Tu0rBkeIU8MEb2nSspC/1IQ==\")\n            .key(\"test\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    Fn::Invoke:\n      Function: vault:transit:getDecrypt\n      Arguments:\n        backend: transit\n        ciphertext: vault:v1:S3GtnJ5GUNCWV+/pdL9+g1Feu/nzAv+RlmTmE91Tu0rBkeIU8MEb2nSspC/1IQ==\n        key: test\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getDecrypt.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the transit secret backend is mounted at, with no leading or trailing `/`.\n"
                    },
                    "ciphertext": {
                        "type": "string",
                        "description": "Ciphertext to be decoded.\n"
                    },
                    "context": {
                        "type": "string",
                        "description": "Context for key derivation. This is required if key derivation is enabled for this key.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "Specifies the name of the transit key to decrypt against.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "ciphertext",
                    "key"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDecrypt.\n",
                "properties": {
                    "backend": {
                        "type": "string"
                    },
                    "ciphertext": {
                        "type": "string"
                    },
                    "context": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "key": {
                        "type": "string"
                    },
                    "namespace": {
                        "type": "string"
                    },
                    "plaintext": {
                        "type": "string",
                        "description": "Decrypted plaintext returned from Vault\n",
                        "secret": true
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "ciphertext",
                    "key",
                    "plaintext",
                    "id"
                ]
            }
        },
        "vault:transit/getEncrypt:getEncrypt": {
            "description": "This is a data source which can be used to encrypt plaintext using a Vault Transit key.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getEncrypt.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the transit secret backend is mounted at, with no leading or trailing `/`.\n"
                    },
                    "context": {
                        "type": "string",
                        "description": "Context for key derivation. This is required if key derivation is enabled for this key.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "Specifies the name of the transit key to encrypt against.\n"
                    },
                    "keyVersion": {
                        "type": "integer",
                        "description": "The version of the key to use for encryption. If not set, uses the latest version. Must be greater than or equal to the key's `min_encryption_version`, if set.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "plaintext": {
                        "type": "string",
                        "description": "Plaintext to be encoded.\n",
                        "secret": true
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "key",
                    "plaintext"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getEncrypt.\n",
                "properties": {
                    "backend": {
                        "type": "string"
                    },
                    "ciphertext": {
                        "type": "string",
                        "description": "Encrypted ciphertext returned from Vault\n"
                    },
                    "context": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "key": {
                        "type": "string"
                    },
                    "keyVersion": {
                        "type": "integer"
                    },
                    "namespace": {
                        "type": "string"
                    },
                    "plaintext": {
                        "type": "string",
                        "secret": true
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "ciphertext",
                    "key",
                    "plaintext",
                    "id"
                ]
            }
        }
    }
}