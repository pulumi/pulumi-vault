{
    "name": "vault",
    "description": "A Pulumi package for creating and managing vault cloud resources.",
    "keywords": [
        "pulumi",
        "vault"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`vault` Terraform Provider](https://github.com/hashicorp/terraform-provider-vault).",
    "repository": "https://github.com/pulumi/pulumi-vault",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "config": {
        "variables": {
            "addAddressToEnv": {
                "type": "string",
                "description": "If true, adds the value of the `address` argument to the Terraform process environment.\n"
            },
            "address": {
                "type": "string",
                "description": "URL of the root of the target Vault server.\n"
            },
            "authLogins": {
                "type": "array",
                "items": {
                    "$ref": "#/types/vault:config/authLogins:authLogins"
                },
                "description": "Login to vault with an existing auth method using auth/\u003cmount\u003e/login\n"
            },
            "caCertDir": {
                "type": "string",
                "description": "Path to directory containing CA certificate files to validate the server's certificate.\n"
            },
            "caCertFile": {
                "type": "string",
                "description": "Path to a CA certificate file to validate the server's certificate.\n"
            },
            "clientAuths": {
                "type": "array",
                "items": {
                    "$ref": "#/types/vault:config/clientAuths:clientAuths"
                },
                "description": "Client authentication credentials.\n"
            },
            "headers": {
                "type": "array",
                "items": {
                    "$ref": "#/types/vault:config/headers:headers"
                },
                "description": "The headers to send with each Vault request.\n"
            },
            "maxLeaseTtlSeconds": {
                "type": "integer",
                "description": "Maximum TTL for secret leases requested by this provider.\n",
                "default": 1200,
                "defaultInfo": {
                    "environment": [
                        "TERRAFORM_VAULT_MAX_TTL"
                    ]
                }
            },
            "maxRetries": {
                "type": "integer",
                "description": "Maximum number of retries when a 5xx error code is encountered.\n",
                "default": 2,
                "defaultInfo": {
                    "environment": [
                        "VAULT_MAX_RETRIES"
                    ]
                }
            },
            "maxRetriesCcc": {
                "type": "integer",
                "description": "Maximum number of retries for Client Controlled Consistency related operations\n"
            },
            "namespace": {
                "type": "string",
                "description": "The namespace to use. Available only for Vault Enterprise.\n"
            },
            "skipChildToken": {
                "type": "boolean",
                "description": "Set this to true to prevent the creation of ephemeral child token used by this provider.\n"
            },
            "skipTlsVerify": {
                "type": "boolean",
                "description": "Set this to true only if the target Vault server is an insecure development instance.\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_SKIP_VERIFY"
                    ]
                }
            },
            "token": {
                "type": "string",
                "description": "Token to use to authenticate to Vault.\n"
            },
            "tokenName": {
                "type": "string",
                "description": "Token name to use for creating the Vault child token.\n"
            }
        },
        "defaults": [
            "address",
            "token"
        ]
    },
    "types": {
        "vault:azure/BackendRoleAzureGroup:BackendRoleAzureGroup": {
            "properties": {
                "groupName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "objectId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "groupName"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "groupName",
                        "objectId"
                    ]
                }
            }
        },
        "vault:azure/BackendRoleAzureRole:BackendRoleAzureRole": {
            "properties": {
                "roleId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "scope": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "roleName",
                "scope"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "roleId",
                        "roleName",
                        "scope"
                    ]
                }
            }
        },
        "vault:config/authLogins:authLogins": {
            "properties": {
                "method": {
                    "type": "string"
                },
                "namespace": {
                    "type": "string"
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "path": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "path"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vault:config/clientAuths:clientAuths": {
            "properties": {
                "certFile": {
                    "type": "string"
                },
                "keyFile": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "certFile",
                "keyFile"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vault:config/headers:headers": {
            "properties": {
                "name": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vault:database/SecretBackendConnectionCassandra:SecretBackendConnectionCassandra": {
            "properties": {
                "connectTimeout": {
                    "type": "integer",
                    "description": "The number of seconds to use as a connection\ntimeout.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Couchbase URIs to connect to. Must use `couchbases://` scheme if `tls` is `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Whether to skip verification of the server\ncertificate when using TLS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pemBundle": {
                    "type": "string",
                    "description": "Concatenated PEM blocks configuring the certificate\nchain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pemJson": {
                    "type": "string",
                    "description": "A JSON structure configuring the certificate chain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "port": {
                    "type": "integer",
                    "description": "The default port to connect to if no port is specified as\npart of the host.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "protocolVersion": {
                    "type": "integer",
                    "description": "The CQL protocol version to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tls": {
                    "type": "boolean",
                    "description": "Whether to use TLS when connecting to Cassandra.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionCouchbase:SecretBackendConnectionCouchbase": {
            "properties": {
                "base64Pem": {
                    "type": "string",
                    "description": "Required if `tls` is `true`. Specifies the certificate authority of the Couchbase server, as a PEM certificate that has been base64 encoded.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bucketName": {
                    "type": "string",
                    "description": "Required for Couchbase versions prior to 6.5.0. This is only used to verify vault's connection to the server.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of Couchbase URIs to connect to. Must use `couchbases://` scheme if `tls` is `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Whether to skip verification of the server\ncertificate when using TLS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tls": {
                    "type": "boolean",
                    "description": "Whether to use TLS when connecting to Cassandra.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "hosts",
                "password",
                "username"
            ]
        },
        "vault:database/SecretBackendConnectionElasticsearch:SecretBackendConnectionElasticsearch": {
            "properties": {
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "url": {
                    "type": "string",
                    "description": "The URL for Elasticsearch's API. https requires certificate\nby trusted CA if used.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "password",
                "url",
                "username"
            ]
        },
        "vault:database/SecretBackendConnectionHana:SecretBackendConnectionHana": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "Specifies the Redshift DSN. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/redshift#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum amount of time a connection may be reused.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionInfluxdb:SecretBackendConnectionInfluxdb": {
            "properties": {
                "connectTimeout": {
                    "type": "integer",
                    "description": "The number of seconds to use as a connection\ntimeout.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "description": "The host to connect to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Whether to skip verification of the server\ncertificate when using TLS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pemBundle": {
                    "type": "string",
                    "description": "Concatenated PEM blocks configuring the certificate\nchain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pemJson": {
                    "type": "string",
                    "description": "A JSON structure configuring the certificate chain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "port": {
                    "type": "integer",
                    "description": "The default port to connect to if no port is specified as\npart of the host.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tls": {
                    "type": "boolean",
                    "description": "Whether to use TLS when connecting to Cassandra.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "host",
                "password",
                "username"
            ]
        },
        "vault:database/SecretBackendConnectionMongodb:SecretBackendConnectionMongodb": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "Specifies the Redshift DSN. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/redshift#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum amount of time a connection may be reused.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionMongodbatlas:SecretBackendConnectionMongodbatlas": {
            "properties": {
                "privateKey": {
                    "type": "string",
                    "description": "The Private Programmatic API Key used to connect with MongoDB Atlas API.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "projectId": {
                    "type": "string",
                    "description": "The Project ID the Database User should be created within.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "publicKey": {
                    "type": "string",
                    "description": "The Public Programmatic API Key used to authenticate with the MongoDB Atlas API.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "privateKey",
                "projectId",
                "publicKey"
            ]
        },
        "vault:database/SecretBackendConnectionMssql:SecretBackendConnectionMssql": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "Specifies the Redshift DSN. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/redshift#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "containedDb": {
                    "type": "boolean",
                    "description": "For Vault v1.9+. Set to true when the target is a\nContained Database, e.g. AzureSQL.\nSee the [Vault\ndocs](https://www.vaultproject.io/api/secret/databases/mssql#contained_db)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum amount of time a connection may be reused.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionMysql:SecretBackendConnectionMysql": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "Specifies the Redshift DSN. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/redshift#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum amount of time a connection may be reused.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tlsCa": {
                    "type": "string",
                    "description": "x509 CA file for validating the certificate presented by the MySQL server. Must be PEM encoded.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tlsCertificateKey": {
                    "type": "string",
                    "description": "x509 certificate for connecting to the database. This must be a PEM encoded version of the private key and the certificate combined.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionMysqlAurora:SecretBackendConnectionMysqlAurora": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "Specifies the Redshift DSN. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/redshift#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum amount of time a connection may be reused.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionMysqlLegacy:SecretBackendConnectionMysqlLegacy": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "Specifies the Redshift DSN. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/redshift#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum amount of time a connection may be reused.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionMysqlRds:SecretBackendConnectionMysqlRds": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "Specifies the Redshift DSN. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/redshift#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum amount of time a connection may be reused.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionOracle:SecretBackendConnectionOracle": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "Specifies the Redshift DSN. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/redshift#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum amount of time a connection may be reused.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionPostgresql:SecretBackendConnectionPostgresql": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "Specifies the Redshift DSN. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/redshift#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum amount of time a connection may be reused.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionRedshift:SecretBackendConnectionRedshift": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "Specifies the Redshift DSN. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/redshift#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum amount of time a connection may be reused.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionSnowflake:SecretBackendConnectionSnowflake": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "Specifies the Redshift DSN. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/redshift#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum amount of time a connection may be reused.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nthe database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The root credential password used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The root credential username used in the connection URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "- [Template](https://www.vaultproject.io/docs/concepts/username-templating) describing how dynamic usernames are generated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:gcp/SecretRolesetBinding:SecretRolesetBinding": {
            "properties": {
                "resource": {
                    "type": "string",
                    "description": "Resource or resource path for which IAM policy information will be bound. The resource path may be specified in a few different [formats](https://www.vaultproject.io/docs/secrets/gcp/index.html#roleset-bindings).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of [GCP IAM roles](https://cloud.google.com/iam/docs/understanding-roles) for the resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "resource",
                "roles"
            ]
        },
        "vault:gcp/SecretStaticAccountBinding:SecretStaticAccountBinding": {
            "properties": {
                "resource": {
                    "type": "string",
                    "description": "Resource or resource path for which IAM policy information will be bound. The resource path may be specified in a few different [formats](https://www.vaultproject.io/docs/secrets/gcp/index.html#bindings).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of [GCP IAM roles](https://cloud.google.com/iam/docs/understanding-roles) for the resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "resource",
                "roles"
            ]
        },
        "vault:github/AuthBackendTune:AuthBackendTune": {
            "properties": {
                "allowedResponseHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of headers to whitelist and allowing\na plugin to include them in the response.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "auditNonHmacRequestKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will\nnot be HMAC'd by audit devices in the request data object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "auditNonHmacResponseKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will\nnot be HMAC'd by audit devices in the response data object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "defaultLeaseTtl": {
                    "type": "string",
                    "description": "Specifies the default time-to-live.\nIf set, this overrides the global default.\nMust be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "listingVisibility": {
                    "type": "string",
                    "description": "Specifies whether to show this mount in\nthe UI-specific listing endpoint. Valid values are \"unauth\" or \"hidden\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxLeaseTtl": {
                    "type": "string",
                    "description": "Specifies the maximum time-to-live.\nIf set, this overrides the global default.\nMust be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "passthroughRequestHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of headers to whitelist and\npass from the request to the backend.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tokenType": {
                    "type": "string",
                    "description": "Specifies the type of tokens that should be returned by\nthe mount. Valid values are \"default-service\", \"default-batch\", \"service\", \"batch\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:identity/getEntityAlias:getEntityAlias": {
            "properties": {
                "canonicalId": {
                    "type": "string",
                    "description": "Canonical ID of the Alias\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "creationTime": {
                    "type": "string",
                    "description": "Creation time of the Alias\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "ID of the alias\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lastUpdateTime": {
                    "type": "string",
                    "description": "Last update time of the alias\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mergedFromCanonicalIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of canonical IDs merged with this alias\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Arbitrary metadata\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "Authentication mount acccessor which this alias belongs to\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mountPath": {
                    "type": "string",
                    "description": "Authentication mount path which this alias belongs to\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mountType": {
                    "type": "string",
                    "description": "Authentication mount type which this alias belongs to\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of the alias\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "canonicalId",
                "creationTime",
                "id",
                "lastUpdateTime",
                "mergedFromCanonicalIds",
                "metadata",
                "mountAccessor",
                "mountPath",
                "mountType",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vault:index/AuthBackendTune:AuthBackendTune": {
            "properties": {
                "allowedResponseHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of headers to whitelist and allowing\na plugin to include them in the response.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "auditNonHmacRequestKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will\nnot be HMAC'd by audit devices in the request data object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "auditNonHmacResponseKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will\nnot be HMAC'd by audit devices in the response data object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "defaultLeaseTtl": {
                    "type": "string",
                    "description": "Specifies the default time-to-live.\nIf set, this overrides the global default.\nMust be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "listingVisibility": {
                    "type": "string",
                    "description": "Specifies whether to show this mount in\nthe UI-specific listing endpoint. Valid values are \"unauth\" or \"hidden\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxLeaseTtl": {
                    "type": "string",
                    "description": "Specifies the maximum time-to-live.\nIf set, this overrides the global default.\nMust be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "passthroughRequestHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of headers to whitelist and\npass from the request to the backend.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tokenType": {
                    "type": "string",
                    "description": "Specifies the type of tokens that should be returned by\nthe mount. Valid values are \"default-service\", \"default-batch\", \"service\", \"batch\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:index/ProviderAuthLogin:ProviderAuthLogin": {
            "properties": {
                "method": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "namespace": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "path"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": []
                }
            }
        },
        "vault:index/ProviderClientAuth:ProviderClientAuth": {
            "properties": {
                "certFile": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyFile": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "certFile",
                "keyFile"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": []
                }
            }
        },
        "vault:index/ProviderHeader:ProviderHeader": {
            "properties": {
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": []
                }
            }
        },
        "vault:index/getPolicyDocumentRule:getPolicyDocumentRule": {
            "properties": {
                "allowedParameters": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:index/getPolicyDocumentRuleAllowedParameter:getPolicyDocumentRuleAllowedParameter"
                    },
                    "description": "Whitelists a list of keys and values that are permitted on the given path. See Parameters below.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "capabilities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of capabilities that this rule apply to `path`. For example, [\"read\", \"write\"].\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "deniedParameters": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:index/getPolicyDocumentRuleDeniedParameter:getPolicyDocumentRuleDeniedParameter"
                    },
                    "description": "Blacklists a list of parameter and values. Any values specified here take precedence over `allowed_parameter`. See Parameters below.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "description": "Description of the rule. Will be added as a comment to rendered rule.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxWrappingTtl": {
                    "type": "string",
                    "description": "The maximum allowed TTL that clients can specify for a wrapped response.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minWrappingTtl": {
                    "type": "string",
                    "description": "The minimum allowed TTL that clients can specify for a wrapped response.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "description": "A path in Vault that this rule applies to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "requiredParameters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of parameters that must be specified.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "capabilities",
                "path"
            ]
        },
        "vault:index/getPolicyDocumentRuleAllowedParameter:getPolicyDocumentRuleAllowedParameter": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "name of permitted or denied parameter.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "list of values what are permitted or denied by policy rule.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "key",
                "values"
            ]
        },
        "vault:index/getPolicyDocumentRuleDeniedParameter:getPolicyDocumentRuleDeniedParameter": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "name of permitted or denied parameter.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "list of values what are permitted or denied by policy rule.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "key",
                "values"
            ]
        },
        "vault:jwt/AuthBackendTune:AuthBackendTune": {
            "properties": {
                "allowedResponseHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of headers to whitelist and allowing\na plugin to include them in the response.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "auditNonHmacRequestKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will\nnot be HMAC'd by audit devices in the request data object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "auditNonHmacResponseKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will\nnot be HMAC'd by audit devices in the response data object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "defaultLeaseTtl": {
                    "type": "string",
                    "description": "Specifies the default time-to-live.\nIf set, this overrides the global default.\nMust be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "listingVisibility": {
                    "type": "string",
                    "description": "Specifies whether to show this mount in\nthe UI-specific listing endpoint. Valid values are \"unauth\" or \"hidden\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxLeaseTtl": {
                    "type": "string",
                    "description": "Specifies the maximum time-to-live.\nIf set, this overrides the global default.\nMust be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "passthroughRequestHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of headers to whitelist and\npass from the request to the backend.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tokenType": {
                    "type": "string",
                    "description": "Specifies the type of tokens that should be returned by\nthe mount. Valid values are \"default-service\", \"default-batch\", \"service\", \"batch\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:okta/AuthBackendGroup:AuthBackendGroup": {
            "properties": {
                "groupName": {
                    "type": "string",
                    "description": "Name of the group within the Okta\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Vault policies to associate with this user\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "groupName",
                "policies"
            ]
        },
        "vault:okta/AuthBackendUser:AuthBackendUser": {
            "properties": {
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Okta groups to associate with this user\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Vault policies to associate with this user\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "Name of the user within Okta\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "groups",
                "username"
            ]
        },
        "vault:rabbitMq/SecretBackendRoleVhost:SecretBackendRoleVhost": {
            "properties": {
                "configure": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "read": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "write": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "configure",
                "host",
                "read",
                "write"
            ]
        },
        "vault:rabbitMq/SecretBackendRoleVhostTopic:SecretBackendRoleVhostTopic": {
            "properties": {
                "host": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "vhosts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:rabbitMq/SecretBackendRoleVhostTopicVhost:SecretBackendRoleVhostTopicVhost"
                    },
                    "description": "Specifies a map of virtual hosts to permissions.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "host"
            ]
        },
        "vault:rabbitMq/SecretBackendRoleVhostTopicVhost:SecretBackendRoleVhostTopicVhost": {
            "properties": {
                "read": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "topic": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "write": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "read",
                "topic",
                "write"
            ]
        }
    },
    "provider": {
        "description": "The provider type for the vault package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "addAddressToEnv": {
                "type": "string",
                "description": "If true, adds the value of the `address` argument to the Terraform process environment.\n"
            },
            "address": {
                "type": "string",
                "description": "URL of the root of the target Vault server.\n"
            },
            "authLogins": {
                "type": "array",
                "items": {
                    "$ref": "#/types/vault:index/ProviderAuthLogin:ProviderAuthLogin"
                },
                "description": "Login to vault with an existing auth method using auth/\u003cmount\u003e/login\n"
            },
            "caCertDir": {
                "type": "string",
                "description": "Path to directory containing CA certificate files to validate the server's certificate.\n"
            },
            "caCertFile": {
                "type": "string",
                "description": "Path to a CA certificate file to validate the server's certificate.\n"
            },
            "clientAuths": {
                "type": "array",
                "items": {
                    "$ref": "#/types/vault:index/ProviderClientAuth:ProviderClientAuth"
                },
                "description": "Client authentication credentials.\n"
            },
            "headers": {
                "type": "array",
                "items": {
                    "$ref": "#/types/vault:index/ProviderHeader:ProviderHeader"
                },
                "description": "The headers to send with each Vault request.\n"
            },
            "maxLeaseTtlSeconds": {
                "type": "integer",
                "description": "Maximum TTL for secret leases requested by this provider.\n"
            },
            "maxRetries": {
                "type": "integer",
                "description": "Maximum number of retries when a 5xx error code is encountered.\n"
            },
            "maxRetriesCcc": {
                "type": "integer",
                "description": "Maximum number of retries for Client Controlled Consistency related operations\n"
            },
            "namespace": {
                "type": "string",
                "description": "The namespace to use. Available only for Vault Enterprise.\n"
            },
            "skipChildToken": {
                "type": "boolean",
                "description": "Set this to true to prevent the creation of ephemeral child token used by this provider.\n"
            },
            "skipTlsVerify": {
                "type": "boolean",
                "description": "Set this to true only if the target Vault server is an insecure development instance.\n"
            },
            "token": {
                "type": "string",
                "description": "Token to use to authenticate to Vault.\n"
            },
            "tokenName": {
                "type": "string",
                "description": "Token name to use for creating the Vault child token.\n"
            }
        },
        "required": [
            "address",
            "token"
        ],
        "inputProperties": {
            "addAddressToEnv": {
                "type": "string",
                "description": "If true, adds the value of the `address` argument to the Terraform process environment.\n"
            },
            "address": {
                "type": "string",
                "description": "URL of the root of the target Vault server.\n"
            },
            "authLogins": {
                "type": "array",
                "items": {
                    "$ref": "#/types/vault:index/ProviderAuthLogin:ProviderAuthLogin"
                },
                "description": "Login to vault with an existing auth method using auth/\u003cmount\u003e/login\n"
            },
            "caCertDir": {
                "type": "string",
                "description": "Path to directory containing CA certificate files to validate the server's certificate.\n"
            },
            "caCertFile": {
                "type": "string",
                "description": "Path to a CA certificate file to validate the server's certificate.\n"
            },
            "clientAuths": {
                "type": "array",
                "items": {
                    "$ref": "#/types/vault:index/ProviderClientAuth:ProviderClientAuth"
                },
                "description": "Client authentication credentials.\n"
            },
            "headers": {
                "type": "array",
                "items": {
                    "$ref": "#/types/vault:index/ProviderHeader:ProviderHeader"
                },
                "description": "The headers to send with each Vault request.\n"
            },
            "maxLeaseTtlSeconds": {
                "type": "integer",
                "description": "Maximum TTL for secret leases requested by this provider.\n",
                "default": 1200,
                "defaultInfo": {
                    "environment": [
                        "TERRAFORM_VAULT_MAX_TTL"
                    ]
                }
            },
            "maxRetries": {
                "type": "integer",
                "description": "Maximum number of retries when a 5xx error code is encountered.\n",
                "default": 2,
                "defaultInfo": {
                    "environment": [
                        "VAULT_MAX_RETRIES"
                    ]
                }
            },
            "maxRetriesCcc": {
                "type": "integer",
                "description": "Maximum number of retries for Client Controlled Consistency related operations\n"
            },
            "namespace": {
                "type": "string",
                "description": "The namespace to use. Available only for Vault Enterprise.\n"
            },
            "skipChildToken": {
                "type": "boolean",
                "description": "Set this to true to prevent the creation of ephemeral child token used by this provider.\n"
            },
            "skipTlsVerify": {
                "type": "boolean",
                "description": "Set this to true only if the target Vault server is an insecure development instance.\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_SKIP_VERIFY"
                    ]
                }
            },
            "token": {
                "type": "string",
                "description": "Token to use to authenticate to Vault.\n"
            },
            "tokenName": {
                "type": "string",
                "description": "Token name to use for creating the Vault child token.\n"
            }
        },
        "requiredInputs": [
            "address",
            "token"
        ]
    },
    "resources": {
        "vault:ad/secretBackend:SecretBackend": {
            "description": "\n\n\n## Import\n\nAD secret backend can be imported using the `backend`, e.g.\n\n```sh\n $ pulumi import vault:ad/secretBackend:SecretBackend ad ad\n```\n\n ",
            "properties": {
                "anonymousGroupSearch": {
                    "type": "boolean",
                    "description": "Use anonymous binds when performing LDAP group searches\n(if true the initial credentials will still be used for the initial connection test).\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `ad`.\n"
                },
                "binddn": {
                    "type": "string",
                    "description": "Distinguished name of object to bind when performing user and group search.\n"
                },
                "bindpass": {
                    "type": "string",
                    "description": "Password to use along with binddn when performing user search.\n"
                },
                "caseSensitiveNames": {
                    "type": "boolean",
                    "description": "If set, user and group names assigned to policies within the\nbackend will be case sensitive. Otherwise, names will be normalized to lower case.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "CA certificate to use when verifying LDAP server certificate, must be\nx509 PEM encoded.\n"
                },
                "clientTlsCert": {
                    "type": "string",
                    "description": "Client certificate to provide to the LDAP server, must be x509 PEM encoded.\n"
                },
                "clientTlsKey": {
                    "type": "string",
                    "description": "Client certificate key to provide to the LDAP server, must be x509 PEM encoded.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Default lease duration for secrets in seconds.\n"
                },
                "denyNullBind": {
                    "type": "boolean",
                    "description": "Denies an unauthenticated LDAP bind request if the user's password is empty;\ndefaults to true.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the Active Directory backend.\n"
                },
                "discoverdn": {
                    "type": "boolean",
                    "description": "Use anonymous bind to discover the bind Distinguished Name of a user.\n"
                },
                "formatter": {
                    "type": "string",
                    "description": "**Deprecated** use `password_policy`. Text to insert the password into, ex. \"customPrefix{{PASSWORD}}customSuffix\".\n",
                    "deprecationMessage": "Formatter is deprecated and password_policy should be used with Vault \u003e= 1.5."
                },
                "groupattr": {
                    "type": "string",
                    "description": "LDAP attribute to follow on objects returned by \u003cgroupfilter\u003e in order to enumerate\nuser group membership. Examples: `cn` or `memberOf`, etc. Defaults to `cn`.\n"
                },
                "groupdn": {
                    "type": "string",
                    "description": "LDAP search base to use for group membership search (eg: ou=Groups,dc=example,dc=org).\n"
                },
                "groupfilter": {
                    "type": "string",
                    "description": "Go template for querying group membership of user (optional) The template can access\nthe following context variables: UserDN, Username. Defaults to `(|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}}))`\n"
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Skip LDAP server SSL Certificate verification. This is not recommended for production.\nDefaults to `false`.\n"
                },
                "lastRotationTolerance": {
                    "type": "integer",
                    "description": "The number of seconds after a Vault rotation where, if Active Directory\nshows a later rotation, it should be considered out-of-band\n"
                },
                "length": {
                    "type": "integer",
                    "description": "**Deprecated** use `password_policy`. The desired length of passwords that Vault generates.\n",
                    "deprecationMessage": "Length is deprecated and password_policy should be used with Vault \u003e= 1.5."
                },
                "local": {
                    "type": "boolean",
                    "description": "Mark the secrets engine as local-only. Local engines are not replicated or removed by\nreplication.Tolerance duration to use when checking the last rotation time.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Maximum possible lease duration for secrets in seconds.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "In seconds, the maximum password time-to-live.\n"
                },
                "passwordPolicy": {
                    "type": "string",
                    "description": "Name of the password policy to use to generate passwords.\n"
                },
                "requestTimeout": {
                    "type": "integer",
                    "description": "Timeout, in seconds, for the connection when making requests against the server\nbefore returning back an error.\n"
                },
                "starttls": {
                    "type": "boolean",
                    "description": "Issue a StartTLS command after establishing unencrypted connection.\n"
                },
                "tlsMaxVersion": {
                    "type": "string",
                    "description": "Maximum TLS version to use. Accepted values are `tls10`, `tls11`,\n`tls12` or `tls13`. Defaults to `tls12`.\n"
                },
                "tlsMinVersion": {
                    "type": "string",
                    "description": "Minimum TLS version to use. Accepted values are `tls10`, `tls11`,\n`tls12` or `tls13`. Defaults to `tls12`.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "In seconds, the default password time-to-live.\n"
                },
                "upndomain": {
                    "type": "string",
                    "description": "Enables userPrincipalDomain login with [username]@UPNDomain.\n"
                },
                "url": {
                    "type": "string",
                    "description": "LDAP URL to connect to. Multiple URLs can be specified by concatenating\nthem with commas; they will be tried in-order. Defaults to `ldap://127.0.0.1`.\n"
                },
                "usePre111GroupCnBehavior": {
                    "type": "boolean",
                    "description": "In Vault 1.1.1 a fix for handling group CN values of\ndifferent cases unfortunately introduced a regression that could cause previously defined groups\nto not be found due to a change in the resulting name. If set true, the pre-1.1.1 behavior for\nmatching group CNs will be used. This is only needed in some upgrade scenarios for backwards\ncompatibility. It is enabled by default if the config is upgraded but disabled by default on\nnew configurations.\n"
                },
                "useTokenGroups": {
                    "type": "boolean",
                    "description": "If true, use the Active Directory tokenGroups constructed attribute of the\nuser to find the group memberships. This will find all security groups including nested ones.\n"
                },
                "userattr": {
                    "type": "string",
                    "description": "Attribute used when searching users. Defaults to `cn`.\n"
                },
                "userdn": {
                    "type": "string",
                    "description": "LDAP domain to use for users (eg: ou=People,dc=example,dc=org)`.\n"
                }
            },
            "required": [
                "binddn",
                "bindpass",
                "defaultLeaseTtlSeconds",
                "formatter",
                "lastRotationTolerance",
                "length",
                "maxLeaseTtlSeconds",
                "maxTtl",
                "starttls",
                "tlsMaxVersion",
                "tlsMinVersion",
                "ttl",
                "upndomain",
                "usePre111GroupCnBehavior"
            ],
            "inputProperties": {
                "anonymousGroupSearch": {
                    "type": "boolean",
                    "description": "Use anonymous binds when performing LDAP group searches\n(if true the initial credentials will still be used for the initial connection test).\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `ad`.\n"
                },
                "binddn": {
                    "type": "string",
                    "description": "Distinguished name of object to bind when performing user and group search.\n"
                },
                "bindpass": {
                    "type": "string",
                    "description": "Password to use along with binddn when performing user search.\n"
                },
                "caseSensitiveNames": {
                    "type": "boolean",
                    "description": "If set, user and group names assigned to policies within the\nbackend will be case sensitive. Otherwise, names will be normalized to lower case.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "CA certificate to use when verifying LDAP server certificate, must be\nx509 PEM encoded.\n"
                },
                "clientTlsCert": {
                    "type": "string",
                    "description": "Client certificate to provide to the LDAP server, must be x509 PEM encoded.\n"
                },
                "clientTlsKey": {
                    "type": "string",
                    "description": "Client certificate key to provide to the LDAP server, must be x509 PEM encoded.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Default lease duration for secrets in seconds.\n"
                },
                "denyNullBind": {
                    "type": "boolean",
                    "description": "Denies an unauthenticated LDAP bind request if the user's password is empty;\ndefaults to true.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the Active Directory backend.\n"
                },
                "discoverdn": {
                    "type": "boolean",
                    "description": "Use anonymous bind to discover the bind Distinguished Name of a user.\n"
                },
                "formatter": {
                    "type": "string",
                    "description": "**Deprecated** use `password_policy`. Text to insert the password into, ex. \"customPrefix{{PASSWORD}}customSuffix\".\n",
                    "deprecationMessage": "Formatter is deprecated and password_policy should be used with Vault \u003e= 1.5."
                },
                "groupattr": {
                    "type": "string",
                    "description": "LDAP attribute to follow on objects returned by \u003cgroupfilter\u003e in order to enumerate\nuser group membership. Examples: `cn` or `memberOf`, etc. Defaults to `cn`.\n"
                },
                "groupdn": {
                    "type": "string",
                    "description": "LDAP search base to use for group membership search (eg: ou=Groups,dc=example,dc=org).\n"
                },
                "groupfilter": {
                    "type": "string",
                    "description": "Go template for querying group membership of user (optional) The template can access\nthe following context variables: UserDN, Username. Defaults to `(|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}}))`\n"
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Skip LDAP server SSL Certificate verification. This is not recommended for production.\nDefaults to `false`.\n"
                },
                "lastRotationTolerance": {
                    "type": "integer",
                    "description": "The number of seconds after a Vault rotation where, if Active Directory\nshows a later rotation, it should be considered out-of-band\n"
                },
                "length": {
                    "type": "integer",
                    "description": "**Deprecated** use `password_policy`. The desired length of passwords that Vault generates.\n",
                    "deprecationMessage": "Length is deprecated and password_policy should be used with Vault \u003e= 1.5."
                },
                "local": {
                    "type": "boolean",
                    "description": "Mark the secrets engine as local-only. Local engines are not replicated or removed by\nreplication.Tolerance duration to use when checking the last rotation time.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Maximum possible lease duration for secrets in seconds.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "In seconds, the maximum password time-to-live.\n"
                },
                "passwordPolicy": {
                    "type": "string",
                    "description": "Name of the password policy to use to generate passwords.\n"
                },
                "requestTimeout": {
                    "type": "integer",
                    "description": "Timeout, in seconds, for the connection when making requests against the server\nbefore returning back an error.\n"
                },
                "starttls": {
                    "type": "boolean",
                    "description": "Issue a StartTLS command after establishing unencrypted connection.\n"
                },
                "tlsMaxVersion": {
                    "type": "string",
                    "description": "Maximum TLS version to use. Accepted values are `tls10`, `tls11`,\n`tls12` or `tls13`. Defaults to `tls12`.\n"
                },
                "tlsMinVersion": {
                    "type": "string",
                    "description": "Minimum TLS version to use. Accepted values are `tls10`, `tls11`,\n`tls12` or `tls13`. Defaults to `tls12`.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "In seconds, the default password time-to-live.\n"
                },
                "upndomain": {
                    "type": "string",
                    "description": "Enables userPrincipalDomain login with [username]@UPNDomain.\n"
                },
                "url": {
                    "type": "string",
                    "description": "LDAP URL to connect to. Multiple URLs can be specified by concatenating\nthem with commas; they will be tried in-order. Defaults to `ldap://127.0.0.1`.\n"
                },
                "usePre111GroupCnBehavior": {
                    "type": "boolean",
                    "description": "In Vault 1.1.1 a fix for handling group CN values of\ndifferent cases unfortunately introduced a regression that could cause previously defined groups\nto not be found due to a change in the resulting name. If set true, the pre-1.1.1 behavior for\nmatching group CNs will be used. This is only needed in some upgrade scenarios for backwards\ncompatibility. It is enabled by default if the config is upgraded but disabled by default on\nnew configurations.\n"
                },
                "useTokenGroups": {
                    "type": "boolean",
                    "description": "If true, use the Active Directory tokenGroups constructed attribute of the\nuser to find the group memberships. This will find all security groups including nested ones.\n"
                },
                "userattr": {
                    "type": "string",
                    "description": "Attribute used when searching users. Defaults to `cn`.\n"
                },
                "userdn": {
                    "type": "string",
                    "description": "LDAP domain to use for users (eg: ou=People,dc=example,dc=org)`.\n"
                }
            },
            "requiredInputs": [
                "binddn",
                "bindpass"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackend resources.\n",
                "properties": {
                    "anonymousGroupSearch": {
                        "type": "boolean",
                        "description": "Use anonymous binds when performing LDAP group searches\n(if true the initial credentials will still be used for the initial connection test).\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `ad`.\n"
                    },
                    "binddn": {
                        "type": "string",
                        "description": "Distinguished name of object to bind when performing user and group search.\n"
                    },
                    "bindpass": {
                        "type": "string",
                        "description": "Password to use along with binddn when performing user search.\n"
                    },
                    "caseSensitiveNames": {
                        "type": "boolean",
                        "description": "If set, user and group names assigned to policies within the\nbackend will be case sensitive. Otherwise, names will be normalized to lower case.\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "CA certificate to use when verifying LDAP server certificate, must be\nx509 PEM encoded.\n"
                    },
                    "clientTlsCert": {
                        "type": "string",
                        "description": "Client certificate to provide to the LDAP server, must be x509 PEM encoded.\n"
                    },
                    "clientTlsKey": {
                        "type": "string",
                        "description": "Client certificate key to provide to the LDAP server, must be x509 PEM encoded.\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "Default lease duration for secrets in seconds.\n"
                    },
                    "denyNullBind": {
                        "type": "boolean",
                        "description": "Denies an unauthenticated LDAP bind request if the user's password is empty;\ndefaults to true.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Human-friendly description of the mount for the Active Directory backend.\n"
                    },
                    "discoverdn": {
                        "type": "boolean",
                        "description": "Use anonymous bind to discover the bind Distinguished Name of a user.\n"
                    },
                    "formatter": {
                        "type": "string",
                        "description": "**Deprecated** use `password_policy`. Text to insert the password into, ex. \"customPrefix{{PASSWORD}}customSuffix\".\n",
                        "deprecationMessage": "Formatter is deprecated and password_policy should be used with Vault \u003e= 1.5."
                    },
                    "groupattr": {
                        "type": "string",
                        "description": "LDAP attribute to follow on objects returned by \u003cgroupfilter\u003e in order to enumerate\nuser group membership. Examples: `cn` or `memberOf`, etc. Defaults to `cn`.\n"
                    },
                    "groupdn": {
                        "type": "string",
                        "description": "LDAP search base to use for group membership search (eg: ou=Groups,dc=example,dc=org).\n"
                    },
                    "groupfilter": {
                        "type": "string",
                        "description": "Go template for querying group membership of user (optional) The template can access\nthe following context variables: UserDN, Username. Defaults to `(|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}}))`\n"
                    },
                    "insecureTls": {
                        "type": "boolean",
                        "description": "Skip LDAP server SSL Certificate verification. This is not recommended for production.\nDefaults to `false`.\n"
                    },
                    "lastRotationTolerance": {
                        "type": "integer",
                        "description": "The number of seconds after a Vault rotation where, if Active Directory\nshows a later rotation, it should be considered out-of-band\n"
                    },
                    "length": {
                        "type": "integer",
                        "description": "**Deprecated** use `password_policy`. The desired length of passwords that Vault generates.\n",
                        "deprecationMessage": "Length is deprecated and password_policy should be used with Vault \u003e= 1.5."
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Mark the secrets engine as local-only. Local engines are not replicated or removed by\nreplication.Tolerance duration to use when checking the last rotation time.\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "Maximum possible lease duration for secrets in seconds.\n"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "In seconds, the maximum password time-to-live.\n"
                    },
                    "passwordPolicy": {
                        "type": "string",
                        "description": "Name of the password policy to use to generate passwords.\n"
                    },
                    "requestTimeout": {
                        "type": "integer",
                        "description": "Timeout, in seconds, for the connection when making requests against the server\nbefore returning back an error.\n"
                    },
                    "starttls": {
                        "type": "boolean",
                        "description": "Issue a StartTLS command after establishing unencrypted connection.\n"
                    },
                    "tlsMaxVersion": {
                        "type": "string",
                        "description": "Maximum TLS version to use. Accepted values are `tls10`, `tls11`,\n`tls12` or `tls13`. Defaults to `tls12`.\n"
                    },
                    "tlsMinVersion": {
                        "type": "string",
                        "description": "Minimum TLS version to use. Accepted values are `tls10`, `tls11`,\n`tls12` or `tls13`. Defaults to `tls12`.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "In seconds, the default password time-to-live.\n"
                    },
                    "upndomain": {
                        "type": "string",
                        "description": "Enables userPrincipalDomain login with [username]@UPNDomain.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "LDAP URL to connect to. Multiple URLs can be specified by concatenating\nthem with commas; they will be tried in-order. Defaults to `ldap://127.0.0.1`.\n"
                    },
                    "usePre111GroupCnBehavior": {
                        "type": "boolean",
                        "description": "In Vault 1.1.1 a fix for handling group CN values of\ndifferent cases unfortunately introduced a regression that could cause previously defined groups\nto not be found due to a change in the resulting name. If set true, the pre-1.1.1 behavior for\nmatching group CNs will be used. This is only needed in some upgrade scenarios for backwards\ncompatibility. It is enabled by default if the config is upgraded but disabled by default on\nnew configurations.\n"
                    },
                    "useTokenGroups": {
                        "type": "boolean",
                        "description": "If true, use the Active Directory tokenGroups constructed attribute of the\nuser to find the group memberships. This will find all security groups including nested ones.\n"
                    },
                    "userattr": {
                        "type": "string",
                        "description": "Attribute used when searching users. Defaults to `cn`.\n"
                    },
                    "userdn": {
                        "type": "string",
                        "description": "LDAP domain to use for users (eg: ou=People,dc=example,dc=org)`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:ad/secretLibrary:SecretLibrary": {
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The mount path for the AD backend.\n"
                },
                "disableCheckInEnforcement": {
                    "type": "boolean",
                    "description": "Disable enforcing that service accounts must be checked in by the entity or client token that checked them out.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum amount of time, in seconds, a check-out last with renewal before Vault automatically checks it back in.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the set of service accounts.\n"
                },
                "serviceAccountNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The names of all the service accounts that can be checked out from this set. These service accounts must already exist\nin Active Directory.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The amount of time, in seconds, a single check-out lasts before Vault automatically checks it back in.\n"
                }
            },
            "required": [
                "backend",
                "maxTtl",
                "name",
                "serviceAccountNames",
                "ttl"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The mount path for the AD backend.\n"
                },
                "disableCheckInEnforcement": {
                    "type": "boolean",
                    "description": "Disable enforcing that service accounts must be checked in by the entity or client token that checked them out.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum amount of time, in seconds, a check-out last with renewal before Vault automatically checks it back in.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the set of service accounts.\n"
                },
                "serviceAccountNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The names of all the service accounts that can be checked out from this set. These service accounts must already exist\nin Active Directory.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The amount of time, in seconds, a single check-out lasts before Vault automatically checks it back in.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "serviceAccountNames"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretLibrary resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The mount path for the AD backend.\n"
                    },
                    "disableCheckInEnforcement": {
                        "type": "boolean",
                        "description": "Disable enforcing that service accounts must be checked in by the entity or client token that checked them out.\n"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "The maximum amount of time, in seconds, a check-out last with renewal before Vault automatically checks it back in.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the set of service accounts.\n"
                    },
                    "serviceAccountNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The names of all the service accounts that can be checked out from this set. These service accounts must already exist\nin Active Directory.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "The amount of time, in seconds, a single check-out lasts before Vault automatically checks it back in.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:ad/secretRole:SecretRole": {
            "description": "\n\n\n## Import\n\nAD secret backend roles can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:ad/secretRole:SecretRole role ad/roles/bob\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path the AD secret backend is mounted at,\nwith no leading or trailing `/`s.\n"
                },
                "lastVaultRotation": {
                    "type": "string",
                    "description": "Timestamp of the last password rotation by Vault.\n"
                },
                "passwordLastSet": {
                    "type": "string",
                    "description": "Timestamp of the last password set by Vault.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n"
                },
                "serviceAccountName": {
                    "type": "string",
                    "description": "Specifies the name of the Active Directory service\naccount mapped to this role.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The password time-to-live in seconds. Defaults to the configuration\nttl if not provided.\n"
                }
            },
            "required": [
                "backend",
                "lastVaultRotation",
                "passwordLastSet",
                "role",
                "serviceAccountName"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path the AD secret backend is mounted at,\nwith no leading or trailing `/`s.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n"
                },
                "serviceAccountName": {
                    "type": "string",
                    "description": "Specifies the name of the Active Directory service\naccount mapped to this role.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The password time-to-live in seconds. Defaults to the configuration\nttl if not provided.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "role",
                "serviceAccountName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the AD secret backend is mounted at,\nwith no leading or trailing `/`s.\n"
                    },
                    "lastVaultRotation": {
                        "type": "string",
                        "description": "Timestamp of the last password rotation by Vault.\n"
                    },
                    "passwordLastSet": {
                        "type": "string",
                        "description": "Timestamp of the last password set by Vault.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n"
                    },
                    "serviceAccountName": {
                        "type": "string",
                        "description": "Specifies the name of the Active Directory service\naccount mapped to this role.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "The password time-to-live in seconds. Defaults to the configuration\nttl if not provided.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:alicloud/authBackendRole:AuthBackendRole": {
            "description": "Provides a resource to create a role in an [AliCloud auth backend within Vault](https://www.vaultproject.io/docs/auth/alicloud.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst alicloudAuthBackend = new vault.AuthBackend(\"alicloudAuthBackend\", {\n    type: \"alicloud\",\n    path: \"alicloud\",\n});\nconst alicloudAuthBackendRole = new vault.alicloud.AuthBackendRole(\"alicloudAuthBackendRole\", {\n    backend: alicloudAuthBackend.path,\n    role: \"example\",\n    arn: \"acs:ram:123456:tf:role/foobar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nalicloud_auth_backend = vault.AuthBackend(\"alicloudAuthBackend\",\n    type=\"alicloud\",\n    path=\"alicloud\")\nalicloud_auth_backend_role = vault.alicloud.AuthBackendRole(\"alicloudAuthBackendRole\",\n    backend=alicloud_auth_backend.path,\n    role=\"example\",\n    arn=\"acs:ram:123456:tf:role/foobar\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var alicloudAuthBackend = new Vault.AuthBackend(\"alicloudAuthBackend\", new Vault.AuthBackendArgs\n        {\n            Type = \"alicloud\",\n            Path = \"alicloud\",\n        });\n        var alicloudAuthBackendRole = new Vault.AliCloud.AuthBackendRole(\"alicloudAuthBackendRole\", new Vault.AliCloud.AuthBackendRoleArgs\n        {\n            Backend = alicloudAuthBackend.Path,\n            Role = \"example\",\n            Arn = \"acs:ram:123456:tf:role/foobar\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/alicloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\talicloudAuthBackend, err := vault.NewAuthBackend(ctx, \"alicloudAuthBackend\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"alicloud\"),\n\t\t\tPath: pulumi.String(\"alicloud\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = alicloud.NewAuthBackendRole(ctx, \"alicloudAuthBackendRole\", \u0026alicloud.AuthBackendRoleArgs{\n\t\t\tBackend: alicloudAuthBackend.Path,\n\t\t\tRole:    pulumi.String(\"example\"),\n\t\t\tArn:     pulumi.String(\"acs:ram:123456:tf:role/foobar\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAlicloud authentication roles can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:alicloud/authBackendRole:AuthBackendRole my_role auth/alicloud/role/my_role\n```\n\n ",
            "properties": {
                "arn": {
                    "type": "string",
                    "description": "The role's arn.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Path to the mounted AliCloud auth backend.\nDefaults to `alicloud`\n"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the role. Must correspond with the name of\nthe role reflected in the arn.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "required": [
                "arn",
                "role"
            ],
            "inputProperties": {
                "arn": {
                    "type": "string",
                    "description": "The role's arn.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Path to the mounted AliCloud auth backend.\nDefaults to `alicloud`\n"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the role. Must correspond with the name of\nthe role reflected in the arn.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "requiredInputs": [
                "arn",
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "arn": {
                        "type": "string",
                        "description": "The role's arn.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "Path to the mounted AliCloud auth backend.\nDefaults to `alicloud`\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "Name of the role. Must correspond with the name of\nthe role reflected in the arn.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:appRole/authBackendLogin:AuthBackendLogin": {
            "description": "Logs into Vault using the AppRole auth backend. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/approle) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst approle = new vault.AuthBackend(\"approle\", {type: \"approle\"});\nconst example = new vault.approle.AuthBackendRole(\"example\", {\n    backend: approle.path,\n    roleName: \"test-role\",\n    tokenPolicies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n});\nconst id = new vault.approle.AuthBackendRoleSecretID(\"id\", {\n    backend: approle.path,\n    roleName: example.roleName,\n});\nconst login = new vault.approle.AuthBackendLogin(\"login\", {\n    backend: approle.path,\n    roleId: example.roleId,\n    secretId: id.secretId,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\napprole = vault.AuthBackend(\"approle\", type=\"approle\")\nexample = vault.app_role.AuthBackendRole(\"example\",\n    backend=approle.path,\n    role_name=\"test-role\",\n    token_policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ])\nid = vault.app_role.AuthBackendRoleSecretID(\"id\",\n    backend=approle.path,\n    role_name=example.role_name)\nlogin = vault.app_role.AuthBackendLogin(\"login\",\n    backend=approle.path,\n    role_id=example.role_id,\n    secret_id=id.secret_id)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var approle = new Vault.AuthBackend(\"approle\", new Vault.AuthBackendArgs\n        {\n            Type = \"approle\",\n        });\n        var example = new Vault.AppRole.AuthBackendRole(\"example\", new Vault.AppRole.AuthBackendRoleArgs\n        {\n            Backend = approle.Path,\n            RoleName = \"test-role\",\n            TokenPolicies = \n            {\n                \"default\",\n                \"dev\",\n                \"prod\",\n            },\n        });\n        var id = new Vault.AppRole.AuthBackendRoleSecretID(\"id\", new Vault.AppRole.AuthBackendRoleSecretIDArgs\n        {\n            Backend = approle.Path,\n            RoleName = example.RoleName,\n        });\n        var login = new Vault.AppRole.AuthBackendLogin(\"login\", new Vault.AppRole.AuthBackendLoginArgs\n        {\n            Backend = approle.Path,\n            RoleId = example.RoleId,\n            SecretId = id.SecretId,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/appRole\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tapprole, err := vault.NewAuthBackend(ctx, \"approle\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"approle\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texample, err := appRole.NewAuthBackendRole(ctx, \"example\", \u0026appRole.AuthBackendRoleArgs{\n\t\t\tBackend:  approle.Path,\n\t\t\tRoleName: pulumi.String(\"test-role\"),\n\t\t\tTokenPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tid, err := appRole.NewAuthBackendRoleSecretID(ctx, \"id\", \u0026appRole.AuthBackendRoleSecretIDArgs{\n\t\t\tBackend:  approle.Path,\n\t\t\tRoleName: example.RoleName,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = appRole.NewAuthBackendLogin(ctx, \"login\", \u0026appRole.AuthBackendLoginArgs{\n\t\t\tBackend:  approle.Path,\n\t\t\tRoleId:   example.RoleId,\n\t\t\tSecretId: id.SecretId,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The accessor for the token.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique path of the Vault backend to log in with.\n"
                },
                "clientToken": {
                    "type": "string",
                    "description": "The Vault token created.\n"
                },
                "leaseDuration": {
                    "type": "integer",
                    "description": "How long the token is valid for, in seconds.\n"
                },
                "leaseStarted": {
                    "type": "string",
                    "description": "The date and time the lease started, in RFC 3339 format.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The metadata associated with the token.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of policies applied to the token.\n"
                },
                "renewable": {
                    "type": "boolean",
                    "description": "Whether the token is renewable or not.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "The ID of the role to log in with.\n"
                },
                "secretId": {
                    "type": "string",
                    "description": "The secret ID of the role to log in with. Required\nunless `bind_secret_id` is set to false on the role.\n"
                }
            },
            "required": [
                "accessor",
                "clientToken",
                "leaseDuration",
                "leaseStarted",
                "metadata",
                "policies",
                "renewable",
                "roleId"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The unique path of the Vault backend to log in with.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "The ID of the role to log in with.\n"
                },
                "secretId": {
                    "type": "string",
                    "description": "The secret ID of the role to log in with. Required\nunless `bind_secret_id` is set to false on the role.\n"
                }
            },
            "requiredInputs": [
                "roleId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendLogin resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The accessor for the token.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The unique path of the Vault backend to log in with.\n"
                    },
                    "clientToken": {
                        "type": "string",
                        "description": "The Vault token created.\n"
                    },
                    "leaseDuration": {
                        "type": "integer",
                        "description": "How long the token is valid for, in seconds.\n"
                    },
                    "leaseStarted": {
                        "type": "string",
                        "description": "The date and time the lease started, in RFC 3339 format.\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "The metadata associated with the token.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of policies applied to the token.\n"
                    },
                    "renewable": {
                        "type": "boolean",
                        "description": "Whether the token is renewable or not.\n"
                    },
                    "roleId": {
                        "type": "string",
                        "description": "The ID of the role to log in with.\n"
                    },
                    "secretId": {
                        "type": "string",
                        "description": "The secret ID of the role to log in with. Required\nunless `bind_secret_id` is set to false on the role.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:appRole/authBackendRole:AuthBackendRole": {
            "description": "Manages an AppRole auth backend role in a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/approle) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst approle = new vault.AuthBackend(\"approle\", {type: \"approle\"});\nconst example = new vault.approle.AuthBackendRole(\"example\", {\n    backend: approle.path,\n    roleName: \"test-role\",\n    tokenPolicies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\napprole = vault.AuthBackend(\"approle\", type=\"approle\")\nexample = vault.app_role.AuthBackendRole(\"example\",\n    backend=approle.path,\n    role_name=\"test-role\",\n    token_policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ])\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var approle = new Vault.AuthBackend(\"approle\", new Vault.AuthBackendArgs\n        {\n            Type = \"approle\",\n        });\n        var example = new Vault.AppRole.AuthBackendRole(\"example\", new Vault.AppRole.AuthBackendRoleArgs\n        {\n            Backend = approle.Path,\n            RoleName = \"test-role\",\n            TokenPolicies = \n            {\n                \"default\",\n                \"dev\",\n                \"prod\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/appRole\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tapprole, err := vault.NewAuthBackend(ctx, \"approle\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"approle\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = appRole.NewAuthBackendRole(ctx, \"example\", \u0026appRole.AuthBackendRoleArgs{\n\t\t\tBackend:  approle.Path,\n\t\t\tRoleName: pulumi.String(\"test-role\"),\n\t\t\tTokenPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAppRole authentication backend roles can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:appRole/authBackendRole:AuthBackendRole example auth/approle/role/test-role\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of the auth backend to configure.\nDefaults to `approle`.\n"
                },
                "bindSecretId": {
                    "type": "boolean",
                    "description": "Whether or not to require `secret_id` to be\npresented when logging in using this AppRole. Defaults to `true`.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "The RoleID of this role. If not specified, one will be\nauto-generated.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "secretIdBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set,\nspecifies blocks of IP addresses which can perform the login operation.\n"
                },
                "secretIdNumUses": {
                    "type": "integer",
                    "description": "The number of times any particular SecretID\ncan be used to fetch a token from this AppRole, after which the SecretID will\nexpire. A value of zero will allow unlimited uses.\n"
                },
                "secretIdTtl": {
                    "type": "integer",
                    "description": "The number of seconds after which any SecretID\nexpires.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "required": [
                "roleId",
                "roleName"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of the auth backend to configure.\nDefaults to `approle`.\n"
                },
                "bindSecretId": {
                    "type": "boolean",
                    "description": "Whether or not to require `secret_id` to be\npresented when logging in using this AppRole. Defaults to `true`.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "The RoleID of this role. If not specified, one will be\nauto-generated.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "secretIdBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set,\nspecifies blocks of IP addresses which can perform the login operation.\n"
                },
                "secretIdNumUses": {
                    "type": "integer",
                    "description": "The number of times any particular SecretID\ncan be used to fetch a token from this AppRole, after which the SecretID will\nexpire. A value of zero will allow unlimited uses.\n"
                },
                "secretIdTtl": {
                    "type": "integer",
                    "description": "The number of seconds after which any SecretID\nexpires.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "requiredInputs": [
                "roleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The unique name of the auth backend to configure.\nDefaults to `approle`.\n"
                    },
                    "bindSecretId": {
                        "type": "boolean",
                        "description": "Whether or not to require `secret_id` to be\npresented when logging in using this AppRole. Defaults to `true`.\n"
                    },
                    "roleId": {
                        "type": "string",
                        "description": "The RoleID of this role. If not specified, one will be\nauto-generated.\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "secretIdBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set,\nspecifies blocks of IP addresses which can perform the login operation.\n"
                    },
                    "secretIdNumUses": {
                        "type": "integer",
                        "description": "The number of times any particular SecretID\ncan be used to fetch a token from this AppRole, after which the SecretID will\nexpire. A value of zero will allow unlimited uses.\n"
                    },
                    "secretIdTtl": {
                        "type": "integer",
                        "description": "The number of seconds after which any SecretID\nexpires.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:appRole/authBackendRoleSecretID:AuthBackendRoleSecretID": {
            "description": "Manages an AppRole auth backend SecretID in a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/approle) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst approle = new vault.AuthBackend(\"approle\", {type: \"approle\"});\nconst example = new vault.approle.AuthBackendRole(\"example\", {\n    backend: approle.path,\n    roleName: \"test-role\",\n    tokenPolicies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n});\nconst id = new vault.approle.AuthBackendRoleSecretID(\"id\", {\n    backend: approle.path,\n    roleName: example.roleName,\n    metadata: `  {\n    \"hello\": \"world\"\n  }\n`,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\napprole = vault.AuthBackend(\"approle\", type=\"approle\")\nexample = vault.app_role.AuthBackendRole(\"example\",\n    backend=approle.path,\n    role_name=\"test-role\",\n    token_policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ])\nid = vault.app_role.AuthBackendRoleSecretID(\"id\",\n    backend=approle.path,\n    role_name=example.role_name,\n    metadata=\"\"\"  {\n    \"hello\": \"world\"\n  }\n\"\"\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var approle = new Vault.AuthBackend(\"approle\", new Vault.AuthBackendArgs\n        {\n            Type = \"approle\",\n        });\n        var example = new Vault.AppRole.AuthBackendRole(\"example\", new Vault.AppRole.AuthBackendRoleArgs\n        {\n            Backend = approle.Path,\n            RoleName = \"test-role\",\n            TokenPolicies = \n            {\n                \"default\",\n                \"dev\",\n                \"prod\",\n            },\n        });\n        var id = new Vault.AppRole.AuthBackendRoleSecretID(\"id\", new Vault.AppRole.AuthBackendRoleSecretIDArgs\n        {\n            Backend = approle.Path,\n            RoleName = example.RoleName,\n            Metadata = @\"  {\n    \"\"hello\"\": \"\"world\"\"\n  }\n\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/appRole\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tapprole, err := vault.NewAuthBackend(ctx, \"approle\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"approle\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texample, err := appRole.NewAuthBackendRole(ctx, \"example\", \u0026appRole.AuthBackendRoleArgs{\n\t\t\tBackend:  approle.Path,\n\t\t\tRoleName: pulumi.String(\"test-role\"),\n\t\t\tTokenPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = appRole.NewAuthBackendRoleSecretID(ctx, \"id\", \u0026appRole.AuthBackendRoleSecretIDArgs{\n\t\t\tBackend:  approle.Path,\n\t\t\tRoleName: example.RoleName,\n\t\t\tMetadata: pulumi.String(fmt.Sprintf(\"%v%v%v\", \"  {\\n\", \"    \\\"hello\\\": \\\"world\\\"\\n\", \"  }\\n\")),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The unique ID for this SecretID that can be safely logged.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Unique name of the auth backend to configure.\n"
                },
                "cidrLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, specifies blocks of IP addresses which can\nperform the login operation using this SecretID.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "A JSON-encoded string containing metadata in\nkey-value pairs to be set on tokens issued with this SecretID.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role to create the SecretID for.\n"
                },
                "secretId": {
                    "type": "string",
                    "description": "The SecretID to be created. If set, uses \"Push\"\nmode.  Defaults to Vault auto-generating SecretIDs.\n"
                },
                "wrappingAccessor": {
                    "type": "string",
                    "description": "The unique ID for the response-wrapped SecretID that can\nbe safely logged.\n"
                },
                "wrappingToken": {
                    "type": "string",
                    "description": "The token used to retrieve a response-wrapped SecretID.\n"
                },
                "wrappingTtl": {
                    "type": "string",
                    "description": "If set, the SecretID response will be\n[response-wrapped](https://www.vaultproject.io/docs/concepts/response-wrapping)\nand available for the duration specified. Only a single unwrapping of the\ntoken is allowed.\n"
                }
            },
            "required": [
                "accessor",
                "roleName",
                "secretId",
                "wrappingAccessor",
                "wrappingToken"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Unique name of the auth backend to configure.\n"
                },
                "cidrLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, specifies blocks of IP addresses which can\nperform the login operation using this SecretID.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "A JSON-encoded string containing metadata in\nkey-value pairs to be set on tokens issued with this SecretID.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role to create the SecretID for.\n"
                },
                "secretId": {
                    "type": "string",
                    "description": "The SecretID to be created. If set, uses \"Push\"\nmode.  Defaults to Vault auto-generating SecretIDs.\n"
                },
                "wrappingTtl": {
                    "type": "string",
                    "description": "If set, the SecretID response will be\n[response-wrapped](https://www.vaultproject.io/docs/concepts/response-wrapping)\nand available for the duration specified. Only a single unwrapping of the\ntoken is allowed.\n"
                }
            },
            "requiredInputs": [
                "roleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRoleSecretID resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The unique ID for this SecretID that can be safely logged.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "Unique name of the auth backend to configure.\n"
                    },
                    "cidrLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, specifies blocks of IP addresses which can\nperform the login operation using this SecretID.\n"
                    },
                    "metadata": {
                        "type": "string",
                        "description": "A JSON-encoded string containing metadata in\nkey-value pairs to be set on tokens issued with this SecretID.\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role to create the SecretID for.\n"
                    },
                    "secretId": {
                        "type": "string",
                        "description": "The SecretID to be created. If set, uses \"Push\"\nmode.  Defaults to Vault auto-generating SecretIDs.\n"
                    },
                    "wrappingAccessor": {
                        "type": "string",
                        "description": "The unique ID for the response-wrapped SecretID that can\nbe safely logged.\n"
                    },
                    "wrappingToken": {
                        "type": "string",
                        "description": "The token used to retrieve a response-wrapped SecretID.\n"
                    },
                    "wrappingTtl": {
                        "type": "string",
                        "description": "If set, the SecretID response will be\n[response-wrapped](https://www.vaultproject.io/docs/concepts/response-wrapping)\nand available for the duration specified. Only a single unwrapping of the\ntoken is allowed.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendCert:AuthBackendCert": {
            "description": "\n\n\n## Import\n\nAWS auth backend certificates can be imported using `auth/`, the `backend` path, `/config/certificate/`, and the `cert_name` e.g.\n\n```sh\n $ pulumi import vault:aws/authBackendCert:AuthBackendCert example auth/aws/config/certificate/my-cert\n```\n\n ",
            "properties": {
                "awsPublicCert": {
                    "type": "string",
                    "description": "The  Base64 encoded AWS Public key required to\nverify PKCS7 signature of the EC2 instance metadata. You can find this key in\nthe [AWS\ndocumentation](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-identity-documents.html).\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                },
                "certName": {
                    "type": "string",
                    "description": "The name of the certificate.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Either \"pkcs7\" or \"identity\", indicating the type of\ndocument which can be verified using the given certificate. Defaults to\n\"pkcs7\".\n"
                }
            },
            "required": [
                "awsPublicCert",
                "certName"
            ],
            "inputProperties": {
                "awsPublicCert": {
                    "type": "string",
                    "description": "The  Base64 encoded AWS Public key required to\nverify PKCS7 signature of the EC2 instance metadata. You can find this key in\nthe [AWS\ndocumentation](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-identity-documents.html).\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                },
                "certName": {
                    "type": "string",
                    "description": "The name of the certificate.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Either \"pkcs7\" or \"identity\", indicating the type of\ndocument which can be verified using the given certificate. Defaults to\n\"pkcs7\".\n"
                }
            },
            "requiredInputs": [
                "awsPublicCert",
                "certName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendCert resources.\n",
                "properties": {
                    "awsPublicCert": {
                        "type": "string",
                        "description": "The  Base64 encoded AWS Public key required to\nverify PKCS7 signature of the EC2 instance metadata. You can find this key in\nthe [AWS\ndocumentation](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-identity-documents.html).\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                    },
                    "certName": {
                        "type": "string",
                        "description": "The name of the certificate.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Either \"pkcs7\" or \"identity\", indicating the type of\ndocument which can be verified using the given certificate. Defaults to\n\"pkcs7\".\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendClient:AuthBackendClient": {
            "description": "\n\n\n## Import\n\nAWS auth backend clients can be imported using `auth/`, the `backend` path, and `/config/client` e.g.\n\n```sh\n $ pulumi import vault:aws/authBackendClient:AuthBackendClient example auth/aws/config/client\n```\n\n ",
            "properties": {
                "accessKey": {
                    "type": "string",
                    "description": "The AWS access key that Vault should use for the\nauth backend.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                },
                "ec2Endpoint": {
                    "type": "string",
                    "description": "Override the URL Vault uses when making EC2 API\ncalls.\n"
                },
                "iamEndpoint": {
                    "type": "string",
                    "description": "Override the URL Vault uses when making IAM API\ncalls.\n"
                },
                "iamServerIdHeaderValue": {
                    "type": "string",
                    "description": "The value to require in the\n`X-Vault-AWS-IAM-Server-ID` header as part of `GetCallerIdentity` requests\nthat are used in the IAM auth method.\n"
                },
                "secretKey": {
                    "type": "string",
                    "description": "The AWS secret key that Vault should use for the\nauth backend.\n"
                },
                "stsEndpoint": {
                    "type": "string",
                    "description": "Override the URL Vault uses when making STS API\ncalls.\n"
                },
                "stsRegion": {
                    "type": "string",
                    "description": "Override the default region when making STS API \ncalls. The `sts_endpoint` argument must be set when using `sts_region`.\n"
                }
            },
            "inputProperties": {
                "accessKey": {
                    "type": "string",
                    "description": "The AWS access key that Vault should use for the\nauth backend.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                },
                "ec2Endpoint": {
                    "type": "string",
                    "description": "Override the URL Vault uses when making EC2 API\ncalls.\n"
                },
                "iamEndpoint": {
                    "type": "string",
                    "description": "Override the URL Vault uses when making IAM API\ncalls.\n"
                },
                "iamServerIdHeaderValue": {
                    "type": "string",
                    "description": "The value to require in the\n`X-Vault-AWS-IAM-Server-ID` header as part of `GetCallerIdentity` requests\nthat are used in the IAM auth method.\n"
                },
                "secretKey": {
                    "type": "string",
                    "description": "The AWS secret key that Vault should use for the\nauth backend.\n"
                },
                "stsEndpoint": {
                    "type": "string",
                    "description": "Override the URL Vault uses when making STS API\ncalls.\n"
                },
                "stsRegion": {
                    "type": "string",
                    "description": "Override the default region when making STS API \ncalls. The `sts_endpoint` argument must be set when using `sts_region`.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendClient resources.\n",
                "properties": {
                    "accessKey": {
                        "type": "string",
                        "description": "The AWS access key that Vault should use for the\nauth backend.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                    },
                    "ec2Endpoint": {
                        "type": "string",
                        "description": "Override the URL Vault uses when making EC2 API\ncalls.\n"
                    },
                    "iamEndpoint": {
                        "type": "string",
                        "description": "Override the URL Vault uses when making IAM API\ncalls.\n"
                    },
                    "iamServerIdHeaderValue": {
                        "type": "string",
                        "description": "The value to require in the\n`X-Vault-AWS-IAM-Server-ID` header as part of `GetCallerIdentity` requests\nthat are used in the IAM auth method.\n"
                    },
                    "secretKey": {
                        "type": "string",
                        "description": "The AWS secret key that Vault should use for the\nauth backend.\n"
                    },
                    "stsEndpoint": {
                        "type": "string",
                        "description": "Override the URL Vault uses when making STS API\ncalls.\n"
                    },
                    "stsRegion": {
                        "type": "string",
                        "description": "Override the default region when making STS API \ncalls. The `sts_endpoint` argument must be set when using `sts_region`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendIdentityWhitelist:AuthBackendIdentityWhitelist": {
            "description": "Configures the periodic tidying operation of the whitelisted identity entries.\n\nFor more information, see the\n[Vault docs](https://www.vaultproject.io/api-docs/auth/aws#configure-identity-whitelist-tidy-operation).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst exampleAuthBackend = new vault.AuthBackend(\"exampleAuthBackend\", {type: \"aws\"});\nconst exampleAuthBackendIdentityWhitelist = new vault.aws.AuthBackendIdentityWhitelist(\"exampleAuthBackendIdentityWhitelist\", {\n    backend: exampleAuthBackend.path,\n    safetyBuffer: 3600,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample_auth_backend = vault.AuthBackend(\"exampleAuthBackend\", type=\"aws\")\nexample_auth_backend_identity_whitelist = vault.aws.AuthBackendIdentityWhitelist(\"exampleAuthBackendIdentityWhitelist\",\n    backend=example_auth_backend.path,\n    safety_buffer=3600)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleAuthBackend = new Vault.AuthBackend(\"exampleAuthBackend\", new Vault.AuthBackendArgs\n        {\n            Type = \"aws\",\n        });\n        var exampleAuthBackendIdentityWhitelist = new Vault.Aws.AuthBackendIdentityWhitelist(\"exampleAuthBackendIdentityWhitelist\", new Vault.Aws.AuthBackendIdentityWhitelistArgs\n        {\n            Backend = exampleAuthBackend.Path,\n            SafetyBuffer = 3600,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/aws\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleAuthBackend, err := vault.NewAuthBackend(ctx, \"exampleAuthBackend\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"aws\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = aws.NewAuthBackendIdentityWhitelist(ctx, \"exampleAuthBackendIdentityWhitelist\", \u0026aws.AuthBackendIdentityWhitelistArgs{\n\t\t\tBackend:      exampleAuthBackend.Path,\n\t\t\tSafetyBuffer: pulumi.Int(3600),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAWS auth backend identity whitelists can be imported using `auth/`, the `backend` path, and `/config/tidy/identity-whitelist` e.g.\n\n```sh\n $ pulumi import vault:aws/authBackendIdentityWhitelist:AuthBackendIdentityWhitelist example auth/aws/config/tidy/identity-whitelist\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path of the AWS backend being configured.\n"
                },
                "disablePeriodicTidy": {
                    "type": "boolean",
                    "description": "If set to true, disables the periodic\ntidying of the identity-whitelist entries.\n"
                },
                "safetyBuffer": {
                    "type": "integer",
                    "description": "The amount of extra time, in minutes, that must\nhave passed beyond the roletag expiration, before it is removed from the\nbackend storage.\n"
                }
            },
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path of the AWS backend being configured.\n"
                },
                "disablePeriodicTidy": {
                    "type": "boolean",
                    "description": "If set to true, disables the periodic\ntidying of the identity-whitelist entries.\n"
                },
                "safetyBuffer": {
                    "type": "integer",
                    "description": "The amount of extra time, in minutes, that must\nhave passed beyond the roletag expiration, before it is removed from the\nbackend storage.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendIdentityWhitelist resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path of the AWS backend being configured.\n"
                    },
                    "disablePeriodicTidy": {
                        "type": "boolean",
                        "description": "If set to true, disables the periodic\ntidying of the identity-whitelist entries.\n"
                    },
                    "safetyBuffer": {
                        "type": "integer",
                        "description": "The amount of extra time, in minutes, that must\nhave passed beyond the roletag expiration, before it is removed from the\nbackend storage.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendLogin:AuthBackendLogin": {
            "description": "Logs into a Vault server using an AWS auth backend. Login can be\naccomplished using a signed identity request from IAM or using ec2\ninstance metadata. For more information, see the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/aws.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst aws = new vault.AuthBackend(\"aws\", {\n    type: \"aws\",\n    path: \"aws\",\n});\nconst exampleAuthBackendClient = new vault.aws.AuthBackendClient(\"exampleAuthBackendClient\", {\n    backend: aws.path,\n    accessKey: \"123456789012\",\n    secretKey: \"AWSSECRETKEYGOESHERE\",\n});\nconst exampleAuthBackendRole = new vault.aws.AuthBackendRole(\"exampleAuthBackendRole\", {\n    backend: aws.path,\n    role: \"test-role\",\n    authType: \"ec2\",\n    boundAmiId: \"ami-8c1be5f6\",\n    boundAccountId: \"123456789012\",\n    boundVpcId: \"vpc-b61106d4\",\n    boundSubnetId: \"vpc-133128f1\",\n    boundIamInstanceProfileArn: \"arn:aws:iam::123456789012:instance-profile/MyProfile\",\n    ttl: 60,\n    maxTtl: 120,\n    tokenPolicies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n}, {\n    dependsOn: [\"vault_aws_auth_backend_client.example\"],\n});\nconst exampleAuthBackendLogin = new vault.aws.AuthBackendLogin(\"exampleAuthBackendLogin\", {\n    backend: vault_auth_backend.example.path,\n    role: exampleAuthBackendRole.role,\n    identity: \"BASE64ENCODEDIDENTITYDOCUMENT\",\n    signature: \"BASE64ENCODEDSHA256IDENTITYDOCUMENTSIGNATURE\",\n});\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The token's accessor.\n"
                },
                "authType": {
                    "type": "string",
                    "description": "The authentication type used to generate this token.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique name of the AWS auth backend. Defaults to\n'aws'.\n"
                },
                "clientToken": {
                    "type": "string",
                    "description": "The token returned by Vault.\n"
                },
                "iamHttpRequestMethod": {
                    "type": "string",
                    "description": "The HTTP method used in the signed IAM\nrequest.\n"
                },
                "iamRequestBody": {
                    "type": "string",
                    "description": "The base64-encoded body of the signed\nrequest.\n"
                },
                "iamRequestHeaders": {
                    "type": "string",
                    "description": "The base64-encoded, JSON serialized\nrepresentation of the GetCallerIdentity HTTP request headers.\n"
                },
                "iamRequestUrl": {
                    "type": "string",
                    "description": "The base64-encoded HTTP URL used in the signed\nrequest.\n"
                },
                "identity": {
                    "type": "string",
                    "description": "The base64-encoded EC2 instance identity document to\nauthenticate with. Can be retrieved from the EC2 metadata server.\n"
                },
                "leaseDuration": {
                    "type": "integer",
                    "description": "The duration in seconds the token will be valid, relative\nto the time in `lease_start_time`.\n"
                },
                "leaseStartTime": {
                    "type": "string",
                    "description": "Time at which the lease was read, using the clock of the system where Terraform was running\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of information returned by the Vault server about the\nauthentication used to generate this token.\n"
                },
                "nonce": {
                    "type": "string",
                    "description": "The unique nonce to be used for login requests. Can be\nset to a user-specified value, or will contain the server-generated value\nonce a token is issued. EC2 instances can only acquire a single token until\nthe whitelist is tidied again unless they keep track of this nonce.\n"
                },
                "pkcs7": {
                    "type": "string",
                    "description": "The PKCS#7 signature of the identity document to\nauthenticate with, with all newline characters removed. Can be retrieved from\nthe EC2 metadata server.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The Vault policies assigned to this token.\n"
                },
                "renewable": {
                    "type": "boolean",
                    "description": "Set to true if the token can be extended through renewal.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the AWS auth backend role to create tokens\nagainst.\n"
                },
                "signature": {
                    "type": "string",
                    "description": "The base64-encoded SHA256 RSA signature of the\ninstance identity document to authenticate with, with all newline characters\nremoved. Can be retrieved from the EC2 metadata server.\n"
                }
            },
            "required": [
                "accessor",
                "authType",
                "clientToken",
                "leaseDuration",
                "leaseStartTime",
                "metadata",
                "nonce",
                "policies",
                "renewable",
                "role"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of the AWS auth backend. Defaults to\n'aws'.\n"
                },
                "iamHttpRequestMethod": {
                    "type": "string",
                    "description": "The HTTP method used in the signed IAM\nrequest.\n"
                },
                "iamRequestBody": {
                    "type": "string",
                    "description": "The base64-encoded body of the signed\nrequest.\n"
                },
                "iamRequestHeaders": {
                    "type": "string",
                    "description": "The base64-encoded, JSON serialized\nrepresentation of the GetCallerIdentity HTTP request headers.\n"
                },
                "iamRequestUrl": {
                    "type": "string",
                    "description": "The base64-encoded HTTP URL used in the signed\nrequest.\n"
                },
                "identity": {
                    "type": "string",
                    "description": "The base64-encoded EC2 instance identity document to\nauthenticate with. Can be retrieved from the EC2 metadata server.\n"
                },
                "nonce": {
                    "type": "string",
                    "description": "The unique nonce to be used for login requests. Can be\nset to a user-specified value, or will contain the server-generated value\nonce a token is issued. EC2 instances can only acquire a single token until\nthe whitelist is tidied again unless they keep track of this nonce.\n"
                },
                "pkcs7": {
                    "type": "string",
                    "description": "The PKCS#7 signature of the identity document to\nauthenticate with, with all newline characters removed. Can be retrieved from\nthe EC2 metadata server.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the AWS auth backend role to create tokens\nagainst.\n"
                },
                "signature": {
                    "type": "string",
                    "description": "The base64-encoded SHA256 RSA signature of the\ninstance identity document to authenticate with, with all newline characters\nremoved. Can be retrieved from the EC2 metadata server.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendLogin resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The token's accessor.\n"
                    },
                    "authType": {
                        "type": "string",
                        "description": "The authentication type used to generate this token.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The unique name of the AWS auth backend. Defaults to\n'aws'.\n"
                    },
                    "clientToken": {
                        "type": "string",
                        "description": "The token returned by Vault.\n"
                    },
                    "iamHttpRequestMethod": {
                        "type": "string",
                        "description": "The HTTP method used in the signed IAM\nrequest.\n"
                    },
                    "iamRequestBody": {
                        "type": "string",
                        "description": "The base64-encoded body of the signed\nrequest.\n"
                    },
                    "iamRequestHeaders": {
                        "type": "string",
                        "description": "The base64-encoded, JSON serialized\nrepresentation of the GetCallerIdentity HTTP request headers.\n"
                    },
                    "iamRequestUrl": {
                        "type": "string",
                        "description": "The base64-encoded HTTP URL used in the signed\nrequest.\n"
                    },
                    "identity": {
                        "type": "string",
                        "description": "The base64-encoded EC2 instance identity document to\nauthenticate with. Can be retrieved from the EC2 metadata server.\n"
                    },
                    "leaseDuration": {
                        "type": "integer",
                        "description": "The duration in seconds the token will be valid, relative\nto the time in `lease_start_time`.\n"
                    },
                    "leaseStartTime": {
                        "type": "string",
                        "description": "Time at which the lease was read, using the clock of the system where Terraform was running\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A map of information returned by the Vault server about the\nauthentication used to generate this token.\n"
                    },
                    "nonce": {
                        "type": "string",
                        "description": "The unique nonce to be used for login requests. Can be\nset to a user-specified value, or will contain the server-generated value\nonce a token is issued. EC2 instances can only acquire a single token until\nthe whitelist is tidied again unless they keep track of this nonce.\n"
                    },
                    "pkcs7": {
                        "type": "string",
                        "description": "The PKCS#7 signature of the identity document to\nauthenticate with, with all newline characters removed. Can be retrieved from\nthe EC2 metadata server.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The Vault policies assigned to this token.\n"
                    },
                    "renewable": {
                        "type": "boolean",
                        "description": "Set to true if the token can be extended through renewal.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the AWS auth backend role to create tokens\nagainst.\n"
                    },
                    "signature": {
                        "type": "string",
                        "description": "The base64-encoded SHA256 RSA signature of the\ninstance identity document to authenticate with, with all newline characters\nremoved. Can be retrieved from the EC2 metadata server.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendRole:AuthBackendRole": {
            "description": "Manages an AWS auth backend role in a Vault server. Roles constrain the\ninstances or principals that can perform the login operation against the\nbackend. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/aws.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst aws = new vault.AuthBackend(\"aws\", {type: \"aws\"});\nconst example = new vault.aws.AuthBackendRole(\"example\", {\n    backend: aws.path,\n    role: \"test-role\",\n    authType: \"iam\",\n    boundAmiIds: [\"ami-8c1be5f6\"],\n    boundAccountIds: [\"123456789012\"],\n    boundVpcIds: [\"vpc-b61106d4\"],\n    boundSubnetIds: [\"vpc-133128f1\"],\n    boundIamRoleArns: [\"arn:aws:iam::123456789012:role/MyRole\"],\n    boundIamInstanceProfileArns: [\"arn:aws:iam::123456789012:instance-profile/MyProfile\"],\n    inferredEntityType: \"ec2_instance\",\n    inferredAwsRegion: \"us-east-1\",\n    tokenTtl: 60,\n    tokenMaxTtl: 120,\n    tokenPolicies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\naws = vault.AuthBackend(\"aws\", type=\"aws\")\nexample = vault.aws.AuthBackendRole(\"example\",\n    backend=aws.path,\n    role=\"test-role\",\n    auth_type=\"iam\",\n    bound_ami_ids=[\"ami-8c1be5f6\"],\n    bound_account_ids=[\"123456789012\"],\n    bound_vpc_ids=[\"vpc-b61106d4\"],\n    bound_subnet_ids=[\"vpc-133128f1\"],\n    bound_iam_role_arns=[\"arn:aws:iam::123456789012:role/MyRole\"],\n    bound_iam_instance_profile_arns=[\"arn:aws:iam::123456789012:instance-profile/MyProfile\"],\n    inferred_entity_type=\"ec2_instance\",\n    inferred_aws_region=\"us-east-1\",\n    token_ttl=60,\n    token_max_ttl=120,\n    token_policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ])\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var aws = new Vault.AuthBackend(\"aws\", new Vault.AuthBackendArgs\n        {\n            Type = \"aws\",\n        });\n        var example = new Vault.Aws.AuthBackendRole(\"example\", new Vault.Aws.AuthBackendRoleArgs\n        {\n            Backend = aws.Path,\n            Role = \"test-role\",\n            AuthType = \"iam\",\n            BoundAmiIds = \n            {\n                \"ami-8c1be5f6\",\n            },\n            BoundAccountIds = \n            {\n                \"123456789012\",\n            },\n            BoundVpcIds = \n            {\n                \"vpc-b61106d4\",\n            },\n            BoundSubnetIds = \n            {\n                \"vpc-133128f1\",\n            },\n            BoundIamRoleArns = \n            {\n                \"arn:aws:iam::123456789012:role/MyRole\",\n            },\n            BoundIamInstanceProfileArns = \n            {\n                \"arn:aws:iam::123456789012:instance-profile/MyProfile\",\n            },\n            InferredEntityType = \"ec2_instance\",\n            InferredAwsRegion = \"us-east-1\",\n            TokenTtl = 60,\n            TokenMaxTtl = 120,\n            TokenPolicies = \n            {\n                \"default\",\n                \"dev\",\n                \"prod\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/aws\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\taws, err := vault.NewAuthBackend(ctx, \"aws\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"aws\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = aws.NewAuthBackendRole(ctx, \"example\", \u0026aws.AuthBackendRoleArgs{\n\t\t\tBackend:  aws.Path,\n\t\t\tRole:     pulumi.String(\"test-role\"),\n\t\t\tAuthType: pulumi.String(\"iam\"),\n\t\t\tBoundAmiIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"ami-8c1be5f6\"),\n\t\t\t},\n\t\t\tBoundAccountIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"123456789012\"),\n\t\t\t},\n\t\t\tBoundVpcIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vpc-b61106d4\"),\n\t\t\t},\n\t\t\tBoundSubnetIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vpc-133128f1\"),\n\t\t\t},\n\t\t\tBoundIamRoleArns: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"arn:aws:iam::123456789012:role/MyRole\"),\n\t\t\t},\n\t\t\tBoundIamInstanceProfileArns: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"arn:aws:iam::123456789012:instance-profile/MyProfile\"),\n\t\t\t},\n\t\t\tInferredEntityType: pulumi.String(\"ec2_instance\"),\n\t\t\tInferredAwsRegion:  pulumi.String(\"us-east-1\"),\n\t\t\tTokenTtl:           pulumi.Int(60),\n\t\t\tTokenMaxTtl:        pulumi.Int(120),\n\t\t\tTokenPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAWS auth backend roles can be imported using `auth/`, the `backend` path, `/role/`, and the `role` name e.g.\n\n```sh\n $ pulumi import vault:aws/authBackendRole:AuthBackendRole example auth/aws/role/test-role\n```\n\n ",
            "properties": {
                "allowInstanceMigration": {
                    "type": "boolean",
                    "description": "If set to `true`, allows migration of\nthe underlying instance where the client resides.\n"
                },
                "authType": {
                    "type": "string",
                    "description": "The auth type permitted for this role. Valid choices\nare `ec2` and `iam`. Defaults to `iam`.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Unique name of the auth backend to configure.\n"
                },
                "boundAccountIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they should be using the\naccount ID specified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundAmiIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they should be using the AMI ID\nspecified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundEc2InstanceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Only EC2 instances that match this instance ID will be permitted to log in.\n"
                },
                "boundIamInstanceProfileArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on\nthe EC2 instances that can perform the login operation that they must be\nassociated with an IAM instance profile ARN which has a prefix that matches\nthe value specified by this field. The value is prefix-matched as though it\nwere a glob ending in `*`. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundIamPrincipalArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines the IAM principal that\nmust be authenticated when `auth_type` is set to `iam`. Wildcards are\nsupported at the end of the ARN.\n"
                },
                "boundIamRoleArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they must match the IAM\nrole ARN specified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that the region in their identity\ndocument must match the one specified by this field. `auth_type` must be set\nto `ec2` or `inferred_entity_type` must be set to `ec2_instance` to use this\nconstraint.\n"
                },
                "boundSubnetIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they be associated with\nthe subnet ID that matches the value specified by this field. `auth_type`\nmust be set to `ec2` or `inferred_entity_type` must be set to `ec2_instance`\nto use this constraint.\n"
                },
                "boundVpcIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they be associated with the VPC ID\nthat matches the value specified by this field. `auth_type` must be set to\n`ec2` or `inferred_entity_type` must be set to `ec2_instance` to use this\nconstraint.\n"
                },
                "disallowReauthentication": {
                    "type": "boolean",
                    "description": "IF set to `true`, only allows a\nsingle token to be granted per instance ID. This can only be set when\n`auth_type` is set to `ec2`.\n"
                },
                "inferredAwsRegion": {
                    "type": "string",
                    "description": "When `inferred_entity_type` is set, this\nis the region to search for the inferred entities. Required if\n`inferred_entity_type` is set. This only applies when `auth_type` is set to\n`iam`.\n"
                },
                "inferredEntityType": {
                    "type": "string",
                    "description": "If set, instructs Vault to turn on\ninferencing. The only valid value is `ec2_instance`, which instructs Vault to\ninfer that the role comes from an EC2 instance in an IAM instance profile.\nThis only applies when `auth_type` is set to `iam`.\n"
                },
                "resolveAwsUniqueIds": {
                    "type": "boolean",
                    "description": "Only valid when\n`auth_type` is `iam`. If set to `true`, the `bound_iam_principal_arns` are\nresolved to [AWS Unique\nIDs](http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-unique-ids)\nfor the bound principal ARN. This field is ignored when a\n`bound_iam_principal_arn` ends in a wildcard. Resolving to unique IDs more\nclosely mimics the behavior of AWS services in that if an IAM user or role is\ndeleted and a new one is recreated with the same name, those new users or\nroles won't get access to roles in Vault that were permissioned to the prior\nprincipals of the same name. Defaults to `true`.\nOnce set to `true`, this cannot be changed to `false` without recreating the role.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "roleTag": {
                    "type": "string",
                    "description": "If set, enable role tags for this role. The value set\nfor this field should be the key of the tag on the EC2 instance. `auth_type`\nmust be set to `ec2` or `inferred_entity_type` must be set to `ec2_instance`\nto use this constraint.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "required": [
                "role"
            ],
            "inputProperties": {
                "allowInstanceMigration": {
                    "type": "boolean",
                    "description": "If set to `true`, allows migration of\nthe underlying instance where the client resides.\n"
                },
                "authType": {
                    "type": "string",
                    "description": "The auth type permitted for this role. Valid choices\nare `ec2` and `iam`. Defaults to `iam`.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Unique name of the auth backend to configure.\n"
                },
                "boundAccountIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they should be using the\naccount ID specified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundAmiIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they should be using the AMI ID\nspecified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundEc2InstanceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Only EC2 instances that match this instance ID will be permitted to log in.\n"
                },
                "boundIamInstanceProfileArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on\nthe EC2 instances that can perform the login operation that they must be\nassociated with an IAM instance profile ARN which has a prefix that matches\nthe value specified by this field. The value is prefix-matched as though it\nwere a glob ending in `*`. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundIamPrincipalArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines the IAM principal that\nmust be authenticated when `auth_type` is set to `iam`. Wildcards are\nsupported at the end of the ARN.\n"
                },
                "boundIamRoleArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they must match the IAM\nrole ARN specified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that the region in their identity\ndocument must match the one specified by this field. `auth_type` must be set\nto `ec2` or `inferred_entity_type` must be set to `ec2_instance` to use this\nconstraint.\n"
                },
                "boundSubnetIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they be associated with\nthe subnet ID that matches the value specified by this field. `auth_type`\nmust be set to `ec2` or `inferred_entity_type` must be set to `ec2_instance`\nto use this constraint.\n"
                },
                "boundVpcIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they be associated with the VPC ID\nthat matches the value specified by this field. `auth_type` must be set to\n`ec2` or `inferred_entity_type` must be set to `ec2_instance` to use this\nconstraint.\n"
                },
                "disallowReauthentication": {
                    "type": "boolean",
                    "description": "IF set to `true`, only allows a\nsingle token to be granted per instance ID. This can only be set when\n`auth_type` is set to `ec2`.\n"
                },
                "inferredAwsRegion": {
                    "type": "string",
                    "description": "When `inferred_entity_type` is set, this\nis the region to search for the inferred entities. Required if\n`inferred_entity_type` is set. This only applies when `auth_type` is set to\n`iam`.\n"
                },
                "inferredEntityType": {
                    "type": "string",
                    "description": "If set, instructs Vault to turn on\ninferencing. The only valid value is `ec2_instance`, which instructs Vault to\ninfer that the role comes from an EC2 instance in an IAM instance profile.\nThis only applies when `auth_type` is set to `iam`.\n"
                },
                "resolveAwsUniqueIds": {
                    "type": "boolean",
                    "description": "Only valid when\n`auth_type` is `iam`. If set to `true`, the `bound_iam_principal_arns` are\nresolved to [AWS Unique\nIDs](http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-unique-ids)\nfor the bound principal ARN. This field is ignored when a\n`bound_iam_principal_arn` ends in a wildcard. Resolving to unique IDs more\nclosely mimics the behavior of AWS services in that if an IAM user or role is\ndeleted and a new one is recreated with the same name, those new users or\nroles won't get access to roles in Vault that were permissioned to the prior\nprincipals of the same name. Defaults to `true`.\nOnce set to `true`, this cannot be changed to `false` without recreating the role.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "roleTag": {
                    "type": "string",
                    "description": "If set, enable role tags for this role. The value set\nfor this field should be the key of the tag on the EC2 instance. `auth_type`\nmust be set to `ec2` or `inferred_entity_type` must be set to `ec2_instance`\nto use this constraint.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "requiredInputs": [
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "allowInstanceMigration": {
                        "type": "boolean",
                        "description": "If set to `true`, allows migration of\nthe underlying instance where the client resides.\n"
                    },
                    "authType": {
                        "type": "string",
                        "description": "The auth type permitted for this role. Valid choices\nare `ec2` and `iam`. Defaults to `iam`.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "Unique name of the auth backend to configure.\n"
                    },
                    "boundAccountIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they should be using the\naccount ID specified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                    },
                    "boundAmiIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they should be using the AMI ID\nspecified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                    },
                    "boundEc2InstanceIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Only EC2 instances that match this instance ID will be permitted to log in.\n"
                    },
                    "boundIamInstanceProfileArns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on\nthe EC2 instances that can perform the login operation that they must be\nassociated with an IAM instance profile ARN which has a prefix that matches\nthe value specified by this field. The value is prefix-matched as though it\nwere a glob ending in `*`. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                    },
                    "boundIamPrincipalArns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines the IAM principal that\nmust be authenticated when `auth_type` is set to `iam`. Wildcards are\nsupported at the end of the ARN.\n"
                    },
                    "boundIamRoleArns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they must match the IAM\nrole ARN specified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                    },
                    "boundRegions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that the region in their identity\ndocument must match the one specified by this field. `auth_type` must be set\nto `ec2` or `inferred_entity_type` must be set to `ec2_instance` to use this\nconstraint.\n"
                    },
                    "boundSubnetIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they be associated with\nthe subnet ID that matches the value specified by this field. `auth_type`\nmust be set to `ec2` or `inferred_entity_type` must be set to `ec2_instance`\nto use this constraint.\n"
                    },
                    "boundVpcIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they be associated with the VPC ID\nthat matches the value specified by this field. `auth_type` must be set to\n`ec2` or `inferred_entity_type` must be set to `ec2_instance` to use this\nconstraint.\n"
                    },
                    "disallowReauthentication": {
                        "type": "boolean",
                        "description": "IF set to `true`, only allows a\nsingle token to be granted per instance ID. This can only be set when\n`auth_type` is set to `ec2`.\n"
                    },
                    "inferredAwsRegion": {
                        "type": "string",
                        "description": "When `inferred_entity_type` is set, this\nis the region to search for the inferred entities. Required if\n`inferred_entity_type` is set. This only applies when `auth_type` is set to\n`iam`.\n"
                    },
                    "inferredEntityType": {
                        "type": "string",
                        "description": "If set, instructs Vault to turn on\ninferencing. The only valid value is `ec2_instance`, which instructs Vault to\ninfer that the role comes from an EC2 instance in an IAM instance profile.\nThis only applies when `auth_type` is set to `iam`.\n"
                    },
                    "resolveAwsUniqueIds": {
                        "type": "boolean",
                        "description": "Only valid when\n`auth_type` is `iam`. If set to `true`, the `bound_iam_principal_arns` are\nresolved to [AWS Unique\nIDs](http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-unique-ids)\nfor the bound principal ARN. This field is ignored when a\n`bound_iam_principal_arn` ends in a wildcard. Resolving to unique IDs more\nclosely mimics the behavior of AWS services in that if an IAM user or role is\ndeleted and a new one is recreated with the same name, those new users or\nroles won't get access to roles in Vault that were permissioned to the prior\nprincipals of the same name. Defaults to `true`.\nOnce set to `true`, this cannot be changed to `false` without recreating the role.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "roleTag": {
                        "type": "string",
                        "description": "If set, enable role tags for this role. The value set\nfor this field should be the key of the tag on the EC2 instance. `auth_type`\nmust be set to `ec2` or `inferred_entity_type` must be set to `ec2_instance`\nto use this constraint.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendRoleTag:AuthBackendRoleTag": {
            "description": "Reads role tag information from an AWS auth backend in Vault. \n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst aws = new vault.AuthBackend(\"aws\", {\n    path: `%s`,\n    type: \"aws\",\n});\nconst role = new vault.aws.AuthBackendRole(\"role\", {\n    backend: aws.path,\n    role: `%s`,\n    authType: \"ec2\",\n    boundAccountId: \"123456789012\",\n    policies: [\n        \"dev\",\n        \"prod\",\n        \"qa\",\n        \"test\",\n    ],\n    roleTag: \"VaultRoleTag\",\n});\nconst test = new vault.aws.AuthBackendRoleTag(\"test\", {\n    backend: aws.path,\n    role: role.role,\n    policies: [\n        \"prod\",\n        \"dev\",\n        \"test\",\n    ],\n    maxTtl: \"1h\",\n    instanceId: \"i-1234567\",\n});\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "allowInstanceMigration": {
                    "type": "boolean",
                    "description": "If set, allows migration of the underlying instances where the client resides. Use with caution.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path to the AWS auth backend to\nread role tags from, with no leading or trailing `/`s. Defaults to \"aws\".\n"
                },
                "disallowReauthentication": {
                    "type": "boolean",
                    "description": "If set, only allows a single token to be granted per instance ID.\n"
                },
                "instanceId": {
                    "type": "string",
                    "description": "Instance ID for which this tag is intended for. If set, the created tag can only be used by the instance with the given ID.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "The maximum TTL of the tokens issued using this role.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The policies to be associated with the tag. Must be a subset of the policies associated with the role.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the AWS auth backend role to read\nrole tags from, with no leading or trailing `/`s.\n"
                },
                "tagKey": {
                    "type": "string",
                    "description": "The key of the role tag.\n"
                },
                "tagValue": {
                    "type": "string",
                    "description": "The value to set the role key.\n"
                }
            },
            "required": [
                "role",
                "tagKey",
                "tagValue"
            ],
            "inputProperties": {
                "allowInstanceMigration": {
                    "type": "boolean",
                    "description": "If set, allows migration of the underlying instances where the client resides. Use with caution.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path to the AWS auth backend to\nread role tags from, with no leading or trailing `/`s. Defaults to \"aws\".\n"
                },
                "disallowReauthentication": {
                    "type": "boolean",
                    "description": "If set, only allows a single token to be granted per instance ID.\n"
                },
                "instanceId": {
                    "type": "string",
                    "description": "Instance ID for which this tag is intended for. If set, the created tag can only be used by the instance with the given ID.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "The maximum TTL of the tokens issued using this role.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The policies to be associated with the tag. Must be a subset of the policies associated with the role.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the AWS auth backend role to read\nrole tags from, with no leading or trailing `/`s.\n"
                }
            },
            "requiredInputs": [
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRoleTag resources.\n",
                "properties": {
                    "allowInstanceMigration": {
                        "type": "boolean",
                        "description": "If set, allows migration of the underlying instances where the client resides. Use with caution.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path to the AWS auth backend to\nread role tags from, with no leading or trailing `/`s. Defaults to \"aws\".\n"
                    },
                    "disallowReauthentication": {
                        "type": "boolean",
                        "description": "If set, only allows a single token to be granted per instance ID.\n"
                    },
                    "instanceId": {
                        "type": "string",
                        "description": "Instance ID for which this tag is intended for. If set, the created tag can only be used by the instance with the given ID.\n"
                    },
                    "maxTtl": {
                        "type": "string",
                        "description": "The maximum TTL of the tokens issued using this role.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The policies to be associated with the tag. Must be a subset of the policies associated with the role.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the AWS auth backend role to read\nrole tags from, with no leading or trailing `/`s.\n"
                    },
                    "tagKey": {
                        "type": "string",
                        "description": "The key of the role tag.\n"
                    },
                    "tagValue": {
                        "type": "string",
                        "description": "The value to set the role key.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendRoletagBlacklist:AuthBackendRoletagBlacklist": {
            "description": "Configures the periodic tidying operation of the blacklisted role tag entries.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst exampleAuthBackend = new vault.AuthBackend(\"exampleAuthBackend\", {type: \"aws\"});\nconst exampleAuthBackendRoletagBlacklist = new vault.aws.AuthBackendRoletagBlacklist(\"exampleAuthBackendRoletagBlacklist\", {\n    backend: exampleAuthBackend.path,\n    safetyBuffer: 360,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample_auth_backend = vault.AuthBackend(\"exampleAuthBackend\", type=\"aws\")\nexample_auth_backend_roletag_blacklist = vault.aws.AuthBackendRoletagBlacklist(\"exampleAuthBackendRoletagBlacklist\",\n    backend=example_auth_backend.path,\n    safety_buffer=360)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleAuthBackend = new Vault.AuthBackend(\"exampleAuthBackend\", new Vault.AuthBackendArgs\n        {\n            Type = \"aws\",\n        });\n        var exampleAuthBackendRoletagBlacklist = new Vault.Aws.AuthBackendRoletagBlacklist(\"exampleAuthBackendRoletagBlacklist\", new Vault.Aws.AuthBackendRoletagBlacklistArgs\n        {\n            Backend = exampleAuthBackend.Path,\n            SafetyBuffer = 360,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/aws\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleAuthBackend, err := vault.NewAuthBackend(ctx, \"exampleAuthBackend\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"aws\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = aws.NewAuthBackendRoletagBlacklist(ctx, \"exampleAuthBackendRoletagBlacklist\", \u0026aws.AuthBackendRoletagBlacklistArgs{\n\t\t\tBackend:      exampleAuthBackend.Path,\n\t\t\tSafetyBuffer: pulumi.Int(360),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.\n"
                },
                "disablePeriodicTidy": {
                    "type": "boolean",
                    "description": "If set to true, disables the periodic\ntidying of the roletag blacklist entries. Defaults to false.\n"
                },
                "safetyBuffer": {
                    "type": "integer",
                    "description": "The amount of extra time that must have passed\nbeyond the roletag expiration, before it is removed from the backend storage.\nDefaults to 259,200 seconds, or 72 hours.\n"
                }
            },
            "required": [
                "backend"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.\n"
                },
                "disablePeriodicTidy": {
                    "type": "boolean",
                    "description": "If set to true, disables the periodic\ntidying of the roletag blacklist entries. Defaults to false.\n"
                },
                "safetyBuffer": {
                    "type": "integer",
                    "description": "The amount of extra time that must have passed\nbeyond the roletag expiration, before it is removed from the backend storage.\nDefaults to 259,200 seconds, or 72 hours.\n"
                }
            },
            "requiredInputs": [
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRoletagBlacklist resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the AWS auth backend being configured was\nmounted at.\n"
                    },
                    "disablePeriodicTidy": {
                        "type": "boolean",
                        "description": "If set to true, disables the periodic\ntidying of the roletag blacklist entries. Defaults to false.\n"
                    },
                    "safetyBuffer": {
                        "type": "integer",
                        "description": "The amount of extra time that must have passed\nbeyond the roletag expiration, before it is removed from the backend storage.\nDefaults to 259,200 seconds, or 72 hours.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendStsRole:AuthBackendStsRole": {
            "description": "\n\n\n## Import\n\nAWS auth backend STS roles can be imported using `auth/`, the `backend` path, `/config/sts/`, and the `account_id` e.g.\n\n```sh\n $ pulumi import vault:aws/authBackendStsRole:AuthBackendStsRole example auth/aws/config/sts/1234567890\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The AWS account ID to configure the STS role for.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                },
                "stsRole": {
                    "type": "string",
                    "description": "The STS role to assume when verifying requests made\nby EC2 instances in the account specified by `account_id`.\n"
                }
            },
            "required": [
                "accountId",
                "stsRole"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The AWS account ID to configure the STS role for.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                },
                "stsRole": {
                    "type": "string",
                    "description": "The STS role to assume when verifying requests made\nby EC2 instances in the account specified by `account_id`.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "stsRole"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendStsRole resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The AWS account ID to configure the STS role for.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                    },
                    "stsRole": {
                        "type": "string",
                        "description": "The STS role to assume when verifying requests made\nby EC2 instances in the account specified by `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/secretBackend:SecretBackend": {
            "description": "\n\n\n## Import\n\nAWS secret backends can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:aws/secretBackend:SecretBackend aws aws\n```\n\n ",
            "properties": {
                "accessKey": {
                    "type": "string",
                    "description": "The AWS Access Key ID this backend should use to\nissue new credentials. Vault uses the official AWS SDK to authenticate, and thus can also use standard AWS environment credentials, shared file credentials or IAM role/ECS task credentials.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials\nissued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "iamEndpoint": {
                    "type": "string",
                    "description": "Specifies a custom HTTP IAM endpoint to use.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `aws`.\n"
                },
                "region": {
                    "type": "string",
                    "description": "The AWS region for API calls. Defaults to `us-east-1`.\n"
                },
                "secretKey": {
                    "type": "string",
                    "description": "The AWS Secret Key this backend should use to\nissue new credentials. Vault uses the official AWS SDK to authenticate, and thus can also use standard AWS environment credentials, shared file credentials or IAM role/ECS task credentials.\n"
                },
                "stsEndpoint": {
                    "type": "string",
                    "description": "Specifies a custom HTTP STS endpoint to use.\n"
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "Template describing how dynamic usernames are generated. The username template is used to generate both IAM usernames (capped at 64 characters) and STS usernames (capped at 32 characters). If no template is provided the field defaults to the template:\n"
                }
            },
            "required": [
                "defaultLeaseTtlSeconds",
                "maxLeaseTtlSeconds",
                "region",
                "usernameTemplate"
            ],
            "inputProperties": {
                "accessKey": {
                    "type": "string",
                    "description": "The AWS Access Key ID this backend should use to\nissue new credentials. Vault uses the official AWS SDK to authenticate, and thus can also use standard AWS environment credentials, shared file credentials or IAM role/ECS task credentials.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials\nissued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "iamEndpoint": {
                    "type": "string",
                    "description": "Specifies a custom HTTP IAM endpoint to use.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `aws`.\n"
                },
                "region": {
                    "type": "string",
                    "description": "The AWS region for API calls. Defaults to `us-east-1`.\n"
                },
                "secretKey": {
                    "type": "string",
                    "description": "The AWS Secret Key this backend should use to\nissue new credentials. Vault uses the official AWS SDK to authenticate, and thus can also use standard AWS environment credentials, shared file credentials or IAM role/ECS task credentials.\n"
                },
                "stsEndpoint": {
                    "type": "string",
                    "description": "Specifies a custom HTTP STS endpoint to use.\n"
                },
                "usernameTemplate": {
                    "type": "string",
                    "description": "Template describing how dynamic usernames are generated. The username template is used to generate both IAM usernames (capped at 64 characters) and STS usernames (capped at 32 characters). If no template is provided the field defaults to the template:\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackend resources.\n",
                "properties": {
                    "accessKey": {
                        "type": "string",
                        "description": "The AWS Access Key ID this backend should use to\nissue new credentials. Vault uses the official AWS SDK to authenticate, and thus can also use standard AWS environment credentials, shared file credentials or IAM role/ECS task credentials.\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The default TTL for credentials\nissued by this backend.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A human-friendly description for this backend.\n"
                    },
                    "iamEndpoint": {
                        "type": "string",
                        "description": "Specifies a custom HTTP IAM endpoint to use.\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `aws`.\n"
                    },
                    "region": {
                        "type": "string",
                        "description": "The AWS region for API calls. Defaults to `us-east-1`.\n"
                    },
                    "secretKey": {
                        "type": "string",
                        "description": "The AWS Secret Key this backend should use to\nissue new credentials. Vault uses the official AWS SDK to authenticate, and thus can also use standard AWS environment credentials, shared file credentials or IAM role/ECS task credentials.\n"
                    },
                    "stsEndpoint": {
                        "type": "string",
                        "description": "Specifies a custom HTTP STS endpoint to use.\n"
                    },
                    "usernameTemplate": {
                        "type": "string",
                        "description": "Template describing how dynamic usernames are generated. The username template is used to generate both IAM usernames (capped at 64 characters) and STS usernames (capped at 32 characters). If no template is provided the field defaults to the template:\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/secretBackendRole:SecretBackendRole": {
            "description": "\n\n\n## Import\n\nAWS secret backend roles can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:aws/secretBackendRole:SecretBackendRole role aws/roles/deploy\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path the AWS secret backend is mounted at,\nwith no leading or trailing `/`s.\n"
                },
                "credentialType": {
                    "type": "string",
                    "description": "Specifies the type of credential to be used when\nretrieving credentials from the role. Must be one of `iam_user`, `assumed_role`, or\n`federation_token`.\n"
                },
                "defaultStsTtl": {
                    "type": "integer",
                    "description": "The default TTL in seconds for STS credentials.\nWhen a TTL is not specified when STS credentials are requested,\nand a default TTL is specified on the role,\nthen this default TTL will be used. Valid only when `credential_type` is one of\n`assumed_role` or `federation_token`.\n"
                },
                "iamGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of IAM group names. IAM users generated\nagainst this vault role will be added to these IAM Groups. For a credential\ntype of `assumed_role` or `federation_token`, the policies sent to the\ncorresponding AWS call (sts:AssumeRole or sts:GetFederation) will be the\npolicies from each group in `iam_groups` combined with the `policy_document`\nand `policy_arns` parameters.\n"
                },
                "maxStsTtl": {
                    "type": "integer",
                    "description": "The max allowed TTL in seconds for STS credentials\n(credentials TTL are capped to `max_sts_ttl`). Valid only when `credential_type` is\none of `assumed_role` or `federation_token`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n"
                },
                "policyArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies a list of AWS managed policy ARNs. The\nbehavior depends on the credential type. With `iam_user`, the policies will be\nattached to IAM users when they are requested. With `assumed_role` and\n`federation_token`, the policy ARNs will act as a filter on what the credentials\ncan do, similar to `policy_document`. When `credential_type` is `iam_user` or\n`federation_token`, at least one of `policy_document` or `policy_arns` must\nbe specified.\n"
                },
                "policyDocument": {
                    "type": "string",
                    "description": "The IAM policy document for the role. The\nbehavior depends on the credential type. With `iam_user`, the policy document\nwill be attached to the IAM user generated and augment the permissions the IAM\nuser has. With `assumed_role` and `federation_token`, the policy document will\nact as a filter on what the credentials can do, similar to `policy_arns`.\n"
                },
                "roleArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the ARNs of the AWS roles this Vault role\nis allowed to assume. Required when `credential_type` is `assumed_role` and\nprohibited otherwise.\n"
                }
            },
            "required": [
                "backend",
                "credentialType",
                "defaultStsTtl",
                "maxStsTtl",
                "name"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path the AWS secret backend is mounted at,\nwith no leading or trailing `/`s.\n"
                },
                "credentialType": {
                    "type": "string",
                    "description": "Specifies the type of credential to be used when\nretrieving credentials from the role. Must be one of `iam_user`, `assumed_role`, or\n`federation_token`.\n"
                },
                "defaultStsTtl": {
                    "type": "integer",
                    "description": "The default TTL in seconds for STS credentials.\nWhen a TTL is not specified when STS credentials are requested,\nand a default TTL is specified on the role,\nthen this default TTL will be used. Valid only when `credential_type` is one of\n`assumed_role` or `federation_token`.\n"
                },
                "iamGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of IAM group names. IAM users generated\nagainst this vault role will be added to these IAM Groups. For a credential\ntype of `assumed_role` or `federation_token`, the policies sent to the\ncorresponding AWS call (sts:AssumeRole or sts:GetFederation) will be the\npolicies from each group in `iam_groups` combined with the `policy_document`\nand `policy_arns` parameters.\n"
                },
                "maxStsTtl": {
                    "type": "integer",
                    "description": "The max allowed TTL in seconds for STS credentials\n(credentials TTL are capped to `max_sts_ttl`). Valid only when `credential_type` is\none of `assumed_role` or `federation_token`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n"
                },
                "policyArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies a list of AWS managed policy ARNs. The\nbehavior depends on the credential type. With `iam_user`, the policies will be\nattached to IAM users when they are requested. With `assumed_role` and\n`federation_token`, the policy ARNs will act as a filter on what the credentials\ncan do, similar to `policy_document`. When `credential_type` is `iam_user` or\n`federation_token`, at least one of `policy_document` or `policy_arns` must\nbe specified.\n"
                },
                "policyDocument": {
                    "type": "string",
                    "description": "The IAM policy document for the role. The\nbehavior depends on the credential type. With `iam_user`, the policy document\nwill be attached to the IAM user generated and augment the permissions the IAM\nuser has. With `assumed_role` and `federation_token`, the policy document will\nact as a filter on what the credentials can do, similar to `policy_arns`.\n"
                },
                "roleArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the ARNs of the AWS roles this Vault role\nis allowed to assume. Required when `credential_type` is `assumed_role` and\nprohibited otherwise.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "credentialType"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the AWS secret backend is mounted at,\nwith no leading or trailing `/`s.\n"
                    },
                    "credentialType": {
                        "type": "string",
                        "description": "Specifies the type of credential to be used when\nretrieving credentials from the role. Must be one of `iam_user`, `assumed_role`, or\n`federation_token`.\n"
                    },
                    "defaultStsTtl": {
                        "type": "integer",
                        "description": "The default TTL in seconds for STS credentials.\nWhen a TTL is not specified when STS credentials are requested,\nand a default TTL is specified on the role,\nthen this default TTL will be used. Valid only when `credential_type` is one of\n`assumed_role` or `federation_token`.\n"
                    },
                    "iamGroups": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of IAM group names. IAM users generated\nagainst this vault role will be added to these IAM Groups. For a credential\ntype of `assumed_role` or `federation_token`, the policies sent to the\ncorresponding AWS call (sts:AssumeRole or sts:GetFederation) will be the\npolicies from each group in `iam_groups` combined with the `policy_document`\nand `policy_arns` parameters.\n"
                    },
                    "maxStsTtl": {
                        "type": "integer",
                        "description": "The max allowed TTL in seconds for STS credentials\n(credentials TTL are capped to `max_sts_ttl`). Valid only when `credential_type` is\none of `assumed_role` or `federation_token`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n"
                    },
                    "policyArns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies a list of AWS managed policy ARNs. The\nbehavior depends on the credential type. With `iam_user`, the policies will be\nattached to IAM users when they are requested. With `assumed_role` and\n`federation_token`, the policy ARNs will act as a filter on what the credentials\ncan do, similar to `policy_document`. When `credential_type` is `iam_user` or\n`federation_token`, at least one of `policy_document` or `policy_arns` must\nbe specified.\n"
                    },
                    "policyDocument": {
                        "type": "string",
                        "description": "The IAM policy document for the role. The\nbehavior depends on the credential type. With `iam_user`, the policy document\nwill be attached to the IAM user generated and augment the permissions the IAM\nuser has. With `assumed_role` and `federation_token`, the policy document will\nact as a filter on what the credentials can do, similar to `policy_arns`.\n"
                    },
                    "roleArns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the ARNs of the AWS roles this Vault role\nis allowed to assume. Required when `credential_type` is `assumed_role` and\nprohibited otherwise.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:azure/authBackendConfig:AuthBackendConfig": {
            "description": "\n\n\n## Import\n\nAzure auth backends can be imported using `auth/`, the `backend` path, and `/config` e.g.\n\n```sh\n $ pulumi import vault:azure/authBackendConfig:AuthBackendConfig example auth/azure/config\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path the Azure auth backend being configured was\nmounted at.  Defaults to `azure`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client id for credentials to query the Azure APIs.\nCurrently read permissions to query compute resources are required.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client secret for credentials to query the\nAzure APIs.\n"
                },
                "environment": {
                    "type": "string",
                    "description": "The Azure cloud environment. Valid values:\nAzurePublicCloud, AzureUSGovernmentCloud, AzureChinaCloud,\nAzureGermanCloud.  Defaults to `AzurePublicCloud`.\n"
                },
                "resource": {
                    "type": "string",
                    "description": "The configured URL for the application registered in\nAzure Active Directory.\n"
                },
                "tenantId": {
                    "type": "string",
                    "description": "The tenant id for the Azure Active Directory\norganization.\n"
                }
            },
            "required": [
                "resource",
                "tenantId"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path the Azure auth backend being configured was\nmounted at.  Defaults to `azure`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client id for credentials to query the Azure APIs.\nCurrently read permissions to query compute resources are required.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client secret for credentials to query the\nAzure APIs.\n"
                },
                "environment": {
                    "type": "string",
                    "description": "The Azure cloud environment. Valid values:\nAzurePublicCloud, AzureUSGovernmentCloud, AzureChinaCloud,\nAzureGermanCloud.  Defaults to `AzurePublicCloud`.\n"
                },
                "resource": {
                    "type": "string",
                    "description": "The configured URL for the application registered in\nAzure Active Directory.\n"
                },
                "tenantId": {
                    "type": "string",
                    "description": "The tenant id for the Azure Active Directory\norganization.\n"
                }
            },
            "requiredInputs": [
                "resource",
                "tenantId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendConfig resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the Azure auth backend being configured was\nmounted at.  Defaults to `azure`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client id for credentials to query the Azure APIs.\nCurrently read permissions to query compute resources are required.\n"
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "The client secret for credentials to query the\nAzure APIs.\n"
                    },
                    "environment": {
                        "type": "string",
                        "description": "The Azure cloud environment. Valid values:\nAzurePublicCloud, AzureUSGovernmentCloud, AzureChinaCloud,\nAzureGermanCloud.  Defaults to `AzurePublicCloud`.\n"
                    },
                    "resource": {
                        "type": "string",
                        "description": "The configured URL for the application registered in\nAzure Active Directory.\n"
                    },
                    "tenantId": {
                        "type": "string",
                        "description": "The tenant id for the Azure Active Directory\norganization.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:azure/authBackendRole:AuthBackendRole": {
            "description": "Manages an Azure auth backend role in a Vault server. Roles constrain the\ninstances or principals that can perform the login operation against the\nbackend. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/azure.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst azure = new vault.AuthBackend(\"azure\", {type: \"azure\"});\nconst example = new vault.azure.AuthBackendRole(\"example\", {\n    backend: azure.path,\n    role: \"test-role\",\n    boundSubscriptionIds: [\"11111111-2222-3333-4444-555555555555\"],\n    boundResourceGroups: [\"123456789012\"],\n    tokenTtl: 60,\n    tokenMaxTtl: 120,\n    tokenPolicies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nazure = vault.AuthBackend(\"azure\", type=\"azure\")\nexample = vault.azure.AuthBackendRole(\"example\",\n    backend=azure.path,\n    role=\"test-role\",\n    bound_subscription_ids=[\"11111111-2222-3333-4444-555555555555\"],\n    bound_resource_groups=[\"123456789012\"],\n    token_ttl=60,\n    token_max_ttl=120,\n    token_policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ])\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var azure = new Vault.AuthBackend(\"azure\", new Vault.AuthBackendArgs\n        {\n            Type = \"azure\",\n        });\n        var example = new Vault.Azure.AuthBackendRole(\"example\", new Vault.Azure.AuthBackendRoleArgs\n        {\n            Backend = azure.Path,\n            Role = \"test-role\",\n            BoundSubscriptionIds = \n            {\n                \"11111111-2222-3333-4444-555555555555\",\n            },\n            BoundResourceGroups = \n            {\n                \"123456789012\",\n            },\n            TokenTtl = 60,\n            TokenMaxTtl = 120,\n            TokenPolicies = \n            {\n                \"default\",\n                \"dev\",\n                \"prod\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/azure\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tazure, err := vault.NewAuthBackend(ctx, \"azure\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"azure\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = azure.NewAuthBackendRole(ctx, \"example\", \u0026azure.AuthBackendRoleArgs{\n\t\t\tBackend: azure.Path,\n\t\t\tRole:    pulumi.String(\"test-role\"),\n\t\t\tBoundSubscriptionIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"11111111-2222-3333-4444-555555555555\"),\n\t\t\t},\n\t\t\tBoundResourceGroups: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"123456789012\"),\n\t\t\t},\n\t\t\tTokenTtl:    pulumi.Int(60),\n\t\t\tTokenMaxTtl: pulumi.Int(120),\n\t\t\tTokenPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAzure auth backend roles can be imported using `auth/`, the `backend` path, `/role/`, and the `role` name e.g.\n\n```sh\n $ pulumi import vault:azure/authBackendRole:AuthBackendRole example auth/azure/role/test-role\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Unique name of the auth backend to configure.\n"
                },
                "boundGroupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the groups\nthat can perform the login operation that they should be using the group\nID specified by this field.\n"
                },
                "boundLocations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the virtual machines\nthat can perform the login operation that the location in their identity\ndocument must match the one specified by this field.\n"
                },
                "boundResourceGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the virtual\nmachines that can perform the login operation that they be associated with\nthe resource group that matches the value specified by this field.\n"
                },
                "boundScaleSets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the virtual\nmachines that can perform the login operation that they must match the scale set\nspecified by this field.\n"
                },
                "boundServicePrincipalIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the\nservice principals that can perform the login operation that they should be possess\nthe ids specified by this field.\n"
                },
                "boundSubscriptionIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the subscriptions\nthat can perform the login operation to ones which  matches the value specified by this\nfield.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "required": [
                "role"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Unique name of the auth backend to configure.\n"
                },
                "boundGroupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the groups\nthat can perform the login operation that they should be using the group\nID specified by this field.\n"
                },
                "boundLocations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the virtual machines\nthat can perform the login operation that the location in their identity\ndocument must match the one specified by this field.\n"
                },
                "boundResourceGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the virtual\nmachines that can perform the login operation that they be associated with\nthe resource group that matches the value specified by this field.\n"
                },
                "boundScaleSets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the virtual\nmachines that can perform the login operation that they must match the scale set\nspecified by this field.\n"
                },
                "boundServicePrincipalIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the\nservice principals that can perform the login operation that they should be possess\nthe ids specified by this field.\n"
                },
                "boundSubscriptionIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the subscriptions\nthat can perform the login operation to ones which  matches the value specified by this\nfield.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "requiredInputs": [
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Unique name of the auth backend to configure.\n"
                    },
                    "boundGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the groups\nthat can perform the login operation that they should be using the group\nID specified by this field.\n"
                    },
                    "boundLocations": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the virtual machines\nthat can perform the login operation that the location in their identity\ndocument must match the one specified by this field.\n"
                    },
                    "boundResourceGroups": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the virtual\nmachines that can perform the login operation that they be associated with\nthe resource group that matches the value specified by this field.\n"
                    },
                    "boundScaleSets": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the virtual\nmachines that can perform the login operation that they must match the scale set\nspecified by this field.\n"
                    },
                    "boundServicePrincipalIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the\nservice principals that can perform the login operation that they should be possess\nthe ids specified by this field.\n"
                    },
                    "boundSubscriptionIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the subscriptions\nthat can perform the login operation to ones which  matches the value specified by this\nfield.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:azure/backend:Backend": {
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "- The OAuth2 client id to connect to Azure.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "- The OAuth2 client secret to connect to Azure.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the backend.\n"
                },
                "environment": {
                    "type": "string",
                    "description": "- The Azure environment.\n"
                },
                "path": {
                    "type": "string",
                    "description": "- The unique path this backend should be mounted at. Defaults to `azure`.\n"
                },
                "subscriptionId": {
                    "type": "string",
                    "description": "- The subscription id for the Azure Active Directory.\n"
                },
                "tenantId": {
                    "type": "string",
                    "description": "- The tenant id for the Azure Active Directory.\n"
                },
                "useMicrosoftGraphApi": {
                    "type": "boolean",
                    "description": "- Use the Microsoft Graph API introduced in `vault-1.9`. \nShould be set to true for `vault-1.10+`\n"
                }
            },
            "required": [
                "subscriptionId",
                "tenantId",
                "useMicrosoftGraphApi"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "- The OAuth2 client id to connect to Azure.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "- The OAuth2 client secret to connect to Azure.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the backend.\n"
                },
                "environment": {
                    "type": "string",
                    "description": "- The Azure environment.\n"
                },
                "path": {
                    "type": "string",
                    "description": "- The unique path this backend should be mounted at. Defaults to `azure`.\n"
                },
                "subscriptionId": {
                    "type": "string",
                    "description": "- The subscription id for the Azure Active Directory.\n"
                },
                "tenantId": {
                    "type": "string",
                    "description": "- The tenant id for the Azure Active Directory.\n"
                },
                "useMicrosoftGraphApi": {
                    "type": "boolean",
                    "description": "- Use the Microsoft Graph API introduced in `vault-1.9`. \nShould be set to true for `vault-1.10+`\n"
                }
            },
            "requiredInputs": [
                "subscriptionId",
                "tenantId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Backend resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "- The OAuth2 client id to connect to Azure.\n"
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "- The OAuth2 client secret to connect to Azure.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Human-friendly description of the mount for the backend.\n"
                    },
                    "environment": {
                        "type": "string",
                        "description": "- The Azure environment.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "- The unique path this backend should be mounted at. Defaults to `azure`.\n"
                    },
                    "subscriptionId": {
                        "type": "string",
                        "description": "- The subscription id for the Azure Active Directory.\n"
                    },
                    "tenantId": {
                        "type": "string",
                        "description": "- The tenant id for the Azure Active Directory.\n"
                    },
                    "useMicrosoftGraphApi": {
                        "type": "boolean",
                        "description": "- Use the Microsoft Graph API introduced in `vault-1.9`. \nShould be set to true for `vault-1.10+`\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:azure/backendRole:BackendRole": {
            "properties": {
                "applicationObjectId": {
                    "type": "string",
                    "description": "Application Object ID for an existing service principal that will\nbe used instead of creating dynamic service principals. If present, `azure_roles` will be ignored.\n"
                },
                "azureGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:azure/BackendRoleAzureGroup:BackendRoleAzureGroup"
                    },
                    "description": "List of Azure groups to be assigned to the generated service principal.\n"
                },
                "azureRoles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:azure/BackendRoleAzureRole:BackendRoleAzureRole"
                    },
                    "description": "List of Azure roles to be assigned to the generated service principal.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Path to the mounted Azure auth backend\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the backend.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Specifies the maximum TTL for service principals generated using this role. Accepts time\nsuffixed strings (\"1h\") or an integer number of seconds. Defaults to the system/engine max TTL time.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the Azure role\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Specifies the default TTL for service principals generated using this role.\nAccepts time suffixed strings (\"1h\") or an integer number of seconds. Defaults to the system/engine default TTL time.\n"
                }
            },
            "required": [
                "role"
            ],
            "inputProperties": {
                "applicationObjectId": {
                    "type": "string",
                    "description": "Application Object ID for an existing service principal that will\nbe used instead of creating dynamic service principals. If present, `azure_roles` will be ignored.\n"
                },
                "azureGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:azure/BackendRoleAzureGroup:BackendRoleAzureGroup"
                    },
                    "description": "List of Azure groups to be assigned to the generated service principal.\n"
                },
                "azureRoles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:azure/BackendRoleAzureRole:BackendRoleAzureRole"
                    },
                    "description": "List of Azure roles to be assigned to the generated service principal.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Path to the mounted Azure auth backend\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the backend.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Specifies the maximum TTL for service principals generated using this role. Accepts time\nsuffixed strings (\"1h\") or an integer number of seconds. Defaults to the system/engine max TTL time.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the Azure role\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Specifies the default TTL for service principals generated using this role.\nAccepts time suffixed strings (\"1h\") or an integer number of seconds. Defaults to the system/engine default TTL time.\n"
                }
            },
            "requiredInputs": [
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering BackendRole resources.\n",
                "properties": {
                    "applicationObjectId": {
                        "type": "string",
                        "description": "Application Object ID for an existing service principal that will\nbe used instead of creating dynamic service principals. If present, `azure_roles` will be ignored.\n"
                    },
                    "azureGroups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:azure/BackendRoleAzureGroup:BackendRoleAzureGroup"
                        },
                        "description": "List of Azure groups to be assigned to the generated service principal.\n"
                    },
                    "azureRoles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:azure/BackendRoleAzureRole:BackendRoleAzureRole"
                        },
                        "description": "List of Azure roles to be assigned to the generated service principal.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "Path to the mounted Azure auth backend\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Human-friendly description of the mount for the backend.\n"
                    },
                    "maxTtl": {
                        "type": "string",
                        "description": "Specifies the maximum TTL for service principals generated using this role. Accepts time\nsuffixed strings (\"1h\") or an integer number of seconds. Defaults to the system/engine max TTL time.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "Name of the Azure role\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Specifies the default TTL for service principals generated using this role.\nAccepts time suffixed strings (\"1h\") or an integer number of seconds. Defaults to the system/engine default TTL time.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:consul/secretBackend:SecretBackend": {
            "description": "\n\n\n## Import\n\nConsul secret backends can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:consul/secretBackend:SecretBackend example consul\n```\n\n ",
            "properties": {
                "address": {
                    "type": "string",
                    "description": "Specifies the address of the Consul instance, provided as \"host:port\" like \"127.0.0.1:8500\".\n"
                },
                "caCert": {
                    "type": "string",
                    "description": "CA certificate to use when verifying Consul server certificate, must be x509 PEM encoded.\n"
                },
                "clientCert": {
                    "type": "string",
                    "description": "Client certificate used for Consul's TLS communication, must be x509 PEM encoded and if this is set you need to also set client_key.\n"
                },
                "clientKey": {
                    "type": "string",
                    "description": "Client key used for Consul's TLS communication, must be x509 PEM encoded and if this is set you need to also set client_cert.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials issued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the secret backend is local only.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique location this backend should be mounted at. Must not begin or end with a `/`. Defaults to `consul`.\n"
                },
                "scheme": {
                    "type": "string",
                    "description": "Specifies the URL scheme to use. Defaults to `http`.\n"
                },
                "token": {
                    "type": "string",
                    "description": "The Consul management token this backend should use to issue new tokens.\n"
                }
            },
            "required": [
                "address",
                "token"
            ],
            "inputProperties": {
                "address": {
                    "type": "string",
                    "description": "Specifies the address of the Consul instance, provided as \"host:port\" like \"127.0.0.1:8500\".\n"
                },
                "caCert": {
                    "type": "string",
                    "description": "CA certificate to use when verifying Consul server certificate, must be x509 PEM encoded.\n"
                },
                "clientCert": {
                    "type": "string",
                    "description": "Client certificate used for Consul's TLS communication, must be x509 PEM encoded and if this is set you need to also set client_key.\n"
                },
                "clientKey": {
                    "type": "string",
                    "description": "Client key used for Consul's TLS communication, must be x509 PEM encoded and if this is set you need to also set client_cert.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials issued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the secret backend is local only.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique location this backend should be mounted at. Must not begin or end with a `/`. Defaults to `consul`.\n"
                },
                "scheme": {
                    "type": "string",
                    "description": "Specifies the URL scheme to use. Defaults to `http`.\n"
                },
                "token": {
                    "type": "string",
                    "description": "The Consul management token this backend should use to issue new tokens.\n"
                }
            },
            "requiredInputs": [
                "address",
                "token"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackend resources.\n",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "Specifies the address of the Consul instance, provided as \"host:port\" like \"127.0.0.1:8500\".\n"
                    },
                    "caCert": {
                        "type": "string",
                        "description": "CA certificate to use when verifying Consul server certificate, must be x509 PEM encoded.\n"
                    },
                    "clientCert": {
                        "type": "string",
                        "description": "Client certificate used for Consul's TLS communication, must be x509 PEM encoded and if this is set you need to also set client_key.\n"
                    },
                    "clientKey": {
                        "type": "string",
                        "description": "Client key used for Consul's TLS communication, must be x509 PEM encoded and if this is set you need to also set client_cert.\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The default TTL for credentials issued by this backend.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A human-friendly description for this backend.\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Specifies if the secret backend is local only.\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The unique location this backend should be mounted at. Must not begin or end with a `/`. Defaults to `consul`.\n"
                    },
                    "scheme": {
                        "type": "string",
                        "description": "Specifies the URL scheme to use. Defaults to `http`.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "The Consul management token this backend should use to issue new tokens.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:consul/secretBackendRole:SecretBackendRole": {
            "description": "Manages a Consul secrets role for a Consul secrets engine in Vault. Consul secret backends can then issue Consul tokens.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst test = new vault.consul.SecretBackend(\"test\", {\n    path: \"consul\",\n    description: \"Manages the Consul backend\",\n    address: \"127.0.0.1:8500\",\n    token: \"4240861b-ce3d-8530-115a-521ff070dd29\",\n});\nconst example = new vault.consul.SecretBackendRole(\"example\", {\n    backend: test.path,\n    policies: [\"example-policy\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntest = vault.consul.SecretBackend(\"test\",\n    path=\"consul\",\n    description=\"Manages the Consul backend\",\n    address=\"127.0.0.1:8500\",\n    token=\"4240861b-ce3d-8530-115a-521ff070dd29\")\nexample = vault.consul.SecretBackendRole(\"example\",\n    backend=test.path,\n    policies=[\"example-policy\"])\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var test = new Vault.Consul.SecretBackend(\"test\", new Vault.Consul.SecretBackendArgs\n        {\n            Path = \"consul\",\n            Description = \"Manages the Consul backend\",\n            Address = \"127.0.0.1:8500\",\n            Token = \"4240861b-ce3d-8530-115a-521ff070dd29\",\n        });\n        var example = new Vault.Consul.SecretBackendRole(\"example\", new Vault.Consul.SecretBackendRoleArgs\n        {\n            Backend = test.Path,\n            Policies = \n            {\n                \"example-policy\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := consul.NewSecretBackend(ctx, \"test\", \u0026consul.SecretBackendArgs{\n\t\t\tPath:        pulumi.String(\"consul\"),\n\t\t\tDescription: pulumi.String(\"Manages the Consul backend\"),\n\t\t\tAddress:     pulumi.String(\"127.0.0.1:8500\"),\n\t\t\tToken:       pulumi.String(\"4240861b-ce3d-8530-115a-521ff070dd29\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = consul.NewSecretBackendRole(ctx, \"example\", \u0026consul.SecretBackendRoleArgs{\n\t\t\tBackend: test.Path,\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"example-policy\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nConsul secret backend roles can be imported using the `backend`, `/roles/`, and the `name` e.g.\n\n```sh\n $ pulumi import vault:consul/secretBackendRole:SecretBackendRole example consul/roles/my-role\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of an existing Consul secrets backend mount. Must not begin or end with a `/`. One of `path` or `backend` is required.\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Indicates that the token should not be replicated globally and instead be local to the current datacenter.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "Maximum TTL for leases associated with this role, in seconds.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Consul secrets engine role to create.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of Consul ACL policies to associate with these roles.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "Specifies the type of token to create when using this role. Valid values are \"client\" or \"management\".\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "Specifies the TTL for this role.\n"
                }
            },
            "required": [
                "name",
                "policies"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of an existing Consul secrets backend mount. Must not begin or end with a `/`. One of `path` or `backend` is required.\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Indicates that the token should not be replicated globally and instead be local to the current datacenter.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "Maximum TTL for leases associated with this role, in seconds.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Consul secrets engine role to create.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of Consul ACL policies to associate with these roles.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "Specifies the type of token to create when using this role. Valid values are \"client\" or \"management\".\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "Specifies the TTL for this role.\n"
                }
            },
            "requiredInputs": [
                "policies"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The unique name of an existing Consul secrets backend mount. Must not begin or end with a `/`. One of `path` or `backend` is required.\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Indicates that the token should not be replicated globally and instead be local to the current datacenter.\n"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "Maximum TTL for leases associated with this role, in seconds.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Consul secrets engine role to create.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of Consul ACL policies to associate with these roles.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "Specifies the type of token to create when using this role. Valid values are \"client\" or \"management\".\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "Specifies the TTL for this role.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:database/secretBackendConnection:SecretBackendConnection": {
            "description": "\n\n\n## Import\n\nDatabase secret backend connections can be imported using the `backend`, `/config/`, and the `name` e.g.\n\n```sh\n $ pulumi import vault:database/secretBackendConnection:SecretBackendConnection example postgres/config/postgres\n```\n\n ",
            "properties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of roles that are allowed to use this\nconnection.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique name of the Vault mount to configure.\n"
                },
                "cassandra": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionCassandra:SecretBackendConnectionCassandra",
                    "description": "A nested block containing configuration options for Cassandra connections.\n"
                },
                "couchbase": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionCouchbase:SecretBackendConnectionCouchbase",
                    "description": "A nested block containing configuration options for Couchbase connections.\n"
                },
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n"
                },
                "elasticsearch": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionElasticsearch:SecretBackendConnectionElasticsearch",
                    "description": "A nested block containing configuration options for Elasticsearch connections.\n"
                },
                "hana": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionHana:SecretBackendConnectionHana",
                    "description": "A nested block containing configuration options for SAP HanaDB connections.\n"
                },
                "influxdb": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionInfluxdb:SecretBackendConnectionInfluxdb",
                    "description": "A nested block containing configuration options for InfluxDB connections.\n"
                },
                "mongodb": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMongodb:SecretBackendConnectionMongodb",
                    "description": "A nested block containing configuration options for MongoDB connections.\n"
                },
                "mongodbatlas": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMongodbatlas:SecretBackendConnectionMongodbatlas",
                    "description": "A nested block containing configuration options for MongoDB Atlas connections.\n"
                },
                "mssql": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMssql:SecretBackendConnectionMssql",
                    "description": "A nested block containing configuration options for MSSQL connections.\n"
                },
                "mysql": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysql:SecretBackendConnectionMysql",
                    "description": "A nested block containing configuration options for MySQL connections.\n"
                },
                "mysqlAurora": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysqlAurora:SecretBackendConnectionMysqlAurora",
                    "description": "A nested block containing configuration options for Aurora MySQL connections.\n"
                },
                "mysqlLegacy": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysqlLegacy:SecretBackendConnectionMysqlLegacy",
                    "description": "A nested block containing configuration options for legacy MySQL connections.\n"
                },
                "mysqlRds": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysqlRds:SecretBackendConnectionMysqlRds",
                    "description": "A nested block containing configuration options for RDS MySQL connections.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to give the database connection.\n"
                },
                "oracle": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionOracle:SecretBackendConnectionOracle",
                    "description": "A nested block containing configuration options for Oracle connections.\n"
                },
                "pluginName": {
                    "type": "string",
                    "description": "Specifies the name of the plugin to use. All values must be prefixed\nto match the corresponding database engine directive.\nFor example the `plugin_name` for the `mysql_aurora` engine must begin with `mysql-aurora`. Note the hyphenation.\n"
                },
                "postgresql": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionPostgresql:SecretBackendConnectionPostgresql",
                    "description": "A nested block containing configuration options for PostgreSQL connections.\n"
                },
                "redshift": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionRedshift:SecretBackendConnectionRedshift",
                    "description": "Connection parameters for the redshift-database-plugin plugin.\n"
                },
                "rootRotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of database statements to be executed to rotate the root user's credentials.\n"
                },
                "snowflake": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionSnowflake:SecretBackendConnectionSnowflake",
                    "description": "A nested block containing configuration options for Snowflake connections.\n"
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Whether the connection should be verified on\ninitial configuration or not.\n"
                }
            },
            "required": [
                "backend",
                "name",
                "pluginName"
            ],
            "inputProperties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of roles that are allowed to use this\nconnection.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique name of the Vault mount to configure.\n"
                },
                "cassandra": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionCassandra:SecretBackendConnectionCassandra",
                    "description": "A nested block containing configuration options for Cassandra connections.\n"
                },
                "couchbase": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionCouchbase:SecretBackendConnectionCouchbase",
                    "description": "A nested block containing configuration options for Couchbase connections.\n"
                },
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n"
                },
                "elasticsearch": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionElasticsearch:SecretBackendConnectionElasticsearch",
                    "description": "A nested block containing configuration options for Elasticsearch connections.\n"
                },
                "hana": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionHana:SecretBackendConnectionHana",
                    "description": "A nested block containing configuration options for SAP HanaDB connections.\n"
                },
                "influxdb": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionInfluxdb:SecretBackendConnectionInfluxdb",
                    "description": "A nested block containing configuration options for InfluxDB connections.\n"
                },
                "mongodb": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMongodb:SecretBackendConnectionMongodb",
                    "description": "A nested block containing configuration options for MongoDB connections.\n"
                },
                "mongodbatlas": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMongodbatlas:SecretBackendConnectionMongodbatlas",
                    "description": "A nested block containing configuration options for MongoDB Atlas connections.\n"
                },
                "mssql": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMssql:SecretBackendConnectionMssql",
                    "description": "A nested block containing configuration options for MSSQL connections.\n"
                },
                "mysql": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysql:SecretBackendConnectionMysql",
                    "description": "A nested block containing configuration options for MySQL connections.\n"
                },
                "mysqlAurora": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysqlAurora:SecretBackendConnectionMysqlAurora",
                    "description": "A nested block containing configuration options for Aurora MySQL connections.\n"
                },
                "mysqlLegacy": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysqlLegacy:SecretBackendConnectionMysqlLegacy",
                    "description": "A nested block containing configuration options for legacy MySQL connections.\n"
                },
                "mysqlRds": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysqlRds:SecretBackendConnectionMysqlRds",
                    "description": "A nested block containing configuration options for RDS MySQL connections.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to give the database connection.\n"
                },
                "oracle": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionOracle:SecretBackendConnectionOracle",
                    "description": "A nested block containing configuration options for Oracle connections.\n"
                },
                "pluginName": {
                    "type": "string",
                    "description": "Specifies the name of the plugin to use. All values must be prefixed\nto match the corresponding database engine directive.\nFor example the `plugin_name` for the `mysql_aurora` engine must begin with `mysql-aurora`. Note the hyphenation.\n"
                },
                "postgresql": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionPostgresql:SecretBackendConnectionPostgresql",
                    "description": "A nested block containing configuration options for PostgreSQL connections.\n"
                },
                "redshift": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionRedshift:SecretBackendConnectionRedshift",
                    "description": "Connection parameters for the redshift-database-plugin plugin.\n"
                },
                "rootRotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of database statements to be executed to rotate the root user's credentials.\n"
                },
                "snowflake": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionSnowflake:SecretBackendConnectionSnowflake",
                    "description": "A nested block containing configuration options for Snowflake connections.\n"
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Whether the connection should be verified on\ninitial configuration or not.\n"
                }
            },
            "requiredInputs": [
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendConnection resources.\n",
                "properties": {
                    "allowedRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of roles that are allowed to use this\nconnection.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The unique name of the Vault mount to configure.\n"
                    },
                    "cassandra": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionCassandra:SecretBackendConnectionCassandra",
                        "description": "A nested block containing configuration options for Cassandra connections.\n"
                    },
                    "couchbase": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionCouchbase:SecretBackendConnectionCouchbase",
                        "description": "A nested block containing configuration options for Couchbase connections.\n"
                    },
                    "data": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n"
                    },
                    "elasticsearch": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionElasticsearch:SecretBackendConnectionElasticsearch",
                        "description": "A nested block containing configuration options for Elasticsearch connections.\n"
                    },
                    "hana": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionHana:SecretBackendConnectionHana",
                        "description": "A nested block containing configuration options for SAP HanaDB connections.\n"
                    },
                    "influxdb": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionInfluxdb:SecretBackendConnectionInfluxdb",
                        "description": "A nested block containing configuration options for InfluxDB connections.\n"
                    },
                    "mongodb": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionMongodb:SecretBackendConnectionMongodb",
                        "description": "A nested block containing configuration options for MongoDB connections.\n"
                    },
                    "mongodbatlas": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionMongodbatlas:SecretBackendConnectionMongodbatlas",
                        "description": "A nested block containing configuration options for MongoDB Atlas connections.\n"
                    },
                    "mssql": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionMssql:SecretBackendConnectionMssql",
                        "description": "A nested block containing configuration options for MSSQL connections.\n"
                    },
                    "mysql": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionMysql:SecretBackendConnectionMysql",
                        "description": "A nested block containing configuration options for MySQL connections.\n"
                    },
                    "mysqlAurora": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionMysqlAurora:SecretBackendConnectionMysqlAurora",
                        "description": "A nested block containing configuration options for Aurora MySQL connections.\n"
                    },
                    "mysqlLegacy": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionMysqlLegacy:SecretBackendConnectionMysqlLegacy",
                        "description": "A nested block containing configuration options for legacy MySQL connections.\n"
                    },
                    "mysqlRds": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionMysqlRds:SecretBackendConnectionMysqlRds",
                        "description": "A nested block containing configuration options for RDS MySQL connections.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name to give the database connection.\n"
                    },
                    "oracle": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionOracle:SecretBackendConnectionOracle",
                        "description": "A nested block containing configuration options for Oracle connections.\n"
                    },
                    "pluginName": {
                        "type": "string",
                        "description": "Specifies the name of the plugin to use. All values must be prefixed\nto match the corresponding database engine directive.\nFor example the `plugin_name` for the `mysql_aurora` engine must begin with `mysql-aurora`. Note the hyphenation.\n"
                    },
                    "postgresql": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionPostgresql:SecretBackendConnectionPostgresql",
                        "description": "A nested block containing configuration options for PostgreSQL connections.\n"
                    },
                    "redshift": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionRedshift:SecretBackendConnectionRedshift",
                        "description": "Connection parameters for the redshift-database-plugin plugin.\n"
                    },
                    "rootRotationStatements": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of database statements to be executed to rotate the root user's credentials.\n"
                    },
                    "snowflake": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionSnowflake:SecretBackendConnectionSnowflake",
                        "description": "A nested block containing configuration options for Snowflake connections.\n"
                    },
                    "verifyConnection": {
                        "type": "boolean",
                        "description": "Whether the connection should be verified on\ninitial configuration or not.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:database/secretBackendRole:SecretBackendRole": {
            "description": "\n\n\n## Import\n\nDatabase secret backend roles can be imported using the `backend`, `/roles/`, and the `name` e.g.\n\n```sh\n $ pulumi import vault:database/secretBackendRole:SecretBackendRole example postgres/roles/my-role\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of the Vault mount to configure.\n"
                },
                "creationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\ncreating a user.\n"
                },
                "dbName": {
                    "type": "string",
                    "description": "The unique name of the database connection to use for\nthe role.\n"
                },
                "defaultTtl": {
                    "type": "integer",
                    "description": "The default number of seconds for leases for this\nrole.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum number of seconds for leases for this\nrole.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to give the role.\n"
                },
                "renewStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\nrenewing a user.\n"
                },
                "revocationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\nrevoking a user.\n"
                },
                "rollbackStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\nrolling back creation due to an error.\n"
                }
            },
            "required": [
                "backend",
                "creationStatements",
                "dbName",
                "name"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of the Vault mount to configure.\n"
                },
                "creationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\ncreating a user.\n"
                },
                "dbName": {
                    "type": "string",
                    "description": "The unique name of the database connection to use for\nthe role.\n"
                },
                "defaultTtl": {
                    "type": "integer",
                    "description": "The default number of seconds for leases for this\nrole.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum number of seconds for leases for this\nrole.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to give the role.\n"
                },
                "renewStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\nrenewing a user.\n"
                },
                "revocationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\nrevoking a user.\n"
                },
                "rollbackStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\nrolling back creation due to an error.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "creationStatements",
                "dbName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The unique name of the Vault mount to configure.\n"
                    },
                    "creationStatements": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The database statements to execute when\ncreating a user.\n"
                    },
                    "dbName": {
                        "type": "string",
                        "description": "The unique name of the database connection to use for\nthe role.\n"
                    },
                    "defaultTtl": {
                        "type": "integer",
                        "description": "The default number of seconds for leases for this\nrole.\n"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "The maximum number of seconds for leases for this\nrole.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name to give the role.\n"
                    },
                    "renewStatements": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The database statements to execute when\nrenewing a user.\n"
                    },
                    "revocationStatements": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The database statements to execute when\nrevoking a user.\n"
                    },
                    "rollbackStatements": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The database statements to execute when\nrolling back creation due to an error.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:database/secretBackendStaticRole:SecretBackendStaticRole": {
            "description": "Creates a Database Secret Backend static role in Vault. Database secret backend\nstatic roles can be used to manage 1-to-1 mapping of a Vault Role to a user in a\ndatabase for the database.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst db = new vault.Mount(\"db\", {\n    path: \"postgres\",\n    type: \"database\",\n});\nconst postgres = new vault.database.SecretBackendConnection(\"postgres\", {\n    backend: db.path,\n    allowedRoles: [\"*\"],\n    postgresql: {\n        connectionUrl: \"postgres://username:password@host:port/database\",\n    },\n});\nconst staticRole = new vault.database.SecretBackendStaticRole(\"staticRole\", {\n    backend: db.path,\n    dbName: postgres.name,\n    username: \"example\",\n    rotationPeriod: \"3600\",\n    rotationStatements: [\"ALTER USER \\\"{{name}}\\\" WITH PASSWORD '{{password}}';\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ndb = vault.Mount(\"db\",\n    path=\"postgres\",\n    type=\"database\")\npostgres = vault.database.SecretBackendConnection(\"postgres\",\n    backend=db.path,\n    allowed_roles=[\"*\"],\n    postgresql=vault.database.SecretBackendConnectionPostgresqlArgs(\n        connection_url=\"postgres://username:password@host:port/database\",\n    ))\nstatic_role = vault.database.SecretBackendStaticRole(\"staticRole\",\n    backend=db.path,\n    db_name=postgres.name,\n    username=\"example\",\n    rotation_period=3600,\n    rotation_statements=[\"ALTER USER \\\"{{name}}\\\" WITH PASSWORD '{{password}}';\"])\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var db = new Vault.Mount(\"db\", new Vault.MountArgs\n        {\n            Path = \"postgres\",\n            Type = \"database\",\n        });\n        var postgres = new Vault.Database.SecretBackendConnection(\"postgres\", new Vault.Database.SecretBackendConnectionArgs\n        {\n            Backend = db.Path,\n            AllowedRoles = \n            {\n                \"*\",\n            },\n            Postgresql = new Vault.Database.Inputs.SecretBackendConnectionPostgresqlArgs\n            {\n                ConnectionUrl = \"postgres://username:password@host:port/database\",\n            },\n        });\n        var staticRole = new Vault.Database.SecretBackendStaticRole(\"staticRole\", new Vault.Database.SecretBackendStaticRoleArgs\n        {\n            Backend = db.Path,\n            DbName = postgres.Name,\n            Username = \"example\",\n            RotationPeriod = 3600,\n            RotationStatements = \n            {\n                \"ALTER USER \\\"{{name}}\\\" WITH PASSWORD '{{password}}';\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/database\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdb, err := vault.NewMount(ctx, \"db\", \u0026vault.MountArgs{\n\t\t\tPath: pulumi.String(\"postgres\"),\n\t\t\tType: pulumi.String(\"database\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpostgres, err := database.NewSecretBackendConnection(ctx, \"postgres\", \u0026database.SecretBackendConnectionArgs{\n\t\t\tBackend: db.Path,\n\t\t\tAllowedRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"*\"),\n\t\t\t},\n\t\t\tPostgresql: \u0026database.SecretBackendConnectionPostgresqlArgs{\n\t\t\t\tConnectionUrl: pulumi.String(\"postgres://username:password@host:port/database\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = database.NewSecretBackendStaticRole(ctx, \"staticRole\", \u0026database.SecretBackendStaticRoleArgs{\n\t\t\tBackend:        db.Path,\n\t\t\tDbName:         postgres.Name,\n\t\t\tUsername:       pulumi.String(\"example\"),\n\t\t\tRotationPeriod: pulumi.Int(3600),\n\t\t\tRotationStatements: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"ALTER USER \\\"{{name}}\\\" WITH PASSWORD '{{password}}';\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nDatabase secret backend static roles can be imported using the `backend`, `/static-roles/`, and the `name` e.g.\n\n```sh\n $ pulumi import vault:database/secretBackendStaticRole:SecretBackendStaticRole example postgres/static-roles/my-role\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of the Vault mount to configure.\n"
                },
                "dbName": {
                    "type": "string",
                    "description": "The unique name of the database connection to use for the static role.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to give the static role.\n"
                },
                "rotationPeriod": {
                    "type": "integer",
                    "description": "The amount of time Vault should wait before rotating the password, in seconds.\n"
                },
                "rotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Database statements to execute to rotate the password for the configured database user.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The database username that this static role corresponds to.\n"
                }
            },
            "required": [
                "backend",
                "dbName",
                "name",
                "rotationPeriod",
                "username"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of the Vault mount to configure.\n"
                },
                "dbName": {
                    "type": "string",
                    "description": "The unique name of the database connection to use for the static role.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to give the static role.\n"
                },
                "rotationPeriod": {
                    "type": "integer",
                    "description": "The amount of time Vault should wait before rotating the password, in seconds.\n"
                },
                "rotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Database statements to execute to rotate the password for the configured database user.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The database username that this static role corresponds to.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "dbName",
                "rotationPeriod",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendStaticRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The unique name of the Vault mount to configure.\n"
                    },
                    "dbName": {
                        "type": "string",
                        "description": "The unique name of the database connection to use for the static role.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name to give the static role.\n"
                    },
                    "rotationPeriod": {
                        "type": "integer",
                        "description": "The amount of time Vault should wait before rotating the password, in seconds.\n"
                    },
                    "rotationStatements": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Database statements to execute to rotate the password for the configured database user.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "The database username that this static role corresponds to.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:gcp/authBackend:AuthBackend": {
            "description": "Provides a resource to configure the [GCP auth backend within Vault](https://www.vaultproject.io/docs/auth/gcp.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\nimport * from \"fs\";\n\nconst gcp = new vault.gcp.AuthBackend(\"gcp\", {credentials: fs.readFileSync(\"vault-gcp-credentials.json\")});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ngcp = vault.gcp.AuthBackend(\"gcp\", credentials=(lambda path: open(path).read())(\"vault-gcp-credentials.json\"))\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var gcp = new Vault.Gcp.AuthBackend(\"gcp\", new Vault.Gcp.AuthBackendArgs\n        {\n            Credentials = File.ReadAllText(\"vault-gcp-credentials.json\"),\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/gcp\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gcp.NewAuthBackend(ctx, \"gcp\", \u0026gcp.AuthBackendArgs{\n\t\t\tCredentials: readFileOrPanic(\"vault-gcp-credentials.json\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGCP authentication backends can be imported using the backend name, e.g.\n\n```sh\n $ pulumi import vault:gcp/authBackend:AuthBackend gcp gcp\n```\n\n ",
            "properties": {
                "clientEmail": {
                    "type": "string",
                    "description": "The clients email associated with the credentials\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The Client ID of the credentials\n"
                },
                "credentials": {
                    "type": "string",
                    "description": "A JSON string containing the contents of a GCP credentials file. If this value is empty, Vault will try to use Application Default Credentials from the machine on which the Vault server is running.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description of the auth method.\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the auth method is local only.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path to mount the auth method  this defaults to 'gcp'.\n"
                },
                "privateKeyId": {
                    "type": "string",
                    "description": "The ID of the private key from the credentials\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The GCP Project ID\n"
                }
            },
            "required": [
                "clientEmail",
                "clientId",
                "privateKeyId",
                "projectId"
            ],
            "inputProperties": {
                "clientEmail": {
                    "type": "string",
                    "description": "The clients email associated with the credentials\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The Client ID of the credentials\n"
                },
                "credentials": {
                    "type": "string",
                    "description": "A JSON string containing the contents of a GCP credentials file. If this value is empty, Vault will try to use Application Default Credentials from the machine on which the Vault server is running.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description of the auth method.\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the auth method is local only.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path to mount the auth method  this defaults to 'gcp'.\n"
                },
                "privateKeyId": {
                    "type": "string",
                    "description": "The ID of the private key from the credentials\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The GCP Project ID\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackend resources.\n",
                "properties": {
                    "clientEmail": {
                        "type": "string",
                        "description": "The clients email associated with the credentials\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The Client ID of the credentials\n"
                    },
                    "credentials": {
                        "type": "string",
                        "description": "A JSON string containing the contents of a GCP credentials file. If this value is empty, Vault will try to use Application Default Credentials from the machine on which the Vault server is running.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description of the auth method.\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Specifies if the auth method is local only.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path to mount the auth method  this defaults to 'gcp'.\n"
                    },
                    "privateKeyId": {
                        "type": "string",
                        "description": "The ID of the private key from the credentials\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The GCP Project ID\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:gcp/authBackendRole:AuthBackendRole": {
            "description": "Provides a resource to create a role in an [GCP auth backend within Vault](https://www.vaultproject.io/docs/auth/gcp.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst gcpAuthBackend = new vault.AuthBackend(\"gcpAuthBackend\", {\n    path: \"gcp\",\n    type: \"gcp\",\n});\nconst gcpAuthBackendRole = new vault.gcp.AuthBackendRole(\"gcpAuthBackendRole\", {\n    backend: gcpAuthBackend.path,\n    projectId: \"foo-bar-baz\",\n    boundServiceAccounts: [\"database-server@foo-bar-baz.iam.gserviceaccount.com\"],\n    tokenPolicies: [\"database-server\"],\n});\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGCP authentication roles can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:gcp/authBackendRole:AuthBackendRole my_role auth/gcp/role/my_role\n```\n\n ",
            "properties": {
                "addGroupAliases": {
                    "type": "boolean"
                },
                "allowGceInference": {
                    "type": "boolean",
                    "description": "A flag to determine if this role should allow GCE instances to authenticate by inferring service accounts from the GCE identity metadata token.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Path to the mounted GCP auth backend\n"
                },
                "boundInstanceGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The instance groups that an authorized instance must belong to in order to be authenticated. If specified, either `bound_zones` or `bound_regions` must be set too.\n"
                },
                "boundLabels": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A comma-separated list of GCP labels formatted as `\"key:value\"` strings that must be set on authorized GCE instances. Because GCP labels are not currently ACL'd, we recommend that this be used in conjunction with other restrictions.\n"
                },
                "boundProjects": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "GCP Projects that the role exists within\n"
                },
                "boundRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of regions that a GCE instance must belong to in order to be authenticated. If bound_instance_groups is provided, it is assumed to be a regional group and the group must belong to this region. If bound_zones are provided, this attribute is ignored.\n"
                },
                "boundServiceAccounts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "GCP Service Accounts allowed to issue tokens under this role. (Note: **Required** if role is `iam`)\n"
                },
                "boundZones": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of zones that a GCE instance must belong to in order to be authenticated. If bound_instance_groups is provided, it is assumed to be a zonal group and the group must belong to this zone.\n"
                },
                "maxJwtExp": {
                    "type": "string",
                    "description": "The number of seconds past the time of authentication that the login param JWT must expire within. For example, if a user attempts to login with a token that expires within an hour and this is set to 15 minutes, Vault will return an error prompting the user to create a new signed JWT with a shorter `exp`. The GCE metadata tokens currently do not allow the `exp` claim to be customized.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the GCP role\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of GCP authentication role (either `gce` or `iam`)\n"
                }
            },
            "required": [
                "addGroupAliases",
                "allowGceInference",
                "boundInstanceGroups",
                "boundLabels",
                "boundRegions",
                "boundServiceAccounts",
                "boundZones",
                "maxJwtExp",
                "role",
                "type"
            ],
            "inputProperties": {
                "addGroupAliases": {
                    "type": "boolean"
                },
                "allowGceInference": {
                    "type": "boolean",
                    "description": "A flag to determine if this role should allow GCE instances to authenticate by inferring service accounts from the GCE identity metadata token.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Path to the mounted GCP auth backend\n"
                },
                "boundInstanceGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The instance groups that an authorized instance must belong to in order to be authenticated. If specified, either `bound_zones` or `bound_regions` must be set too.\n"
                },
                "boundLabels": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A comma-separated list of GCP labels formatted as `\"key:value\"` strings that must be set on authorized GCE instances. Because GCP labels are not currently ACL'd, we recommend that this be used in conjunction with other restrictions.\n"
                },
                "boundProjects": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "GCP Projects that the role exists within\n"
                },
                "boundRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of regions that a GCE instance must belong to in order to be authenticated. If bound_instance_groups is provided, it is assumed to be a regional group and the group must belong to this region. If bound_zones are provided, this attribute is ignored.\n"
                },
                "boundServiceAccounts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "GCP Service Accounts allowed to issue tokens under this role. (Note: **Required** if role is `iam`)\n"
                },
                "boundZones": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of zones that a GCE instance must belong to in order to be authenticated. If bound_instance_groups is provided, it is assumed to be a zonal group and the group must belong to this zone.\n"
                },
                "maxJwtExp": {
                    "type": "string",
                    "description": "The number of seconds past the time of authentication that the login param JWT must expire within. For example, if a user attempts to login with a token that expires within an hour and this is set to 15 minutes, Vault will return an error prompting the user to create a new signed JWT with a shorter `exp`. The GCE metadata tokens currently do not allow the `exp` claim to be customized.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the GCP role\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of GCP authentication role (either `gce` or `iam`)\n"
                }
            },
            "requiredInputs": [
                "role",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "addGroupAliases": {
                        "type": "boolean"
                    },
                    "allowGceInference": {
                        "type": "boolean",
                        "description": "A flag to determine if this role should allow GCE instances to authenticate by inferring service accounts from the GCE identity metadata token.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "Path to the mounted GCP auth backend\n"
                    },
                    "boundInstanceGroups": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The instance groups that an authorized instance must belong to in order to be authenticated. If specified, either `bound_zones` or `bound_regions` must be set too.\n"
                    },
                    "boundLabels": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A comma-separated list of GCP labels formatted as `\"key:value\"` strings that must be set on authorized GCE instances. Because GCP labels are not currently ACL'd, we recommend that this be used in conjunction with other restrictions.\n"
                    },
                    "boundProjects": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "GCP Projects that the role exists within\n"
                    },
                    "boundRegions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of regions that a GCE instance must belong to in order to be authenticated. If bound_instance_groups is provided, it is assumed to be a regional group and the group must belong to this region. If bound_zones are provided, this attribute is ignored.\n"
                    },
                    "boundServiceAccounts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "GCP Service Accounts allowed to issue tokens under this role. (Note: **Required** if role is `iam`)\n"
                    },
                    "boundZones": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of zones that a GCE instance must belong to in order to be authenticated. If bound_instance_groups is provided, it is assumed to be a zonal group and the group must belong to this zone.\n"
                    },
                    "maxJwtExp": {
                        "type": "string",
                        "description": "The number of seconds past the time of authentication that the login param JWT must expire within. For example, if a user attempts to login with a token that expires within an hour and this is set to 15 minutes, Vault will return an error prompting the user to create a new signed JWT with a shorter `exp`. The GCE metadata tokens currently do not allow the `exp` claim to be customized.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "Name of the GCP role\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of GCP authentication role (either `gce` or `iam`)\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:gcp/secretBackend:SecretBackend": {
            "properties": {
                "credentials": {
                    "type": "string",
                    "description": "The GCP service account credentials in JSON format.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials\nissued by this backend. Defaults to '0'.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Boolean flag that can be explicitly set to true to enforce local mount in HA environment\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend. Defaults to '0'.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `gcp`.\n"
                }
            },
            "inputProperties": {
                "credentials": {
                    "type": "string",
                    "description": "The GCP service account credentials in JSON format.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials\nissued by this backend. Defaults to '0'.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Boolean flag that can be explicitly set to true to enforce local mount in HA environment\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend. Defaults to '0'.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `gcp`.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackend resources.\n",
                "properties": {
                    "credentials": {
                        "type": "string",
                        "description": "The GCP service account credentials in JSON format.\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The default TTL for credentials\nissued by this backend. Defaults to '0'.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A human-friendly description for this backend.\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Boolean flag that can be explicitly set to true to enforce local mount in HA environment\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The maximum TTL that can be requested\nfor credentials issued by this backend. Defaults to '0'.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `gcp`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:gcp/secretRoleset:SecretRoleset": {
            "description": "Creates a Roleset in the [GCP Secrets Engine](https://www.vaultproject.io/docs/secrets/gcp/index.html) for Vault.\n\nEach Roleset is [tied](https://www.vaultproject.io/docs/secrets/gcp/index.html#service-accounts-are-tied-to-rolesets) to a Service Account, and can have one or more [bindings](https://www.vaultproject.io/docs/secrets/gcp/index.html#roleset-bindings) associated with it.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\nimport * from \"fs\";\n\nconst project = \"my-awesome-project\";\nconst gcp = new vault.gcp.SecretBackend(\"gcp\", {\n    path: \"gcp\",\n    credentials: fs.readFileSync(\"credentials.json\"),\n});\nconst roleset = new vault.gcp.SecretRoleset(\"roleset\", {\n    backend: gcp.path,\n    roleset: \"project_viewer\",\n    secretType: \"access_token\",\n    project: project,\n    tokenScopes: [\"https://www.googleapis.com/auth/cloud-platform\"],\n    bindings: [{\n        resource: `//cloudresourcemanager.googleapis.com/projects/${project}`,\n        roles: [\"roles/viewer\"],\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nproject = \"my-awesome-project\"\ngcp = vault.gcp.SecretBackend(\"gcp\",\n    path=\"gcp\",\n    credentials=(lambda path: open(path).read())(\"credentials.json\"))\nroleset = vault.gcp.SecretRoleset(\"roleset\",\n    backend=gcp.path,\n    roleset=\"project_viewer\",\n    secret_type=\"access_token\",\n    project=project,\n    token_scopes=[\"https://www.googleapis.com/auth/cloud-platform\"],\n    bindings=[vault.gcp.SecretRolesetBindingArgs(\n        resource=f\"//cloudresourcemanager.googleapis.com/projects/{project}\",\n        roles=[\"roles/viewer\"],\n    )])\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var project = \"my-awesome-project\";\n        var gcp = new Vault.Gcp.SecretBackend(\"gcp\", new Vault.Gcp.SecretBackendArgs\n        {\n            Path = \"gcp\",\n            Credentials = File.ReadAllText(\"credentials.json\"),\n        });\n        var roleset = new Vault.Gcp.SecretRoleset(\"roleset\", new Vault.Gcp.SecretRolesetArgs\n        {\n            Backend = gcp.Path,\n            Roleset = \"project_viewer\",\n            SecretType = \"access_token\",\n            Project = project,\n            TokenScopes = \n            {\n                \"https://www.googleapis.com/auth/cloud-platform\",\n            },\n            Bindings = \n            {\n                new Vault.Gcp.Inputs.SecretRolesetBindingArgs\n                {\n                    Resource = $\"//cloudresourcemanager.googleapis.com/projects/{project}\",\n                    Roles = \n                    {\n                        \"roles/viewer\",\n                    },\n                },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/gcp\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tproject := \"my-awesome-project\"\n\t\tgcp, err := gcp.NewSecretBackend(ctx, \"gcp\", \u0026gcp.SecretBackendArgs{\n\t\t\tPath:        pulumi.String(\"gcp\"),\n\t\t\tCredentials: readFileOrPanic(\"credentials.json\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gcp.NewSecretRoleset(ctx, \"roleset\", \u0026gcp.SecretRolesetArgs{\n\t\t\tBackend:    gcp.Path,\n\t\t\tRoleset:    pulumi.String(\"project_viewer\"),\n\t\t\tSecretType: pulumi.String(\"access_token\"),\n\t\t\tProject:    pulumi.String(project),\n\t\t\tTokenScopes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"https://www.googleapis.com/auth/cloud-platform\"),\n\t\t\t},\n\t\t\tBindings: gcp.SecretRolesetBindingArray{\n\t\t\t\t\u0026gcp.SecretRolesetBindingArgs{\n\t\t\t\t\tResource: pulumi.String(fmt.Sprintf(\"%v%v\", \"//cloudresourcemanager.googleapis.com/projects/\", project)),\n\t\t\t\t\tRoles: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"roles/viewer\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nA roleset can be imported using its Vault Path. For example, referencing the example above,\n\n```sh\n $ pulumi import vault:gcp/secretRoleset:SecretRoleset roleset gcp/roleset/project_viewer\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the GCP Secrets Engine is mounted\n"
                },
                "bindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:gcp/SecretRolesetBinding:SecretRolesetBinding"
                    },
                    "description": "Bindings to create for this roleset. This can be specified multiple times for multiple bindings. Structure is documented below.\n"
                },
                "project": {
                    "type": "string",
                    "description": "Name of the GCP project that this roleset's service account will belong to.\n"
                },
                "roleset": {
                    "type": "string",
                    "description": "Name of the Roleset to create\n"
                },
                "secretType": {
                    "type": "string",
                    "description": "Type of secret generated for this role set. Accepted values: `access_token`, `service_account_key`. Defaults to `access_token`.\n"
                },
                "serviceAccountEmail": {
                    "type": "string",
                    "description": "Email of the service account created by Vault for this Roleset\n"
                },
                "tokenScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of OAuth scopes to assign to `access_token` secrets generated under this role set (`access_token` role sets only).\n"
                }
            },
            "required": [
                "backend",
                "bindings",
                "project",
                "roleset",
                "secretType",
                "serviceAccountEmail"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the GCP Secrets Engine is mounted\n"
                },
                "bindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:gcp/SecretRolesetBinding:SecretRolesetBinding"
                    },
                    "description": "Bindings to create for this roleset. This can be specified multiple times for multiple bindings. Structure is documented below.\n"
                },
                "project": {
                    "type": "string",
                    "description": "Name of the GCP project that this roleset's service account will belong to.\n"
                },
                "roleset": {
                    "type": "string",
                    "description": "Name of the Roleset to create\n"
                },
                "secretType": {
                    "type": "string",
                    "description": "Type of secret generated for this role set. Accepted values: `access_token`, `service_account_key`. Defaults to `access_token`.\n"
                },
                "tokenScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of OAuth scopes to assign to `access_token` secrets generated under this role set (`access_token` role sets only).\n"
                }
            },
            "requiredInputs": [
                "backend",
                "bindings",
                "project",
                "roleset"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretRoleset resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Path where the GCP Secrets Engine is mounted\n"
                    },
                    "bindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:gcp/SecretRolesetBinding:SecretRolesetBinding"
                        },
                        "description": "Bindings to create for this roleset. This can be specified multiple times for multiple bindings. Structure is documented below.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "Name of the GCP project that this roleset's service account will belong to.\n"
                    },
                    "roleset": {
                        "type": "string",
                        "description": "Name of the Roleset to create\n"
                    },
                    "secretType": {
                        "type": "string",
                        "description": "Type of secret generated for this role set. Accepted values: `access_token`, `service_account_key`. Defaults to `access_token`.\n"
                    },
                    "serviceAccountEmail": {
                        "type": "string",
                        "description": "Email of the service account created by Vault for this Roleset\n"
                    },
                    "tokenScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of OAuth scopes to assign to `access_token` secrets generated under this role set (`access_token` role sets only).\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:gcp/secretStaticAccount:SecretStaticAccount": {
            "description": "Creates a Static Account in the [GCP Secrets Engine](https://www.vaultproject.io/docs/secrets/gcp/index.html) for Vault.\n\nEach [static account](https://www.vaultproject.io/docs/secrets/gcp/index.html#static-accounts) is tied to a separately managed\nService Account, and can have one or more [bindings](https://www.vaultproject.io/docs/secrets/gcp/index.html#bindings) associated with it.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\nimport * as vault from \"@pulumi/vault\";\nimport * from \"fs\";\n\nconst _this = new gcp.serviceaccount.Account(\"this\", {accountId: \"my-awesome-account\"});\nconst gcp = new vault.gcp.SecretBackend(\"gcp\", {\n    path: \"gcp\",\n    credentials: fs.readFileSync(\"credentials.json\"),\n});\nconst staticAccount = new vault.gcp.SecretStaticAccount(\"staticAccount\", {\n    backend: gcp.path,\n    staticAccount: \"project_viewer\",\n    secretType: \"access_token\",\n    tokenScopes: [\"https://www.googleapis.com/auth/cloud-platform\"],\n    serviceAccountEmail: _this.email,\n    bindings: [{\n        resource: pulumi.interpolate`//cloudresourcemanager.googleapis.com/projects/${_this.project}`,\n        roles: [\"roles/viewer\"],\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\nimport pulumi_vault as vault\n\nthis = gcp.service_account.Account(\"this\", account_id=\"my-awesome-account\")\ngcp = vault.gcp.SecretBackend(\"gcp\",\n    path=\"gcp\",\n    credentials=(lambda path: open(path).read())(\"credentials.json\"))\nstatic_account = vault.gcp.SecretStaticAccount(\"staticAccount\",\n    backend=gcp.path,\n    static_account=\"project_viewer\",\n    secret_type=\"access_token\",\n    token_scopes=[\"https://www.googleapis.com/auth/cloud-platform\"],\n    service_account_email=this.email,\n    bindings=[vault.gcp.SecretStaticAccountBindingArgs(\n        resource=this.project.apply(lambda project: f\"//cloudresourcemanager.googleapis.com/projects/{project}\"),\n        roles=[\"roles/viewer\"],\n    )])\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var @this = new Gcp.ServiceAccount.Account(\"this\", new Gcp.ServiceAccount.AccountArgs\n        {\n            AccountId = \"my-awesome-account\",\n        });\n        var gcp = new Vault.Gcp.SecretBackend(\"gcp\", new Vault.Gcp.SecretBackendArgs\n        {\n            Path = \"gcp\",\n            Credentials = File.ReadAllText(\"credentials.json\"),\n        });\n        var staticAccount = new Vault.Gcp.SecretStaticAccount(\"staticAccount\", new Vault.Gcp.SecretStaticAccountArgs\n        {\n            Backend = gcp.Path,\n            StaticAccount = \"project_viewer\",\n            SecretType = \"access_token\",\n            TokenScopes = \n            {\n                \"https://www.googleapis.com/auth/cloud-platform\",\n            },\n            ServiceAccountEmail = @this.Email,\n            Bindings = \n            {\n                new Vault.Gcp.Inputs.SecretStaticAccountBindingArgs\n                {\n                    Resource = @this.Project.Apply(project =\u003e $\"//cloudresourcemanager.googleapis.com/projects/{project}\"),\n                    Roles = \n                    {\n                        \"roles/viewer\",\n                    },\n                },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-gcp/sdk/v5/go/gcp/serviceAccount\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/gcp\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tthis, err := serviceAccount.NewAccount(ctx, \"this\", \u0026serviceAccount.AccountArgs{\n\t\t\tAccountId: pulumi.String(\"my-awesome-account\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgcp, err := gcp.NewSecretBackend(ctx, \"gcp\", \u0026gcp.SecretBackendArgs{\n\t\t\tPath:        pulumi.String(\"gcp\"),\n\t\t\tCredentials: readFileOrPanic(\"credentials.json\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gcp.NewSecretStaticAccount(ctx, \"staticAccount\", \u0026gcp.SecretStaticAccountArgs{\n\t\t\tBackend:       gcp.Path,\n\t\t\tStaticAccount: pulumi.String(\"project_viewer\"),\n\t\t\tSecretType:    pulumi.String(\"access_token\"),\n\t\t\tTokenScopes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"https://www.googleapis.com/auth/cloud-platform\"),\n\t\t\t},\n\t\t\tServiceAccountEmail: this.Email,\n\t\t\tBindings: gcp.SecretStaticAccountBindingArray{\n\t\t\t\t\u0026gcp.SecretStaticAccountBindingArgs{\n\t\t\t\t\tResource: this.Project.ApplyT(func(project string) (string, error) {\n\t\t\t\t\t\treturn fmt.Sprintf(\"%v%v\", \"//cloudresourcemanager.googleapis.com/projects/\", project), nil\n\t\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t\t\tRoles: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"roles/viewer\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nA static account can be imported using its Vault Path. For example, referencing the example above,\n\n```sh\n $ pulumi import vault:gcp/secretStaticAccount:SecretStaticAccount static_account gcp/static-account/project_viewer\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the GCP Secrets Engine is mounted\n"
                },
                "bindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:gcp/SecretStaticAccountBinding:SecretStaticAccountBinding"
                    },
                    "description": "Bindings to create for this static account. This can be specified multiple times for multiple bindings. Structure is documented below.\n"
                },
                "secretType": {
                    "type": "string",
                    "description": "Type of secret generated for this static account. Accepted values: `access_token`, `service_account_key`. Defaults to `access_token`.\n"
                },
                "serviceAccountEmail": {
                    "type": "string",
                    "description": "Email of the GCP service account to manage.\n"
                },
                "serviceAccountProject": {
                    "type": "string",
                    "description": "Project the service account belongs to.\n"
                },
                "staticAccount": {
                    "type": "string",
                    "description": "Name of the Static Account to create\n"
                },
                "tokenScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of OAuth scopes to assign to `access_token` secrets generated under this static account (`access_token` static accounts only).\n"
                }
            },
            "required": [
                "backend",
                "secretType",
                "serviceAccountEmail",
                "serviceAccountProject",
                "staticAccount"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the GCP Secrets Engine is mounted\n"
                },
                "bindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:gcp/SecretStaticAccountBinding:SecretStaticAccountBinding"
                    },
                    "description": "Bindings to create for this static account. This can be specified multiple times for multiple bindings. Structure is documented below.\n"
                },
                "secretType": {
                    "type": "string",
                    "description": "Type of secret generated for this static account. Accepted values: `access_token`, `service_account_key`. Defaults to `access_token`.\n"
                },
                "serviceAccountEmail": {
                    "type": "string",
                    "description": "Email of the GCP service account to manage.\n"
                },
                "staticAccount": {
                    "type": "string",
                    "description": "Name of the Static Account to create\n"
                },
                "tokenScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of OAuth scopes to assign to `access_token` secrets generated under this static account (`access_token` static accounts only).\n"
                }
            },
            "requiredInputs": [
                "backend",
                "serviceAccountEmail",
                "staticAccount"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretStaticAccount resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Path where the GCP Secrets Engine is mounted\n"
                    },
                    "bindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:gcp/SecretStaticAccountBinding:SecretStaticAccountBinding"
                        },
                        "description": "Bindings to create for this static account. This can be specified multiple times for multiple bindings. Structure is documented below.\n"
                    },
                    "secretType": {
                        "type": "string",
                        "description": "Type of secret generated for this static account. Accepted values: `access_token`, `service_account_key`. Defaults to `access_token`.\n"
                    },
                    "serviceAccountEmail": {
                        "type": "string",
                        "description": "Email of the GCP service account to manage.\n"
                    },
                    "serviceAccountProject": {
                        "type": "string",
                        "description": "Project the service account belongs to.\n"
                    },
                    "staticAccount": {
                        "type": "string",
                        "description": "Name of the Static Account to create\n"
                    },
                    "tokenScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of OAuth scopes to assign to `access_token` secrets generated under this static account (`access_token` static accounts only).\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:generic/endpoint:Endpoint": {
            "description": "\n\n\n## Import\n\nImport is not supported for this resource. ",
            "properties": {
                "dataJson": {
                    "type": "string",
                    "description": "String containing a JSON-encoded object that will be\nwritten to the given path as the secret data.\n"
                },
                "disableDelete": {
                    "type": "boolean",
                    "description": "Don't attempt to delete the path from Vault if true\n"
                },
                "disableRead": {
                    "type": "boolean",
                    "description": "True/false. Set this to true if your vault\nauthentication is not able to read the data or if the endpoint does\nnot support the `GET` method. Setting this to `true` will break drift\ndetection. You should set this to `true` for endpoints that are\nwrite-only. Defaults to false.\n"
                },
                "ignoreAbsentFields": {
                    "type": "boolean",
                    "description": "When reading, disregard fields not present in data_json\n"
                },
                "path": {
                    "type": "string",
                    "description": "The full logical path at which to write the given\ndata. Consult each backend's documentation to see which endpoints\nsupport the `PUT` methods and to determine whether they also support\n`DELETE` and `GET`.\n"
                },
                "writeData": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of strings returned by write operation\n"
                },
                "writeDataJson": {
                    "type": "string",
                    "description": "JSON data returned by write operation\n"
                },
                "writeFields": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Top-level fields returned by write to persist in state\n"
                }
            },
            "required": [
                "dataJson",
                "path",
                "writeData",
                "writeDataJson"
            ],
            "inputProperties": {
                "dataJson": {
                    "type": "string",
                    "description": "String containing a JSON-encoded object that will be\nwritten to the given path as the secret data.\n"
                },
                "disableDelete": {
                    "type": "boolean",
                    "description": "Don't attempt to delete the path from Vault if true\n"
                },
                "disableRead": {
                    "type": "boolean",
                    "description": "True/false. Set this to true if your vault\nauthentication is not able to read the data or if the endpoint does\nnot support the `GET` method. Setting this to `true` will break drift\ndetection. You should set this to `true` for endpoints that are\nwrite-only. Defaults to false.\n"
                },
                "ignoreAbsentFields": {
                    "type": "boolean",
                    "description": "When reading, disregard fields not present in data_json\n"
                },
                "path": {
                    "type": "string",
                    "description": "The full logical path at which to write the given\ndata. Consult each backend's documentation to see which endpoints\nsupport the `PUT` methods and to determine whether they also support\n`DELETE` and `GET`.\n"
                },
                "writeFields": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Top-level fields returned by write to persist in state\n"
                }
            },
            "requiredInputs": [
                "dataJson",
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Endpoint resources.\n",
                "properties": {
                    "dataJson": {
                        "type": "string",
                        "description": "String containing a JSON-encoded object that will be\nwritten to the given path as the secret data.\n"
                    },
                    "disableDelete": {
                        "type": "boolean",
                        "description": "Don't attempt to delete the path from Vault if true\n"
                    },
                    "disableRead": {
                        "type": "boolean",
                        "description": "True/false. Set this to true if your vault\nauthentication is not able to read the data or if the endpoint does\nnot support the `GET` method. Setting this to `true` will break drift\ndetection. You should set this to `true` for endpoints that are\nwrite-only. Defaults to false.\n"
                    },
                    "ignoreAbsentFields": {
                        "type": "boolean",
                        "description": "When reading, disregard fields not present in data_json\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The full logical path at which to write the given\ndata. Consult each backend's documentation to see which endpoints\nsupport the `PUT` methods and to determine whether they also support\n`DELETE` and `GET`.\n"
                    },
                    "writeData": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of strings returned by write operation\n"
                    },
                    "writeDataJson": {
                        "type": "string",
                        "description": "JSON data returned by write operation\n"
                    },
                    "writeFields": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Top-level fields returned by write to persist in state\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:generic/secret:Secret": {
            "description": "\n\n\n## Import\n\nGeneric secrets can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:generic/secret:Secret example secret/foo\n```\n\n ",
            "properties": {
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A mapping whose keys are the top-level data keys returned from\nVault and whose values are the corresponding values. This map can only\nrepresent string data, so any non-string values returned from Vault are\nserialized as JSON.\n"
                },
                "dataJson": {
                    "type": "string",
                    "description": "String containing a JSON-encoded object that will be\nwritten as the secret data at the given path.\n"
                },
                "deleteAllVersions": {
                    "type": "boolean",
                    "description": "true/false.  Only applicable for kv-v2 stores.\nIf set to `true`, permanently deletes all versions for\nthe specified key. The default behavior is to only delete the latest version of the\nsecret.\n"
                },
                "disableRead": {
                    "type": "boolean",
                    "description": "true/false. Set this to true if your vault\nauthentication is not able to read the data. Setting this to `true` will\nbreak drift detection. Defaults to false.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The full logical path at which to write the given data.\nTo write data into the \"generic\" secret backend mounted in Vault by default,\nthis should be prefixed with `secret/`. Writing to other backends with this\nresource is possible; consult each backend's documentation to see which\nendpoints support the `PUT` and `DELETE` methods.\n"
                }
            },
            "required": [
                "data",
                "dataJson",
                "path"
            ],
            "inputProperties": {
                "dataJson": {
                    "type": "string",
                    "description": "String containing a JSON-encoded object that will be\nwritten as the secret data at the given path.\n"
                },
                "deleteAllVersions": {
                    "type": "boolean",
                    "description": "true/false.  Only applicable for kv-v2 stores.\nIf set to `true`, permanently deletes all versions for\nthe specified key. The default behavior is to only delete the latest version of the\nsecret.\n"
                },
                "disableRead": {
                    "type": "boolean",
                    "description": "true/false. Set this to true if your vault\nauthentication is not able to read the data. Setting this to `true` will\nbreak drift detection. Defaults to false.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The full logical path at which to write the given data.\nTo write data into the \"generic\" secret backend mounted in Vault by default,\nthis should be prefixed with `secret/`. Writing to other backends with this\nresource is possible; consult each backend's documentation to see which\nendpoints support the `PUT` and `DELETE` methods.\n"
                }
            },
            "requiredInputs": [
                "dataJson",
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Secret resources.\n",
                "properties": {
                    "data": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A mapping whose keys are the top-level data keys returned from\nVault and whose values are the corresponding values. This map can only\nrepresent string data, so any non-string values returned from Vault are\nserialized as JSON.\n"
                    },
                    "dataJson": {
                        "type": "string",
                        "description": "String containing a JSON-encoded object that will be\nwritten as the secret data at the given path.\n"
                    },
                    "deleteAllVersions": {
                        "type": "boolean",
                        "description": "true/false.  Only applicable for kv-v2 stores.\nIf set to `true`, permanently deletes all versions for\nthe specified key. The default behavior is to only delete the latest version of the\nsecret.\n"
                    },
                    "disableRead": {
                        "type": "boolean",
                        "description": "true/false. Set this to true if your vault\nauthentication is not able to read the data. Setting this to `true` will\nbreak drift detection. Defaults to false.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The full logical path at which to write the given data.\nTo write data into the \"generic\" secret backend mounted in Vault by default,\nthis should be prefixed with `secret/`. Writing to other backends with this\nresource is possible; consult each backend's documentation to see which\nendpoints support the `PUT` and `DELETE` methods.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:github/authBackend:AuthBackend": {
            "description": "Manages a GitHub Auth mount in a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/github/) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.github.AuthBackend(\"example\", {\n    organization: \"myorg\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.github.AuthBackend(\"example\", organization=\"myorg\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.GitHub.AuthBackend(\"example\", new Vault.GitHub.AuthBackendArgs\n        {\n            Organization = \"myorg\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/github\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := github.NewAuthBackend(ctx, \"example\", \u0026github.AuthBackendArgs{\n\t\t\tOrganization: pulumi.String(\"myorg\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitHub authentication mounts can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:github/authBackend:AuthBackend example github\n```\n\n ",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The mount accessor related to the auth mount. It is useful for integration with [Identity Secrets Engine](https://www.vaultproject.io/docs/secrets/identity/index.html).\n"
                },
                "baseUrl": {
                    "type": "string",
                    "description": "The API endpoint to use. Useful if you\nare running GitHub Enterprise or an API-compatible authentication server.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Specifies the description of the mount.\nThis overrides the current stored value, if any.\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization configured users must be part of.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path where the auth backend is mounted. Defaults to `auth/github`\nif not specified.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Optional) List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "(Optional) If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "(Optional) The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "(Optional) If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "(Optional) The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "(Optional) If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Optional) List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "(Optional) The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "Specifies the type of tokens that should be returned by\nthe mount. Valid values are \"default-service\", \"default-batch\", \"service\", \"batch\".\n"
                },
                "tune": {
                    "$ref": "#/types/vault:github/AuthBackendTune:AuthBackendTune",
                    "description": "Extra configuration block. Structure is documented below.\n"
                }
            },
            "required": [
                "accessor",
                "organization",
                "tune"
            ],
            "inputProperties": {
                "baseUrl": {
                    "type": "string",
                    "description": "The API endpoint to use. Useful if you\nare running GitHub Enterprise or an API-compatible authentication server.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Specifies the description of the mount.\nThis overrides the current stored value, if any.\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization configured users must be part of.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path where the auth backend is mounted. Defaults to `auth/github`\nif not specified.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Optional) List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "(Optional) If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "(Optional) The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "(Optional) If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "(Optional) The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "(Optional) If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Optional) List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "(Optional) The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "Specifies the type of tokens that should be returned by\nthe mount. Valid values are \"default-service\", \"default-batch\", \"service\", \"batch\".\n"
                },
                "tune": {
                    "$ref": "#/types/vault:github/AuthBackendTune:AuthBackendTune",
                    "description": "Extra configuration block. Structure is documented below.\n"
                }
            },
            "requiredInputs": [
                "organization"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackend resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The mount accessor related to the auth mount. It is useful for integration with [Identity Secrets Engine](https://www.vaultproject.io/docs/secrets/identity/index.html).\n"
                    },
                    "baseUrl": {
                        "type": "string",
                        "description": "The API endpoint to use. Useful if you\nare running GitHub Enterprise or an API-compatible authentication server.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Specifies the description of the mount.\nThis overrides the current stored value, if any.\n"
                    },
                    "organization": {
                        "type": "string",
                        "description": "The organization configured users must be part of.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Path where the auth backend is mounted. Defaults to `auth/github`\nif not specified.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(Optional) List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "(Optional) If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "(Optional) The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "(Optional) If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "(Optional) The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "(Optional) If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(Optional) List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "(Optional) The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "Specifies the type of tokens that should be returned by\nthe mount. Valid values are \"default-service\", \"default-batch\", \"service\", \"batch\".\n"
                    },
                    "tune": {
                        "$ref": "#/types/vault:github/AuthBackendTune:AuthBackendTune",
                        "description": "Extra configuration block. Structure is documented below.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:github/team:Team": {
            "description": "Manages policy mappings for Github Teams authenticated via Github. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/github/) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.github.AuthBackend(\"example\", {organization: \"myorg\"});\nconst tfDevs = new vault.github.Team(\"tfDevs\", {\n    backend: example.id,\n    team: \"terraform-developers\",\n    policies: [\n        \"developer\",\n        \"read-only\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.github.AuthBackend(\"example\", organization=\"myorg\")\ntf_devs = vault.github.Team(\"tfDevs\",\n    backend=example.id,\n    team=\"terraform-developers\",\n    policies=[\n        \"developer\",\n        \"read-only\",\n    ])\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.GitHub.AuthBackend(\"example\", new Vault.GitHub.AuthBackendArgs\n        {\n            Organization = \"myorg\",\n        });\n        var tfDevs = new Vault.GitHub.Team(\"tfDevs\", new Vault.GitHub.TeamArgs\n        {\n            Backend = example.Id,\n            Team = \"terraform-developers\",\n            Policies = \n            {\n                \"developer\",\n                \"read-only\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/github\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := github.NewAuthBackend(ctx, \"example\", \u0026github.AuthBackendArgs{\n\t\t\tOrganization: pulumi.String(\"myorg\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = github.NewTeam(ctx, \"tfDevs\", \u0026github.TeamArgs{\n\t\t\tBackend: example.ID(),\n\t\t\tTeam:    pulumi.String(\"terraform-developers\"),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"developer\"),\n\t\t\t\tpulumi.String(\"read-only\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGithub team mappings can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:github/team:Team tf_devs auth/github/map/teams/terraform-developers\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the github auth backend is mounted. Defaults to `github`\nif not specified.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings specifying the policies to be set on tokens\nissued using this role.\n"
                },
                "team": {
                    "type": "string",
                    "description": "GitHub team name in \"slugified\" format.\n",
                    "language": {
                        "csharp": {
                            "name": "TeamCity"
                        }
                    }
                }
            },
            "required": [
                "team"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the github auth backend is mounted. Defaults to `github`\nif not specified.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings specifying the policies to be set on tokens\nissued using this role.\n"
                },
                "team": {
                    "type": "string",
                    "description": "GitHub team name in \"slugified\" format.\n",
                    "language": {
                        "csharp": {
                            "name": "TeamCity"
                        }
                    }
                }
            },
            "requiredInputs": [
                "team"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Team resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Path where the github auth backend is mounted. Defaults to `github`\nif not specified.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of strings specifying the policies to be set on tokens\nissued using this role.\n"
                    },
                    "team": {
                        "type": "string",
                        "description": "GitHub team name in \"slugified\" format.\n",
                        "language": {
                            "csharp": {
                                "name": "TeamCity"
                            }
                        }
                    }
                },
                "type": "object"
            }
        },
        "vault:github/user:User": {
            "description": "Manages policy mappings for Github Users authenticated via Github. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/github/) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.github.AuthBackend(\"example\", {organization: \"myorg\"});\nconst tfUser = new vault.github.User(\"tfUser\", {\n    backend: example.id,\n    user: \"john.doe\",\n    policies: [\n        \"developer\",\n        \"read-only\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.github.AuthBackend(\"example\", organization=\"myorg\")\ntf_user = vault.github.User(\"tfUser\",\n    backend=example.id,\n    user=\"john.doe\",\n    policies=[\n        \"developer\",\n        \"read-only\",\n    ])\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.GitHub.AuthBackend(\"example\", new Vault.GitHub.AuthBackendArgs\n        {\n            Organization = \"myorg\",\n        });\n        var tfUser = new Vault.GitHub.User(\"tfUser\", new Vault.GitHub.UserArgs\n        {\n            Backend = example.Id,\n            User = \"john.doe\",\n            Policies = \n            {\n                \"developer\",\n                \"read-only\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/github\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := github.NewAuthBackend(ctx, \"example\", \u0026github.AuthBackendArgs{\n\t\t\tOrganization: pulumi.String(\"myorg\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = github.NewUser(ctx, \"tfUser\", \u0026github.UserArgs{\n\t\t\tBackend: example.ID(),\n\t\t\tUser:    pulumi.String(\"john.doe\"),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"developer\"),\n\t\t\t\tpulumi.String(\"read-only\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGithub user mappings can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:github/user:User tf_user auth/github/map/users/john.doe\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the github auth backend is mounted. Defaults to `github`\nif not specified.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings specifying the policies to be set on tokens issued\nusing this role.\n"
                },
                "user": {
                    "type": "string",
                    "description": "GitHub user name.\n",
                    "language": {
                        "csharp": {
                            "name": "UserName"
                        }
                    }
                }
            },
            "required": [
                "user"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the github auth backend is mounted. Defaults to `github`\nif not specified.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings specifying the policies to be set on tokens issued\nusing this role.\n"
                },
                "user": {
                    "type": "string",
                    "description": "GitHub user name.\n",
                    "language": {
                        "csharp": {
                            "name": "UserName"
                        }
                    }
                }
            },
            "requiredInputs": [
                "user"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering User resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Path where the github auth backend is mounted. Defaults to `github`\nif not specified.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of strings specifying the policies to be set on tokens issued\nusing this role.\n"
                    },
                    "user": {
                        "type": "string",
                        "description": "GitHub user name.\n",
                        "language": {
                            "csharp": {
                                "name": "UserName"
                            }
                        }
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/entity:Entity": {
            "description": "\n\n\n## Import\n\nIdentity entity can be imported using the `id`, e.g.\n\n```sh\n $ pulumi import vault:identity/entity:Entity test \"ae6f8ued-0f1a-9f6b-2915-1a2be20dc053\"\n```\n\n ",
            "properties": {
                "disabled": {
                    "type": "boolean",
                    "description": "True/false Is this entity currently disabled. Defaults to `false`\n"
                },
                "externalPolicies": {
                    "type": "boolean",
                    "description": "`false` by default. If set to `true`, this resource will ignore any policies return from Vault or specified in the resource. You can use `vault.identity.EntityPolicies` to manage policies for this entity in a decoupled manner.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A Map of additional metadata to associate with the user.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the identity entity to create.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of policies to apply to the entity.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "disabled": {
                    "type": "boolean",
                    "description": "True/false Is this entity currently disabled. Defaults to `false`\n"
                },
                "externalPolicies": {
                    "type": "boolean",
                    "description": "`false` by default. If set to `true`, this resource will ignore any policies return from Vault or specified in the resource. You can use `vault.identity.EntityPolicies` to manage policies for this entity in a decoupled manner.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A Map of additional metadata to associate with the user.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the identity entity to create.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of policies to apply to the entity.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Entity resources.\n",
                "properties": {
                    "disabled": {
                        "type": "boolean",
                        "description": "True/false Is this entity currently disabled. Defaults to `false`\n"
                    },
                    "externalPolicies": {
                        "type": "boolean",
                        "description": "`false` by default. If set to `true`, this resource will ignore any policies return from Vault or specified in the resource. You can use `vault.identity.EntityPolicies` to manage policies for this entity in a decoupled manner.\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A Map of additional metadata to associate with the user.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the identity entity to create.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of policies to apply to the entity.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/entityAlias:EntityAlias": {
            "description": "\n\n\n## Import\n\nIdentity entity alias can be imported using the `id`, e.g.\n\n```sh\n $ pulumi import vault:identity/entityAlias:EntityAlias test \"3856fb4d-3c91-dcaf-2401-68f446796bfb\"\n```\n\n ",
            "properties": {
                "canonicalId": {
                    "type": "string",
                    "description": "Entity ID to which this alias belongs to.\n"
                },
                "customMetadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Custom metadata to be associated with this alias.\n"
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "Accessor of the mount to which the alias should belong to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the alias. Name should be the identifier of the client in the authentication source. For example, if the alias belongs to userpass backend, the name should be a valid username within userpass backend. If alias belongs to GitHub, it should be the GitHub username.\n"
                }
            },
            "required": [
                "canonicalId",
                "mountAccessor",
                "name"
            ],
            "inputProperties": {
                "canonicalId": {
                    "type": "string",
                    "description": "Entity ID to which this alias belongs to.\n"
                },
                "customMetadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Custom metadata to be associated with this alias.\n"
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "Accessor of the mount to which the alias should belong to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the alias. Name should be the identifier of the client in the authentication source. For example, if the alias belongs to userpass backend, the name should be a valid username within userpass backend. If alias belongs to GitHub, it should be the GitHub username.\n"
                }
            },
            "requiredInputs": [
                "canonicalId",
                "mountAccessor"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EntityAlias resources.\n",
                "properties": {
                    "canonicalId": {
                        "type": "string",
                        "description": "Entity ID to which this alias belongs to.\n"
                    },
                    "customMetadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Custom metadata to be associated with this alias.\n"
                    },
                    "mountAccessor": {
                        "type": "string",
                        "description": "Accessor of the mount to which the alias should belong to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the alias. Name should be the identifier of the client in the authentication source. For example, if the alias belongs to userpass backend, the name should be a valid username within userpass backend. If alias belongs to GitHub, it should be the GitHub username.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/entityPolicies:EntityPolicies": {
            "description": "Manages policies for an Identity Entity for Vault. The [Identity secrets engine](https://www.vaultproject.io/docs/secrets/identity/index.html) is the identity management solution for Vault.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Exclusive Policies\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst entity = new vault.identity.Entity(\"entity\", {externalPolicies: true});\nconst policies = new vault.identity.EntityPolicies(\"policies\", {\n    policies: [\n        \"default\",\n        \"test\",\n    ],\n    exclusive: true,\n    entityId: entity.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nentity = vault.identity.Entity(\"entity\", external_policies=True)\npolicies = vault.identity.EntityPolicies(\"policies\",\n    policies=[\n        \"default\",\n        \"test\",\n    ],\n    exclusive=True,\n    entity_id=entity.id)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var entity = new Vault.Identity.Entity(\"entity\", new Vault.Identity.EntityArgs\n        {\n            ExternalPolicies = true,\n        });\n        var policies = new Vault.Identity.EntityPolicies(\"policies\", new Vault.Identity.EntityPoliciesArgs\n        {\n            Policies = \n            {\n                \"default\",\n                \"test\",\n            },\n            Exclusive = true,\n            EntityId = entity.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tentity, err := identity.NewEntity(ctx, \"entity\", \u0026identity.EntityArgs{\n\t\t\tExternalPolicies: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewEntityPolicies(ctx, \"policies\", \u0026identity.EntityPoliciesArgs{\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tExclusive: pulumi.Bool(true),\n\t\t\tEntityId:  entity.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% example %}}\n### Non-exclusive Policies\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst entity = new vault.identity.Entity(\"entity\", {externalPolicies: true});\nconst _default = new vault.identity.EntityPolicies(\"default\", {\n    policies: [\n        \"default\",\n        \"test\",\n    ],\n    exclusive: false,\n    entityId: entity.id,\n});\nconst others = new vault.identity.EntityPolicies(\"others\", {\n    policies: [\"others\"],\n    exclusive: false,\n    entityId: entity.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nentity = vault.identity.Entity(\"entity\", external_policies=True)\ndefault = vault.identity.EntityPolicies(\"default\",\n    policies=[\n        \"default\",\n        \"test\",\n    ],\n    exclusive=False,\n    entity_id=entity.id)\nothers = vault.identity.EntityPolicies(\"others\",\n    policies=[\"others\"],\n    exclusive=False,\n    entity_id=entity.id)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var entity = new Vault.Identity.Entity(\"entity\", new Vault.Identity.EntityArgs\n        {\n            ExternalPolicies = true,\n        });\n        var @default = new Vault.Identity.EntityPolicies(\"default\", new Vault.Identity.EntityPoliciesArgs\n        {\n            Policies = \n            {\n                \"default\",\n                \"test\",\n            },\n            Exclusive = false,\n            EntityId = entity.Id,\n        });\n        var others = new Vault.Identity.EntityPolicies(\"others\", new Vault.Identity.EntityPoliciesArgs\n        {\n            Policies = \n            {\n                \"others\",\n            },\n            Exclusive = false,\n            EntityId = entity.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tentity, err := identity.NewEntity(ctx, \"entity\", \u0026identity.EntityArgs{\n\t\t\tExternalPolicies: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewEntityPolicies(ctx, \"default\", \u0026identity.EntityPoliciesArgs{\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tExclusive: pulumi.Bool(false),\n\t\t\tEntityId:  entity.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewEntityPolicies(ctx, \"others\", \u0026identity.EntityPoliciesArgs{\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"others\"),\n\t\t\t},\n\t\t\tExclusive: pulumi.Bool(false),\n\t\t\tEntityId:  entity.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "entityId": {
                    "type": "string",
                    "description": "Entity ID to assign policies to.\n"
                },
                "entityName": {
                    "type": "string",
                    "description": "The name of the entity that are assigned the policies.\n"
                },
                "exclusive": {
                    "type": "boolean",
                    "description": "Defaults to `true`.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to assign to the entity\n"
                }
            },
            "required": [
                "entityId",
                "entityName",
                "policies"
            ],
            "inputProperties": {
                "entityId": {
                    "type": "string",
                    "description": "Entity ID to assign policies to.\n"
                },
                "exclusive": {
                    "type": "boolean",
                    "description": "Defaults to `true`.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to assign to the entity\n"
                }
            },
            "requiredInputs": [
                "entityId",
                "policies"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EntityPolicies resources.\n",
                "properties": {
                    "entityId": {
                        "type": "string",
                        "description": "Entity ID to assign policies to.\n"
                    },
                    "entityName": {
                        "type": "string",
                        "description": "The name of the entity that are assigned the policies.\n"
                    },
                    "exclusive": {
                        "type": "boolean",
                        "description": "Defaults to `true`.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to assign to the entity\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/group:Group": {
            "description": "Creates an Identity Group for Vault. The [Identity secrets engine](https://www.vaultproject.io/docs/secrets/identity/index.html) is the identity management solution for Vault.\n\nA group can contain multiple entities as its members. A group can also have subgroups. Policies set on the group is granted to all members of the group. During request time, when the token's entity ID is being evaluated for the policies that it has access to; along with the policies on the entity itself, policies that are inherited due to group memberships are also granted.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Internal Group\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst internal = new vault.identity.Group(\"internal\", {\n    metadata: {\n        version: \"2\",\n    },\n    policies: [\n        \"dev\",\n        \"test\",\n    ],\n    type: \"internal\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ninternal = vault.identity.Group(\"internal\",\n    metadata={\n        \"version\": \"2\",\n    },\n    policies=[\n        \"dev\",\n        \"test\",\n    ],\n    type=\"internal\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var @internal = new Vault.Identity.Group(\"internal\", new Vault.Identity.GroupArgs\n        {\n            Metadata = \n            {\n                { \"version\", \"2\" },\n            },\n            Policies = \n            {\n                \"dev\",\n                \"test\",\n            },\n            Type = \"internal\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := identity.NewGroup(ctx, \"internal\", \u0026identity.GroupArgs{\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"version\": pulumi.String(\"2\"),\n\t\t\t},\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"internal\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% example %}}\n### External Group\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst group = new vault.identity.Group(\"group\", {\n    metadata: {\n        version: \"1\",\n    },\n    policies: [\"test\"],\n    type: \"external\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ngroup = vault.identity.Group(\"group\",\n    metadata={\n        \"version\": \"1\",\n    },\n    policies=[\"test\"],\n    type=\"external\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var @group = new Vault.Identity.Group(\"group\", new Vault.Identity.GroupArgs\n        {\n            Metadata = \n            {\n                { \"version\", \"1\" },\n            },\n            Policies = \n            {\n                \"test\",\n            },\n            Type = \"external\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := identity.NewGroup(ctx, \"group\", \u0026identity.GroupArgs{\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"version\": pulumi.String(\"1\"),\n\t\t\t},\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"external\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n## Caveats\n\nIt's important to note that Vault identity groups names are *case-insensitive*. For example the following resources would be equivalent.\nApplying this configuration would result in the provider failing to create one of the identity groups, since the resources share the same `name`.\n\nThis sort of pattern should be avoided:\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst internalIdentityGroup = new vault.identity.Group(\"internal\", {\n    metadata: {\n        version: \"2\",\n    },\n    policies: [\n        \"dev\",\n        \"test\",\n    ],\n    type: \"internal\",\n});\nconst internalGroup = new vault.identity.Group(\"Internal\", {\n    metadata: {\n        version: \"2\",\n    },\n    policies: [\n        \"dev\",\n        \"test\",\n    ],\n    type: \"internal\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ninternal_identity_group_group = vault.identity.Group(\"internalIdentity/groupGroup\",\n    metadata={\n        \"version\": \"2\",\n    },\n    policies=[\n        \"dev\",\n        \"test\",\n    ],\n    type=\"internal\")\ninternal_group = vault.identity.Group(\"internalGroup\",\n    metadata={\n        \"version\": \"2\",\n    },\n    policies=[\n        \"dev\",\n        \"test\",\n    ],\n    type=\"internal\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var internalIdentity_groupGroup = new Vault.Identity.Group(\"internalIdentity/groupGroup\", new Vault.Identity.GroupArgs\n        {\n            Metadata = \n            {\n                { \"version\", \"2\" },\n            },\n            Policies = \n            {\n                \"dev\",\n                \"test\",\n            },\n            Type = \"internal\",\n        });\n        var internalGroup = new Vault.Identity.Group(\"internalGroup\", new Vault.Identity.GroupArgs\n        {\n            Metadata = \n            {\n                { \"version\", \"2\" },\n            },\n            Policies = \n            {\n                \"dev\",\n                \"test\",\n            },\n            Type = \"internal\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := identity.NewGroup(ctx, \"internalIdentity/groupGroup\", \u0026identity.GroupArgs{\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"version\": pulumi.String(\"2\"),\n\t\t\t},\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"internal\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewGroup(ctx, \"internalGroup\", \u0026identity.GroupArgs{\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"version\": pulumi.String(\"2\"),\n\t\t\t},\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"internal\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n\n## Import\n\nIdentity group can be imported using the `id`, e.g.\n\n```sh\n $ pulumi import vault:identity/group:Group test 'fcbf1efb-2b69-4209-bed8-811e3475dad3'\n```\n\n ",
            "properties": {
                "externalMemberEntityIds": {
                    "type": "boolean",
                    "description": "`false` by default. If set to `true`, this resource will ignore any Entity IDs returned from Vault or specified in the resource. You can use `vault.identity.GroupMemberEntityIds` to manage Entity IDs for this group in a decoupled manner.\n"
                },
                "externalPolicies": {
                    "type": "boolean",
                    "description": "`false` by default. If set to `true`, this resource will ignore any policies returned from Vault or specified in the resource. You can use `vault.identity.GroupPolicies` to manage policies for this group in a decoupled manner.\n"
                },
                "memberEntityIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of Entity IDs to be assigned as group members. Not allowed on `external` groups.\n"
                },
                "memberGroupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of Group IDs to be assigned as group members. Not allowed on `external` groups.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A Map of additional metadata to associate with the group.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the identity group to create.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of policies to apply to the group.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the group, internal or external. Defaults to `internal`.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "externalMemberEntityIds": {
                    "type": "boolean",
                    "description": "`false` by default. If set to `true`, this resource will ignore any Entity IDs returned from Vault or specified in the resource. You can use `vault.identity.GroupMemberEntityIds` to manage Entity IDs for this group in a decoupled manner.\n"
                },
                "externalPolicies": {
                    "type": "boolean",
                    "description": "`false` by default. If set to `true`, this resource will ignore any policies returned from Vault or specified in the resource. You can use `vault.identity.GroupPolicies` to manage policies for this group in a decoupled manner.\n"
                },
                "memberEntityIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of Entity IDs to be assigned as group members. Not allowed on `external` groups.\n"
                },
                "memberGroupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of Group IDs to be assigned as group members. Not allowed on `external` groups.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A Map of additional metadata to associate with the group.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the identity group to create.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of policies to apply to the group.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the group, internal or external. Defaults to `internal`.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Group resources.\n",
                "properties": {
                    "externalMemberEntityIds": {
                        "type": "boolean",
                        "description": "`false` by default. If set to `true`, this resource will ignore any Entity IDs returned from Vault or specified in the resource. You can use `vault.identity.GroupMemberEntityIds` to manage Entity IDs for this group in a decoupled manner.\n"
                    },
                    "externalPolicies": {
                        "type": "boolean",
                        "description": "`false` by default. If set to `true`, this resource will ignore any policies returned from Vault or specified in the resource. You can use `vault.identity.GroupPolicies` to manage policies for this group in a decoupled manner.\n"
                    },
                    "memberEntityIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of Entity IDs to be assigned as group members. Not allowed on `external` groups.\n"
                    },
                    "memberGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of Group IDs to be assigned as group members. Not allowed on `external` groups.\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A Map of additional metadata to associate with the group.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the identity group to create.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of policies to apply to the group.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of the group, internal or external. Defaults to `internal`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/groupAlias:GroupAlias": {
            "description": "Creates an Identity Group Alias for Vault. The [Identity secrets engine](https://www.vaultproject.io/docs/secrets/identity/index.html) is the identity management solution for Vault.\n\nGroup aliases allows entity membership in external groups to be managed semi-automatically. External group serves as a mapping to a group that is outside of the identity store. External groups can have one (and only one) alias. This alias should map to a notion of group that is outside of the identity store. For example, groups in LDAP, and teams in GitHub. A username in LDAP, belonging to a group in LDAP, can get its entity ID added as a member of a group in Vault automatically during logins and token renewals. This works only if the group in Vault is an external group and has an alias that maps to the group in LDAP. If the user is removed from the group in LDAP, that change gets reflected in Vault only upon the subsequent login or renewal operation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst group = new vault.identity.Group(\"group\", {\n    type: \"external\",\n    policies: [\"test\"],\n});\nconst github = new vault.AuthBackend(\"github\", {\n    type: \"github\",\n    path: \"github\",\n});\nconst group_alias = new vault.identity.GroupAlias(\"group-alias\", {\n    name: \"Github_Team_Slug\",\n    mountAccessor: github.accessor,\n    canonicalId: group.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ngroup = vault.identity.Group(\"group\",\n    type=\"external\",\n    policies=[\"test\"])\ngithub = vault.AuthBackend(\"github\",\n    type=\"github\",\n    path=\"github\")\ngroup_alias = vault.identity.GroupAlias(\"group-alias\",\n    name=\"Github_Team_Slug\",\n    mount_accessor=github.accessor,\n    canonical_id=group.id)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var @group = new Vault.Identity.Group(\"group\", new Vault.Identity.GroupArgs\n        {\n            Type = \"external\",\n            Policies = \n            {\n                \"test\",\n            },\n        });\n        var github = new Vault.AuthBackend(\"github\", new Vault.AuthBackendArgs\n        {\n            Type = \"github\",\n            Path = \"github\",\n        });\n        var group_alias = new Vault.Identity.GroupAlias(\"group-alias\", new Vault.Identity.GroupAliasArgs\n        {\n            Name = \"Github_Team_Slug\",\n            MountAccessor = github.Accessor,\n            CanonicalId = @group.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tgroup, err := identity.NewGroup(ctx, \"group\", \u0026identity.GroupArgs{\n\t\t\tType: pulumi.String(\"external\"),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgithub, err := vault.NewAuthBackend(ctx, \"github\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"github\"),\n\t\t\tPath: pulumi.String(\"github\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewGroupAlias(ctx, \"group-alias\", \u0026identity.GroupAliasArgs{\n\t\t\tName:          pulumi.String(\"Github_Team_Slug\"),\n\t\t\tMountAccessor: github.Accessor,\n\t\t\tCanonicalId:   group.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nThe group alias can be imported with the group alias `id`, for example\n\n```sh\n $ pulumi import vault:identity/groupAlias:GroupAlias group-alias id\n```\n\n Group aliases can also be imported using the UUID of the alias record, e.g.\n\n```sh\n $ pulumi import vault:identity/groupAlias:GroupAlias alias_name 63104e20-88e4-11eb-8d04-cf7ac9d60157\n```\n\n ",
            "properties": {
                "canonicalId": {
                    "type": "string",
                    "description": "ID of the group to which this is an alias.\n"
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "Mount accessor of the authentication backend to which this alias belongs to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the group alias to create.\n"
                }
            },
            "required": [
                "canonicalId",
                "mountAccessor",
                "name"
            ],
            "inputProperties": {
                "canonicalId": {
                    "type": "string",
                    "description": "ID of the group to which this is an alias.\n"
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "Mount accessor of the authentication backend to which this alias belongs to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the group alias to create.\n"
                }
            },
            "requiredInputs": [
                "canonicalId",
                "mountAccessor",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupAlias resources.\n",
                "properties": {
                    "canonicalId": {
                        "type": "string",
                        "description": "ID of the group to which this is an alias.\n"
                    },
                    "mountAccessor": {
                        "type": "string",
                        "description": "Mount accessor of the authentication backend to which this alias belongs to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the group alias to create.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/groupMemberEntityIds:GroupMemberEntityIds": {
            "description": "Manages member entities for an Identity Group for Vault. The [Identity secrets engine](https://www.vaultproject.io/docs/secrets/identity/index.html) is the identity management solution for Vault.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Exclusive Member Entities\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst internal = new vault.identity.Group(\"internal\", {\n    type: \"internal\",\n    externalMemberEntityIds: true,\n    metadata: {\n        version: \"2\",\n    },\n});\nconst user = new vault.identity.Entity(\"user\", {});\nconst members = new vault.identity.GroupMemberEntityIds(\"members\", {\n    exclusive: true,\n    memberEntityIds: [user.id],\n    groupId: internal.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ninternal = vault.identity.Group(\"internal\",\n    type=\"internal\",\n    external_member_entity_ids=True,\n    metadata={\n        \"version\": \"2\",\n    })\nuser = vault.identity.Entity(\"user\")\nmembers = vault.identity.GroupMemberEntityIds(\"members\",\n    exclusive=True,\n    member_entity_ids=[user.id],\n    group_id=internal.id)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var @internal = new Vault.Identity.Group(\"internal\", new Vault.Identity.GroupArgs\n        {\n            Type = \"internal\",\n            ExternalMemberEntityIds = true,\n            Metadata = \n            {\n                { \"version\", \"2\" },\n            },\n        });\n        var user = new Vault.Identity.Entity(\"user\", new Vault.Identity.EntityArgs\n        {\n        });\n        var members = new Vault.Identity.GroupMemberEntityIds(\"members\", new Vault.Identity.GroupMemberEntityIdsArgs\n        {\n            Exclusive = true,\n            MemberEntityIds = \n            {\n                user.Id,\n            },\n            GroupId = @internal.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tinternal, err := identity.NewGroup(ctx, \"internal\", \u0026identity.GroupArgs{\n\t\t\tType:                    pulumi.String(\"internal\"),\n\t\t\tExternalMemberEntityIds: pulumi.Bool(true),\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"version\": pulumi.String(\"2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tuser, err := identity.NewEntity(ctx, \"user\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewGroupMemberEntityIds(ctx, \"members\", \u0026identity.GroupMemberEntityIdsArgs{\n\t\t\tExclusive: pulumi.Bool(true),\n\t\t\tMemberEntityIds: pulumi.StringArray{\n\t\t\t\tuser.ID(),\n\t\t\t},\n\t\t\tGroupId: internal.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% example %}}\n### Non-exclusive Member Entities\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst internal = new vault.identity.Group(\"internal\", {\n    type: \"internal\",\n    externalMemberEntityIds: true,\n    metadata: {\n        version: \"2\",\n    },\n});\nconst testUser = new vault.identity.Entity(\"testUser\", {});\nconst secondTestUser = new vault.identity.Entity(\"secondTestUser\", {});\nconst devUser = new vault.identity.Entity(\"devUser\", {});\nconst test = new vault.identity.GroupMemberEntityIds(\"test\", {\n    memberEntityIds: [\n        testUser.id,\n        secondTestUser.id,\n    ],\n    exclusive: false,\n    groupId: internal.id,\n});\nconst others = new vault.identity.GroupMemberEntityIds(\"others\", {\n    memberEntityIds: [devUser.id],\n    exclusive: false,\n    groupId: internal.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ninternal = vault.identity.Group(\"internal\",\n    type=\"internal\",\n    external_member_entity_ids=True,\n    metadata={\n        \"version\": \"2\",\n    })\ntest_user = vault.identity.Entity(\"testUser\")\nsecond_test_user = vault.identity.Entity(\"secondTestUser\")\ndev_user = vault.identity.Entity(\"devUser\")\ntest = vault.identity.GroupMemberEntityIds(\"test\",\n    member_entity_ids=[\n        test_user.id,\n        second_test_user.id,\n    ],\n    exclusive=False,\n    group_id=internal.id)\nothers = vault.identity.GroupMemberEntityIds(\"others\",\n    member_entity_ids=[dev_user.id],\n    exclusive=False,\n    group_id=internal.id)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var @internal = new Vault.Identity.Group(\"internal\", new Vault.Identity.GroupArgs\n        {\n            Type = \"internal\",\n            ExternalMemberEntityIds = true,\n            Metadata = \n            {\n                { \"version\", \"2\" },\n            },\n        });\n        var testUser = new Vault.Identity.Entity(\"testUser\", new Vault.Identity.EntityArgs\n        {\n        });\n        var secondTestUser = new Vault.Identity.Entity(\"secondTestUser\", new Vault.Identity.EntityArgs\n        {\n        });\n        var devUser = new Vault.Identity.Entity(\"devUser\", new Vault.Identity.EntityArgs\n        {\n        });\n        var test = new Vault.Identity.GroupMemberEntityIds(\"test\", new Vault.Identity.GroupMemberEntityIdsArgs\n        {\n            MemberEntityIds = \n            {\n                testUser.Id,\n                secondTestUser.Id,\n            },\n            Exclusive = false,\n            GroupId = @internal.Id,\n        });\n        var others = new Vault.Identity.GroupMemberEntityIds(\"others\", new Vault.Identity.GroupMemberEntityIdsArgs\n        {\n            MemberEntityIds = \n            {\n                devUser.Id,\n            },\n            Exclusive = false,\n            GroupId = @internal.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tinternal, err := identity.NewGroup(ctx, \"internal\", \u0026identity.GroupArgs{\n\t\t\tType:                    pulumi.String(\"internal\"),\n\t\t\tExternalMemberEntityIds: pulumi.Bool(true),\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"version\": pulumi.String(\"2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestUser, err := identity.NewEntity(ctx, \"testUser\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsecondTestUser, err := identity.NewEntity(ctx, \"secondTestUser\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdevUser, err := identity.NewEntity(ctx, \"devUser\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewGroupMemberEntityIds(ctx, \"test\", \u0026identity.GroupMemberEntityIdsArgs{\n\t\t\tMemberEntityIds: pulumi.StringArray{\n\t\t\t\ttestUser.ID(),\n\t\t\t\tsecondTestUser.ID(),\n\t\t\t},\n\t\t\tExclusive: pulumi.Bool(false),\n\t\t\tGroupId:   internal.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewGroupMemberEntityIds(ctx, \"others\", \u0026identity.GroupMemberEntityIdsArgs{\n\t\t\tMemberEntityIds: pulumi.StringArray{\n\t\t\t\tdevUser.ID(),\n\t\t\t},\n\t\t\tExclusive: pulumi.Bool(false),\n\t\t\tGroupId:   internal.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "exclusive": {
                    "type": "boolean",
                    "description": "Defaults to `true`.\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "Group ID to assign member entities to.\n"
                },
                "groupName": {
                    "type": "string",
                    "description": "The name of the group that are assigned the member entities.\n"
                },
                "memberEntityIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of member entities that belong to the group\n"
                }
            },
            "required": [
                "groupId",
                "groupName"
            ],
            "inputProperties": {
                "exclusive": {
                    "type": "boolean",
                    "description": "Defaults to `true`.\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "Group ID to assign member entities to.\n"
                },
                "memberEntityIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of member entities that belong to the group\n"
                }
            },
            "requiredInputs": [
                "groupId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupMemberEntityIds resources.\n",
                "properties": {
                    "exclusive": {
                        "type": "boolean",
                        "description": "Defaults to `true`.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "Group ID to assign member entities to.\n"
                    },
                    "groupName": {
                        "type": "string",
                        "description": "The name of the group that are assigned the member entities.\n"
                    },
                    "memberEntityIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of member entities that belong to the group\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/groupPolicies:GroupPolicies": {
            "description": "Manages policies for an Identity Group for Vault. The [Identity secrets engine](https://www.vaultproject.io/docs/secrets/identity/index.html) is the identity management solution for Vault.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Exclusive Policies\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst internal = new vault.identity.Group(\"internal\", {\n    type: \"internal\",\n    externalPolicies: true,\n    metadata: {\n        version: \"2\",\n    },\n});\nconst policies = new vault.identity.GroupPolicies(\"policies\", {\n    policies: [\n        \"default\",\n        \"test\",\n    ],\n    exclusive: true,\n    groupId: internal.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ninternal = vault.identity.Group(\"internal\",\n    type=\"internal\",\n    external_policies=True,\n    metadata={\n        \"version\": \"2\",\n    })\npolicies = vault.identity.GroupPolicies(\"policies\",\n    policies=[\n        \"default\",\n        \"test\",\n    ],\n    exclusive=True,\n    group_id=internal.id)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var @internal = new Vault.Identity.Group(\"internal\", new Vault.Identity.GroupArgs\n        {\n            Type = \"internal\",\n            ExternalPolicies = true,\n            Metadata = \n            {\n                { \"version\", \"2\" },\n            },\n        });\n        var policies = new Vault.Identity.GroupPolicies(\"policies\", new Vault.Identity.GroupPoliciesArgs\n        {\n            Policies = \n            {\n                \"default\",\n                \"test\",\n            },\n            Exclusive = true,\n            GroupId = @internal.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tinternal, err := identity.NewGroup(ctx, \"internal\", \u0026identity.GroupArgs{\n\t\t\tType:             pulumi.String(\"internal\"),\n\t\t\tExternalPolicies: pulumi.Bool(true),\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"version\": pulumi.String(\"2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewGroupPolicies(ctx, \"policies\", \u0026identity.GroupPoliciesArgs{\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tExclusive: pulumi.Bool(true),\n\t\t\tGroupId:   internal.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% example %}}\n### Non-exclusive Policies\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst internal = new vault.identity.Group(\"internal\", {\n    type: \"internal\",\n    externalPolicies: true,\n    metadata: {\n        version: \"2\",\n    },\n});\nconst _default = new vault.identity.GroupPolicies(\"default\", {\n    policies: [\n        \"default\",\n        \"test\",\n    ],\n    exclusive: false,\n    groupId: internal.id,\n});\nconst others = new vault.identity.GroupPolicies(\"others\", {\n    policies: [\"others\"],\n    exclusive: false,\n    groupId: internal.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ninternal = vault.identity.Group(\"internal\",\n    type=\"internal\",\n    external_policies=True,\n    metadata={\n        \"version\": \"2\",\n    })\ndefault = vault.identity.GroupPolicies(\"default\",\n    policies=[\n        \"default\",\n        \"test\",\n    ],\n    exclusive=False,\n    group_id=internal.id)\nothers = vault.identity.GroupPolicies(\"others\",\n    policies=[\"others\"],\n    exclusive=False,\n    group_id=internal.id)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var @internal = new Vault.Identity.Group(\"internal\", new Vault.Identity.GroupArgs\n        {\n            Type = \"internal\",\n            ExternalPolicies = true,\n            Metadata = \n            {\n                { \"version\", \"2\" },\n            },\n        });\n        var @default = new Vault.Identity.GroupPolicies(\"default\", new Vault.Identity.GroupPoliciesArgs\n        {\n            Policies = \n            {\n                \"default\",\n                \"test\",\n            },\n            Exclusive = false,\n            GroupId = @internal.Id,\n        });\n        var others = new Vault.Identity.GroupPolicies(\"others\", new Vault.Identity.GroupPoliciesArgs\n        {\n            Policies = \n            {\n                \"others\",\n            },\n            Exclusive = false,\n            GroupId = @internal.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tinternal, err := identity.NewGroup(ctx, \"internal\", \u0026identity.GroupArgs{\n\t\t\tType:             pulumi.String(\"internal\"),\n\t\t\tExternalPolicies: pulumi.Bool(true),\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"version\": pulumi.String(\"2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewGroupPolicies(ctx, \"default\", \u0026identity.GroupPoliciesArgs{\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tExclusive: pulumi.Bool(false),\n\t\t\tGroupId:   internal.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewGroupPolicies(ctx, \"others\", \u0026identity.GroupPoliciesArgs{\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"others\"),\n\t\t\t},\n\t\t\tExclusive: pulumi.Bool(false),\n\t\t\tGroupId:   internal.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "exclusive": {
                    "type": "boolean",
                    "description": "Defaults to `true`.\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "Group ID to assign policies to.\n"
                },
                "groupName": {
                    "type": "string",
                    "description": "The name of the group that are assigned the policies.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to assign to the group\n"
                }
            },
            "required": [
                "groupId",
                "groupName",
                "policies"
            ],
            "inputProperties": {
                "exclusive": {
                    "type": "boolean",
                    "description": "Defaults to `true`.\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "Group ID to assign policies to.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to assign to the group\n"
                }
            },
            "requiredInputs": [
                "groupId",
                "policies"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupPolicies resources.\n",
                "properties": {
                    "exclusive": {
                        "type": "boolean",
                        "description": "Defaults to `true`.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "Group ID to assign policies to.\n"
                    },
                    "groupName": {
                        "type": "string",
                        "description": "The name of the group that are assigned the policies.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to assign to the group\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/oidc:Oidc": {
            "description": "Configure the [Identity Tokens Backend](https://www.vaultproject.io/docs/secrets/identity/index.html#identity-tokens).\n\nThe Identity secrets engine is the identity management solution for Vault. It internally maintains\nthe clients who are recognized by Vault.\n\n\u003e **NOTE:** Each Vault server may only have one Identity Tokens Backend configuration. Multiple configurations of the resource against the same Vault server will cause a perpetual difference.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst server = new vault.identity.Oidc(\"server\", {\n    issuer: \"https://www.acme.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nserver = vault.identity.Oidc(\"server\", issuer=\"https://www.acme.com\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var server = new Vault.Identity.Oidc(\"server\", new Vault.Identity.OidcArgs\n        {\n            Issuer = \"https://www.acme.com\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := identity.NewOidc(ctx, \"server\", \u0026identity.OidcArgs{\n\t\t\tIssuer: pulumi.String(\"https://www.acme.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "issuer": {
                    "type": "string",
                    "description": "Issuer URL to be used in the iss claim of the token. If not set, Vault's\n`api_addr` will be used. The issuer is a case sensitive URL using the https scheme that contains\nscheme, host, and optionally, port number and path components, but no query or fragment\ncomponents.\n"
                }
            },
            "required": [
                "issuer"
            ],
            "inputProperties": {
                "issuer": {
                    "type": "string",
                    "description": "Issuer URL to be used in the iss claim of the token. If not set, Vault's\n`api_addr` will be used. The issuer is a case sensitive URL using the https scheme that contains\nscheme, host, and optionally, port number and path components, but no query or fragment\ncomponents.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Oidc resources.\n",
                "properties": {
                    "issuer": {
                        "type": "string",
                        "description": "Issuer URL to be used in the iss claim of the token. If not set, Vault's\n`api_addr` will be used. The issuer is a case sensitive URL using the https scheme that contains\nscheme, host, and optionally, port number and path components, but no query or fragment\ncomponents.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/oidcKey:OidcKey": {
            "description": "\n\n\n## Import\n\nThe key can be imported with the key name, for example\n\n```sh\n $ pulumi import vault:identity/oidcKey:OidcKey key key\n```\n\n ",
            "properties": {
                "algorithm": {
                    "type": "string",
                    "description": "Signing algorithm to use. Signing algorithm to use.\nAllowed values are: RS256 (default), RS384, RS512, ES256, ES384, ES512, EdDSA.\n"
                },
                "allowedClientIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Array of role client ids allowed to use this key for signing. If empty, no roles are allowed. If \"*\", all roles are\nallowed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the OIDC Key to create.\n"
                },
                "rotationPeriod": {
                    "type": "integer",
                    "description": "How often to generate a new signing key in number of seconds\n"
                },
                "verificationTtl": {
                    "type": "integer",
                    "description": "\"Controls how long the public portion of a signing key will be\navailable for verification after being rotated in seconds.\n"
                }
            },
            "required": [
                "allowedClientIds",
                "name"
            ],
            "inputProperties": {
                "algorithm": {
                    "type": "string",
                    "description": "Signing algorithm to use. Signing algorithm to use.\nAllowed values are: RS256 (default), RS384, RS512, ES256, ES384, ES512, EdDSA.\n"
                },
                "allowedClientIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Array of role client ids allowed to use this key for signing. If empty, no roles are allowed. If \"*\", all roles are\nallowed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the OIDC Key to create.\n"
                },
                "rotationPeriod": {
                    "type": "integer",
                    "description": "How often to generate a new signing key in number of seconds\n"
                },
                "verificationTtl": {
                    "type": "integer",
                    "description": "\"Controls how long the public portion of a signing key will be\navailable for verification after being rotated in seconds.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OidcKey resources.\n",
                "properties": {
                    "algorithm": {
                        "type": "string",
                        "description": "Signing algorithm to use. Signing algorithm to use.\nAllowed values are: RS256 (default), RS384, RS512, ES256, ES384, ES512, EdDSA.\n"
                    },
                    "allowedClientIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Array of role client ids allowed to use this key for signing. If empty, no roles are allowed. If \"*\", all roles are\nallowed.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the OIDC Key to create.\n"
                    },
                    "rotationPeriod": {
                        "type": "integer",
                        "description": "How often to generate a new signing key in number of seconds\n"
                    },
                    "verificationTtl": {
                        "type": "integer",
                        "description": "\"Controls how long the public portion of a signing key will be\navailable for verification after being rotated in seconds.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/oidcKeyAllowedClientID:OidcKeyAllowedClientID": {
            "properties": {
                "allowedClientId": {
                    "type": "string",
                    "description": "Client ID to allow usage with the OIDC named key\n"
                },
                "keyName": {
                    "type": "string",
                    "description": "Name of the OIDC Key allow the Client ID.\n"
                }
            },
            "required": [
                "allowedClientId",
                "keyName"
            ],
            "inputProperties": {
                "allowedClientId": {
                    "type": "string",
                    "description": "Client ID to allow usage with the OIDC named key\n"
                },
                "keyName": {
                    "type": "string",
                    "description": "Name of the OIDC Key allow the Client ID.\n"
                }
            },
            "requiredInputs": [
                "allowedClientId",
                "keyName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OidcKeyAllowedClientID resources.\n",
                "properties": {
                    "allowedClientId": {
                        "type": "string",
                        "description": "Client ID to allow usage with the OIDC named key\n"
                    },
                    "keyName": {
                        "type": "string",
                        "description": "Name of the OIDC Key allow the Client ID.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/oidcRole:OidcRole": {
            "description": "\n\n\n## Import\n\nThe key can be imported with the role name, for example\n\n```sh\n $ pulumi import vault:identity/oidcRole:OidcRole role role\n```\n\n ",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The value that will be included in the `aud` field of all the OIDC identity\ntokens issued by this role\n"
                },
                "key": {
                    "type": "string",
                    "description": "A configured named key, the key must already exist\nbefore tokens can be issued.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the OIDC Role to create.\n"
                },
                "template": {
                    "type": "string",
                    "description": "The template string to use for generating tokens. This may be in\nstring-ified JSON or base64 format. See the\n[documentation](https://www.vaultproject.io/docs/secrets/identity/index.html#token-contents-and-templates)\nfor the template format.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "TTL of the tokens generated against the role in number of seconds.\n"
                }
            },
            "required": [
                "clientId",
                "key",
                "name"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The value that will be included in the `aud` field of all the OIDC identity\ntokens issued by this role\n"
                },
                "key": {
                    "type": "string",
                    "description": "A configured named key, the key must already exist\nbefore tokens can be issued.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the OIDC Role to create.\n"
                },
                "template": {
                    "type": "string",
                    "description": "The template string to use for generating tokens. This may be in\nstring-ified JSON or base64 format. See the\n[documentation](https://www.vaultproject.io/docs/secrets/identity/index.html#token-contents-and-templates)\nfor the template format.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "TTL of the tokens generated against the role in number of seconds.\n"
                }
            },
            "requiredInputs": [
                "key"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OidcRole resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The value that will be included in the `aud` field of all the OIDC identity\ntokens issued by this role\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "A configured named key, the key must already exist\nbefore tokens can be issued.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the OIDC Role to create.\n"
                    },
                    "template": {
                        "type": "string",
                        "description": "The template string to use for generating tokens. This may be in\nstring-ified JSON or base64 format. See the\n[documentation](https://www.vaultproject.io/docs/secrets/identity/index.html#token-contents-and-templates)\nfor the template format.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "TTL of the tokens generated against the role in number of seconds.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/audit:Audit": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n### File Audit Device)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst test = new vault.Audit(\"test\", {\n    options: {\n        file_path: \"C:/temp/audit.txt\",\n    },\n    type: \"file\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntest = vault.Audit(\"test\",\n    options={\n        \"file_path\": \"C:/temp/audit.txt\",\n    },\n    type=\"file\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var test = new Vault.Audit(\"test\", new Vault.AuditArgs\n        {\n            Options = \n            {\n                { \"file_path\", \"C:/temp/audit.txt\" },\n            },\n            Type = \"file\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewAudit(ctx, \"test\", \u0026vault.AuditArgs{\n\t\t\tOptions: pulumi.StringMap{\n\t\t\t\t\"file_path\": pulumi.String(\"C:/temp/audit.txt\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"file\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Socket Audit Device)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst test = new vault.Audit(\"test\", {\n    local: false,\n    options: {\n        address: \"127.0.0.1:8000\",\n        description: \"application x socket\",\n        socket_type: \"tcp\",\n    },\n    path: \"app_socket\",\n    type: \"socket\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntest = vault.Audit(\"test\",\n    local=False,\n    options={\n        \"address\": \"127.0.0.1:8000\",\n        \"description\": \"application x socket\",\n        \"socket_type\": \"tcp\",\n    },\n    path=\"app_socket\",\n    type=\"socket\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var test = new Vault.Audit(\"test\", new Vault.AuditArgs\n        {\n            Local = false,\n            Options = \n            {\n                { \"address\", \"127.0.0.1:8000\" },\n                { \"description\", \"application x socket\" },\n                { \"socket_type\", \"tcp\" },\n            },\n            Path = \"app_socket\",\n            Type = \"socket\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewAudit(ctx, \"test\", \u0026vault.AuditArgs{\n\t\t\tLocal: pulumi.Bool(false),\n\t\t\tOptions: pulumi.StringMap{\n\t\t\t\t\"address\":     pulumi.String(\"127.0.0.1:8000\"),\n\t\t\t\t\"description\": pulumi.String(\"application x socket\"),\n\t\t\t\t\"socket_type\": pulumi.String(\"tcp\"),\n\t\t\t},\n\t\t\tPath: pulumi.String(\"app_socket\"),\n\t\t\tType: pulumi.String(\"socket\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAudit devices can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:index/audit:Audit test syslog\n```\n\n ",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the audit device.\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the audit device is a local only. Local audit devices are not replicated nor (if a secondary) removed by replication.\n"
                },
                "options": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Configuration options to pass to the audit device itself.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path to mount the audit device. This defaults to the type.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the audit device, such as 'file'.\n"
                }
            },
            "required": [
                "options",
                "path",
                "type"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the audit device.\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the audit device is a local only. Local audit devices are not replicated nor (if a secondary) removed by replication.\n"
                },
                "options": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Configuration options to pass to the audit device itself.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path to mount the audit device. This defaults to the type.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the audit device, such as 'file'.\n"
                }
            },
            "requiredInputs": [
                "options",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Audit resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Human-friendly description of the audit device.\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Specifies if the audit device is a local only. Local audit devices are not replicated nor (if a secondary) removed by replication.\n"
                    },
                    "options": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Configuration options to pass to the audit device itself.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path to mount the audit device. This defaults to the type.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of the audit device, such as 'file'.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/authBackend:AuthBackend": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.AuthBackend(\"example\", {\n    tune: {\n        listingVisibility: \"unauth\",\n        maxLeaseTtl: \"90000s\",\n    },\n    type: \"github\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.AuthBackend(\"example\",\n    tune=vault.AuthBackendTuneArgs(\n        listing_visibility=\"unauth\",\n        max_lease_ttl=\"90000s\",\n    ),\n    type=\"github\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.AuthBackend(\"example\", new Vault.AuthBackendArgs\n        {\n            Tune = new Vault.Inputs.AuthBackendTuneArgs\n            {\n                ListingVisibility = \"unauth\",\n                MaxLeaseTtl = \"90000s\",\n            },\n            Type = \"github\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewAuthBackend(ctx, \"example\", \u0026vault.AuthBackendArgs{\n\t\t\tTune: \u0026AuthBackendTuneArgs{\n\t\t\t\tListingVisibility: pulumi.String(\"unauth\"),\n\t\t\t\tMaxLeaseTtl:       pulumi.String(\"90000s\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"github\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAuth methods can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:index/authBackend:AuthBackend example github\n```\n\n ",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The accessor for this auth method\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description of the auth method\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the auth method is local only.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path to mount the auth method  this defaults to the name of the type\n"
                },
                "tune": {
                    "$ref": "#/types/vault:index/AuthBackendTune:AuthBackendTune",
                    "description": "Extra configuration block. Structure is documented below.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The name of the auth method type\n"
                }
            },
            "required": [
                "accessor",
                "path",
                "tune",
                "type"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "A description of the auth method\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the auth method is local only.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path to mount the auth method  this defaults to the name of the type\n"
                },
                "tune": {
                    "$ref": "#/types/vault:index/AuthBackendTune:AuthBackendTune",
                    "description": "Extra configuration block. Structure is documented below.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The name of the auth method type\n"
                }
            },
            "requiredInputs": [
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackend resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The accessor for this auth method\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description of the auth method\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Specifies if the auth method is local only.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path to mount the auth method  this defaults to the name of the type\n"
                    },
                    "tune": {
                        "$ref": "#/types/vault:index/AuthBackendTune:AuthBackendTune",
                        "description": "Extra configuration block. Structure is documented below.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The name of the auth method type\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/certAuthBackendRole:CertAuthBackendRole": {
            "description": "Provides a resource to create a role in an [Cert auth backend within Vault](https://www.vaultproject.io/docs/auth/cert.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\nimport * from \"fs\";\n\nconst certAuthBackend = new vault.AuthBackend(\"certAuthBackend\", {\n    path: \"cert\",\n    type: \"cert\",\n});\nconst certCertAuthBackendRole = new vault.CertAuthBackendRole(\"certCertAuthBackendRole\", {\n    certificate: fs.readFileSync(\"/path/to/certs/ca-cert.pem\"),\n    backend: certAuthBackend.path,\n    allowedNames: [\n        \"foo.example.org\",\n        \"baz.example.org\",\n    ],\n    tokenTtl: 300,\n    tokenMaxTtl: 600,\n    tokenPolicies: [\"foo\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ncert_auth_backend = vault.AuthBackend(\"certAuthBackend\",\n    path=\"cert\",\n    type=\"cert\")\ncert_cert_auth_backend_role = vault.CertAuthBackendRole(\"certCertAuthBackendRole\",\n    certificate=(lambda path: open(path).read())(\"/path/to/certs/ca-cert.pem\"),\n    backend=cert_auth_backend.path,\n    allowed_names=[\n        \"foo.example.org\",\n        \"baz.example.org\",\n    ],\n    token_ttl=300,\n    token_max_ttl=600,\n    token_policies=[\"foo\"])\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var certAuthBackend = new Vault.AuthBackend(\"certAuthBackend\", new Vault.AuthBackendArgs\n        {\n            Path = \"cert\",\n            Type = \"cert\",\n        });\n        var certCertAuthBackendRole = new Vault.CertAuthBackendRole(\"certCertAuthBackendRole\", new Vault.CertAuthBackendRoleArgs\n        {\n            Certificate = File.ReadAllText(\"/path/to/certs/ca-cert.pem\"),\n            Backend = certAuthBackend.Path,\n            AllowedNames = \n            {\n                \"foo.example.org\",\n                \"baz.example.org\",\n            },\n            TokenTtl = 300,\n            TokenMaxTtl = 600,\n            TokenPolicies = \n            {\n                \"foo\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcertAuthBackend, err := vault.NewAuthBackend(ctx, \"certAuthBackend\", \u0026vault.AuthBackendArgs{\n\t\t\tPath: pulumi.String(\"cert\"),\n\t\t\tType: pulumi.String(\"cert\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vault.NewCertAuthBackendRole(ctx, \"certCertAuthBackendRole\", \u0026vault.CertAuthBackendRoleArgs{\n\t\t\tCertificate: readFileOrPanic(\"/path/to/certs/ca-cert.pem\"),\n\t\t\tBackend:     certAuthBackend.Path,\n\t\t\tAllowedNames: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"foo.example.org\"),\n\t\t\t\tpulumi.String(\"baz.example.org\"),\n\t\t\t},\n\t\t\tTokenTtl:    pulumi.Int(300),\n\t\t\tTokenMaxTtl: pulumi.Int(600),\n\t\t\tTokenPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"foo\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "allowedCommonNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed the common names for authenticated client certificates\n"
                },
                "allowedDnsSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed alternative dns names for authenticated client certificates\n"
                },
                "allowedEmailSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed emails for authenticated client certificates\n"
                },
                "allowedNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed subject names for authenticated client certificates\n"
                },
                "allowedOrganizationUnits": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed organization units for authenticated client certificates\n"
                },
                "allowedUriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed URIs for authenticated client certificates\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Path to the mounted Cert auth backend\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "CA certificate used to validate client certificates\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "The name to display on tokens issued under this role.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the role\n"
                },
                "requiredExtensions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "TLS extensions required on client certificates\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "required": [
                "allowedCommonNames",
                "allowedDnsSans",
                "allowedEmailSans",
                "allowedNames",
                "allowedOrganizationUnits",
                "allowedUriSans",
                "certificate",
                "displayName",
                "name",
                "requiredExtensions"
            ],
            "inputProperties": {
                "allowedCommonNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed the common names for authenticated client certificates\n"
                },
                "allowedDnsSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed alternative dns names for authenticated client certificates\n"
                },
                "allowedEmailSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed emails for authenticated client certificates\n"
                },
                "allowedNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed subject names for authenticated client certificates\n"
                },
                "allowedOrganizationUnits": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed organization units for authenticated client certificates\n"
                },
                "allowedUriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed URIs for authenticated client certificates\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Path to the mounted Cert auth backend\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "CA certificate used to validate client certificates\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "The name to display on tokens issued under this role.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the role\n"
                },
                "requiredExtensions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "TLS extensions required on client certificates\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "requiredInputs": [
                "certificate"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CertAuthBackendRole resources.\n",
                "properties": {
                    "allowedCommonNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Allowed the common names for authenticated client certificates\n"
                    },
                    "allowedDnsSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Allowed alternative dns names for authenticated client certificates\n"
                    },
                    "allowedEmailSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Allowed emails for authenticated client certificates\n"
                    },
                    "allowedNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Allowed subject names for authenticated client certificates\n"
                    },
                    "allowedOrganizationUnits": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Allowed organization units for authenticated client certificates\n"
                    },
                    "allowedUriSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Allowed URIs for authenticated client certificates\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "Path to the mounted Cert auth backend\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "CA certificate used to validate client certificates\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "The name to display on tokens issued under this role.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the role\n"
                    },
                    "requiredExtensions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "TLS extensions required on client certificates\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/egpPolicy:EgpPolicy": {
            "description": "Provides a resource to manage Endpoint Governing Policy (EGP) via [Sentinel](https://www.vaultproject.io/docs/enterprise/sentinel/index.html).\n\n**Note** this feature is available only with Vault Enterprise.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst allow_all = new vault.EgpPolicy(\"allow-all\", {\n    enforcementLevel: \"soft-mandatory\",\n    paths: [\"*\"],\n    policy: `main = rule {\n  true\n}\n`,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nallow_all = vault.EgpPolicy(\"allow-all\",\n    enforcement_level=\"soft-mandatory\",\n    paths=[\"*\"],\n    policy=\"\"\"main = rule {\n  true\n}\n\n\"\"\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var allow_all = new Vault.EgpPolicy(\"allow-all\", new Vault.EgpPolicyArgs\n        {\n            EnforcementLevel = \"soft-mandatory\",\n            Paths = \n            {\n                \"*\",\n            },\n            Policy = @\"main = rule {\n  true\n}\n\n\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewEgpPolicy(ctx, \"allow-all\", \u0026vault.EgpPolicyArgs{\n\t\t\tEnforcementLevel: pulumi.String(\"soft-mandatory\"),\n\t\t\tPaths: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"*\"),\n\t\t\t},\n\t\t\tPolicy: pulumi.String(fmt.Sprintf(\"%v%v%v%v\", \"main = rule {\\n\", \"  true\\n\", \"}\\n\", \"\\n\")),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "enforcementLevel": {
                    "type": "string",
                    "description": "Enforcement level of Sentinel policy. Can be either `advisory` or `soft-mandatory` or `hard-mandatory`\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the policy\n"
                },
                "paths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of paths to which the policy will be applied to\n"
                },
                "policy": {
                    "type": "string",
                    "description": "String containing a Sentinel policy\n"
                }
            },
            "required": [
                "enforcementLevel",
                "name",
                "paths",
                "policy"
            ],
            "inputProperties": {
                "enforcementLevel": {
                    "type": "string",
                    "description": "Enforcement level of Sentinel policy. Can be either `advisory` or `soft-mandatory` or `hard-mandatory`\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the policy\n"
                },
                "paths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of paths to which the policy will be applied to\n"
                },
                "policy": {
                    "type": "string",
                    "description": "String containing a Sentinel policy\n"
                }
            },
            "requiredInputs": [
                "enforcementLevel",
                "paths",
                "policy"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EgpPolicy resources.\n",
                "properties": {
                    "enforcementLevel": {
                        "type": "string",
                        "description": "Enforcement level of Sentinel policy. Can be either `advisory` or `soft-mandatory` or `hard-mandatory`\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the policy\n"
                    },
                    "paths": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of paths to which the policy will be applied to\n"
                    },
                    "policy": {
                        "type": "string",
                        "description": "String containing a Sentinel policy\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/mfaDuo:MfaDuo": {
            "description": "Provides a resource to manage [Duo MFA](https://www.vaultproject.io/docs/enterprise/mfa/mfa-duo.html).\n\n**Note** this feature is available only with Vault Enterprise.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst userpass = new vault.AuthBackend(\"userpass\", {\n    type: \"userpass\",\n    path: \"userpass\",\n});\nconst myDuo = new vault.MfaDuo(\"myDuo\", {\n    mountAccessor: userpass.accessor,\n    secretKey: \"8C7THtrIigh2rPZQMbguugt8IUftWhMRCOBzbuyz\",\n    integrationKey: \"BIACEUEAXI20BNWTEYXT\",\n    apiHostname: \"api-2b5c39f5.duosecurity.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nuserpass = vault.AuthBackend(\"userpass\",\n    type=\"userpass\",\n    path=\"userpass\")\nmy_duo = vault.MfaDuo(\"myDuo\",\n    mount_accessor=userpass.accessor,\n    secret_key=\"8C7THtrIigh2rPZQMbguugt8IUftWhMRCOBzbuyz\",\n    integration_key=\"BIACEUEAXI20BNWTEYXT\",\n    api_hostname=\"api-2b5c39f5.duosecurity.com\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var userpass = new Vault.AuthBackend(\"userpass\", new Vault.AuthBackendArgs\n        {\n            Type = \"userpass\",\n            Path = \"userpass\",\n        });\n        var myDuo = new Vault.MfaDuo(\"myDuo\", new Vault.MfaDuoArgs\n        {\n            MountAccessor = userpass.Accessor,\n            SecretKey = \"8C7THtrIigh2rPZQMbguugt8IUftWhMRCOBzbuyz\",\n            IntegrationKey = \"BIACEUEAXI20BNWTEYXT\",\n            ApiHostname = \"api-2b5c39f5.duosecurity.com\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tuserpass, err := vault.NewAuthBackend(ctx, \"userpass\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"userpass\"),\n\t\t\tPath: pulumi.String(\"userpass\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vault.NewMfaDuo(ctx, \"myDuo\", \u0026vault.MfaDuoArgs{\n\t\t\tMountAccessor:  userpass.Accessor,\n\t\t\tSecretKey:      pulumi.String(\"8C7THtrIigh2rPZQMbguugt8IUftWhMRCOBzbuyz\"),\n\t\t\tIntegrationKey: pulumi.String(\"BIACEUEAXI20BNWTEYXT\"),\n\t\t\tApiHostname:    pulumi.String(\"api-2b5c39f5.duosecurity.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nMounts can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:index/mfaDuo:MfaDuo my_duo my_duo\n```\n\n ",
            "properties": {
                "apiHostname": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - API hostname for Duo.\n"
                },
                "integrationKey": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - Integration key for Duo.\n"
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The mount to tie this method to for use in automatic mappings. The mapping will use the Name field of Aliases associated with this mount as the username in the mapping.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)`  Name of the MFA method.\n"
                },
                "pushInfo": {
                    "type": "string",
                    "description": "`(string)` - Push information for Duo.\n"
                },
                "secretKey": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - Secret key for Duo.\n"
                },
                "usernameFormat": {
                    "type": "string",
                    "description": "`(string)` - A format string for mapping Identity names to MFA method names. Values to substitute should be placed in `{{}}`. For example, `\"{{alias.name}}@example.com\"`. If blank, the Alias's Name field will be used as-is. Currently-supported mappings:\n- alias.name: The name returned by the mount configured via the `mount_accessor` parameter\n- entity.name: The name configured for the Entity\n- alias.metadata.`\u003ckey\u003e`: The value of the Alias's metadata parameter\n- entity.metadata.`\u003ckey\u003e`: The value of the Entity's metadata parameter\n"
                }
            },
            "required": [
                "apiHostname",
                "integrationKey",
                "mountAccessor",
                "name",
                "secretKey"
            ],
            "inputProperties": {
                "apiHostname": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - API hostname for Duo.\n"
                },
                "integrationKey": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - Integration key for Duo.\n"
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - The mount to tie this method to for use in automatic mappings. The mapping will use the Name field of Aliases associated with this mount as the username in the mapping.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)`  Name of the MFA method.\n"
                },
                "pushInfo": {
                    "type": "string",
                    "description": "`(string)` - Push information for Duo.\n"
                },
                "secretKey": {
                    "type": "string",
                    "description": "`(string: \u003crequired\u003e)` - Secret key for Duo.\n"
                },
                "usernameFormat": {
                    "type": "string",
                    "description": "`(string)` - A format string for mapping Identity names to MFA method names. Values to substitute should be placed in `{{}}`. For example, `\"{{alias.name}}@example.com\"`. If blank, the Alias's Name field will be used as-is. Currently-supported mappings:\n- alias.name: The name returned by the mount configured via the `mount_accessor` parameter\n- entity.name: The name configured for the Entity\n- alias.metadata.`\u003ckey\u003e`: The value of the Alias's metadata parameter\n- entity.metadata.`\u003ckey\u003e`: The value of the Entity's metadata parameter\n"
                }
            },
            "requiredInputs": [
                "apiHostname",
                "integrationKey",
                "mountAccessor",
                "secretKey"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MfaDuo resources.\n",
                "properties": {
                    "apiHostname": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - API hostname for Duo.\n"
                    },
                    "integrationKey": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - Integration key for Duo.\n"
                    },
                    "mountAccessor": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - The mount to tie this method to for use in automatic mappings. The mapping will use the Name field of Aliases associated with this mount as the username in the mapping.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)`  Name of the MFA method.\n"
                    },
                    "pushInfo": {
                        "type": "string",
                        "description": "`(string)` - Push information for Duo.\n"
                    },
                    "secretKey": {
                        "type": "string",
                        "description": "`(string: \u003crequired\u003e)` - Secret key for Duo.\n"
                    },
                    "usernameFormat": {
                        "type": "string",
                        "description": "`(string)` - A format string for mapping Identity names to MFA method names. Values to substitute should be placed in `{{}}`. For example, `\"{{alias.name}}@example.com\"`. If blank, the Alias's Name field will be used as-is. Currently-supported mappings:\n- alias.name: The name returned by the mount configured via the `mount_accessor` parameter\n- entity.name: The name configured for the Entity\n- alias.metadata.`\u003ckey\u003e`: The value of the Alias's metadata parameter\n- entity.metadata.`\u003ckey\u003e`: The value of the Entity's metadata parameter\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/mount:Mount": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.Mount(\"example\", {\n    description: \"This is an example mount\",\n    path: \"dummy\",\n    type: \"generic\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.Mount(\"example\",\n    description=\"This is an example mount\",\n    path=\"dummy\",\n    type=\"generic\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.Mount(\"example\", new Vault.MountArgs\n        {\n            Description = \"This is an example mount\",\n            Path = \"dummy\",\n            Type = \"generic\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewMount(ctx, \"example\", \u0026vault.MountArgs{\n\t\t\tDescription: pulumi.String(\"This is an example mount\"),\n\t\t\tPath:        pulumi.String(\"dummy\"),\n\t\t\tType:        pulumi.String(\"generic\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst kvv2_example = new vault.Mount(\"kvv2-example\", {\n    description: \"This is an example KV Version 2 secret engine mount\",\n    path: \"version2-example\",\n    type: \"kv-v2\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nkvv2_example = vault.Mount(\"kvv2-example\",\n    description=\"This is an example KV Version 2 secret engine mount\",\n    path=\"version2-example\",\n    type=\"kv-v2\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var kvv2_example = new Vault.Mount(\"kvv2-example\", new Vault.MountArgs\n        {\n            Description = \"This is an example KV Version 2 secret engine mount\",\n            Path = \"version2-example\",\n            Type = \"kv-v2\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewMount(ctx, \"kvv2-example\", \u0026vault.MountArgs{\n\t\t\tDescription: pulumi.String(\"This is an example KV Version 2 secret engine mount\"),\n\t\t\tPath:        pulumi.String(\"version2-example\"),\n\t\t\tType:        pulumi.String(\"kv-v2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst transit_example = new vault.Mount(\"transit-example\", {\n    description: \"This is an example transit secret engine mount\",\n    options: {\n        convergent_encryption: false,\n    },\n    path: \"transit-example\",\n    type: \"transit\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntransit_example = vault.Mount(\"transit-example\",\n    description=\"This is an example transit secret engine mount\",\n    options={\n        \"convergent_encryption\": False,\n    },\n    path=\"transit-example\",\n    type=\"transit\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var transit_example = new Vault.Mount(\"transit-example\", new Vault.MountArgs\n        {\n            Description = \"This is an example transit secret engine mount\",\n            Options = \n            {\n                { \"convergent_encryption\", false },\n            },\n            Path = \"transit-example\",\n            Type = \"transit\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewMount(ctx, \"transit-example\", \u0026vault.MountArgs{\n\t\t\tDescription: pulumi.String(\"This is an example transit secret engine mount\"),\n\t\t\tOptions: pulumi.AnyMap{\n\t\t\t\t\"convergent_encryption\": pulumi.Any(false),\n\t\t\t},\n\t\t\tPath: pulumi.String(\"transit-example\"),\n\t\t\tType: pulumi.String(\"transit\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst pki_example = new vault.Mount(\"pki-example\", {\n    defaultLeaseTtlSeconds: 3600,\n    description: \"This is an example PKI mount\",\n    maxLeaseTtlSeconds: 86400,\n    path: \"pki-example\",\n    type: \"pki\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\npki_example = vault.Mount(\"pki-example\",\n    default_lease_ttl_seconds=3600,\n    description=\"This is an example PKI mount\",\n    max_lease_ttl_seconds=86400,\n    path=\"pki-example\",\n    type=\"pki\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var pki_example = new Vault.Mount(\"pki-example\", new Vault.MountArgs\n        {\n            DefaultLeaseTtlSeconds = 3600,\n            Description = \"This is an example PKI mount\",\n            MaxLeaseTtlSeconds = 86400,\n            Path = \"pki-example\",\n            Type = \"pki\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewMount(ctx, \"pki-example\", \u0026vault.MountArgs{\n\t\t\tDefaultLeaseTtlSeconds: pulumi.Int(3600),\n\t\t\tDescription:            pulumi.String(\"This is an example PKI mount\"),\n\t\t\tMaxLeaseTtlSeconds:     pulumi.Int(86400),\n\t\t\tPath:                   pulumi.String(\"pki-example\"),\n\t\t\tType:                   pulumi.String(\"pki\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nMounts can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:index/mount:Mount example dummy\n```\n\n ",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The accessor for this mount.\n"
                },
                "auditNonHmacRequestKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the request data object.\n"
                },
                "auditNonHmacResponseKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the response data object.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Default lease duration for tokens and secrets in seconds\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount\n"
                },
                "externalEntropyAccess": {
                    "type": "boolean",
                    "description": "Boolean flag that can be explicitly set to true to enable the secrets engine to access Vault's external entropy source\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Boolean flag that can be explicitly set to true to enforce local mount in HA environment\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Maximum possible lease duration for tokens and secrets in seconds\n"
                },
                "options": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies mount type specific options that are passed to the backend\n"
                },
                "path": {
                    "type": "string",
                    "description": "Where the secret backend will be mounted\n"
                },
                "sealWrap": {
                    "type": "boolean",
                    "description": "Boolean flag that can be explicitly set to true to enable seal wrapping for the mount, causing values stored by the mount to be wrapped by the seal's encryption capability\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the backend, such as \"aws\"\n"
                }
            },
            "required": [
                "accessor",
                "auditNonHmacRequestKeys",
                "auditNonHmacResponseKeys",
                "defaultLeaseTtlSeconds",
                "maxLeaseTtlSeconds",
                "path",
                "sealWrap",
                "type"
            ],
            "inputProperties": {
                "auditNonHmacRequestKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the request data object.\n"
                },
                "auditNonHmacResponseKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the response data object.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Default lease duration for tokens and secrets in seconds\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount\n"
                },
                "externalEntropyAccess": {
                    "type": "boolean",
                    "description": "Boolean flag that can be explicitly set to true to enable the secrets engine to access Vault's external entropy source\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Boolean flag that can be explicitly set to true to enforce local mount in HA environment\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Maximum possible lease duration for tokens and secrets in seconds\n"
                },
                "options": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies mount type specific options that are passed to the backend\n"
                },
                "path": {
                    "type": "string",
                    "description": "Where the secret backend will be mounted\n"
                },
                "sealWrap": {
                    "type": "boolean",
                    "description": "Boolean flag that can be explicitly set to true to enable seal wrapping for the mount, causing values stored by the mount to be wrapped by the seal's encryption capability\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the backend, such as \"aws\"\n"
                }
            },
            "requiredInputs": [
                "path",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Mount resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The accessor for this mount.\n"
                    },
                    "auditNonHmacRequestKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the request data object.\n"
                    },
                    "auditNonHmacResponseKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the list of keys that will not be HMAC'd by audit devices in the response data object.\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "Default lease duration for tokens and secrets in seconds\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Human-friendly description of the mount\n"
                    },
                    "externalEntropyAccess": {
                        "type": "boolean",
                        "description": "Boolean flag that can be explicitly set to true to enable the secrets engine to access Vault's external entropy source\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Boolean flag that can be explicitly set to true to enforce local mount in HA environment\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "Maximum possible lease duration for tokens and secrets in seconds\n"
                    },
                    "options": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Specifies mount type specific options that are passed to the backend\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Where the secret backend will be mounted\n"
                    },
                    "sealWrap": {
                        "type": "boolean",
                        "description": "Boolean flag that can be explicitly set to true to enable seal wrapping for the mount, causing values stored by the mount to be wrapped by the seal's encryption capability\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of the backend, such as \"aws\"\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/namespace:Namespace": {
            "description": "Provides a resource to manage [Namespaces](https://www.vaultproject.io/docs/enterprise/namespaces/index.html).\n\n**Note** this feature is available only with Vault Enterprise.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst ns1 = new vault.Namespace(\"ns1\", {\n    path: \"ns1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nns1 = vault.Namespace(\"ns1\", path=\"ns1\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var ns1 = new Vault.Namespace(\"ns1\", new Vault.NamespaceArgs\n        {\n            Path = \"ns1\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewNamespace(ctx, \"ns1\", \u0026vault.NamespaceArgs{\n\t\t\tPath: pulumi.String(\"ns1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nNamespaces can be imported using its `name` as accessor id\n\n```sh\n $ pulumi import vault:index/namespace:Namespace example \u003cname\u003e\n```\n\n If the declared resource is imported and intends to support namespaces using a provider alias, then the name is relative to the namespace path. provider \"vault\" {\n\n # Configuration options\n\n namespace = \"example\"\n\n alias\n\n\n\n = \"example\" } resource vault_namespace \"example2\" {\n\n provider = vault.example }\n\n```sh\n $ pulumi import vault:index/namespace:Namespace example2 example2\n```\n\n $ terraform state show vault_namespace.example2 # vault_namespace.example2 resource \"vault_namespace\" \"example2\" {\n\n\n\n id\n\n\n\n\n\n\n\n\n\n = \"example/example2/\"\n\n\n\n namespace_id = \u003cknown after import\u003e\n\n\n\n path\n\n\n\n\n\n\n\n = \"example2\" } ",
            "properties": {
                "namespaceId": {
                    "type": "string",
                    "description": "ID of the namepsace.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path of the namespace. Must not have a trailing `/`\n"
                }
            },
            "required": [
                "namespaceId",
                "path"
            ],
            "inputProperties": {
                "path": {
                    "type": "string",
                    "description": "The path of the namespace. Must not have a trailing `/`\n"
                }
            },
            "requiredInputs": [
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Namespace resources.\n",
                "properties": {
                    "namespaceId": {
                        "type": "string",
                        "description": "ID of the namepsace.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path of the namespace. Must not have a trailing `/`\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/nomadSecretBackend:NomadSecretBackend": {
            "description": "\n\n\n## Import\n\nNomad secret backend can be imported using the `backend`, e.g.\n\n```sh\n $ pulumi import vault:index/nomadSecretBackend:NomadSecretBackend nomad nomad\n```\n\n ",
            "properties": {
                "address": {
                    "type": "string",
                    "description": "Specifies the address of the Nomad instance, provided\nas \"protocol://host:port\" like \"http://127.0.0.1:4646\".\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `nomad`.\n"
                },
                "caCert": {
                    "type": "string",
                    "description": "CA certificate to use when verifying the Nomad server certificate, must be\nx509 PEM encoded.\n"
                },
                "clientCert": {
                    "type": "string",
                    "description": "Client certificate to provide to the Nomad server, must be x509 PEM encoded.\n"
                },
                "clientKey": {
                    "type": "string",
                    "description": "Client certificate key to provide to the Nomad server, must be x509 PEM encoded.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Default lease duration for secrets in seconds.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the Active Directory backend.\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Mark the secrets engine as local-only. Local engines are not replicated or removed by\nreplication.Tolerance duration to use when checking the last rotation time.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Maximum possible lease duration for secrets in seconds.\n"
                },
                "maxTokenNameLength": {
                    "type": "integer",
                    "description": "Specifies the maximum length to use for the name of the Nomad token\ngenerated with Generate Credential. If omitted, 0 is used and ignored, defaulting to the max value allowed\nby the Nomad version.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "Maximum possible lease duration for secrets in seconds.\n"
                },
                "token": {
                    "type": "string",
                    "description": "Specifies the Nomad Management token to use.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "Specifies the ttl of the lease for the generated token.\n"
                }
            },
            "required": [
                "defaultLeaseTtlSeconds",
                "maxLeaseTtlSeconds",
                "maxTokenNameLength",
                "maxTtl",
                "ttl"
            ],
            "inputProperties": {
                "address": {
                    "type": "string",
                    "description": "Specifies the address of the Nomad instance, provided\nas \"protocol://host:port\" like \"http://127.0.0.1:4646\".\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `nomad`.\n"
                },
                "caCert": {
                    "type": "string",
                    "description": "CA certificate to use when verifying the Nomad server certificate, must be\nx509 PEM encoded.\n"
                },
                "clientCert": {
                    "type": "string",
                    "description": "Client certificate to provide to the Nomad server, must be x509 PEM encoded.\n"
                },
                "clientKey": {
                    "type": "string",
                    "description": "Client certificate key to provide to the Nomad server, must be x509 PEM encoded.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Default lease duration for secrets in seconds.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the Active Directory backend.\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Mark the secrets engine as local-only. Local engines are not replicated or removed by\nreplication.Tolerance duration to use when checking the last rotation time.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Maximum possible lease duration for secrets in seconds.\n"
                },
                "maxTokenNameLength": {
                    "type": "integer",
                    "description": "Specifies the maximum length to use for the name of the Nomad token\ngenerated with Generate Credential. If omitted, 0 is used and ignored, defaulting to the max value allowed\nby the Nomad version.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "Maximum possible lease duration for secrets in seconds.\n"
                },
                "token": {
                    "type": "string",
                    "description": "Specifies the Nomad Management token to use.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "Specifies the ttl of the lease for the generated token.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NomadSecretBackend resources.\n",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "Specifies the address of the Nomad instance, provided\nas \"protocol://host:port\" like \"http://127.0.0.1:4646\".\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `nomad`.\n"
                    },
                    "caCert": {
                        "type": "string",
                        "description": "CA certificate to use when verifying the Nomad server certificate, must be\nx509 PEM encoded.\n"
                    },
                    "clientCert": {
                        "type": "string",
                        "description": "Client certificate to provide to the Nomad server, must be x509 PEM encoded.\n"
                    },
                    "clientKey": {
                        "type": "string",
                        "description": "Client certificate key to provide to the Nomad server, must be x509 PEM encoded.\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "Default lease duration for secrets in seconds.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Human-friendly description of the mount for the Active Directory backend.\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Mark the secrets engine as local-only. Local engines are not replicated or removed by\nreplication.Tolerance duration to use when checking the last rotation time.\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "Maximum possible lease duration for secrets in seconds.\n"
                    },
                    "maxTokenNameLength": {
                        "type": "integer",
                        "description": "Specifies the maximum length to use for the name of the Nomad token\ngenerated with Generate Credential. If omitted, 0 is used and ignored, defaulting to the max value allowed\nby the Nomad version.\n"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "Maximum possible lease duration for secrets in seconds.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "Specifies the Nomad Management token to use.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "Specifies the ttl of the lease for the generated token.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/nomadSecretRole:NomadSecretRole": {
            "description": "\n\n\n## Import\n\nNomad secret role can be imported using the `backend`, e.g.\n\n```sh\n $ pulumi import vault:index/nomadSecretRole:NomadSecretRole bob nomad/role/bob\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `nomad`.\n"
                },
                "global": {
                    "type": "boolean",
                    "description": "Specifies if the generated token should be global. Defaults to \nfalse.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies attached to the generated token. This setting is only used \nwhen `type` is 'client'.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Specifies the type of token to create when using this role. Valid \nsettings are 'client' and 'management'. Defaults to 'client'.\n"
                }
            },
            "required": [
                "backend",
                "global",
                "policies",
                "role",
                "type"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `nomad`.\n"
                },
                "global": {
                    "type": "boolean",
                    "description": "Specifies if the generated token should be global. Defaults to \nfalse.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies attached to the generated token. This setting is only used \nwhen `type` is 'client'.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Specifies the type of token to create when using this role. Valid \nsettings are 'client' and 'management'. Defaults to 'client'.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NomadSecretRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `nomad`.\n"
                    },
                    "global": {
                        "type": "boolean",
                        "description": "Specifies if the generated token should be global. Defaults to \nfalse.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies attached to the generated token. This setting is only used \nwhen `type` is 'client'.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Specifies the type of token to create when using this role. Valid \nsettings are 'client' and 'management'. Defaults to 'client'.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/passwordPolicy:PasswordPolicy": {
            "description": "Provides a resource to manage Password Policies \n\n**Note** this feature is available only Vault 1.5+ \n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst alphanumeric = new vault.PasswordPolicy(\"alphanumeric\", {\n    policy: `    length = 20\n    rule \"charset\" {\n      charset = \"abcdefghijklmnopqrstuvwxyz0123456789\"\n    }\n  `,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nalphanumeric = vault.PasswordPolicy(\"alphanumeric\", policy=\"\"\"    length = 20\n    rule \"charset\" {\n      charset = \"abcdefghijklmnopqrstuvwxyz0123456789\"\n    }\n  \n\"\"\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var alphanumeric = new Vault.PasswordPolicy(\"alphanumeric\", new Vault.PasswordPolicyArgs\n        {\n            Policy = @\"    length = 20\n    rule \"\"charset\"\" {\n      charset = \"\"abcdefghijklmnopqrstuvwxyz0123456789\"\"\n    }\n  \n\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewPasswordPolicy(ctx, \"alphanumeric\", \u0026vault.PasswordPolicyArgs{\n\t\t\tPolicy: pulumi.String(fmt.Sprintf(\"%v%v%v%v%v\", \"    length = 20\\n\", \"    rule \\\"charset\\\" {\\n\", \"      charset = \\\"abcdefghijklmnopqrstuvwxyz0123456789\\\"\\n\", \"    }\\n\", \"  \\n\")),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nPassword policies can be imported using the `name`, e.g.\n\n```sh\n $ pulumi import vault:index/passwordPolicy:PasswordPolicy alphanumeric alphanumeric\n```\n\n ",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the password policy.\n"
                },
                "policy": {
                    "type": "string",
                    "description": "String containing a password policy.\n"
                }
            },
            "required": [
                "name",
                "policy"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "The name of the password policy.\n"
                },
                "policy": {
                    "type": "string",
                    "description": "String containing a password policy.\n"
                }
            },
            "requiredInputs": [
                "policy"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PasswordPolicy resources.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the password policy.\n"
                    },
                    "policy": {
                        "type": "string",
                        "description": "String containing a password policy.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/policy:Policy": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.Policy(\"example\", {\n    policy: `path \"secret/my_app\" {\n  capabilities = [\"update\"]\n}\n`,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.Policy(\"example\", policy=\"\"\"path \"secret/my_app\" {\n  capabilities = [\"update\"]\n}\n\n\"\"\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.Policy(\"example\", new Vault.PolicyArgs\n        {\n            Policy = @\"path \"\"secret/my_app\"\" {\n  capabilities = [\"\"update\"\"]\n}\n\n\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewPolicy(ctx, \"example\", \u0026vault.PolicyArgs{\n\t\t\tPolicy: pulumi.String(fmt.Sprintf(\"%v%v%v%v\", \"path \\\"secret/my_app\\\" {\\n\", \"  capabilities = [\\\"update\\\"]\\n\", \"}\\n\", \"\\n\")),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nPolicies can be imported using the `name`, e.g.\n\n```sh\n $ pulumi import vault:index/policy:Policy example dev-team\n```\n\n ",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the policy\n"
                },
                "policy": {
                    "type": "string",
                    "description": "String containing a Vault policy\n",
                    "language": {
                        "csharp": {
                            "name": "PolicyContents"
                        }
                    }
                }
            },
            "required": [
                "name",
                "policy"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "The name of the policy\n"
                },
                "policy": {
                    "type": "string",
                    "description": "String containing a Vault policy\n",
                    "language": {
                        "csharp": {
                            "name": "PolicyContents"
                        }
                    }
                }
            },
            "requiredInputs": [
                "policy"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Policy resources.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the policy\n"
                    },
                    "policy": {
                        "type": "string",
                        "description": "String containing a Vault policy\n",
                        "language": {
                            "csharp": {
                                "name": "PolicyContents"
                            }
                        }
                    }
                },
                "type": "object"
            }
        },
        "vault:index/quotaLeaseCount:QuotaLeaseCount": {
            "description": "Manage lease count quotas which enforce the number of leases that can be created.\nA lease count quota can be created at the root level or defined on a namespace or mount by\nspecifying a path when creating the quota.\n\nSee [Vault's Documentation](https://www.vaultproject.io/docs/enterprise/lease-count-quotas) for more\ninformation.   \n\n**Note** this feature is available only with Vault Enterprise.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst global = new vault.QuotaLeaseCount(\"global\", {\n    maxLeases: 100,\n    path: \"\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nglobal_ = vault.QuotaLeaseCount(\"global\",\n    max_leases=100,\n    path=\"\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var @global = new Vault.QuotaLeaseCount(\"global\", new Vault.QuotaLeaseCountArgs\n        {\n            MaxLeases = 100,\n            Path = \"\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewQuotaLeaseCount(ctx, \"global\", \u0026vault.QuotaLeaseCountArgs{\n\t\t\tMaxLeases: pulumi.Int(100),\n\t\t\tPath:      pulumi.String(\"\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nLease count quotas can be imported using their names\n\n```sh\n $ pulumi import vault:index/quotaLeaseCount:QuotaLeaseCount global global\n```\n\n ",
            "properties": {
                "maxLeases": {
                    "type": "integer",
                    "description": "The maximum number of leases to be allowed by the quota\nrule. The `max_leases` must be positive.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the rate limit quota\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path of the mount or namespace to apply the quota. A blank path configures a\nglobal rate limit quota. For example `namespace1/` adds a quota to a full namespace,\n`namespace1/auth/userpass` adds a `quota` to `userpass` in `namespace1`.\nUpdating this field on an existing quota can have \"moving\" effects. For example, updating\n`auth/userpass` to `namespace1/auth/userpass` moves this quota from being a global mount quota to\na namespace specific mount quota. **Note, namespaces are supported in Enterprise only.**\n"
                }
            },
            "required": [
                "maxLeases",
                "name"
            ],
            "inputProperties": {
                "maxLeases": {
                    "type": "integer",
                    "description": "The maximum number of leases to be allowed by the quota\nrule. The `max_leases` must be positive.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the rate limit quota\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path of the mount or namespace to apply the quota. A blank path configures a\nglobal rate limit quota. For example `namespace1/` adds a quota to a full namespace,\n`namespace1/auth/userpass` adds a `quota` to `userpass` in `namespace1`.\nUpdating this field on an existing quota can have \"moving\" effects. For example, updating\n`auth/userpass` to `namespace1/auth/userpass` moves this quota from being a global mount quota to\na namespace specific mount quota. **Note, namespaces are supported in Enterprise only.**\n"
                }
            },
            "requiredInputs": [
                "maxLeases"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering QuotaLeaseCount resources.\n",
                "properties": {
                    "maxLeases": {
                        "type": "integer",
                        "description": "The maximum number of leases to be allowed by the quota\nrule. The `max_leases` must be positive.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the rate limit quota\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Path of the mount or namespace to apply the quota. A blank path configures a\nglobal rate limit quota. For example `namespace1/` adds a quota to a full namespace,\n`namespace1/auth/userpass` adds a `quota` to `userpass` in `namespace1`.\nUpdating this field on an existing quota can have \"moving\" effects. For example, updating\n`auth/userpass` to `namespace1/auth/userpass` moves this quota from being a global mount quota to\na namespace specific mount quota. **Note, namespaces are supported in Enterprise only.**\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/quotaRateLimit:QuotaRateLimit": {
            "description": "Manage rate limit quotas which enforce API rate limiting using a token bucket algorithm.\nA rate limit quota can be created at the root level or defined on a namespace or mount by\nspecifying a path when creating the quota.\n\nSee [Vault's Documentation](https://www.vaultproject.io/docs/concepts/resource-quotas) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst global = new vault.QuotaRateLimit(\"global\", {\n    path: \"\",\n    rate: 100,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nglobal_ = vault.QuotaRateLimit(\"global\",\n    path=\"\",\n    rate=100)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var @global = new Vault.QuotaRateLimit(\"global\", new Vault.QuotaRateLimitArgs\n        {\n            Path = \"\",\n            Rate = 100,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewQuotaRateLimit(ctx, \"global\", \u0026vault.QuotaRateLimitArgs{\n\t\t\tPath: pulumi.String(\"\"),\n\t\t\tRate: pulumi.Float64(100),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nRate limit quotas can be imported using their names\n\n```sh\n $ pulumi import vault:index/quotaRateLimit:QuotaRateLimit global global\n```\n\n ",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the rate limit quota\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path of the mount or namespace to apply the quota. A blank path configures a\nglobal rate limit quota. For example `namespace1/` adds a quota to a full namespace,\n`namespace1/auth/userpass` adds a `quota` to `userpass` in `namespace1`.\nUpdating this field on an existing quota can have \"moving\" effects. For example, updating\n`auth/userpass` to `namespace1/auth/userpass` moves this quota from being a global mount quota to\na namespace specific mount quota. **Note, namespaces are supported in Enterprise only.**\n"
                },
                "rate": {
                    "type": "number",
                    "description": "The maximum number of requests at any given second to be allowed by the quota\nrule. The `rate` must be positive.\n"
                }
            },
            "required": [
                "name",
                "rate"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "Name of the rate limit quota\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path of the mount or namespace to apply the quota. A blank path configures a\nglobal rate limit quota. For example `namespace1/` adds a quota to a full namespace,\n`namespace1/auth/userpass` adds a `quota` to `userpass` in `namespace1`.\nUpdating this field on an existing quota can have \"moving\" effects. For example, updating\n`auth/userpass` to `namespace1/auth/userpass` moves this quota from being a global mount quota to\na namespace specific mount quota. **Note, namespaces are supported in Enterprise only.**\n"
                },
                "rate": {
                    "type": "number",
                    "description": "The maximum number of requests at any given second to be allowed by the quota\nrule. The `rate` must be positive.\n"
                }
            },
            "requiredInputs": [
                "rate"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering QuotaRateLimit resources.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Name of the rate limit quota\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Path of the mount or namespace to apply the quota. A blank path configures a\nglobal rate limit quota. For example `namespace1/` adds a quota to a full namespace,\n`namespace1/auth/userpass` adds a `quota` to `userpass` in `namespace1`.\nUpdating this field on an existing quota can have \"moving\" effects. For example, updating\n`auth/userpass` to `namespace1/auth/userpass` moves this quota from being a global mount quota to\na namespace specific mount quota. **Note, namespaces are supported in Enterprise only.**\n"
                    },
                    "rate": {
                        "type": "number",
                        "description": "The maximum number of requests at any given second to be allowed by the quota\nrule. The `rate` must be positive.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/raftAutopilot:RaftAutopilot": {
            "description": "Autopilot enables automated workflows for managing Raft clusters. The \ncurrent feature set includes 3 main features: Server Stabilization, Dead \nServer Cleanup and State API. **These three features are introduced in \nVault 1.7.**\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst autopilot = new vault.RaftAutopilot(\"autopilot\", {\n    cleanupDeadServers: true,\n    deadServerLastContactThreshold: \"24h0m0s\",\n    lastContactThreshold: \"10s\",\n    maxTrailingLogs: 1000,\n    minQuorum: 3,\n    serverStabilizationTime: \"10s\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nautopilot = vault.RaftAutopilot(\"autopilot\",\n    cleanup_dead_servers=True,\n    dead_server_last_contact_threshold=\"24h0m0s\",\n    last_contact_threshold=\"10s\",\n    max_trailing_logs=1000,\n    min_quorum=3,\n    server_stabilization_time=\"10s\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var autopilot = new Vault.RaftAutopilot(\"autopilot\", new Vault.RaftAutopilotArgs\n        {\n            CleanupDeadServers = true,\n            DeadServerLastContactThreshold = \"24h0m0s\",\n            LastContactThreshold = \"10s\",\n            MaxTrailingLogs = 1000,\n            MinQuorum = 3,\n            ServerStabilizationTime = \"10s\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewRaftAutopilot(ctx, \"autopilot\", \u0026vault.RaftAutopilotArgs{\n\t\t\tCleanupDeadServers:             pulumi.Bool(true),\n\t\t\tDeadServerLastContactThreshold: pulumi.String(\"24h0m0s\"),\n\t\t\tLastContactThreshold:           pulumi.String(\"10s\"),\n\t\t\tMaxTrailingLogs:                pulumi.Int(1000),\n\t\t\tMinQuorum:                      pulumi.Int(3),\n\t\t\tServerStabilizationTime:        pulumi.String(\"10s\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "cleanupDeadServers": {
                    "type": "boolean",
                    "description": "Specifies whether to remove dead server nodes\nperiodically or when a new server joins. This requires that `min-quorum` is also set.\n"
                },
                "deadServerLastContactThreshold": {
                    "type": "string",
                    "description": "Limit the amount of time a \nserver can go without leader contact before being considered failed. This only takes\neffect when `cleanup_dead_servers` is set.\n"
                },
                "lastContactThreshold": {
                    "type": "string",
                    "description": "Limit the amount of time a server can go \nwithout leader contact before being considered unhealthy.\n"
                },
                "maxTrailingLogs": {
                    "type": "integer",
                    "description": "Maximum number of log entries in the Raft log \nthat a server can be behind its leader before being considered unhealthy.\n"
                },
                "minQuorum": {
                    "type": "integer",
                    "description": "Minimum number of servers allowed in a cluster before \nautopilot can prune dead servers. This should at least be 3. Applicable only for\nvoting nodes.\n"
                },
                "serverStabilizationTime": {
                    "type": "string",
                    "description": "Minimum amount of time a server must be \nstable in the 'healthy' state before being added to the cluster.\n"
                }
            },
            "inputProperties": {
                "cleanupDeadServers": {
                    "type": "boolean",
                    "description": "Specifies whether to remove dead server nodes\nperiodically or when a new server joins. This requires that `min-quorum` is also set.\n"
                },
                "deadServerLastContactThreshold": {
                    "type": "string",
                    "description": "Limit the amount of time a \nserver can go without leader contact before being considered failed. This only takes\neffect when `cleanup_dead_servers` is set.\n"
                },
                "lastContactThreshold": {
                    "type": "string",
                    "description": "Limit the amount of time a server can go \nwithout leader contact before being considered unhealthy.\n"
                },
                "maxTrailingLogs": {
                    "type": "integer",
                    "description": "Maximum number of log entries in the Raft log \nthat a server can be behind its leader before being considered unhealthy.\n"
                },
                "minQuorum": {
                    "type": "integer",
                    "description": "Minimum number of servers allowed in a cluster before \nautopilot can prune dead servers. This should at least be 3. Applicable only for\nvoting nodes.\n"
                },
                "serverStabilizationTime": {
                    "type": "string",
                    "description": "Minimum amount of time a server must be \nstable in the 'healthy' state before being added to the cluster.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RaftAutopilot resources.\n",
                "properties": {
                    "cleanupDeadServers": {
                        "type": "boolean",
                        "description": "Specifies whether to remove dead server nodes\nperiodically or when a new server joins. This requires that `min-quorum` is also set.\n"
                    },
                    "deadServerLastContactThreshold": {
                        "type": "string",
                        "description": "Limit the amount of time a \nserver can go without leader contact before being considered failed. This only takes\neffect when `cleanup_dead_servers` is set.\n"
                    },
                    "lastContactThreshold": {
                        "type": "string",
                        "description": "Limit the amount of time a server can go \nwithout leader contact before being considered unhealthy.\n"
                    },
                    "maxTrailingLogs": {
                        "type": "integer",
                        "description": "Maximum number of log entries in the Raft log \nthat a server can be behind its leader before being considered unhealthy.\n"
                    },
                    "minQuorum": {
                        "type": "integer",
                        "description": "Minimum number of servers allowed in a cluster before \nautopilot can prune dead servers. This should at least be 3. Applicable only for\nvoting nodes.\n"
                    },
                    "serverStabilizationTime": {
                        "type": "string",
                        "description": "Minimum amount of time a server must be \nstable in the 'healthy' state before being added to the cluster.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/raftSnapshotAgentConfig:RaftSnapshotAgentConfig": {
            "description": "\n\n\n## Import\n\nRaft Snapshot Agent Configurations can be imported using the `name`, e.g.\n\n```sh\n $ pulumi import vault:index/raftSnapshotAgentConfig:RaftSnapshotAgentConfig local local\n```\n\n ",
            "properties": {
                "awsAccessKeyId": {
                    "type": "string",
                    "description": "AWS access key ID.\n"
                },
                "awsS3Bucket": {
                    "type": "string",
                    "description": "`\u003crequired\u003e` - S3 bucket to write snapshots to.\n"
                },
                "awsS3DisableTls": {
                    "type": "boolean",
                    "description": "Disable TLS for the S3 endpoint. This\nshould only be used for testing purposes, typically in conjunction with\n`aws_s3_endpoint`.\n"
                },
                "awsS3EnableKms": {
                    "type": "boolean",
                    "description": "Use KMS to encrypt bucket contents.\n"
                },
                "awsS3Endpoint": {
                    "type": "string",
                    "description": "AWS endpoint. This is typically only set when\nusing a non-AWS S3 implementation like Minio.\n"
                },
                "awsS3ForcePathStyle": {
                    "type": "boolean",
                    "description": "Use the endpoint/bucket URL style\ninstead of bucket.endpoint. May be needed when setting `aws_s3_endpoint`.\n"
                },
                "awsS3KmsKey": {
                    "type": "string",
                    "description": "Use named KMS key, when `aws_s3_enable_kms = true`\n"
                },
                "awsS3Region": {
                    "type": "string",
                    "description": "`\u003crequired\u003e` - AWS region bucket is in.\n"
                },
                "awsS3ServerSideEncryption": {
                    "type": "boolean",
                    "description": "Use AES256 to encrypt bucket contents.\n"
                },
                "awsSecretAccessKey": {
                    "type": "string",
                    "description": "AWS secret access key.\n"
                },
                "awsSessionToken": {
                    "type": "string",
                    "description": "AWS session token.\n"
                },
                "azureAccountKey": {
                    "type": "string",
                    "description": "Azure account key.\n"
                },
                "azureAccountName": {
                    "type": "string",
                    "description": "Azure account name.\n"
                },
                "azureBlobEnvironment": {
                    "type": "string",
                    "description": "Azure blob environment.\n"
                },
                "azureContainerName": {
                    "type": "string",
                    "description": "`\u003crequired\u003e` - Azure container name to write\nsnapshots to.\n"
                },
                "azureEndpoint": {
                    "type": "string",
                    "description": "Azure blob storage endpoint. This is typically\nonly set when using a non-Azure implementation like Azurite.\n"
                },
                "filePrefix": {
                    "type": "string",
                    "description": "Within the directory or bucket\nprefix given by `path_prefix`, the file or object name of snapshot files\nwill start with this string.\n"
                },
                "googleDisableTls": {
                    "type": "boolean",
                    "description": "Disable TLS for the GCS endpoint. This\nshould only be used for testing purposes, typically in conjunction with\n`google_endpoint`.\n"
                },
                "googleEndpoint": {
                    "type": "string",
                    "description": "GCS endpoint. This is typically only set when\nusing a non-Google GCS implementation like fake-gcs-server.\n"
                },
                "googleGcsBucket": {
                    "type": "string",
                    "description": "`\u003crequired\u003e` - GCS bucket to write snapshots to.\n"
                },
                "googleServiceAccountKey": {
                    "type": "string",
                    "description": "Google service account key in JSON format. \nThe raw value looks like this:\n"
                },
                "intervalSeconds": {
                    "type": "integer",
                    "description": "`\u003crequired\u003e` - Time (in seconds) between snapshots.\n"
                },
                "localMaxSpace": {
                    "type": "integer",
                    "description": "For `storage_type = local`, the maximum\nspace, in bytes, to use for snapshots. Snapshot attempts will fail if there is not enough\nspace left in this allowance.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`\u003crequired\u003e`  Name of the configuration to modify.\n"
                },
                "pathPrefix": {
                    "type": "string",
                    "description": "`\u003crequired\u003e` - For `storage_type = \"local\"`, the directory to\nwrite the snapshots in. For cloud storage types, the bucket prefix to use.\nTypes `azure-s3` and `google-gcs` require a trailing `/` (slash).\nTypes `local` and `aws-s3` the trailing `/` is optional.\n"
                },
                "retain": {
                    "type": "integer",
                    "description": "How many snapshots are to be kept; when writing a\nsnapshot, if there are more snapshots already stored than this number, the\noldest ones will be deleted.\n"
                },
                "storageType": {
                    "type": "string",
                    "description": "`\u003crequired\u003e` - One of \"local\", \"azure-blob\", \"aws-s3\",\nor \"google-gcs\". The remaining parameters described below are all specific to\nthe selected `storage_type` and prefixed accordingly.\n"
                }
            },
            "required": [
                "intervalSeconds",
                "name",
                "pathPrefix",
                "storageType"
            ],
            "inputProperties": {
                "awsAccessKeyId": {
                    "type": "string",
                    "description": "AWS access key ID.\n"
                },
                "awsS3Bucket": {
                    "type": "string",
                    "description": "`\u003crequired\u003e` - S3 bucket to write snapshots to.\n"
                },
                "awsS3DisableTls": {
                    "type": "boolean",
                    "description": "Disable TLS for the S3 endpoint. This\nshould only be used for testing purposes, typically in conjunction with\n`aws_s3_endpoint`.\n"
                },
                "awsS3EnableKms": {
                    "type": "boolean",
                    "description": "Use KMS to encrypt bucket contents.\n"
                },
                "awsS3Endpoint": {
                    "type": "string",
                    "description": "AWS endpoint. This is typically only set when\nusing a non-AWS S3 implementation like Minio.\n"
                },
                "awsS3ForcePathStyle": {
                    "type": "boolean",
                    "description": "Use the endpoint/bucket URL style\ninstead of bucket.endpoint. May be needed when setting `aws_s3_endpoint`.\n"
                },
                "awsS3KmsKey": {
                    "type": "string",
                    "description": "Use named KMS key, when `aws_s3_enable_kms = true`\n"
                },
                "awsS3Region": {
                    "type": "string",
                    "description": "`\u003crequired\u003e` - AWS region bucket is in.\n"
                },
                "awsS3ServerSideEncryption": {
                    "type": "boolean",
                    "description": "Use AES256 to encrypt bucket contents.\n"
                },
                "awsSecretAccessKey": {
                    "type": "string",
                    "description": "AWS secret access key.\n"
                },
                "awsSessionToken": {
                    "type": "string",
                    "description": "AWS session token.\n"
                },
                "azureAccountKey": {
                    "type": "string",
                    "description": "Azure account key.\n"
                },
                "azureAccountName": {
                    "type": "string",
                    "description": "Azure account name.\n"
                },
                "azureBlobEnvironment": {
                    "type": "string",
                    "description": "Azure blob environment.\n"
                },
                "azureContainerName": {
                    "type": "string",
                    "description": "`\u003crequired\u003e` - Azure container name to write\nsnapshots to.\n"
                },
                "azureEndpoint": {
                    "type": "string",
                    "description": "Azure blob storage endpoint. This is typically\nonly set when using a non-Azure implementation like Azurite.\n"
                },
                "filePrefix": {
                    "type": "string",
                    "description": "Within the directory or bucket\nprefix given by `path_prefix`, the file or object name of snapshot files\nwill start with this string.\n"
                },
                "googleDisableTls": {
                    "type": "boolean",
                    "description": "Disable TLS for the GCS endpoint. This\nshould only be used for testing purposes, typically in conjunction with\n`google_endpoint`.\n"
                },
                "googleEndpoint": {
                    "type": "string",
                    "description": "GCS endpoint. This is typically only set when\nusing a non-Google GCS implementation like fake-gcs-server.\n"
                },
                "googleGcsBucket": {
                    "type": "string",
                    "description": "`\u003crequired\u003e` - GCS bucket to write snapshots to.\n"
                },
                "googleServiceAccountKey": {
                    "type": "string",
                    "description": "Google service account key in JSON format. \nThe raw value looks like this:\n"
                },
                "intervalSeconds": {
                    "type": "integer",
                    "description": "`\u003crequired\u003e` - Time (in seconds) between snapshots.\n"
                },
                "localMaxSpace": {
                    "type": "integer",
                    "description": "For `storage_type = local`, the maximum\nspace, in bytes, to use for snapshots. Snapshot attempts will fail if there is not enough\nspace left in this allowance.\n"
                },
                "name": {
                    "type": "string",
                    "description": "`\u003crequired\u003e`  Name of the configuration to modify.\n"
                },
                "pathPrefix": {
                    "type": "string",
                    "description": "`\u003crequired\u003e` - For `storage_type = \"local\"`, the directory to\nwrite the snapshots in. For cloud storage types, the bucket prefix to use.\nTypes `azure-s3` and `google-gcs` require a trailing `/` (slash).\nTypes `local` and `aws-s3` the trailing `/` is optional.\n"
                },
                "retain": {
                    "type": "integer",
                    "description": "How many snapshots are to be kept; when writing a\nsnapshot, if there are more snapshots already stored than this number, the\noldest ones will be deleted.\n"
                },
                "storageType": {
                    "type": "string",
                    "description": "`\u003crequired\u003e` - One of \"local\", \"azure-blob\", \"aws-s3\",\nor \"google-gcs\". The remaining parameters described below are all specific to\nthe selected `storage_type` and prefixed accordingly.\n"
                }
            },
            "requiredInputs": [
                "intervalSeconds",
                "pathPrefix",
                "storageType"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RaftSnapshotAgentConfig resources.\n",
                "properties": {
                    "awsAccessKeyId": {
                        "type": "string",
                        "description": "AWS access key ID.\n"
                    },
                    "awsS3Bucket": {
                        "type": "string",
                        "description": "`\u003crequired\u003e` - S3 bucket to write snapshots to.\n"
                    },
                    "awsS3DisableTls": {
                        "type": "boolean",
                        "description": "Disable TLS for the S3 endpoint. This\nshould only be used for testing purposes, typically in conjunction with\n`aws_s3_endpoint`.\n"
                    },
                    "awsS3EnableKms": {
                        "type": "boolean",
                        "description": "Use KMS to encrypt bucket contents.\n"
                    },
                    "awsS3Endpoint": {
                        "type": "string",
                        "description": "AWS endpoint. This is typically only set when\nusing a non-AWS S3 implementation like Minio.\n"
                    },
                    "awsS3ForcePathStyle": {
                        "type": "boolean",
                        "description": "Use the endpoint/bucket URL style\ninstead of bucket.endpoint. May be needed when setting `aws_s3_endpoint`.\n"
                    },
                    "awsS3KmsKey": {
                        "type": "string",
                        "description": "Use named KMS key, when `aws_s3_enable_kms = true`\n"
                    },
                    "awsS3Region": {
                        "type": "string",
                        "description": "`\u003crequired\u003e` - AWS region bucket is in.\n"
                    },
                    "awsS3ServerSideEncryption": {
                        "type": "boolean",
                        "description": "Use AES256 to encrypt bucket contents.\n"
                    },
                    "awsSecretAccessKey": {
                        "type": "string",
                        "description": "AWS secret access key.\n"
                    },
                    "awsSessionToken": {
                        "type": "string",
                        "description": "AWS session token.\n"
                    },
                    "azureAccountKey": {
                        "type": "string",
                        "description": "Azure account key.\n"
                    },
                    "azureAccountName": {
                        "type": "string",
                        "description": "Azure account name.\n"
                    },
                    "azureBlobEnvironment": {
                        "type": "string",
                        "description": "Azure blob environment.\n"
                    },
                    "azureContainerName": {
                        "type": "string",
                        "description": "`\u003crequired\u003e` - Azure container name to write\nsnapshots to.\n"
                    },
                    "azureEndpoint": {
                        "type": "string",
                        "description": "Azure blob storage endpoint. This is typically\nonly set when using a non-Azure implementation like Azurite.\n"
                    },
                    "filePrefix": {
                        "type": "string",
                        "description": "Within the directory or bucket\nprefix given by `path_prefix`, the file or object name of snapshot files\nwill start with this string.\n"
                    },
                    "googleDisableTls": {
                        "type": "boolean",
                        "description": "Disable TLS for the GCS endpoint. This\nshould only be used for testing purposes, typically in conjunction with\n`google_endpoint`.\n"
                    },
                    "googleEndpoint": {
                        "type": "string",
                        "description": "GCS endpoint. This is typically only set when\nusing a non-Google GCS implementation like fake-gcs-server.\n"
                    },
                    "googleGcsBucket": {
                        "type": "string",
                        "description": "`\u003crequired\u003e` - GCS bucket to write snapshots to.\n"
                    },
                    "googleServiceAccountKey": {
                        "type": "string",
                        "description": "Google service account key in JSON format. \nThe raw value looks like this:\n"
                    },
                    "intervalSeconds": {
                        "type": "integer",
                        "description": "`\u003crequired\u003e` - Time (in seconds) between snapshots.\n"
                    },
                    "localMaxSpace": {
                        "type": "integer",
                        "description": "For `storage_type = local`, the maximum\nspace, in bytes, to use for snapshots. Snapshot attempts will fail if there is not enough\nspace left in this allowance.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "`\u003crequired\u003e`  Name of the configuration to modify.\n"
                    },
                    "pathPrefix": {
                        "type": "string",
                        "description": "`\u003crequired\u003e` - For `storage_type = \"local\"`, the directory to\nwrite the snapshots in. For cloud storage types, the bucket prefix to use.\nTypes `azure-s3` and `google-gcs` require a trailing `/` (slash).\nTypes `local` and `aws-s3` the trailing `/` is optional.\n"
                    },
                    "retain": {
                        "type": "integer",
                        "description": "How many snapshots are to be kept; when writing a\nsnapshot, if there are more snapshots already stored than this number, the\noldest ones will be deleted.\n"
                    },
                    "storageType": {
                        "type": "string",
                        "description": "`\u003crequired\u003e` - One of \"local\", \"azure-blob\", \"aws-s3\",\nor \"google-gcs\". The remaining parameters described below are all specific to\nthe selected `storage_type` and prefixed accordingly.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/rgpPolicy:RgpPolicy": {
            "description": "Provides a resource to manage Role Governing Policy (RGP) via [Sentinel](https://www.vaultproject.io/docs/enterprise/sentinel/index.html).\n\n**Note** this feature is available only with Vault Enterprise.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst allow_all = new vault.RgpPolicy(\"allow-all\", {\n    enforcementLevel: \"soft-mandatory\",\n    policy: `main = rule {\n  true\n}\n`,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nallow_all = vault.RgpPolicy(\"allow-all\",\n    enforcement_level=\"soft-mandatory\",\n    policy=\"\"\"main = rule {\n  true\n}\n\n\"\"\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var allow_all = new Vault.RgpPolicy(\"allow-all\", new Vault.RgpPolicyArgs\n        {\n            EnforcementLevel = \"soft-mandatory\",\n            Policy = @\"main = rule {\n  true\n}\n\n\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewRgpPolicy(ctx, \"allow-all\", \u0026vault.RgpPolicyArgs{\n\t\t\tEnforcementLevel: pulumi.String(\"soft-mandatory\"),\n\t\t\tPolicy:           pulumi.String(fmt.Sprintf(\"%v%v%v%v\", \"main = rule {\\n\", \"  true\\n\", \"}\\n\", \"\\n\")),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "enforcementLevel": {
                    "type": "string",
                    "description": "Enforcement level of Sentinel policy. Can be either `advisory` or `soft-mandatory` or `hard-mandatory`\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the policy\n"
                },
                "policy": {
                    "type": "string",
                    "description": "String containing a Sentinel policy\n"
                }
            },
            "required": [
                "enforcementLevel",
                "name",
                "policy"
            ],
            "inputProperties": {
                "enforcementLevel": {
                    "type": "string",
                    "description": "Enforcement level of Sentinel policy. Can be either `advisory` or `soft-mandatory` or `hard-mandatory`\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the policy\n"
                },
                "policy": {
                    "type": "string",
                    "description": "String containing a Sentinel policy\n"
                }
            },
            "requiredInputs": [
                "enforcementLevel",
                "policy"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RgpPolicy resources.\n",
                "properties": {
                    "enforcementLevel": {
                        "type": "string",
                        "description": "Enforcement level of Sentinel policy. Can be either `advisory` or `soft-mandatory` or `hard-mandatory`\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the policy\n"
                    },
                    "policy": {
                        "type": "string",
                        "description": "String containing a Sentinel policy\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/token:Token": {
            "description": "\n\n\n## Import\n\nTokens can be imported using its `id` as accessor id, e.g.\n\n```sh\n $ pulumi import vault:index/token:Token example \u003caccessor_id\u003e\n```\n\n ",
            "properties": {
                "clientToken": {
                    "type": "string",
                    "description": "String containing the client token if stored in present file\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "String containing the token display name\n"
                },
                "explicitMaxTtl": {
                    "type": "string",
                    "description": "The explicit max TTL of this token\n"
                },
                "leaseDuration": {
                    "type": "integer",
                    "description": "String containing the token lease duration if present in state file\n"
                },
                "leaseStarted": {
                    "type": "string",
                    "description": "String containing the token lease started time if present in state file\n"
                },
                "noDefaultPolicy": {
                    "type": "boolean",
                    "description": "Flag to not attach the default policy to this token\n"
                },
                "noParent": {
                    "type": "boolean",
                    "description": "Flag to create a token without parent\n"
                },
                "numUses": {
                    "type": "integer",
                    "description": "The number of allowed uses of this token\n"
                },
                "period": {
                    "type": "string",
                    "description": "The period of this token\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to attach to this token\n"
                },
                "renewIncrement": {
                    "type": "integer",
                    "description": "The renew increment\n"
                },
                "renewMinLease": {
                    "type": "integer",
                    "description": "The minimal lease to renew this token\n"
                },
                "renewable": {
                    "type": "boolean",
                    "description": "Flag to allow to renew this token\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The token role name\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "The TTL period of this token\n"
                },
                "wrappedToken": {
                    "type": "string",
                    "description": "The client wrapped token.\n"
                },
                "wrappingAccessor": {
                    "type": "string",
                    "description": "The client wrapping accessor.\n"
                },
                "wrappingTtl": {
                    "type": "string",
                    "description": "The TTL period of the wrapped token.\n"
                }
            },
            "required": [
                "clientToken",
                "leaseDuration",
                "leaseStarted",
                "noParent",
                "numUses",
                "renewable",
                "wrappedToken",
                "wrappingAccessor"
            ],
            "inputProperties": {
                "displayName": {
                    "type": "string",
                    "description": "String containing the token display name\n"
                },
                "explicitMaxTtl": {
                    "type": "string",
                    "description": "The explicit max TTL of this token\n"
                },
                "noDefaultPolicy": {
                    "type": "boolean",
                    "description": "Flag to not attach the default policy to this token\n"
                },
                "noParent": {
                    "type": "boolean",
                    "description": "Flag to create a token without parent\n"
                },
                "numUses": {
                    "type": "integer",
                    "description": "The number of allowed uses of this token\n"
                },
                "period": {
                    "type": "string",
                    "description": "The period of this token\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to attach to this token\n"
                },
                "renewIncrement": {
                    "type": "integer",
                    "description": "The renew increment\n"
                },
                "renewMinLease": {
                    "type": "integer",
                    "description": "The minimal lease to renew this token\n"
                },
                "renewable": {
                    "type": "boolean",
                    "description": "Flag to allow to renew this token\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The token role name\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "The TTL period of this token\n"
                },
                "wrappingTtl": {
                    "type": "string",
                    "description": "The TTL period of the wrapped token.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Token resources.\n",
                "properties": {
                    "clientToken": {
                        "type": "string",
                        "description": "String containing the client token if stored in present file\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "String containing the token display name\n"
                    },
                    "explicitMaxTtl": {
                        "type": "string",
                        "description": "The explicit max TTL of this token\n"
                    },
                    "leaseDuration": {
                        "type": "integer",
                        "description": "String containing the token lease duration if present in state file\n"
                    },
                    "leaseStarted": {
                        "type": "string",
                        "description": "String containing the token lease started time if present in state file\n"
                    },
                    "noDefaultPolicy": {
                        "type": "boolean",
                        "description": "Flag to not attach the default policy to this token\n"
                    },
                    "noParent": {
                        "type": "boolean",
                        "description": "Flag to create a token without parent\n"
                    },
                    "numUses": {
                        "type": "integer",
                        "description": "The number of allowed uses of this token\n"
                    },
                    "period": {
                        "type": "string",
                        "description": "The period of this token\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to attach to this token\n"
                    },
                    "renewIncrement": {
                        "type": "integer",
                        "description": "The renew increment\n"
                    },
                    "renewMinLease": {
                        "type": "integer",
                        "description": "The minimal lease to renew this token\n"
                    },
                    "renewable": {
                        "type": "boolean",
                        "description": "Flag to allow to renew this token\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The token role name\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "The TTL period of this token\n"
                    },
                    "wrappedToken": {
                        "type": "string",
                        "description": "The client wrapped token.\n"
                    },
                    "wrappingAccessor": {
                        "type": "string",
                        "description": "The client wrapping accessor.\n"
                    },
                    "wrappingTtl": {
                        "type": "string",
                        "description": "The TTL period of the wrapped token.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:jwt/authBackend:AuthBackend": {
            "description": "Provides a resource for managing an\n[JWT auth backend within Vault](https://www.vaultproject.io/docs/auth/jwt.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nManage JWT auth backend:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.jwt.AuthBackend(\"example\", {\n    boundIssuer: \"https://myco.auth0.com/\",\n    description: \"Demonstration of the Terraform JWT auth backend\",\n    oidcDiscoveryUrl: \"https://myco.auth0.com/\",\n    path: \"jwt\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.jwt.AuthBackend(\"example\",\n    bound_issuer=\"https://myco.auth0.com/\",\n    description=\"Demonstration of the Terraform JWT auth backend\",\n    oidc_discovery_url=\"https://myco.auth0.com/\",\n    path=\"jwt\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.Jwt.AuthBackend(\"example\", new Vault.Jwt.AuthBackendArgs\n        {\n            BoundIssuer = \"https://myco.auth0.com/\",\n            Description = \"Demonstration of the Terraform JWT auth backend\",\n            OidcDiscoveryUrl = \"https://myco.auth0.com/\",\n            Path = \"jwt\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/jwt\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := jwt.NewAuthBackend(ctx, \"example\", \u0026jwt.AuthBackendArgs{\n\t\t\tBoundIssuer:      pulumi.String(\"https://myco.auth0.com/\"),\n\t\t\tDescription:      pulumi.String(\"Demonstration of the Terraform JWT auth backend\"),\n\t\t\tOidcDiscoveryUrl: pulumi.String(\"https://myco.auth0.com/\"),\n\t\t\tPath:             pulumi.String(\"jwt\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\nManage OIDC auth backend:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.jwt.AuthBackend(\"example\", {\n    boundIssuer: \"https://myco.auth0.com/\",\n    description: \"Demonstration of the Terraform JWT auth backend\",\n    oidcClientId: \"1234567890\",\n    oidcClientSecret: \"secret123456\",\n    oidcDiscoveryUrl: \"https://myco.auth0.com/\",\n    path: \"oidc\",\n    tune: {\n        listingVisibility: \"unauth\",\n    },\n    type: \"oidc\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.jwt.AuthBackend(\"example\",\n    bound_issuer=\"https://myco.auth0.com/\",\n    description=\"Demonstration of the Terraform JWT auth backend\",\n    oidc_client_id=\"1234567890\",\n    oidc_client_secret=\"secret123456\",\n    oidc_discovery_url=\"https://myco.auth0.com/\",\n    path=\"oidc\",\n    tune=vault.jwt.AuthBackendTuneArgs(\n        listing_visibility=\"unauth\",\n    ),\n    type=\"oidc\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.Jwt.AuthBackend(\"example\", new Vault.Jwt.AuthBackendArgs\n        {\n            BoundIssuer = \"https://myco.auth0.com/\",\n            Description = \"Demonstration of the Terraform JWT auth backend\",\n            OidcClientId = \"1234567890\",\n            OidcClientSecret = \"secret123456\",\n            OidcDiscoveryUrl = \"https://myco.auth0.com/\",\n            Path = \"oidc\",\n            Tune = new Vault.Jwt.Inputs.AuthBackendTuneArgs\n            {\n                ListingVisibility = \"unauth\",\n            },\n            Type = \"oidc\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/jwt\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := jwt.NewAuthBackend(ctx, \"example\", \u0026jwt.AuthBackendArgs{\n\t\t\tBoundIssuer:      pulumi.String(\"https://myco.auth0.com/\"),\n\t\t\tDescription:      pulumi.String(\"Demonstration of the Terraform JWT auth backend\"),\n\t\t\tOidcClientId:     pulumi.String(\"1234567890\"),\n\t\t\tOidcClientSecret: pulumi.String(\"secret123456\"),\n\t\t\tOidcDiscoveryUrl: pulumi.String(\"https://myco.auth0.com/\"),\n\t\t\tPath:             pulumi.String(\"oidc\"),\n\t\t\tTune: \u0026jwt.AuthBackendTuneArgs{\n\t\t\t\tListingVisibility: pulumi.String(\"unauth\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"oidc\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\nConfiguring the auth backend with a `provider_config:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst gsuite = new vault.jwt.AuthBackend(\"gsuite\", {\n    description: \"OIDC backend\",\n    oidcDiscoveryUrl: \"https://accounts.google.com\",\n    path: \"oidc\",\n    providerConfig: {\n        fetch_groups: true,\n        fetch_user_info: true,\n        groups_recurse_max_depth: 1,\n        provider: \"gsuite\",\n    },\n    type: \"oidc\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ngsuite = vault.jwt.AuthBackend(\"gsuite\",\n    description=\"OIDC backend\",\n    oidc_discovery_url=\"https://accounts.google.com\",\n    path=\"oidc\",\n    provider_config={\n        \"fetch_groups\": \"true\",\n        \"fetch_user_info\": \"true\",\n        \"groups_recurse_max_depth\": \"1\",\n        \"provider\": \"gsuite\",\n    },\n    type=\"oidc\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var gsuite = new Vault.Jwt.AuthBackend(\"gsuite\", new Vault.Jwt.AuthBackendArgs\n        {\n            Description = \"OIDC backend\",\n            OidcDiscoveryUrl = \"https://accounts.google.com\",\n            Path = \"oidc\",\n            ProviderConfig = \n            {\n                { \"fetch_groups\", \"true\" },\n                { \"fetch_user_info\", \"true\" },\n                { \"groups_recurse_max_depth\", \"1\" },\n                { \"provider\", \"gsuite\" },\n            },\n            Type = \"oidc\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/jwt\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := jwt.NewAuthBackend(ctx, \"gsuite\", \u0026jwt.AuthBackendArgs{\n\t\t\tDescription:      pulumi.String(\"OIDC backend\"),\n\t\t\tOidcDiscoveryUrl: pulumi.String(\"https://accounts.google.com\"),\n\t\t\tPath:             pulumi.String(\"oidc\"),\n\t\t\tProviderConfig: pulumi.StringMap{\n\t\t\t\t\"fetch_groups\":             pulumi.String(\"true\"),\n\t\t\t\t\"fetch_user_info\":          pulumi.String(\"true\"),\n\t\t\t\t\"groups_recurse_max_depth\": pulumi.String(\"1\"),\n\t\t\t\t\"provider\":                 pulumi.String(\"gsuite\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"oidc\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nJWT auth backend can be imported using the `type`, e.g.\n\n```sh\n $ pulumi import vault:jwt/authBackend:AuthBackend oidc oidc\n```\n\n or\n\n```sh\n $ pulumi import vault:jwt/authBackend:AuthBackend jwt jwt\n```\n\n ",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The accessor for this auth method\n"
                },
                "boundIssuer": {
                    "type": "string",
                    "description": "The value against which to match the iss claim in a JWT\n"
                },
                "defaultRole": {
                    "type": "string",
                    "description": "The default role to use if none is provided during login\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the auth backend\n"
                },
                "jwksCaPem": {
                    "type": "string",
                    "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the JWKS URL. If not set, system certificates are used.\n"
                },
                "jwksUrl": {
                    "type": "string",
                    "description": "JWKS URL to use to authenticate signatures. Cannot be used with \"oidc_discovery_url\" or \"jwt_validation_pubkeys\".\n"
                },
                "jwtSupportedAlgs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of supported signing algorithms. Vault 1.1.0 defaults to [RS256] but future or past versions of Vault may differ\n"
                },
                "jwtValidationPubkeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of PEM-encoded public keys to use to authenticate signatures locally. Cannot be used in combination with `oidc_discovery_url`\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the auth method is local only.\n"
                },
                "namespaceInState": {
                    "type": "boolean",
                    "description": "Pass namespace in the OIDC state parameter instead of as a separate query parameter. With this setting, the allowed redirect URL(s) in Vault and on the provider side should not contain a namespace query parameter. This means only one redirect URL entry needs to be maintained on the OIDC provider side for all vault namespaces that will be authenticating against it. Defaults to true for new configs\n"
                },
                "oidcClientId": {
                    "type": "string",
                    "description": "Client ID used for OIDC backends\n"
                },
                "oidcClientSecret": {
                    "type": "string",
                    "description": "Client Secret used for OIDC backends\n"
                },
                "oidcDiscoveryCaPem": {
                    "type": "string",
                    "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the OIDC Discovery URL. If not set, system certificates are used\n"
                },
                "oidcDiscoveryUrl": {
                    "type": "string",
                    "description": "The OIDC Discovery URL, without any .well-known component (base path). Cannot be used in combination with `jwt_validation_pubkeys`\n"
                },
                "oidcResponseMode": {
                    "type": "string",
                    "description": "The response mode to be used in the OAuth2 request. Allowed values are `query` and `form_post`. Defaults to `query`. If using Vault namespaces, and `oidc_response_mode` is `form_post`, then `namespace_in_state` should be set to `false`.\n"
                },
                "oidcResponseTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of response types to request. Allowed values are 'code' and 'id_token'. Defaults to `[\"code\"]`. Note: `id_token` may only be used if `oidc_response_mode` is set to `form_post`.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to mount the JWT/OIDC auth backend\n"
                },
                "providerConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Provider specific handling configuration. All values may be strings, and the provider will convert to the appropriate type when configuring Vault.\n"
                },
                "tune": {
                    "$ref": "#/types/vault:jwt/AuthBackendTune:AuthBackendTune"
                },
                "type": {
                    "type": "string",
                    "description": "Type of auth backend. Should be one of `jwt` or `oidc`. Default - `jwt`\n"
                }
            },
            "required": [
                "accessor",
                "tune"
            ],
            "inputProperties": {
                "boundIssuer": {
                    "type": "string",
                    "description": "The value against which to match the iss claim in a JWT\n"
                },
                "defaultRole": {
                    "type": "string",
                    "description": "The default role to use if none is provided during login\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the auth backend\n"
                },
                "jwksCaPem": {
                    "type": "string",
                    "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the JWKS URL. If not set, system certificates are used.\n"
                },
                "jwksUrl": {
                    "type": "string",
                    "description": "JWKS URL to use to authenticate signatures. Cannot be used with \"oidc_discovery_url\" or \"jwt_validation_pubkeys\".\n"
                },
                "jwtSupportedAlgs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of supported signing algorithms. Vault 1.1.0 defaults to [RS256] but future or past versions of Vault may differ\n"
                },
                "jwtValidationPubkeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of PEM-encoded public keys to use to authenticate signatures locally. Cannot be used in combination with `oidc_discovery_url`\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the auth method is local only.\n"
                },
                "namespaceInState": {
                    "type": "boolean",
                    "description": "Pass namespace in the OIDC state parameter instead of as a separate query parameter. With this setting, the allowed redirect URL(s) in Vault and on the provider side should not contain a namespace query parameter. This means only one redirect URL entry needs to be maintained on the OIDC provider side for all vault namespaces that will be authenticating against it. Defaults to true for new configs\n"
                },
                "oidcClientId": {
                    "type": "string",
                    "description": "Client ID used for OIDC backends\n"
                },
                "oidcClientSecret": {
                    "type": "string",
                    "description": "Client Secret used for OIDC backends\n"
                },
                "oidcDiscoveryCaPem": {
                    "type": "string",
                    "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the OIDC Discovery URL. If not set, system certificates are used\n"
                },
                "oidcDiscoveryUrl": {
                    "type": "string",
                    "description": "The OIDC Discovery URL, without any .well-known component (base path). Cannot be used in combination with `jwt_validation_pubkeys`\n"
                },
                "oidcResponseMode": {
                    "type": "string",
                    "description": "The response mode to be used in the OAuth2 request. Allowed values are `query` and `form_post`. Defaults to `query`. If using Vault namespaces, and `oidc_response_mode` is `form_post`, then `namespace_in_state` should be set to `false`.\n"
                },
                "oidcResponseTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of response types to request. Allowed values are 'code' and 'id_token'. Defaults to `[\"code\"]`. Note: `id_token` may only be used if `oidc_response_mode` is set to `form_post`.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to mount the JWT/OIDC auth backend\n"
                },
                "providerConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Provider specific handling configuration. All values may be strings, and the provider will convert to the appropriate type when configuring Vault.\n"
                },
                "tune": {
                    "$ref": "#/types/vault:jwt/AuthBackendTune:AuthBackendTune"
                },
                "type": {
                    "type": "string",
                    "description": "Type of auth backend. Should be one of `jwt` or `oidc`. Default - `jwt`\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackend resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The accessor for this auth method\n"
                    },
                    "boundIssuer": {
                        "type": "string",
                        "description": "The value against which to match the iss claim in a JWT\n"
                    },
                    "defaultRole": {
                        "type": "string",
                        "description": "The default role to use if none is provided during login\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the auth backend\n"
                    },
                    "jwksCaPem": {
                        "type": "string",
                        "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the JWKS URL. If not set, system certificates are used.\n"
                    },
                    "jwksUrl": {
                        "type": "string",
                        "description": "JWKS URL to use to authenticate signatures. Cannot be used with \"oidc_discovery_url\" or \"jwt_validation_pubkeys\".\n"
                    },
                    "jwtSupportedAlgs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of supported signing algorithms. Vault 1.1.0 defaults to [RS256] but future or past versions of Vault may differ\n"
                    },
                    "jwtValidationPubkeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of PEM-encoded public keys to use to authenticate signatures locally. Cannot be used in combination with `oidc_discovery_url`\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Specifies if the auth method is local only.\n"
                    },
                    "namespaceInState": {
                        "type": "boolean",
                        "description": "Pass namespace in the OIDC state parameter instead of as a separate query parameter. With this setting, the allowed redirect URL(s) in Vault and on the provider side should not contain a namespace query parameter. This means only one redirect URL entry needs to be maintained on the OIDC provider side for all vault namespaces that will be authenticating against it. Defaults to true for new configs\n"
                    },
                    "oidcClientId": {
                        "type": "string",
                        "description": "Client ID used for OIDC backends\n"
                    },
                    "oidcClientSecret": {
                        "type": "string",
                        "description": "Client Secret used for OIDC backends\n"
                    },
                    "oidcDiscoveryCaPem": {
                        "type": "string",
                        "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the OIDC Discovery URL. If not set, system certificates are used\n"
                    },
                    "oidcDiscoveryUrl": {
                        "type": "string",
                        "description": "The OIDC Discovery URL, without any .well-known component (base path). Cannot be used in combination with `jwt_validation_pubkeys`\n"
                    },
                    "oidcResponseMode": {
                        "type": "string",
                        "description": "The response mode to be used in the OAuth2 request. Allowed values are `query` and `form_post`. Defaults to `query`. If using Vault namespaces, and `oidc_response_mode` is `form_post`, then `namespace_in_state` should be set to `false`.\n"
                    },
                    "oidcResponseTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of response types to request. Allowed values are 'code' and 'id_token'. Defaults to `[\"code\"]`. Note: `id_token` may only be used if `oidc_response_mode` is set to `form_post`.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Path to mount the JWT/OIDC auth backend\n"
                    },
                    "providerConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Provider specific handling configuration. All values may be strings, and the provider will convert to the appropriate type when configuring Vault.\n"
                    },
                    "tune": {
                        "$ref": "#/types/vault:jwt/AuthBackendTune:AuthBackendTune"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of auth backend. Should be one of `jwt` or `oidc`. Default - `jwt`\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:jwt/authBackendRole:AuthBackendRole": {
            "description": "Manages an JWT/OIDC auth backend role in a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/jwt.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nRole for JWT backend:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst jwt = new vault.jwt.AuthBackend(\"jwt\", {path: \"jwt\"});\nconst example = new vault.jwt.AuthBackendRole(\"example\", {\n    backend: jwt.path,\n    roleName: \"test-role\",\n    tokenPolicies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    boundAudiences: [\"https://myco.test\"],\n    boundClaims: {\n        color: \"red,green,blue\",\n    },\n    userClaim: \"https://vault/user\",\n    roleType: \"jwt\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\njwt = vault.jwt.AuthBackend(\"jwt\", path=\"jwt\")\nexample = vault.jwt.AuthBackendRole(\"example\",\n    backend=jwt.path,\n    role_name=\"test-role\",\n    token_policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    bound_audiences=[\"https://myco.test\"],\n    bound_claims={\n        \"color\": \"red,green,blue\",\n    },\n    user_claim=\"https://vault/user\",\n    role_type=\"jwt\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var jwt = new Vault.Jwt.AuthBackend(\"jwt\", new Vault.Jwt.AuthBackendArgs\n        {\n            Path = \"jwt\",\n        });\n        var example = new Vault.Jwt.AuthBackendRole(\"example\", new Vault.Jwt.AuthBackendRoleArgs\n        {\n            Backend = jwt.Path,\n            RoleName = \"test-role\",\n            TokenPolicies = \n            {\n                \"default\",\n                \"dev\",\n                \"prod\",\n            },\n            BoundAudiences = \n            {\n                \"https://myco.test\",\n            },\n            BoundClaims = \n            {\n                { \"color\", \"red,green,blue\" },\n            },\n            UserClaim = \"https://vault/user\",\n            RoleType = \"jwt\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/jwt\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tjwt, err := jwt.NewAuthBackend(ctx, \"jwt\", \u0026jwt.AuthBackendArgs{\n\t\t\tPath: pulumi.String(\"jwt\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = jwt.NewAuthBackendRole(ctx, \"example\", \u0026jwt.AuthBackendRoleArgs{\n\t\t\tBackend:  jwt.Path,\n\t\t\tRoleName: pulumi.String(\"test-role\"),\n\t\t\tTokenPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t\tBoundAudiences: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"https://myco.test\"),\n\t\t\t},\n\t\t\tBoundClaims: pulumi.AnyMap{\n\t\t\t\t\"color\": pulumi.Any(\"red,green,blue\"),\n\t\t\t},\n\t\t\tUserClaim: pulumi.String(\"https://vault/user\"),\n\t\t\tRoleType:  pulumi.String(\"jwt\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\nRole for OIDC backend:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst oidc = new vault.jwt.AuthBackend(\"oidc\", {\n    path: \"oidc\",\n    defaultRole: \"test-role\",\n});\nconst example = new vault.jwt.AuthBackendRole(\"example\", {\n    backend: oidc.path,\n    roleName: \"test-role\",\n    tokenPolicies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    userClaim: \"https://vault/user\",\n    roleType: \"oidc\",\n    allowedRedirectUris: [\"http://localhost:8200/ui/vault/auth/oidc/oidc/callback\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\noidc = vault.jwt.AuthBackend(\"oidc\",\n    path=\"oidc\",\n    default_role=\"test-role\")\nexample = vault.jwt.AuthBackendRole(\"example\",\n    backend=oidc.path,\n    role_name=\"test-role\",\n    token_policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    user_claim=\"https://vault/user\",\n    role_type=\"oidc\",\n    allowed_redirect_uris=[\"http://localhost:8200/ui/vault/auth/oidc/oidc/callback\"])\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var oidc = new Vault.Jwt.AuthBackend(\"oidc\", new Vault.Jwt.AuthBackendArgs\n        {\n            Path = \"oidc\",\n            DefaultRole = \"test-role\",\n        });\n        var example = new Vault.Jwt.AuthBackendRole(\"example\", new Vault.Jwt.AuthBackendRoleArgs\n        {\n            Backend = oidc.Path,\n            RoleName = \"test-role\",\n            TokenPolicies = \n            {\n                \"default\",\n                \"dev\",\n                \"prod\",\n            },\n            UserClaim = \"https://vault/user\",\n            RoleType = \"oidc\",\n            AllowedRedirectUris = \n            {\n                \"http://localhost:8200/ui/vault/auth/oidc/oidc/callback\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/jwt\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\toidc, err := jwt.NewAuthBackend(ctx, \"oidc\", \u0026jwt.AuthBackendArgs{\n\t\t\tPath:        pulumi.String(\"oidc\"),\n\t\t\tDefaultRole: pulumi.String(\"test-role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = jwt.NewAuthBackendRole(ctx, \"example\", \u0026jwt.AuthBackendRoleArgs{\n\t\t\tBackend:  oidc.Path,\n\t\t\tRoleName: pulumi.String(\"test-role\"),\n\t\t\tTokenPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t\tUserClaim: pulumi.String(\"https://vault/user\"),\n\t\t\tRoleType:  pulumi.String(\"oidc\"),\n\t\t\tAllowedRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8200/ui/vault/auth/oidc/oidc/callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nJWT authentication backend roles can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:jwt/authBackendRole:AuthBackendRole example auth/jwt/role/test-role\n```\n\n ",
            "properties": {
                "allowedRedirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of allowed values for redirect_uri during OIDC logins.\nRequired for OIDC roles\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique name of the auth backend to configure.\nDefaults to `jwt`.\n"
                },
                "boundAudiences": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Required for roles of type `jwt`, optional for roles of\ntype `oidc`) List of `aud` claims to match against. Any match is sufficient.\n"
                },
                "boundClaims": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "If set, a map of claims to values to match against.\nA claim's value must be a string, which may contain one value or multiple\ncomma-separated values, e.g. `\"red\"` or `\"red,green,blue\"`.\n"
                },
                "boundClaimsType": {
                    "type": "string",
                    "description": "How to interpret values in the claims/values\nmap (`bound_claims`): can be either `string` (exact match) or `glob` (wildcard\nmatch). Requires Vault 1.4.0 or above.\n"
                },
                "boundSubject": {
                    "type": "string",
                    "description": "If set, requires that the `sub` claim matches\nthis value.\n"
                },
                "claimMappings": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "If set, a map of claims (keys) to be copied\nto specified metadata fields (values).\n"
                },
                "clockSkewLeeway": {
                    "type": "integer",
                    "description": "The amount of leeway to add to all claims to account for clock skew, in\nseconds. Defaults to `60` seconds if set to `0` and can be disabled if set to `-1`.\nOnly applicable with \"jwt\" roles.\n"
                },
                "disableBoundClaimsParsing": {
                    "type": "boolean",
                    "description": "Disable bound claim value parsing. Useful when values contain commas.\n"
                },
                "expirationLeeway": {
                    "type": "integer",
                    "description": "The amount of leeway to add to expiration (`exp`) claims to account for\nclock skew, in seconds. Defaults to `60` seconds if set to `0` and can be disabled if set to `-1`.\nOnly applicable with \"jwt\" roles.\n"
                },
                "groupsClaim": {
                    "type": "string",
                    "description": "The claim to use to uniquely identify\nthe set of groups to which the user belongs; this will be used as the names\nfor the Identity group aliases created due to a successful login. The claim\nvalue must be a list of strings.\n"
                },
                "notBeforeLeeway": {
                    "type": "integer",
                    "description": "The amount of leeway to add to not before (`nbf`) claims to account for\nclock skew, in seconds. Defaults to `60` seconds if set to `0` and can be disabled if set to `-1`.\nOnly applicable with \"jwt\" roles.\n"
                },
                "oidcScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, a list of OIDC scopes to be used with an OIDC role.\nThe standard scope \"openid\" is automatically included and need not be specified.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "roleType": {
                    "type": "string",
                    "description": "Type of role, either \"oidc\" (default) or \"jwt\".\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                },
                "userClaim": {
                    "type": "string",
                    "description": "The claim to use to uniquely identify\nthe user; this will be used as the name for the Identity entity alias created\ndue to a successful login.\n"
                },
                "verboseOidcLogging": {
                    "type": "boolean",
                    "description": "Log received OIDC tokens and claims when debug-level\nlogging is active. Not recommended in production since sensitive information may be present\nin OIDC responses.\n"
                }
            },
            "required": [
                "boundClaimsType",
                "roleName",
                "roleType",
                "userClaim"
            ],
            "inputProperties": {
                "allowedRedirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of allowed values for redirect_uri during OIDC logins.\nRequired for OIDC roles\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique name of the auth backend to configure.\nDefaults to `jwt`.\n"
                },
                "boundAudiences": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Required for roles of type `jwt`, optional for roles of\ntype `oidc`) List of `aud` claims to match against. Any match is sufficient.\n"
                },
                "boundClaims": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "If set, a map of claims to values to match against.\nA claim's value must be a string, which may contain one value or multiple\ncomma-separated values, e.g. `\"red\"` or `\"red,green,blue\"`.\n"
                },
                "boundClaimsType": {
                    "type": "string",
                    "description": "How to interpret values in the claims/values\nmap (`bound_claims`): can be either `string` (exact match) or `glob` (wildcard\nmatch). Requires Vault 1.4.0 or above.\n"
                },
                "boundSubject": {
                    "type": "string",
                    "description": "If set, requires that the `sub` claim matches\nthis value.\n"
                },
                "claimMappings": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "If set, a map of claims (keys) to be copied\nto specified metadata fields (values).\n"
                },
                "clockSkewLeeway": {
                    "type": "integer",
                    "description": "The amount of leeway to add to all claims to account for clock skew, in\nseconds. Defaults to `60` seconds if set to `0` and can be disabled if set to `-1`.\nOnly applicable with \"jwt\" roles.\n"
                },
                "disableBoundClaimsParsing": {
                    "type": "boolean",
                    "description": "Disable bound claim value parsing. Useful when values contain commas.\n"
                },
                "expirationLeeway": {
                    "type": "integer",
                    "description": "The amount of leeway to add to expiration (`exp`) claims to account for\nclock skew, in seconds. Defaults to `60` seconds if set to `0` and can be disabled if set to `-1`.\nOnly applicable with \"jwt\" roles.\n"
                },
                "groupsClaim": {
                    "type": "string",
                    "description": "The claim to use to uniquely identify\nthe set of groups to which the user belongs; this will be used as the names\nfor the Identity group aliases created due to a successful login. The claim\nvalue must be a list of strings.\n"
                },
                "notBeforeLeeway": {
                    "type": "integer",
                    "description": "The amount of leeway to add to not before (`nbf`) claims to account for\nclock skew, in seconds. Defaults to `60` seconds if set to `0` and can be disabled if set to `-1`.\nOnly applicable with \"jwt\" roles.\n"
                },
                "oidcScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, a list of OIDC scopes to be used with an OIDC role.\nThe standard scope \"openid\" is automatically included and need not be specified.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "roleType": {
                    "type": "string",
                    "description": "Type of role, either \"oidc\" (default) or \"jwt\".\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                },
                "userClaim": {
                    "type": "string",
                    "description": "The claim to use to uniquely identify\nthe user; this will be used as the name for the Identity entity alias created\ndue to a successful login.\n"
                },
                "verboseOidcLogging": {
                    "type": "boolean",
                    "description": "Log received OIDC tokens and claims when debug-level\nlogging is active. Not recommended in production since sensitive information may be present\nin OIDC responses.\n"
                }
            },
            "requiredInputs": [
                "roleName",
                "userClaim"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "allowedRedirectUris": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of allowed values for redirect_uri during OIDC logins.\nRequired for OIDC roles\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The unique name of the auth backend to configure.\nDefaults to `jwt`.\n"
                    },
                    "boundAudiences": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(Required for roles of type `jwt`, optional for roles of\ntype `oidc`) List of `aud` claims to match against. Any match is sufficient.\n"
                    },
                    "boundClaims": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "If set, a map of claims to values to match against.\nA claim's value must be a string, which may contain one value or multiple\ncomma-separated values, e.g. `\"red\"` or `\"red,green,blue\"`.\n"
                    },
                    "boundClaimsType": {
                        "type": "string",
                        "description": "How to interpret values in the claims/values\nmap (`bound_claims`): can be either `string` (exact match) or `glob` (wildcard\nmatch). Requires Vault 1.4.0 or above.\n"
                    },
                    "boundSubject": {
                        "type": "string",
                        "description": "If set, requires that the `sub` claim matches\nthis value.\n"
                    },
                    "claimMappings": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "If set, a map of claims (keys) to be copied\nto specified metadata fields (values).\n"
                    },
                    "clockSkewLeeway": {
                        "type": "integer",
                        "description": "The amount of leeway to add to all claims to account for clock skew, in\nseconds. Defaults to `60` seconds if set to `0` and can be disabled if set to `-1`.\nOnly applicable with \"jwt\" roles.\n"
                    },
                    "disableBoundClaimsParsing": {
                        "type": "boolean",
                        "description": "Disable bound claim value parsing. Useful when values contain commas.\n"
                    },
                    "expirationLeeway": {
                        "type": "integer",
                        "description": "The amount of leeway to add to expiration (`exp`) claims to account for\nclock skew, in seconds. Defaults to `60` seconds if set to `0` and can be disabled if set to `-1`.\nOnly applicable with \"jwt\" roles.\n"
                    },
                    "groupsClaim": {
                        "type": "string",
                        "description": "The claim to use to uniquely identify\nthe set of groups to which the user belongs; this will be used as the names\nfor the Identity group aliases created due to a successful login. The claim\nvalue must be a list of strings.\n"
                    },
                    "notBeforeLeeway": {
                        "type": "integer",
                        "description": "The amount of leeway to add to not before (`nbf`) claims to account for\nclock skew, in seconds. Defaults to `60` seconds if set to `0` and can be disabled if set to `-1`.\nOnly applicable with \"jwt\" roles.\n"
                    },
                    "oidcScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, a list of OIDC scopes to be used with an OIDC role.\nThe standard scope \"openid\" is automatically included and need not be specified.\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "roleType": {
                        "type": "string",
                        "description": "Type of role, either \"oidc\" (default) or \"jwt\".\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    },
                    "userClaim": {
                        "type": "string",
                        "description": "The claim to use to uniquely identify\nthe user; this will be used as the name for the Identity entity alias created\ndue to a successful login.\n"
                    },
                    "verboseOidcLogging": {
                        "type": "boolean",
                        "description": "Log received OIDC tokens and claims when debug-level\nlogging is active. Not recommended in production since sensitive information may be present\nin OIDC responses.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:kmip/secretBackend:SecretBackend": {
            "description": "Manages KMIP Secret backends in a Vault server. This feature requires\nVault Enterprise. See the [Vault documentation](https://www.vaultproject.io/docs/secrets/kmip)\nfor more information.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst defaultSecretBackend = new vault.kmip.SecretBackend(\"default\", {\n    defaultTlsClientKeyBits: 4096,\n    defaultTlsClientKeyType: \"rsa\",\n    defaultTlsClientTtl: 86400,\n    description: \"Vault KMIP backend\",\n    listenAddrs: [\n        \"127.0.0.1:5696\",\n        \"127.0.0.1:8080\",\n    ],\n    path: \"kmip\",\n    tlsCaKeyBits: 4096,\n    tlsCaKeyType: \"rsa\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ndefault = vault.kmip.SecretBackend(\"default\",\n    default_tls_client_key_bits=4096,\n    default_tls_client_key_type=\"rsa\",\n    default_tls_client_ttl=86400,\n    description=\"Vault KMIP backend\",\n    listen_addrs=[\n        \"127.0.0.1:5696\",\n        \"127.0.0.1:8080\",\n    ],\n    path=\"kmip\",\n    tls_ca_key_bits=4096,\n    tls_ca_key_type=\"rsa\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var @default = new Vault.Kmip.SecretBackend(\"default\", new Vault.Kmip.SecretBackendArgs\n        {\n            DefaultTlsClientKeyBits = 4096,\n            DefaultTlsClientKeyType = \"rsa\",\n            DefaultTlsClientTtl = 86400,\n            Description = \"Vault KMIP backend\",\n            ListenAddrs = \n            {\n                \"127.0.0.1:5696\",\n                \"127.0.0.1:8080\",\n            },\n            Path = \"kmip\",\n            TlsCaKeyBits = 4096,\n            TlsCaKeyType = \"rsa\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/kmip\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := kmip.NewSecretBackend(ctx, \"default\", \u0026kmip.SecretBackendArgs{\n\t\t\tDefaultTlsClientKeyBits: pulumi.Int(4096),\n\t\t\tDefaultTlsClientKeyType: pulumi.String(\"rsa\"),\n\t\t\tDefaultTlsClientTtl:     pulumi.Int(86400),\n\t\t\tDescription:             pulumi.String(\"Vault KMIP backend\"),\n\t\t\tListenAddrs: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"127.0.0.1:5696\"),\n\t\t\t\tpulumi.String(\"127.0.0.1:8080\"),\n\t\t\t},\n\t\t\tPath:         pulumi.String(\"kmip\"),\n\t\t\tTlsCaKeyBits: pulumi.Int(4096),\n\t\t\tTlsCaKeyType: pulumi.String(\"rsa\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nKMIP Secret backend can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:kmip/secretBackend:SecretBackend default kmip\n```\n\n ",
            "properties": {
                "defaultTlsClientKeyBits": {
                    "type": "integer",
                    "description": "Client certificate key bits, valid values depend on key type.\n"
                },
                "defaultTlsClientKeyType": {
                    "type": "string",
                    "description": "Client certificate key type, `rsa` or `ec`.\n"
                },
                "defaultTlsClientTtl": {
                    "type": "integer",
                    "description": "Client certificate TTL in seconds\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "listenAddrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Addresses the KMIP server should listen on (`host:port`).\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `kmip`.\n"
                },
                "serverHostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Hostnames to include in the server's TLS certificate as SAN DNS names. The first will be used as the common name (CN).\n"
                },
                "serverIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IPs to include in the server's TLS certificate as SAN IP addresses.\n"
                },
                "tlsCaKeyBits": {
                    "type": "integer",
                    "description": "CA key bits, valid values depend on key type.\n"
                },
                "tlsCaKeyType": {
                    "type": "string",
                    "description": "CA key type, rsa or ec.\n"
                },
                "tlsMinVersion": {
                    "type": "string",
                    "description": "Minimum TLS version to accept.\n"
                }
            },
            "required": [
                "defaultTlsClientKeyBits",
                "defaultTlsClientKeyType",
                "defaultTlsClientTtl",
                "listenAddrs",
                "path",
                "serverHostnames",
                "serverIps",
                "tlsCaKeyBits",
                "tlsCaKeyType",
                "tlsMinVersion"
            ],
            "inputProperties": {
                "defaultTlsClientKeyBits": {
                    "type": "integer",
                    "description": "Client certificate key bits, valid values depend on key type.\n"
                },
                "defaultTlsClientKeyType": {
                    "type": "string",
                    "description": "Client certificate key type, `rsa` or `ec`.\n"
                },
                "defaultTlsClientTtl": {
                    "type": "integer",
                    "description": "Client certificate TTL in seconds\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "listenAddrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Addresses the KMIP server should listen on (`host:port`).\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `kmip`.\n"
                },
                "serverHostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Hostnames to include in the server's TLS certificate as SAN DNS names. The first will be used as the common name (CN).\n"
                },
                "serverIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IPs to include in the server's TLS certificate as SAN IP addresses.\n"
                },
                "tlsCaKeyBits": {
                    "type": "integer",
                    "description": "CA key bits, valid values depend on key type.\n"
                },
                "tlsCaKeyType": {
                    "type": "string",
                    "description": "CA key type, rsa or ec.\n"
                },
                "tlsMinVersion": {
                    "type": "string",
                    "description": "Minimum TLS version to accept.\n"
                }
            },
            "requiredInputs": [
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackend resources.\n",
                "properties": {
                    "defaultTlsClientKeyBits": {
                        "type": "integer",
                        "description": "Client certificate key bits, valid values depend on key type.\n"
                    },
                    "defaultTlsClientKeyType": {
                        "type": "string",
                        "description": "Client certificate key type, `rsa` or `ec`.\n"
                    },
                    "defaultTlsClientTtl": {
                        "type": "integer",
                        "description": "Client certificate TTL in seconds\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A human-friendly description for this backend.\n"
                    },
                    "listenAddrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Addresses the KMIP server should listen on (`host:port`).\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `kmip`.\n"
                    },
                    "serverHostnames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Hostnames to include in the server's TLS certificate as SAN DNS names. The first will be used as the common name (CN).\n"
                    },
                    "serverIps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "IPs to include in the server's TLS certificate as SAN IP addresses.\n"
                    },
                    "tlsCaKeyBits": {
                        "type": "integer",
                        "description": "CA key bits, valid values depend on key type.\n"
                    },
                    "tlsCaKeyType": {
                        "type": "string",
                        "description": "CA key type, rsa or ec.\n"
                    },
                    "tlsMinVersion": {
                        "type": "string",
                        "description": "Minimum TLS version to accept.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:kmip/secretRole:SecretRole": {
            "description": "Manages KMIP Secret roles in a Vault server. This feature requires\nVault Enterprise. See the [Vault documentation](https://www.vaultproject.io/docs/secrets/kmip)\nfor more information.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst _default = new vault.kmip.SecretBackend(\"default\", {\n    path: \"kmip\",\n    description: \"Vault KMIP backend\",\n});\nconst dev = new vault.kmip.SecretScope(\"dev\", {\n    path: _default.path,\n    scope: \"dev\",\n    force: true,\n});\nconst admin = new vault.kmip.SecretRole(\"admin\", {\n    path: dev.path,\n    scope: dev.scope,\n    role: \"admin\",\n    tlsClientKeyType: \"ec\",\n    tlsClientKeyBits: 256,\n    operationActivate: true,\n    operationGet: true,\n    operationGetAttributes: true,\n    operationCreate: true,\n    operationDestroy: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ndefault = vault.kmip.SecretBackend(\"default\",\n    path=\"kmip\",\n    description=\"Vault KMIP backend\")\ndev = vault.kmip.SecretScope(\"dev\",\n    path=default.path,\n    scope=\"dev\",\n    force=True)\nadmin = vault.kmip.SecretRole(\"admin\",\n    path=dev.path,\n    scope=dev.scope,\n    role=\"admin\",\n    tls_client_key_type=\"ec\",\n    tls_client_key_bits=256,\n    operation_activate=True,\n    operation_get=True,\n    operation_get_attributes=True,\n    operation_create=True,\n    operation_destroy=True)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var @default = new Vault.Kmip.SecretBackend(\"default\", new Vault.Kmip.SecretBackendArgs\n        {\n            Path = \"kmip\",\n            Description = \"Vault KMIP backend\",\n        });\n        var dev = new Vault.Kmip.SecretScope(\"dev\", new Vault.Kmip.SecretScopeArgs\n        {\n            Path = @default.Path,\n            Scope = \"dev\",\n            Force = true,\n        });\n        var admin = new Vault.Kmip.SecretRole(\"admin\", new Vault.Kmip.SecretRoleArgs\n        {\n            Path = dev.Path,\n            Scope = dev.Scope,\n            Role = \"admin\",\n            TlsClientKeyType = \"ec\",\n            TlsClientKeyBits = 256,\n            OperationActivate = true,\n            OperationGet = true,\n            OperationGetAttributes = true,\n            OperationCreate = true,\n            OperationDestroy = true,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/kmip\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := kmip.NewSecretBackend(ctx, \"default\", \u0026kmip.SecretBackendArgs{\n\t\t\tPath:        pulumi.String(\"kmip\"),\n\t\t\tDescription: pulumi.String(\"Vault KMIP backend\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdev, err := kmip.NewSecretScope(ctx, \"dev\", \u0026kmip.SecretScopeArgs{\n\t\t\tPath:  _default.Path,\n\t\t\tScope: pulumi.String(\"dev\"),\n\t\t\tForce: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = kmip.NewSecretRole(ctx, \"admin\", \u0026kmip.SecretRoleArgs{\n\t\t\tPath:                   dev.Path,\n\t\t\tScope:                  dev.Scope,\n\t\t\tRole:                   pulumi.String(\"admin\"),\n\t\t\tTlsClientKeyType:       pulumi.String(\"ec\"),\n\t\t\tTlsClientKeyBits:       pulumi.Int(256),\n\t\t\tOperationActivate:      pulumi.Bool(true),\n\t\t\tOperationGet:           pulumi.Bool(true),\n\t\t\tOperationGetAttributes: pulumi.Bool(true),\n\t\t\tOperationCreate:        pulumi.Bool(true),\n\t\t\tOperationDestroy:       pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nKMIP Secret role can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:kmip/secretRole:SecretRole admin kmip\n```\n\n ",
            "properties": {
                "operationActivate": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Activate operation.\n"
                },
                "operationAddAttribute": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Add Attribute operation.\n"
                },
                "operationAll": {
                    "type": "boolean",
                    "description": "Grant all permissions to this role. May not be specified with any other `operation_*` params.\n"
                },
                "operationCreate": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Create operation.\n"
                },
                "operationDestroy": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Destroy operation.\n"
                },
                "operationDiscoverVersions": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Discover Version operation.\n"
                },
                "operationGet": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Get operation.\n"
                },
                "operationGetAttributeList": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Get Atrribute List operation.\n"
                },
                "operationGetAttributes": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Get Atrributes operation.\n"
                },
                "operationLocate": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Get Locate operation.\n"
                },
                "operationNone": {
                    "type": "boolean",
                    "description": "Remove all permissions from this role. May not be specified with any other `operation_*` params.\n"
                },
                "operationRegister": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Register operation.\n"
                },
                "operationRekey": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Rekey operation.\n"
                },
                "operationRevoke": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Revoke operation.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `kmip`.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the role.\n"
                },
                "scope": {
                    "type": "string",
                    "description": "Name of the scope.\n"
                },
                "tlsClientKeyBits": {
                    "type": "integer",
                    "description": "Client certificate key bits, valid values depend on key type.\n"
                },
                "tlsClientKeyType": {
                    "type": "string",
                    "description": "Client certificate key type, `rsa` or `ec`.\n"
                },
                "tlsClientTtl": {
                    "type": "integer",
                    "description": "Client certificate TTL in seconds.\n"
                }
            },
            "required": [
                "operationActivate",
                "operationAddAttribute",
                "operationAll",
                "operationCreate",
                "operationDestroy",
                "operationDiscoverVersions",
                "operationGet",
                "operationGetAttributeList",
                "operationGetAttributes",
                "operationLocate",
                "operationNone",
                "operationRegister",
                "operationRekey",
                "operationRevoke",
                "path",
                "role",
                "scope"
            ],
            "inputProperties": {
                "operationActivate": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Activate operation.\n"
                },
                "operationAddAttribute": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Add Attribute operation.\n"
                },
                "operationAll": {
                    "type": "boolean",
                    "description": "Grant all permissions to this role. May not be specified with any other `operation_*` params.\n"
                },
                "operationCreate": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Create operation.\n"
                },
                "operationDestroy": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Destroy operation.\n"
                },
                "operationDiscoverVersions": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Discover Version operation.\n"
                },
                "operationGet": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Get operation.\n"
                },
                "operationGetAttributeList": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Get Atrribute List operation.\n"
                },
                "operationGetAttributes": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Get Atrributes operation.\n"
                },
                "operationLocate": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Get Locate operation.\n"
                },
                "operationNone": {
                    "type": "boolean",
                    "description": "Remove all permissions from this role. May not be specified with any other `operation_*` params.\n"
                },
                "operationRegister": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Register operation.\n"
                },
                "operationRekey": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Rekey operation.\n"
                },
                "operationRevoke": {
                    "type": "boolean",
                    "description": "Grant permission to use the KMIP Revoke operation.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `kmip`.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the role.\n"
                },
                "scope": {
                    "type": "string",
                    "description": "Name of the scope.\n"
                },
                "tlsClientKeyBits": {
                    "type": "integer",
                    "description": "Client certificate key bits, valid values depend on key type.\n"
                },
                "tlsClientKeyType": {
                    "type": "string",
                    "description": "Client certificate key type, `rsa` or `ec`.\n"
                },
                "tlsClientTtl": {
                    "type": "integer",
                    "description": "Client certificate TTL in seconds.\n"
                }
            },
            "requiredInputs": [
                "path",
                "role",
                "scope"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretRole resources.\n",
                "properties": {
                    "operationActivate": {
                        "type": "boolean",
                        "description": "Grant permission to use the KMIP Activate operation.\n"
                    },
                    "operationAddAttribute": {
                        "type": "boolean",
                        "description": "Grant permission to use the KMIP Add Attribute operation.\n"
                    },
                    "operationAll": {
                        "type": "boolean",
                        "description": "Grant all permissions to this role. May not be specified with any other `operation_*` params.\n"
                    },
                    "operationCreate": {
                        "type": "boolean",
                        "description": "Grant permission to use the KMIP Create operation.\n"
                    },
                    "operationDestroy": {
                        "type": "boolean",
                        "description": "Grant permission to use the KMIP Destroy operation.\n"
                    },
                    "operationDiscoverVersions": {
                        "type": "boolean",
                        "description": "Grant permission to use the KMIP Discover Version operation.\n"
                    },
                    "operationGet": {
                        "type": "boolean",
                        "description": "Grant permission to use the KMIP Get operation.\n"
                    },
                    "operationGetAttributeList": {
                        "type": "boolean",
                        "description": "Grant permission to use the KMIP Get Atrribute List operation.\n"
                    },
                    "operationGetAttributes": {
                        "type": "boolean",
                        "description": "Grant permission to use the KMIP Get Atrributes operation.\n"
                    },
                    "operationLocate": {
                        "type": "boolean",
                        "description": "Grant permission to use the KMIP Get Locate operation.\n"
                    },
                    "operationNone": {
                        "type": "boolean",
                        "description": "Remove all permissions from this role. May not be specified with any other `operation_*` params.\n"
                    },
                    "operationRegister": {
                        "type": "boolean",
                        "description": "Grant permission to use the KMIP Register operation.\n"
                    },
                    "operationRekey": {
                        "type": "boolean",
                        "description": "Grant permission to use the KMIP Rekey operation.\n"
                    },
                    "operationRevoke": {
                        "type": "boolean",
                        "description": "Grant permission to use the KMIP Revoke operation.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `kmip`.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "Name of the role.\n"
                    },
                    "scope": {
                        "type": "string",
                        "description": "Name of the scope.\n"
                    },
                    "tlsClientKeyBits": {
                        "type": "integer",
                        "description": "Client certificate key bits, valid values depend on key type.\n"
                    },
                    "tlsClientKeyType": {
                        "type": "string",
                        "description": "Client certificate key type, `rsa` or `ec`.\n"
                    },
                    "tlsClientTtl": {
                        "type": "integer",
                        "description": "Client certificate TTL in seconds.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:kmip/secretScope:SecretScope": {
            "description": "Manages KMIP Secret Scopes in a Vault server. This feature requires\nVault Enterprise. See the [Vault documentation](https://www.vaultproject.io/docs/secrets/kmip)\nfor more information.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst _default = new vault.kmip.SecretBackend(\"default\", {\n    path: \"kmip\",\n    description: \"Vault KMIP backend\",\n});\nconst dev = new vault.kmip.SecretScope(\"dev\", {\n    path: _default.path,\n    scope: \"dev\",\n    force: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ndefault = vault.kmip.SecretBackend(\"default\",\n    path=\"kmip\",\n    description=\"Vault KMIP backend\")\ndev = vault.kmip.SecretScope(\"dev\",\n    path=default.path,\n    scope=\"dev\",\n    force=True)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var @default = new Vault.Kmip.SecretBackend(\"default\", new Vault.Kmip.SecretBackendArgs\n        {\n            Path = \"kmip\",\n            Description = \"Vault KMIP backend\",\n        });\n        var dev = new Vault.Kmip.SecretScope(\"dev\", new Vault.Kmip.SecretScopeArgs\n        {\n            Path = @default.Path,\n            Scope = \"dev\",\n            Force = true,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/kmip\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := kmip.NewSecretBackend(ctx, \"default\", \u0026kmip.SecretBackendArgs{\n\t\t\tPath:        pulumi.String(\"kmip\"),\n\t\t\tDescription: pulumi.String(\"Vault KMIP backend\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = kmip.NewSecretScope(ctx, \"dev\", \u0026kmip.SecretScopeArgs{\n\t\t\tPath:  _default.Path,\n\t\t\tScope: pulumi.String(\"dev\"),\n\t\t\tForce: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nKMIP Secret scope can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:kmip/secretScope:SecretScope dev kmip\n```\n\n ",
            "properties": {
                "force": {
                    "type": "boolean",
                    "description": "Boolean field to force deletion even if there are managed objects in the scope.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `kmip`.\n"
                },
                "scope": {
                    "type": "string",
                    "description": "Name of the scope.\n"
                }
            },
            "required": [
                "path",
                "scope"
            ],
            "inputProperties": {
                "force": {
                    "type": "boolean",
                    "description": "Boolean field to force deletion even if there are managed objects in the scope.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `kmip`.\n"
                },
                "scope": {
                    "type": "string",
                    "description": "Name of the scope.\n"
                }
            },
            "requiredInputs": [
                "path",
                "scope"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretScope resources.\n",
                "properties": {
                    "force": {
                        "type": "boolean",
                        "description": "Boolean field to force deletion even if there are managed objects in the scope.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `kmip`.\n"
                    },
                    "scope": {
                        "type": "string",
                        "description": "Name of the scope.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:kubernetes/authBackendConfig:AuthBackendConfig": {
            "description": "Manages an Kubernetes auth backend config in a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/kubernetes.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst kubernetes = new vault.AuthBackend(\"kubernetes\", {type: \"kubernetes\"});\nconst example = new vault.kubernetes.AuthBackendConfig(\"example\", {\n    backend: kubernetes.path,\n    kubernetesHost: \"http://example.com:443\",\n    kubernetesCaCert: `-----BEGIN CERTIFICATE-----\nexample\n-----END CERTIFICATE-----`,\n    tokenReviewerJwt: \"ZXhhbXBsZQo=\",\n    issuer: \"api\",\n    disableIssValidation: \"true\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nkubernetes = vault.AuthBackend(\"kubernetes\", type=\"kubernetes\")\nexample = vault.kubernetes.AuthBackendConfig(\"example\",\n    backend=kubernetes.path,\n    kubernetes_host=\"http://example.com:443\",\n    kubernetes_ca_cert=\"\"\"-----BEGIN CERTIFICATE-----\nexample\n-----END CERTIFICATE-----\"\"\",\n    token_reviewer_jwt=\"ZXhhbXBsZQo=\",\n    issuer=\"api\",\n    disable_iss_validation=True)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var kubernetes = new Vault.AuthBackend(\"kubernetes\", new Vault.AuthBackendArgs\n        {\n            Type = \"kubernetes\",\n        });\n        var example = new Vault.Kubernetes.AuthBackendConfig(\"example\", new Vault.Kubernetes.AuthBackendConfigArgs\n        {\n            Backend = kubernetes.Path,\n            KubernetesHost = \"http://example.com:443\",\n            KubernetesCaCert = @\"-----BEGIN CERTIFICATE-----\nexample\n-----END CERTIFICATE-----\",\n            TokenReviewerJwt = \"ZXhhbXBsZQo=\",\n            Issuer = \"api\",\n            DisableIssValidation = true,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/kubernetes\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tkubernetes, err := vault.NewAuthBackend(ctx, \"kubernetes\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"kubernetes\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = kubernetes.NewAuthBackendConfig(ctx, \"example\", \u0026kubernetes.AuthBackendConfigArgs{\n\t\t\tBackend:              kubernetes.Path,\n\t\t\tKubernetesHost:       pulumi.String(\"http://example.com:443\"),\n\t\t\tKubernetesCaCert:     pulumi.String(\"-----BEGIN CERTIFICATE-----\\nexample\\n-----END CERTIFICATE-----\"),\n\t\t\tTokenReviewerJwt:     pulumi.String(\"ZXhhbXBsZQo=\"),\n\t\t\tIssuer:               pulumi.String(\"api\"),\n\t\t\tDisableIssValidation: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nKubernetes authentication backend can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:kubernetes/authBackendConfig:AuthBackendConfig config auth/kubernetes/config\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Unique name of the kubernetes backend to configure.\n"
                },
                "disableIssValidation": {
                    "type": "boolean",
                    "description": "Disable JWT issuer validation. Allows to skip ISS validation. Requires Vault `v1.5.4+` or Vault auth kubernetes plugin `v0.7.1+`\n"
                },
                "disableLocalCaJwt": {
                    "type": "boolean",
                    "description": "Disable defaulting to the local CA cert and service account JWT when running in a Kubernetes pod. Requires Vault `v1.5.4+` or Vault auth kubernetes plugin `v0.7.1+`\n"
                },
                "issuer": {
                    "type": "string",
                    "description": "JWT issuer. If no issuer is specified, `kubernetes.io/serviceaccount` will be used as the default issuer.\n"
                },
                "kubernetesCaCert": {
                    "type": "string",
                    "description": "PEM encoded CA cert for use by the TLS client used to talk with the Kubernetes API.\n"
                },
                "kubernetesHost": {
                    "type": "string",
                    "description": "Host must be a host string, a host:port pair, or a URL to the base of the Kubernetes API server.\n"
                },
                "pemKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of PEM-formatted public keys or certificates used to verify the signatures of Kubernetes service account JWTs. If a certificate is given, its public key will be extracted. Not every installation of Kubernetes exposes these keys.\n"
                },
                "tokenReviewerJwt": {
                    "type": "string",
                    "description": "A service account JWT used to access the TokenReview API to validate other JWTs during login. If not set the JWT used for login will be used to access the API.\n"
                }
            },
            "required": [
                "disableIssValidation",
                "disableLocalCaJwt",
                "kubernetesCaCert",
                "kubernetesHost"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Unique name of the kubernetes backend to configure.\n"
                },
                "disableIssValidation": {
                    "type": "boolean",
                    "description": "Disable JWT issuer validation. Allows to skip ISS validation. Requires Vault `v1.5.4+` or Vault auth kubernetes plugin `v0.7.1+`\n"
                },
                "disableLocalCaJwt": {
                    "type": "boolean",
                    "description": "Disable defaulting to the local CA cert and service account JWT when running in a Kubernetes pod. Requires Vault `v1.5.4+` or Vault auth kubernetes plugin `v0.7.1+`\n"
                },
                "issuer": {
                    "type": "string",
                    "description": "JWT issuer. If no issuer is specified, `kubernetes.io/serviceaccount` will be used as the default issuer.\n"
                },
                "kubernetesCaCert": {
                    "type": "string",
                    "description": "PEM encoded CA cert for use by the TLS client used to talk with the Kubernetes API.\n"
                },
                "kubernetesHost": {
                    "type": "string",
                    "description": "Host must be a host string, a host:port pair, or a URL to the base of the Kubernetes API server.\n"
                },
                "pemKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of PEM-formatted public keys or certificates used to verify the signatures of Kubernetes service account JWTs. If a certificate is given, its public key will be extracted. Not every installation of Kubernetes exposes these keys.\n"
                },
                "tokenReviewerJwt": {
                    "type": "string",
                    "description": "A service account JWT used to access the TokenReview API to validate other JWTs during login. If not set the JWT used for login will be used to access the API.\n"
                }
            },
            "requiredInputs": [
                "kubernetesHost"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendConfig resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Unique name of the kubernetes backend to configure.\n"
                    },
                    "disableIssValidation": {
                        "type": "boolean",
                        "description": "Disable JWT issuer validation. Allows to skip ISS validation. Requires Vault `v1.5.4+` or Vault auth kubernetes plugin `v0.7.1+`\n"
                    },
                    "disableLocalCaJwt": {
                        "type": "boolean",
                        "description": "Disable defaulting to the local CA cert and service account JWT when running in a Kubernetes pod. Requires Vault `v1.5.4+` or Vault auth kubernetes plugin `v0.7.1+`\n"
                    },
                    "issuer": {
                        "type": "string",
                        "description": "JWT issuer. If no issuer is specified, `kubernetes.io/serviceaccount` will be used as the default issuer.\n"
                    },
                    "kubernetesCaCert": {
                        "type": "string",
                        "description": "PEM encoded CA cert for use by the TLS client used to talk with the Kubernetes API.\n"
                    },
                    "kubernetesHost": {
                        "type": "string",
                        "description": "Host must be a host string, a host:port pair, or a URL to the base of the Kubernetes API server.\n"
                    },
                    "pemKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of PEM-formatted public keys or certificates used to verify the signatures of Kubernetes service account JWTs. If a certificate is given, its public key will be extracted. Not every installation of Kubernetes exposes these keys.\n"
                    },
                    "tokenReviewerJwt": {
                        "type": "string",
                        "description": "A service account JWT used to access the TokenReview API to validate other JWTs during login. If not set the JWT used for login will be used to access the API.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:kubernetes/authBackendRole:AuthBackendRole": {
            "description": "Manages an Kubernetes auth backend role in a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/kubernetes.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst kubernetes = new vault.AuthBackend(\"kubernetes\", {type: \"kubernetes\"});\nconst example = new vault.kubernetes.AuthBackendRole(\"example\", {\n    backend: kubernetes.path,\n    roleName: \"example-role\",\n    boundServiceAccountNames: [\"example\"],\n    boundServiceAccountNamespaces: [\"example\"],\n    tokenTtl: 3600,\n    tokenPolicies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    audience: \"vault\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nkubernetes = vault.AuthBackend(\"kubernetes\", type=\"kubernetes\")\nexample = vault.kubernetes.AuthBackendRole(\"example\",\n    backend=kubernetes.path,\n    role_name=\"example-role\",\n    bound_service_account_names=[\"example\"],\n    bound_service_account_namespaces=[\"example\"],\n    token_ttl=3600,\n    token_policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    audience=\"vault\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var kubernetes = new Vault.AuthBackend(\"kubernetes\", new Vault.AuthBackendArgs\n        {\n            Type = \"kubernetes\",\n        });\n        var example = new Vault.Kubernetes.AuthBackendRole(\"example\", new Vault.Kubernetes.AuthBackendRoleArgs\n        {\n            Backend = kubernetes.Path,\n            RoleName = \"example-role\",\n            BoundServiceAccountNames = \n            {\n                \"example\",\n            },\n            BoundServiceAccountNamespaces = \n            {\n                \"example\",\n            },\n            TokenTtl = 3600,\n            TokenPolicies = \n            {\n                \"default\",\n                \"dev\",\n                \"prod\",\n            },\n            Audience = \"vault\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/kubernetes\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tkubernetes, err := vault.NewAuthBackend(ctx, \"kubernetes\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"kubernetes\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = kubernetes.NewAuthBackendRole(ctx, \"example\", \u0026kubernetes.AuthBackendRoleArgs{\n\t\t\tBackend:  kubernetes.Path,\n\t\t\tRoleName: pulumi.String(\"example-role\"),\n\t\t\tBoundServiceAccountNames: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"example\"),\n\t\t\t},\n\t\t\tBoundServiceAccountNamespaces: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"example\"),\n\t\t\t},\n\t\t\tTokenTtl: pulumi.Int(3600),\n\t\t\tTokenPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t\tAudience: pulumi.String(\"vault\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nKubernetes auth backend role can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:kubernetes/authBackendRole:AuthBackendRole foo auth/kubernetes/role/foo\n```\n\n ",
            "properties": {
                "aliasNameSource": {
                    "type": "string",
                    "description": "Configures how identity aliases are generated.\nValid choices are: `serviceaccount_uid`, `serviceaccount_name`. (vault-1.9+)\n"
                },
                "audience": {
                    "type": "string",
                    "description": "Audience claim to verify in the JWT.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Unique name of the kubernetes backend to configure.\n"
                },
                "boundServiceAccountNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of service account names able to access this role. If set to `[\"*\"]` all names are allowed, both this and bound_service_account_namespaces can not be \"*\".\n"
                },
                "boundServiceAccountNamespaces": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of namespaces allowed to access this role. If set to `[\"*\"]` all namespaces are allowed, both this and bound_service_account_names can not be set to \"*\".\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "Name of the role.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "required": [
                "aliasNameSource",
                "boundServiceAccountNames",
                "boundServiceAccountNamespaces",
                "roleName"
            ],
            "inputProperties": {
                "aliasNameSource": {
                    "type": "string",
                    "description": "Configures how identity aliases are generated.\nValid choices are: `serviceaccount_uid`, `serviceaccount_name`. (vault-1.9+)\n"
                },
                "audience": {
                    "type": "string",
                    "description": "Audience claim to verify in the JWT.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Unique name of the kubernetes backend to configure.\n"
                },
                "boundServiceAccountNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of service account names able to access this role. If set to `[\"*\"]` all names are allowed, both this and bound_service_account_namespaces can not be \"*\".\n"
                },
                "boundServiceAccountNamespaces": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of namespaces allowed to access this role. If set to `[\"*\"]` all namespaces are allowed, both this and bound_service_account_names can not be set to \"*\".\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "Name of the role.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "requiredInputs": [
                "boundServiceAccountNames",
                "boundServiceAccountNamespaces",
                "roleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "aliasNameSource": {
                        "type": "string",
                        "description": "Configures how identity aliases are generated.\nValid choices are: `serviceaccount_uid`, `serviceaccount_name`. (vault-1.9+)\n"
                    },
                    "audience": {
                        "type": "string",
                        "description": "Audience claim to verify in the JWT.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "Unique name of the kubernetes backend to configure.\n"
                    },
                    "boundServiceAccountNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of service account names able to access this role. If set to `[\"*\"]` all names are allowed, both this and bound_service_account_namespaces can not be \"*\".\n"
                    },
                    "boundServiceAccountNamespaces": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of namespaces allowed to access this role. If set to `[\"*\"]` all namespaces are allowed, both this and bound_service_account_names can not be set to \"*\".\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "Name of the role.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The initial ttl of the token to generate in seconds\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:ldap/authBackend:AuthBackend": {
            "description": "Provides a resource for managing an [LDAP auth backend within Vault](https://www.vaultproject.io/docs/auth/ldap.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst ldap = new vault.ldap.AuthBackend(\"ldap\", {\n    discoverdn: false,\n    groupdn: \"OU=Groups,DC=example,DC=org\",\n    groupfilter: \"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n    path: \"ldap\",\n    upndomain: \"EXAMPLE.ORG\",\n    url: \"ldaps://dc-01.example.org\",\n    userattr: \"sAMAccountName\",\n    userdn: \"OU=Users,OU=Accounts,DC=example,DC=org\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nldap = vault.ldap.AuthBackend(\"ldap\",\n    discoverdn=False,\n    groupdn=\"OU=Groups,DC=example,DC=org\",\n    groupfilter=\"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n    path=\"ldap\",\n    upndomain=\"EXAMPLE.ORG\",\n    url=\"ldaps://dc-01.example.org\",\n    userattr=\"sAMAccountName\",\n    userdn=\"OU=Users,OU=Accounts,DC=example,DC=org\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var ldap = new Vault.Ldap.AuthBackend(\"ldap\", new Vault.Ldap.AuthBackendArgs\n        {\n            Discoverdn = false,\n            Groupdn = \"OU=Groups,DC=example,DC=org\",\n            Groupfilter = \"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n            Path = \"ldap\",\n            Upndomain = \"EXAMPLE.ORG\",\n            Url = \"ldaps://dc-01.example.org\",\n            Userattr = \"sAMAccountName\",\n            Userdn = \"OU=Users,OU=Accounts,DC=example,DC=org\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := ldap.NewAuthBackend(ctx, \"ldap\", \u0026ldap.AuthBackendArgs{\n\t\t\tDiscoverdn:  pulumi.Bool(false),\n\t\t\tGroupdn:     pulumi.String(\"OU=Groups,DC=example,DC=org\"),\n\t\t\tGroupfilter: pulumi.String(\"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\"),\n\t\t\tPath:        pulumi.String(\"ldap\"),\n\t\t\tUpndomain:   pulumi.String(\"EXAMPLE.ORG\"),\n\t\t\tUrl:         pulumi.String(\"ldaps://dc-01.example.org\"),\n\t\t\tUserattr:    pulumi.String(\"sAMAccountName\"),\n\t\t\tUserdn:      pulumi.String(\"OU=Users,OU=Accounts,DC=example,DC=org\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nLDAP authentication backends can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:ldap/authBackend:AuthBackend ldap ldap\n```\n\n ",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The accessor for this auth mount.\n"
                },
                "binddn": {
                    "type": "string",
                    "description": "DN of object to bind when performing user search\n"
                },
                "bindpass": {
                    "type": "string",
                    "description": "Password to use with `binddn` when performing user search\n"
                },
                "caseSensitiveNames": {
                    "type": "boolean",
                    "description": "Control case senstivity of objects fetched from LDAP, this is used for object matching in vault\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "Trusted CA to validate TLS certificate\n"
                },
                "clientTlsCert": {
                    "type": "string"
                },
                "clientTlsKey": {
                    "type": "string"
                },
                "denyNullBind": {
                    "type": "boolean"
                },
                "description": {
                    "type": "string",
                    "description": "Description for the LDAP auth backend mount\n"
                },
                "discoverdn": {
                    "type": "boolean"
                },
                "groupattr": {
                    "type": "string",
                    "description": "LDAP attribute to follow on objects returned by groupfilter\n"
                },
                "groupdn": {
                    "type": "string",
                    "description": "Base DN under which to perform group search\n"
                },
                "groupfilter": {
                    "type": "string",
                    "description": "Go template used to construct group membership query\n"
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Control whether or TLS certificates must be validated\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the auth method is local only.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to mount the LDAP auth backend under\n"
                },
                "starttls": {
                    "type": "boolean",
                    "description": "Control use of TLS when conecting to LDAP\n"
                },
                "tlsMaxVersion": {
                    "type": "string",
                    "description": "Maximum acceptable version of TLS\n"
                },
                "tlsMinVersion": {
                    "type": "string",
                    "description": "Minimum acceptable version of TLS\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                },
                "upndomain": {
                    "type": "string",
                    "description": "The userPrincipalDomain used to construct UPN string\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL of the LDAP server\n"
                },
                "useTokenGroups": {
                    "type": "boolean",
                    "description": "Use the Active Directory tokenGroups constructed attribute of the user to find the group memberships\n"
                },
                "userattr": {
                    "type": "string",
                    "description": "Attribute on user object matching username passed in\n"
                },
                "userdn": {
                    "type": "string",
                    "description": "Base DN under which to perform user search\n"
                }
            },
            "required": [
                "accessor",
                "binddn",
                "bindpass",
                "caseSensitiveNames",
                "certificate",
                "clientTlsCert",
                "clientTlsKey",
                "denyNullBind",
                "description",
                "discoverdn",
                "groupattr",
                "groupdn",
                "groupfilter",
                "insecureTls",
                "starttls",
                "tlsMaxVersion",
                "tlsMinVersion",
                "upndomain",
                "url",
                "useTokenGroups",
                "userattr",
                "userdn"
            ],
            "inputProperties": {
                "binddn": {
                    "type": "string",
                    "description": "DN of object to bind when performing user search\n"
                },
                "bindpass": {
                    "type": "string",
                    "description": "Password to use with `binddn` when performing user search\n"
                },
                "caseSensitiveNames": {
                    "type": "boolean",
                    "description": "Control case senstivity of objects fetched from LDAP, this is used for object matching in vault\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "Trusted CA to validate TLS certificate\n"
                },
                "clientTlsCert": {
                    "type": "string"
                },
                "clientTlsKey": {
                    "type": "string"
                },
                "denyNullBind": {
                    "type": "boolean"
                },
                "description": {
                    "type": "string",
                    "description": "Description for the LDAP auth backend mount\n"
                },
                "discoverdn": {
                    "type": "boolean"
                },
                "groupattr": {
                    "type": "string",
                    "description": "LDAP attribute to follow on objects returned by groupfilter\n"
                },
                "groupdn": {
                    "type": "string",
                    "description": "Base DN under which to perform group search\n"
                },
                "groupfilter": {
                    "type": "string",
                    "description": "Go template used to construct group membership query\n"
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Control whether or TLS certificates must be validated\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the auth method is local only.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to mount the LDAP auth backend under\n"
                },
                "starttls": {
                    "type": "boolean",
                    "description": "Control use of TLS when conecting to LDAP\n"
                },
                "tlsMaxVersion": {
                    "type": "string",
                    "description": "Maximum acceptable version of TLS\n"
                },
                "tlsMinVersion": {
                    "type": "string",
                    "description": "Minimum acceptable version of TLS\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                },
                "upndomain": {
                    "type": "string",
                    "description": "The userPrincipalDomain used to construct UPN string\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL of the LDAP server\n"
                },
                "useTokenGroups": {
                    "type": "boolean",
                    "description": "Use the Active Directory tokenGroups constructed attribute of the user to find the group memberships\n"
                },
                "userattr": {
                    "type": "string",
                    "description": "Attribute on user object matching username passed in\n"
                },
                "userdn": {
                    "type": "string",
                    "description": "Base DN under which to perform user search\n"
                }
            },
            "requiredInputs": [
                "url"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackend resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The accessor for this auth mount.\n"
                    },
                    "binddn": {
                        "type": "string",
                        "description": "DN of object to bind when performing user search\n"
                    },
                    "bindpass": {
                        "type": "string",
                        "description": "Password to use with `binddn` when performing user search\n"
                    },
                    "caseSensitiveNames": {
                        "type": "boolean",
                        "description": "Control case senstivity of objects fetched from LDAP, this is used for object matching in vault\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "Trusted CA to validate TLS certificate\n"
                    },
                    "clientTlsCert": {
                        "type": "string"
                    },
                    "clientTlsKey": {
                        "type": "string"
                    },
                    "denyNullBind": {
                        "type": "boolean"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description for the LDAP auth backend mount\n"
                    },
                    "discoverdn": {
                        "type": "boolean"
                    },
                    "groupattr": {
                        "type": "string",
                        "description": "LDAP attribute to follow on objects returned by groupfilter\n"
                    },
                    "groupdn": {
                        "type": "string",
                        "description": "Base DN under which to perform group search\n"
                    },
                    "groupfilter": {
                        "type": "string",
                        "description": "Go template used to construct group membership query\n"
                    },
                    "insecureTls": {
                        "type": "boolean",
                        "description": "Control whether or TLS certificates must be validated\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Specifies if the auth method is local only.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Path to mount the LDAP auth backend under\n"
                    },
                    "starttls": {
                        "type": "boolean",
                        "description": "Control use of TLS when conecting to LDAP\n"
                    },
                    "tlsMaxVersion": {
                        "type": "string",
                        "description": "Maximum acceptable version of TLS\n"
                    },
                    "tlsMinVersion": {
                        "type": "string",
                        "description": "Minimum acceptable version of TLS\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    },
                    "upndomain": {
                        "type": "string",
                        "description": "The userPrincipalDomain used to construct UPN string\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "The URL of the LDAP server\n"
                    },
                    "useTokenGroups": {
                        "type": "boolean",
                        "description": "Use the Active Directory tokenGroups constructed attribute of the user to find the group memberships\n"
                    },
                    "userattr": {
                        "type": "string",
                        "description": "Attribute on user object matching username passed in\n"
                    },
                    "userdn": {
                        "type": "string",
                        "description": "Base DN under which to perform user search\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:ldap/authBackendGroup:AuthBackendGroup": {
            "description": "Provides a resource to create a group in an [LDAP auth backend within Vault](https://www.vaultproject.io/docs/auth/ldap.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst ldap = new vault.ldap.AuthBackend(\"ldap\", {\n    path: \"ldap\",\n    url: \"ldaps://dc-01.example.org\",\n    userdn: \"OU=Users,OU=Accounts,DC=example,DC=org\",\n    userattr: \"sAMAccountName\",\n    upndomain: \"EXAMPLE.ORG\",\n    discoverdn: false,\n    groupdn: \"OU=Groups,DC=example,DC=org\",\n    groupfilter: \"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n});\nconst group = new vault.ldap.AuthBackendGroup(\"group\", {\n    groupname: \"dba\",\n    policies: [\"dba\"],\n    backend: ldap.path,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nldap = vault.ldap.AuthBackend(\"ldap\",\n    path=\"ldap\",\n    url=\"ldaps://dc-01.example.org\",\n    userdn=\"OU=Users,OU=Accounts,DC=example,DC=org\",\n    userattr=\"sAMAccountName\",\n    upndomain=\"EXAMPLE.ORG\",\n    discoverdn=False,\n    groupdn=\"OU=Groups,DC=example,DC=org\",\n    groupfilter=\"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\")\ngroup = vault.ldap.AuthBackendGroup(\"group\",\n    groupname=\"dba\",\n    policies=[\"dba\"],\n    backend=ldap.path)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var ldap = new Vault.Ldap.AuthBackend(\"ldap\", new Vault.Ldap.AuthBackendArgs\n        {\n            Path = \"ldap\",\n            Url = \"ldaps://dc-01.example.org\",\n            Userdn = \"OU=Users,OU=Accounts,DC=example,DC=org\",\n            Userattr = \"sAMAccountName\",\n            Upndomain = \"EXAMPLE.ORG\",\n            Discoverdn = false,\n            Groupdn = \"OU=Groups,DC=example,DC=org\",\n            Groupfilter = \"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n        });\n        var @group = new Vault.Ldap.AuthBackendGroup(\"group\", new Vault.Ldap.AuthBackendGroupArgs\n        {\n            Groupname = \"dba\",\n            Policies = \n            {\n                \"dba\",\n            },\n            Backend = ldap.Path,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tldap, err := ldap.NewAuthBackend(ctx, \"ldap\", \u0026ldap.AuthBackendArgs{\n\t\t\tPath:        pulumi.String(\"ldap\"),\n\t\t\tUrl:         pulumi.String(\"ldaps://dc-01.example.org\"),\n\t\t\tUserdn:      pulumi.String(\"OU=Users,OU=Accounts,DC=example,DC=org\"),\n\t\t\tUserattr:    pulumi.String(\"sAMAccountName\"),\n\t\t\tUpndomain:   pulumi.String(\"EXAMPLE.ORG\"),\n\t\t\tDiscoverdn:  pulumi.Bool(false),\n\t\t\tGroupdn:     pulumi.String(\"OU=Groups,DC=example,DC=org\"),\n\t\t\tGroupfilter: pulumi.String(\"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewAuthBackendGroup(ctx, \"group\", \u0026ldap.AuthBackendGroupArgs{\n\t\t\tGroupname: pulumi.String(\"dba\"),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dba\"),\n\t\t\t},\n\t\t\tBackend: ldap.Path,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nLDAP authentication backend groups can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:ldap/authBackendGroup:AuthBackendGroup foo auth/ldap/groups/foo\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Path to the authentication backend\n"
                },
                "groupname": {
                    "type": "string",
                    "description": "The LDAP groupname\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Policies which should be granted to members of the group\n"
                }
            },
            "required": [
                "groupname",
                "policies"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Path to the authentication backend\n"
                },
                "groupname": {
                    "type": "string",
                    "description": "The LDAP groupname\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Policies which should be granted to members of the group\n"
                }
            },
            "requiredInputs": [
                "groupname"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendGroup resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Path to the authentication backend\n"
                    },
                    "groupname": {
                        "type": "string",
                        "description": "The LDAP groupname\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Policies which should be granted to members of the group\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:ldap/authBackendUser:AuthBackendUser": {
            "description": "Provides a resource to create a user in an [LDAP auth backend within Vault](https://www.vaultproject.io/docs/auth/ldap.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst ldap = new vault.ldap.AuthBackend(\"ldap\", {\n    path: \"ldap\",\n    url: \"ldaps://dc-01.example.org\",\n    userdn: \"OU=Users,OU=Accounts,DC=example,DC=org\",\n    userattr: \"sAMAccountName\",\n    upndomain: \"EXAMPLE.ORG\",\n    discoverdn: false,\n    groupdn: \"OU=Groups,DC=example,DC=org\",\n    groupfilter: \"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n});\nconst user = new vault.ldap.AuthBackendUser(\"user\", {\n    username: \"test-user\",\n    policies: [\n        \"dba\",\n        \"sysops\",\n    ],\n    backend: ldap.path,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nldap = vault.ldap.AuthBackend(\"ldap\",\n    path=\"ldap\",\n    url=\"ldaps://dc-01.example.org\",\n    userdn=\"OU=Users,OU=Accounts,DC=example,DC=org\",\n    userattr=\"sAMAccountName\",\n    upndomain=\"EXAMPLE.ORG\",\n    discoverdn=False,\n    groupdn=\"OU=Groups,DC=example,DC=org\",\n    groupfilter=\"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\")\nuser = vault.ldap.AuthBackendUser(\"user\",\n    username=\"test-user\",\n    policies=[\n        \"dba\",\n        \"sysops\",\n    ],\n    backend=ldap.path)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var ldap = new Vault.Ldap.AuthBackend(\"ldap\", new Vault.Ldap.AuthBackendArgs\n        {\n            Path = \"ldap\",\n            Url = \"ldaps://dc-01.example.org\",\n            Userdn = \"OU=Users,OU=Accounts,DC=example,DC=org\",\n            Userattr = \"sAMAccountName\",\n            Upndomain = \"EXAMPLE.ORG\",\n            Discoverdn = false,\n            Groupdn = \"OU=Groups,DC=example,DC=org\",\n            Groupfilter = \"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n        });\n        var user = new Vault.Ldap.AuthBackendUser(\"user\", new Vault.Ldap.AuthBackendUserArgs\n        {\n            Username = \"test-user\",\n            Policies = \n            {\n                \"dba\",\n                \"sysops\",\n            },\n            Backend = ldap.Path,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tldap, err := ldap.NewAuthBackend(ctx, \"ldap\", \u0026ldap.AuthBackendArgs{\n\t\t\tPath:        pulumi.String(\"ldap\"),\n\t\t\tUrl:         pulumi.String(\"ldaps://dc-01.example.org\"),\n\t\t\tUserdn:      pulumi.String(\"OU=Users,OU=Accounts,DC=example,DC=org\"),\n\t\t\tUserattr:    pulumi.String(\"sAMAccountName\"),\n\t\t\tUpndomain:   pulumi.String(\"EXAMPLE.ORG\"),\n\t\t\tDiscoverdn:  pulumi.Bool(false),\n\t\t\tGroupdn:     pulumi.String(\"OU=Groups,DC=example,DC=org\"),\n\t\t\tGroupfilter: pulumi.String(\"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewAuthBackendUser(ctx, \"user\", \u0026ldap.AuthBackendUserArgs{\n\t\t\tUsername: pulumi.String(\"test-user\"),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dba\"),\n\t\t\t\tpulumi.String(\"sysops\"),\n\t\t\t},\n\t\t\tBackend: ldap.Path,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nLDAP authentication backend users can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:ldap/authBackendUser:AuthBackendUser foo auth/ldap/users/foo\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Path to the authentication backend\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Override LDAP groups which should be granted to user\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Policies which should be granted to user\n"
                },
                "username": {
                    "type": "string",
                    "description": "The LDAP username\n"
                }
            },
            "required": [
                "groups",
                "policies",
                "username"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Path to the authentication backend\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Override LDAP groups which should be granted to user\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Policies which should be granted to user\n"
                },
                "username": {
                    "type": "string",
                    "description": "The LDAP username\n"
                }
            },
            "requiredInputs": [
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendUser resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Path to the authentication backend\n"
                    },
                    "groups": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Override LDAP groups which should be granted to user\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Policies which should be granted to user\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "The LDAP username\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:okta/authBackend:AuthBackend": {
            "description": "Provides a resource for managing an\n[Okta auth backend within Vault](https://www.vaultproject.io/docs/auth/okta.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.okta.AuthBackend(\"example\", {\n    description: \"Demonstration of the Terraform Okta auth backend\",\n    groups: [{\n        groupName: \"foo\",\n        policies: [\n            \"one\",\n            \"two\",\n        ],\n    }],\n    organization: \"example\",\n    token: \"something that should be kept secret\",\n    users: [{\n        groups: [\"foo\"],\n        username: \"bar\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.okta.AuthBackend(\"example\",\n    description=\"Demonstration of the Terraform Okta auth backend\",\n    groups=[vault.okta.AuthBackendGroupArgs(\n        group_name=\"foo\",\n        policies=[\n            \"one\",\n            \"two\",\n        ],\n    )],\n    organization=\"example\",\n    token=\"something that should be kept secret\",\n    users=[vault.okta.AuthBackendUserArgs(\n        groups=[\"foo\"],\n        username=\"bar\",\n    )])\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.Okta.AuthBackend(\"example\", new Vault.Okta.AuthBackendArgs\n        {\n            Description = \"Demonstration of the Terraform Okta auth backend\",\n            Groups = \n            {\n                new Vault.Okta.Inputs.AuthBackendGroupArgs\n                {\n                    GroupName = \"foo\",\n                    Policies = \n                    {\n                        \"one\",\n                        \"two\",\n                    },\n                },\n            },\n            Organization = \"example\",\n            Token = \"something that should be kept secret\",\n            Users = \n            {\n                new Vault.Okta.Inputs.AuthBackendUserArgs\n                {\n                    Groups = \n                    {\n                        \"foo\",\n                    },\n                    Username = \"bar\",\n                },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/okta\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := okta.NewAuthBackend(ctx, \"example\", \u0026okta.AuthBackendArgs{\n\t\t\tDescription: pulumi.String(\"Demonstration of the Terraform Okta auth backend\"),\n\t\t\tGroups: okta.AuthBackendGroupArray{\n\t\t\t\t\u0026okta.AuthBackendGroupArgs{\n\t\t\t\t\tGroupName: pulumi.String(\"foo\"),\n\t\t\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"one\"),\n\t\t\t\t\t\tpulumi.String(\"two\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tOrganization: pulumi.String(\"example\"),\n\t\t\tToken:        pulumi.String(\"something that should be kept secret\"),\n\t\t\tUsers: okta.AuthBackendUserArray{\n\t\t\t\t\u0026okta.AuthBackendUserArgs{\n\t\t\t\t\tGroups: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"foo\"),\n\t\t\t\t\t},\n\t\t\t\t\tUsername: pulumi.String(\"bar\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nOkta authentication backends can be imported using its `path`, e.g.\n\n```sh\n $ pulumi import vault:okta/authBackend:AuthBackend example okta\n```\n\n ",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The mount accessor related to the auth mount. It is useful for integration with [Identity Secrets Engine](https://www.vaultproject.io/docs/secrets/identity/index.html).\n"
                },
                "baseUrl": {
                    "type": "string",
                    "description": "The Okta url. Examples: oktapreview.com, okta.com\n"
                },
                "bypassOktaMfa": {
                    "type": "boolean",
                    "description": "When true, requests by Okta for a MFA check will be bypassed. This also disallows certain status checks on the account, such as whether the password is expired.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the auth backend\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:okta/AuthBackendGroup:AuthBackendGroup"
                    },
                    "description": "Associate Okta groups with policies within Vault.\nSee below for more details.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Maximum duration after which authentication will be expired\n[See the documentation for info on valid duration formats](https://golang.org/pkg/time/#ParseDuration).\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The Okta organization. This will be the first part of the url `https://XXX.okta.com`\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to mount the Okta auth backend\n"
                },
                "token": {
                    "type": "string",
                    "description": "The Okta API token. This is required to query Okta for user group membership.\nIf this is not supplied only locally configured groups will be enabled.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Duration after which authentication will be expired.\n[See the documentation for info on valid duration formats](https://golang.org/pkg/time/#ParseDuration).\n"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:okta/AuthBackendUser:AuthBackendUser"
                    },
                    "description": "Associate Okta users with groups or policies within Vault.\nSee below for more details.\n"
                }
            },
            "required": [
                "accessor",
                "groups",
                "organization",
                "users"
            ],
            "inputProperties": {
                "baseUrl": {
                    "type": "string",
                    "description": "The Okta url. Examples: oktapreview.com, okta.com\n"
                },
                "bypassOktaMfa": {
                    "type": "boolean",
                    "description": "When true, requests by Okta for a MFA check will be bypassed. This also disallows certain status checks on the account, such as whether the password is expired.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the auth backend\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:okta/AuthBackendGroup:AuthBackendGroup"
                    },
                    "description": "Associate Okta groups with policies within Vault.\nSee below for more details.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Maximum duration after which authentication will be expired\n[See the documentation for info on valid duration formats](https://golang.org/pkg/time/#ParseDuration).\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The Okta organization. This will be the first part of the url `https://XXX.okta.com`\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to mount the Okta auth backend\n"
                },
                "token": {
                    "type": "string",
                    "description": "The Okta API token. This is required to query Okta for user group membership.\nIf this is not supplied only locally configured groups will be enabled.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Duration after which authentication will be expired.\n[See the documentation for info on valid duration formats](https://golang.org/pkg/time/#ParseDuration).\n"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:okta/AuthBackendUser:AuthBackendUser"
                    },
                    "description": "Associate Okta users with groups or policies within Vault.\nSee below for more details.\n"
                }
            },
            "requiredInputs": [
                "organization"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackend resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The mount accessor related to the auth mount. It is useful for integration with [Identity Secrets Engine](https://www.vaultproject.io/docs/secrets/identity/index.html).\n"
                    },
                    "baseUrl": {
                        "type": "string",
                        "description": "The Okta url. Examples: oktapreview.com, okta.com\n"
                    },
                    "bypassOktaMfa": {
                        "type": "boolean",
                        "description": "When true, requests by Okta for a MFA check will be bypassed. This also disallows certain status checks on the account, such as whether the password is expired.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the auth backend\n"
                    },
                    "groups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:okta/AuthBackendGroup:AuthBackendGroup"
                        },
                        "description": "Associate Okta groups with policies within Vault.\nSee below for more details.\n"
                    },
                    "maxTtl": {
                        "type": "string",
                        "description": "Maximum duration after which authentication will be expired\n[See the documentation for info on valid duration formats](https://golang.org/pkg/time/#ParseDuration).\n"
                    },
                    "organization": {
                        "type": "string",
                        "description": "The Okta organization. This will be the first part of the url `https://XXX.okta.com`\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Path to mount the Okta auth backend\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "The Okta API token. This is required to query Okta for user group membership.\nIf this is not supplied only locally configured groups will be enabled.\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Duration after which authentication will be expired.\n[See the documentation for info on valid duration formats](https://golang.org/pkg/time/#ParseDuration).\n"
                    },
                    "users": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:okta/AuthBackendUser:AuthBackendUser"
                        },
                        "description": "Associate Okta users with groups or policies within Vault.\nSee below for more details.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:okta/authBackendGroup:AuthBackendGroup": {
            "description": "Provides a resource to create a group in an\n[Okta auth backend within Vault](https://www.vaultproject.io/docs/auth/okta.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.okta.AuthBackend(\"example\", {\n    path: \"group_okta\",\n    organization: \"dummy\",\n});\nconst foo = new vault.okta.AuthBackendGroup(\"foo\", {\n    path: example.path,\n    groupName: \"foo\",\n    policies: [\n        \"one\",\n        \"two\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.okta.AuthBackend(\"example\",\n    path=\"group_okta\",\n    organization=\"dummy\")\nfoo = vault.okta.AuthBackendGroup(\"foo\",\n    path=example.path,\n    group_name=\"foo\",\n    policies=[\n        \"one\",\n        \"two\",\n    ])\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.Okta.AuthBackend(\"example\", new Vault.Okta.AuthBackendArgs\n        {\n            Path = \"group_okta\",\n            Organization = \"dummy\",\n        });\n        var foo = new Vault.Okta.AuthBackendGroup(\"foo\", new Vault.Okta.AuthBackendGroupArgs\n        {\n            Path = example.Path,\n            GroupName = \"foo\",\n            Policies = \n            {\n                \"one\",\n                \"two\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/okta\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := okta.NewAuthBackend(ctx, \"example\", \u0026okta.AuthBackendArgs{\n\t\t\tPath:         pulumi.String(\"group_okta\"),\n\t\t\tOrganization: pulumi.String(\"dummy\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = okta.NewAuthBackendGroup(ctx, \"foo\", \u0026okta.AuthBackendGroupArgs{\n\t\t\tPath:      example.Path,\n\t\t\tGroupName: pulumi.String(\"foo\"),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"one\"),\n\t\t\t\tpulumi.String(\"two\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nOkta authentication backend groups can be imported using the format `backend/groupName` e.g.\n\n```sh\n $ pulumi import vault:okta/authBackendGroup:AuthBackendGroup foo okta/foo\n```\n\n ",
            "properties": {
                "groupName": {
                    "type": "string",
                    "description": "Name of the group within the Okta\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path where the Okta auth backend is mounted\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Vault policies to associate with this group\n"
                }
            },
            "required": [
                "groupName",
                "path"
            ],
            "inputProperties": {
                "groupName": {
                    "type": "string",
                    "description": "Name of the group within the Okta\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path where the Okta auth backend is mounted\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Vault policies to associate with this group\n"
                }
            },
            "requiredInputs": [
                "groupName",
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendGroup resources.\n",
                "properties": {
                    "groupName": {
                        "type": "string",
                        "description": "Name of the group within the Okta\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path where the Okta auth backend is mounted\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Vault policies to associate with this group\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:okta/authBackendUser:AuthBackendUser": {
            "description": "Provides a resource to create a user in an\n[Okta auth backend within Vault](https://www.vaultproject.io/docs/auth/okta.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.okta.AuthBackend(\"example\", {\n    path: \"user_okta\",\n    organization: \"dummy\",\n});\nconst foo = new vault.okta.AuthBackendUser(\"foo\", {\n    path: example.path,\n    username: \"foo\",\n    groups: [\n        \"one\",\n        \"two\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.okta.AuthBackend(\"example\",\n    path=\"user_okta\",\n    organization=\"dummy\")\nfoo = vault.okta.AuthBackendUser(\"foo\",\n    path=example.path,\n    username=\"foo\",\n    groups=[\n        \"one\",\n        \"two\",\n    ])\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.Okta.AuthBackend(\"example\", new Vault.Okta.AuthBackendArgs\n        {\n            Path = \"user_okta\",\n            Organization = \"dummy\",\n        });\n        var foo = new Vault.Okta.AuthBackendUser(\"foo\", new Vault.Okta.AuthBackendUserArgs\n        {\n            Path = example.Path,\n            Username = \"foo\",\n            Groups = \n            {\n                \"one\",\n                \"two\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/okta\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := okta.NewAuthBackend(ctx, \"example\", \u0026okta.AuthBackendArgs{\n\t\t\tPath:         pulumi.String(\"user_okta\"),\n\t\t\tOrganization: pulumi.String(\"dummy\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = okta.NewAuthBackendUser(ctx, \"foo\", \u0026okta.AuthBackendUserArgs{\n\t\t\tPath:     example.Path,\n\t\t\tUsername: pulumi.String(\"foo\"),\n\t\t\tGroups: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"one\"),\n\t\t\t\tpulumi.String(\"two\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nOkta authentication backend users can be imported using its `path/user` ID format, e.g.\n\n```sh\n $ pulumi import vault:okta/authBackendUser:AuthBackendUser example okta/foo\n```\n\n ",
            "properties": {
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Okta groups to associate with this user\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path where the Okta auth backend is mounted\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Vault policies to associate with this user\n"
                },
                "username": {
                    "type": "string",
                    "description": "Name of the user within Okta\n"
                }
            },
            "required": [
                "path",
                "username"
            ],
            "inputProperties": {
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Okta groups to associate with this user\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path where the Okta auth backend is mounted\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Vault policies to associate with this user\n"
                },
                "username": {
                    "type": "string",
                    "description": "Name of the user within Okta\n"
                }
            },
            "requiredInputs": [
                "path",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendUser resources.\n",
                "properties": {
                    "groups": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Okta groups to associate with this user\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path where the Okta auth backend is mounted\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Vault policies to associate with this user\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Name of the user within Okta\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendCert:SecretBackendCert": {
            "properties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "autoRenew": {
                    "type": "boolean",
                    "description": "If set to `true`, certs will be renewed if the expiration is within `min_seconds_remaining`. Default `false`\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "caChain": {
                    "type": "string",
                    "description": "The CA chain\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The certificate\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of certificate to create\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "expiration": {
                    "type": "integer",
                    "description": "The expiration date of the certificate in unix epoch format\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "issuingCa": {
                    "type": "string",
                    "description": "The issuing CA\n"
                },
                "minSecondsRemaining": {
                    "type": "integer",
                    "description": "Generate a new certificate when the expiration is within this number of seconds, default is 604800 (7 days)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the role to create the certificate against\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "The private key\n"
                },
                "privateKeyFormat": {
                    "type": "string",
                    "description": "The private key format\n"
                },
                "privateKeyType": {
                    "type": "string",
                    "description": "The private key type\n"
                },
                "serialNumber": {
                    "type": "string",
                    "description": "The serial number\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n"
                }
            },
            "required": [
                "backend",
                "caChain",
                "certificate",
                "commonName",
                "expiration",
                "issuingCa",
                "name",
                "privateKey",
                "privateKeyType",
                "serialNumber"
            ],
            "inputProperties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "autoRenew": {
                    "type": "boolean",
                    "description": "If set to `true`, certs will be renewed if the expiration is within `min_seconds_remaining`. Default `false`\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of certificate to create\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "minSecondsRemaining": {
                    "type": "integer",
                    "description": "Generate a new certificate when the expiration is within this number of seconds, default is 604800 (7 days)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the role to create the certificate against\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "privateKeyFormat": {
                    "type": "string",
                    "description": "The private key format\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n"
                }
            },
            "requiredInputs": [
                "backend",
                "commonName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendCert resources.\n",
                "properties": {
                    "altNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative names\n"
                    },
                    "autoRenew": {
                        "type": "boolean",
                        "description": "If set to `true`, certs will be renewed if the expiration is within `min_seconds_remaining`. Default `false`\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The PKI secret backend the resource belongs to.\n"
                    },
                    "caChain": {
                        "type": "string",
                        "description": "The CA chain\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "The certificate\n"
                    },
                    "commonName": {
                        "type": "string",
                        "description": "CN of certificate to create\n"
                    },
                    "excludeCnFromSans": {
                        "type": "boolean",
                        "description": "Flag to exclude CN from SANs\n"
                    },
                    "expiration": {
                        "type": "integer",
                        "description": "The expiration date of the certificate in unix epoch format\n"
                    },
                    "format": {
                        "type": "string",
                        "description": "The format of data\n"
                    },
                    "ipSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative IPs\n"
                    },
                    "issuingCa": {
                        "type": "string",
                        "description": "The issuing CA\n"
                    },
                    "minSecondsRemaining": {
                        "type": "integer",
                        "description": "Generate a new certificate when the expiration is within this number of seconds, default is 604800 (7 days)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the role to create the certificate against\n"
                    },
                    "otherSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of other SANs\n"
                    },
                    "privateKey": {
                        "type": "string",
                        "description": "The private key\n"
                    },
                    "privateKeyFormat": {
                        "type": "string",
                        "description": "The private key format\n"
                    },
                    "privateKeyType": {
                        "type": "string",
                        "description": "The private key type\n"
                    },
                    "serialNumber": {
                        "type": "string",
                        "description": "The serial number\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Time to live\n"
                    },
                    "uriSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative URIs\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendConfigCa:SecretBackendConfigCa": {
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "pemBundle": {
                    "type": "string",
                    "description": "The key and certificate PEM bundle\n"
                }
            },
            "required": [
                "backend",
                "pemBundle"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "pemBundle": {
                    "type": "string",
                    "description": "The key and certificate PEM bundle\n"
                }
            },
            "requiredInputs": [
                "backend",
                "pemBundle"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendConfigCa resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The PKI secret backend the resource belongs to.\n"
                    },
                    "pemBundle": {
                        "type": "string",
                        "description": "The key and certificate PEM bundle\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendConfigUrls:SecretBackendConfigUrls": {
            "description": "Allows setting the issuing certificate endpoints, CRL distribution points, and OCSP server endpoints that will be encoded into issued certificates.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst configUrls = new vault.pkisecret.SecretBackendConfigUrls(\"configUrls\", {\n    backend: vault_mount.pki.path,\n    issuingCertificates: [\"http://127.0.0.1:8200/v1/pki/ca\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nconfig_urls = vault.pki_secret.SecretBackendConfigUrls(\"configUrls\",\n    backend=vault_mount[\"pki\"][\"path\"],\n    issuing_certificates=[\"http://127.0.0.1:8200/v1/pki/ca\"])\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configUrls = new Vault.PkiSecret.SecretBackendConfigUrls(\"configUrls\", new Vault.PkiSecret.SecretBackendConfigUrlsArgs\n        {\n            Backend = vault_mount.Pki.Path,\n            IssuingCertificates = \n            {\n                \"http://127.0.0.1:8200/v1/pki/ca\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/pkiSecret\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := pkiSecret.NewSecretBackendConfigUrls(ctx, \"configUrls\", \u0026pkiSecret.SecretBackendConfigUrlsArgs{\n\t\t\tBackend: pulumi.Any(vault_mount.Pki.Path),\n\t\t\tIssuingCertificates: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://127.0.0.1:8200/v1/pki/ca\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "crlDistributionPoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the URL values for the CRL Distribution Points field.\n"
                },
                "issuingCertificates": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the URL values for the Issuing Certificate field.\n"
                },
                "ocspServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the URL values for the OCSP Servers field.\n"
                }
            },
            "required": [
                "backend"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "crlDistributionPoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the URL values for the CRL Distribution Points field.\n"
                },
                "issuingCertificates": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the URL values for the Issuing Certificate field.\n"
                },
                "ocspServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the URL values for the OCSP Servers field.\n"
                }
            },
            "requiredInputs": [
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendConfigUrls resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                    },
                    "crlDistributionPoints": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the URL values for the CRL Distribution Points field.\n"
                    },
                    "issuingCertificates": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the URL values for the Issuing Certificate field.\n"
                    },
                    "ocspServers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the URL values for the OCSP Servers field.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendCrlConfig:SecretBackendCrlConfig": {
            "description": "Allows setting the duration for which the generated CRL should be marked valid. If the CRL is disabled, it will return a signed but zero-length CRL for any request. If enabled, it will re-build the CRL.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst pki = new vault.Mount(\"pki\", {\n    path: `%s`,\n    type: \"pki\",\n    defaultLeaseTtlSeconds: 3600,\n    maxLeaseTtlSeconds: 86400,\n});\nconst crlConfig = new vault.pkisecret.SecretBackendCrlConfig(\"crlConfig\", {\n    backend: pki.path,\n    expiry: \"72h\",\n    disable: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\npki = vault.Mount(\"pki\",\n    path=\"%s\",\n    type=\"pki\",\n    default_lease_ttl_seconds=3600,\n    max_lease_ttl_seconds=86400)\ncrl_config = vault.pki_secret.SecretBackendCrlConfig(\"crlConfig\",\n    backend=pki.path,\n    expiry=\"72h\",\n    disable=False)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var pki = new Vault.Mount(\"pki\", new Vault.MountArgs\n        {\n            Path = \"%s\",\n            Type = \"pki\",\n            DefaultLeaseTtlSeconds = 3600,\n            MaxLeaseTtlSeconds = 86400,\n        });\n        var crlConfig = new Vault.PkiSecret.SecretBackendCrlConfig(\"crlConfig\", new Vault.PkiSecret.SecretBackendCrlConfigArgs\n        {\n            Backend = pki.Path,\n            Expiry = \"72h\",\n            Disable = false,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/pkiSecret\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tpki, err := vault.NewMount(ctx, \"pki\", \u0026vault.MountArgs{\n\t\t\tPath:                   pulumi.String(fmt.Sprintf(\"%v%v\", \"%\", \"s\")),\n\t\t\tType:                   pulumi.String(\"pki\"),\n\t\t\tDefaultLeaseTtlSeconds: pulumi.Int(3600),\n\t\t\tMaxLeaseTtlSeconds:     pulumi.Int(86400),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = pkiSecret.NewSecretBackendCrlConfig(ctx, \"crlConfig\", \u0026pkiSecret.SecretBackendCrlConfigArgs{\n\t\t\tBackend: pki.Path,\n\t\t\tExpiry:  pulumi.String(\"72h\"),\n\t\t\tDisable: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "disable": {
                    "type": "boolean",
                    "description": "Disables or enables CRL building.\n"
                },
                "expiry": {
                    "type": "string",
                    "description": "Specifies the time until expiration.\n"
                }
            },
            "required": [
                "backend"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "disable": {
                    "type": "boolean",
                    "description": "Disables or enables CRL building.\n"
                },
                "expiry": {
                    "type": "string",
                    "description": "Specifies the time until expiration.\n"
                }
            },
            "requiredInputs": [
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendCrlConfig resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                    },
                    "disable": {
                        "type": "boolean",
                        "description": "Disables or enables CRL building.\n"
                    },
                    "expiry": {
                        "type": "string",
                        "description": "Specifies the time until expiration.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendIntermediateCertRequest:SecretBackendIntermediateCertRequest": {
            "properties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of intermediate to create\n"
                },
                "country": {
                    "type": "string",
                    "description": "The country\n"
                },
                "csr": {
                    "type": "string",
                    "description": "The CSR\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "keyBits": {
                    "type": "integer",
                    "description": "The number of bits to use\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "The desired key type\n"
                },
                "locality": {
                    "type": "string",
                    "description": "The locality\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "ou": {
                    "type": "string",
                    "description": "The organization unit\n"
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "The private key\n"
                },
                "privateKeyFormat": {
                    "type": "string",
                    "description": "The private key format\n"
                },
                "privateKeyType": {
                    "type": "string",
                    "description": "The private key type\n"
                },
                "province": {
                    "type": "string",
                    "description": "The province\n"
                },
                "streetAddress": {
                    "type": "string",
                    "description": "The street address\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of intermediate to create. Must be either \\\"exported\\\" or \\\"internal\\\"\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n"
                }
            },
            "required": [
                "backend",
                "commonName",
                "csr",
                "privateKey",
                "privateKeyType",
                "type"
            ],
            "inputProperties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of intermediate to create\n"
                },
                "country": {
                    "type": "string",
                    "description": "The country\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "keyBits": {
                    "type": "integer",
                    "description": "The number of bits to use\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "The desired key type\n"
                },
                "locality": {
                    "type": "string",
                    "description": "The locality\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "ou": {
                    "type": "string",
                    "description": "The organization unit\n"
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code\n"
                },
                "privateKeyFormat": {
                    "type": "string",
                    "description": "The private key format\n"
                },
                "province": {
                    "type": "string",
                    "description": "The province\n"
                },
                "streetAddress": {
                    "type": "string",
                    "description": "The street address\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of intermediate to create. Must be either \\\"exported\\\" or \\\"internal\\\"\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n"
                }
            },
            "requiredInputs": [
                "backend",
                "commonName",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendIntermediateCertRequest resources.\n",
                "properties": {
                    "altNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative names\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The PKI secret backend the resource belongs to.\n"
                    },
                    "commonName": {
                        "type": "string",
                        "description": "CN of intermediate to create\n"
                    },
                    "country": {
                        "type": "string",
                        "description": "The country\n"
                    },
                    "csr": {
                        "type": "string",
                        "description": "The CSR\n"
                    },
                    "excludeCnFromSans": {
                        "type": "boolean",
                        "description": "Flag to exclude CN from SANs\n"
                    },
                    "format": {
                        "type": "string",
                        "description": "The format of data\n"
                    },
                    "ipSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative IPs\n"
                    },
                    "keyBits": {
                        "type": "integer",
                        "description": "The number of bits to use\n"
                    },
                    "keyType": {
                        "type": "string",
                        "description": "The desired key type\n"
                    },
                    "locality": {
                        "type": "string",
                        "description": "The locality\n"
                    },
                    "organization": {
                        "type": "string",
                        "description": "The organization\n"
                    },
                    "otherSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of other SANs\n"
                    },
                    "ou": {
                        "type": "string",
                        "description": "The organization unit\n"
                    },
                    "postalCode": {
                        "type": "string",
                        "description": "The postal code\n"
                    },
                    "privateKey": {
                        "type": "string",
                        "description": "The private key\n"
                    },
                    "privateKeyFormat": {
                        "type": "string",
                        "description": "The private key format\n"
                    },
                    "privateKeyType": {
                        "type": "string",
                        "description": "The private key type\n"
                    },
                    "province": {
                        "type": "string",
                        "description": "The province\n"
                    },
                    "streetAddress": {
                        "type": "string",
                        "description": "The street address\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of intermediate to create. Must be either \\\"exported\\\" or \\\"internal\\\"\n"
                    },
                    "uriSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative URIs\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendIntermediateSetSigned:SecretBackendIntermediateSetSigned": {
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "Specifies the PEM encoded certificate. May optionally append additional\nCA certificates to populate the whole chain, which will then enable returning the full chain from\nissue and sign operations.\n"
                }
            },
            "required": [
                "backend",
                "certificate"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "Specifies the PEM encoded certificate. May optionally append additional\nCA certificates to populate the whole chain, which will then enable returning the full chain from\nissue and sign operations.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "certificate"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendIntermediateSetSigned resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The PKI secret backend the resource belongs to.\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "Specifies the PEM encoded certificate. May optionally append additional\nCA certificates to populate the whole chain, which will then enable returning the full chain from\nissue and sign operations.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendRole:SecretBackendRole": {
            "description": "Creates a role on an PKI Secret Backend for Vault.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst pki = new vault.Mount(\"pki\", {\n    path: \"pki\",\n    type: \"pki\",\n    defaultLeaseTtlSeconds: 3600,\n    maxLeaseTtlSeconds: 86400,\n});\nconst role = new vault.pkisecret.SecretBackendRole(\"role\", {\n    backend: pki.path,\n    ttl: 3600,\n    allowIpSans: true,\n    keyType: \"rsa\",\n    keyBits: 4096,\n    allowedDomains: [\n        \"example.com\",\n        \"my.domain\",\n    ],\n    allowSubdomains: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\npki = vault.Mount(\"pki\",\n    path=\"pki\",\n    type=\"pki\",\n    default_lease_ttl_seconds=3600,\n    max_lease_ttl_seconds=86400)\nrole = vault.pki_secret.SecretBackendRole(\"role\",\n    backend=pki.path,\n    ttl=\"3600\",\n    allow_ip_sans=True,\n    key_type=\"rsa\",\n    key_bits=4096,\n    allowed_domains=[\n        \"example.com\",\n        \"my.domain\",\n    ],\n    allow_subdomains=True)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var pki = new Vault.Mount(\"pki\", new Vault.MountArgs\n        {\n            Path = \"pki\",\n            Type = \"pki\",\n            DefaultLeaseTtlSeconds = 3600,\n            MaxLeaseTtlSeconds = 86400,\n        });\n        var role = new Vault.PkiSecret.SecretBackendRole(\"role\", new Vault.PkiSecret.SecretBackendRoleArgs\n        {\n            Backend = pki.Path,\n            Ttl = \"3600\",\n            AllowIpSans = true,\n            KeyType = \"rsa\",\n            KeyBits = 4096,\n            AllowedDomains = \n            {\n                \"example.com\",\n                \"my.domain\",\n            },\n            AllowSubdomains = true,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/pkiSecret\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tpki, err := vault.NewMount(ctx, \"pki\", \u0026vault.MountArgs{\n\t\t\tPath:                   pulumi.String(\"pki\"),\n\t\t\tType:                   pulumi.String(\"pki\"),\n\t\t\tDefaultLeaseTtlSeconds: pulumi.Int(3600),\n\t\t\tMaxLeaseTtlSeconds:     pulumi.Int(86400),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = pkiSecret.NewSecretBackendRole(ctx, \"role\", \u0026pkiSecret.SecretBackendRoleArgs{\n\t\t\tBackend:     pki.Path,\n\t\t\tTtl:         pulumi.String(\"3600\"),\n\t\t\tAllowIpSans: pulumi.Bool(true),\n\t\t\tKeyType:     pulumi.String(\"rsa\"),\n\t\t\tKeyBits:     pulumi.Int(4096),\n\t\t\tAllowedDomains: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"example.com\"),\n\t\t\t\tpulumi.String(\"my.domain\"),\n\t\t\t},\n\t\t\tAllowSubdomains: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nPKI secret backend roles can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:pkiSecret/secretBackendRole:SecretBackendRole role pki/roles/my_role\n```\n\n ",
            "properties": {
                "allowAnyName": {
                    "type": "boolean",
                    "description": "Flag to allow any name\n"
                },
                "allowBareDomains": {
                    "type": "boolean",
                    "description": "Flag to allow certificates matching the actual domain\n"
                },
                "allowGlobDomains": {
                    "type": "boolean",
                    "description": "Flag to allow names containing glob patterns.\n"
                },
                "allowIpSans": {
                    "type": "boolean",
                    "description": "Flag to allow IP SANs\n"
                },
                "allowLocalhost": {
                    "type": "boolean",
                    "description": "Flag to allow certificates for localhost\n"
                },
                "allowSubdomains": {
                    "type": "boolean",
                    "description": "Flag to allow certificates matching subdomains\n"
                },
                "allowedDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of allowed domains for certificates\n"
                },
                "allowedDomainsTemplate": {
                    "type": "boolean",
                    "description": "Flag, if set, `allowed_domains` can be specified using identity template expressions such as `{{identity.entity.aliases.\u003cmount accessor\u003e.name}}`.\n"
                },
                "allowedOtherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Defines allowed custom SANs\n"
                },
                "allowedUriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Defines allowed URI SANs\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "basicConstraintsValidForNonCa": {
                    "type": "boolean",
                    "description": "Flag to mark basic constraints valid when issuing non-CA certificates\n"
                },
                "clientFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for client use\n"
                },
                "codeSigningFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for code signing use\n"
                },
                "countries": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The country of generated certificates\n"
                },
                "emailProtectionFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for email protection use\n"
                },
                "enforceHostnames": {
                    "type": "boolean",
                    "description": "Flag to allow only valid host names\n"
                },
                "extKeyUsages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify the allowed extended key usage constraint on issued certificates\n"
                },
                "generateLease": {
                    "type": "boolean",
                    "description": "Flag to generate leases with certificates\n"
                },
                "keyBits": {
                    "type": "integer",
                    "description": "The number of bits of generated keys\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "The type of generated keys\n"
                },
                "keyUsages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify the allowed key usage constraint on issued certificates\n"
                },
                "localities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The locality of generated certificates\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "The maximum TTL\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this role within the backend. Must be unique within the backend.\n"
                },
                "noStore": {
                    "type": "boolean",
                    "description": "Flag to not store certificates in the storage backend\n"
                },
                "notBeforeDuration": {
                    "type": "string",
                    "description": "Specifies the duration by which to backdate the NotBefore property.\n"
                },
                "organizationUnit": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The organization unit of generated certificates\n"
                },
                "organizations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The organization of generated certificates\n"
                },
                "policyIdentifiers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify the list of allowed policies IODs\n"
                },
                "postalCodes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The postal code of generated certificates\n"
                },
                "provinces": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The province of generated certificates\n"
                },
                "requireCn": {
                    "type": "boolean",
                    "description": "Flag to force CN usage\n"
                },
                "serverFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for server use\n"
                },
                "streetAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The street address of generated certificates\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "The TTL\n"
                },
                "useCsrCommonName": {
                    "type": "boolean",
                    "description": "Flag to use the CN in the CSR\n"
                },
                "useCsrSans": {
                    "type": "boolean",
                    "description": "Flag to use the SANs in the CSR\n"
                }
            },
            "required": [
                "backend",
                "name",
                "notBeforeDuration"
            ],
            "inputProperties": {
                "allowAnyName": {
                    "type": "boolean",
                    "description": "Flag to allow any name\n"
                },
                "allowBareDomains": {
                    "type": "boolean",
                    "description": "Flag to allow certificates matching the actual domain\n"
                },
                "allowGlobDomains": {
                    "type": "boolean",
                    "description": "Flag to allow names containing glob patterns.\n"
                },
                "allowIpSans": {
                    "type": "boolean",
                    "description": "Flag to allow IP SANs\n"
                },
                "allowLocalhost": {
                    "type": "boolean",
                    "description": "Flag to allow certificates for localhost\n"
                },
                "allowSubdomains": {
                    "type": "boolean",
                    "description": "Flag to allow certificates matching subdomains\n"
                },
                "allowedDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of allowed domains for certificates\n"
                },
                "allowedDomainsTemplate": {
                    "type": "boolean",
                    "description": "Flag, if set, `allowed_domains` can be specified using identity template expressions such as `{{identity.entity.aliases.\u003cmount accessor\u003e.name}}`.\n"
                },
                "allowedOtherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Defines allowed custom SANs\n"
                },
                "allowedUriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Defines allowed URI SANs\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "basicConstraintsValidForNonCa": {
                    "type": "boolean",
                    "description": "Flag to mark basic constraints valid when issuing non-CA certificates\n"
                },
                "clientFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for client use\n"
                },
                "codeSigningFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for code signing use\n"
                },
                "countries": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The country of generated certificates\n"
                },
                "emailProtectionFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for email protection use\n"
                },
                "enforceHostnames": {
                    "type": "boolean",
                    "description": "Flag to allow only valid host names\n"
                },
                "extKeyUsages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify the allowed extended key usage constraint on issued certificates\n"
                },
                "generateLease": {
                    "type": "boolean",
                    "description": "Flag to generate leases with certificates\n"
                },
                "keyBits": {
                    "type": "integer",
                    "description": "The number of bits of generated keys\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "The type of generated keys\n"
                },
                "keyUsages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify the allowed key usage constraint on issued certificates\n"
                },
                "localities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The locality of generated certificates\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "The maximum TTL\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this role within the backend. Must be unique within the backend.\n"
                },
                "noStore": {
                    "type": "boolean",
                    "description": "Flag to not store certificates in the storage backend\n"
                },
                "notBeforeDuration": {
                    "type": "string",
                    "description": "Specifies the duration by which to backdate the NotBefore property.\n"
                },
                "organizationUnit": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The organization unit of generated certificates\n"
                },
                "organizations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The organization of generated certificates\n"
                },
                "policyIdentifiers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify the list of allowed policies IODs\n"
                },
                "postalCodes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The postal code of generated certificates\n"
                },
                "provinces": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The province of generated certificates\n"
                },
                "requireCn": {
                    "type": "boolean",
                    "description": "Flag to force CN usage\n"
                },
                "serverFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for server use\n"
                },
                "streetAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The street address of generated certificates\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "The TTL\n"
                },
                "useCsrCommonName": {
                    "type": "boolean",
                    "description": "Flag to use the CN in the CSR\n"
                },
                "useCsrSans": {
                    "type": "boolean",
                    "description": "Flag to use the SANs in the CSR\n"
                }
            },
            "requiredInputs": [
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRole resources.\n",
                "properties": {
                    "allowAnyName": {
                        "type": "boolean",
                        "description": "Flag to allow any name\n"
                    },
                    "allowBareDomains": {
                        "type": "boolean",
                        "description": "Flag to allow certificates matching the actual domain\n"
                    },
                    "allowGlobDomains": {
                        "type": "boolean",
                        "description": "Flag to allow names containing glob patterns.\n"
                    },
                    "allowIpSans": {
                        "type": "boolean",
                        "description": "Flag to allow IP SANs\n"
                    },
                    "allowLocalhost": {
                        "type": "boolean",
                        "description": "Flag to allow certificates for localhost\n"
                    },
                    "allowSubdomains": {
                        "type": "boolean",
                        "description": "Flag to allow certificates matching subdomains\n"
                    },
                    "allowedDomains": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of allowed domains for certificates\n"
                    },
                    "allowedDomainsTemplate": {
                        "type": "boolean",
                        "description": "Flag, if set, `allowed_domains` can be specified using identity template expressions such as `{{identity.entity.aliases.\u003cmount accessor\u003e.name}}`.\n"
                    },
                    "allowedOtherSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Defines allowed custom SANs\n"
                    },
                    "allowedUriSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Defines allowed URI SANs\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                    },
                    "basicConstraintsValidForNonCa": {
                        "type": "boolean",
                        "description": "Flag to mark basic constraints valid when issuing non-CA certificates\n"
                    },
                    "clientFlag": {
                        "type": "boolean",
                        "description": "Flag to specify certificates for client use\n"
                    },
                    "codeSigningFlag": {
                        "type": "boolean",
                        "description": "Flag to specify certificates for code signing use\n"
                    },
                    "countries": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The country of generated certificates\n"
                    },
                    "emailProtectionFlag": {
                        "type": "boolean",
                        "description": "Flag to specify certificates for email protection use\n"
                    },
                    "enforceHostnames": {
                        "type": "boolean",
                        "description": "Flag to allow only valid host names\n"
                    },
                    "extKeyUsages": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specify the allowed extended key usage constraint on issued certificates\n"
                    },
                    "generateLease": {
                        "type": "boolean",
                        "description": "Flag to generate leases with certificates\n"
                    },
                    "keyBits": {
                        "type": "integer",
                        "description": "The number of bits of generated keys\n"
                    },
                    "keyType": {
                        "type": "string",
                        "description": "The type of generated keys\n"
                    },
                    "keyUsages": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specify the allowed key usage constraint on issued certificates\n"
                    },
                    "localities": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The locality of generated certificates\n"
                    },
                    "maxTtl": {
                        "type": "string",
                        "description": "The maximum TTL\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name to identify this role within the backend. Must be unique within the backend.\n"
                    },
                    "noStore": {
                        "type": "boolean",
                        "description": "Flag to not store certificates in the storage backend\n"
                    },
                    "notBeforeDuration": {
                        "type": "string",
                        "description": "Specifies the duration by which to backdate the NotBefore property.\n"
                    },
                    "organizationUnit": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The organization unit of generated certificates\n"
                    },
                    "organizations": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The organization of generated certificates\n"
                    },
                    "policyIdentifiers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specify the list of allowed policies IODs\n"
                    },
                    "postalCodes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The postal code of generated certificates\n"
                    },
                    "provinces": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The province of generated certificates\n"
                    },
                    "requireCn": {
                        "type": "boolean",
                        "description": "Flag to force CN usage\n"
                    },
                    "serverFlag": {
                        "type": "boolean",
                        "description": "Flag to specify certificates for server use\n"
                    },
                    "streetAddresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The street address of generated certificates\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "The TTL\n"
                    },
                    "useCsrCommonName": {
                        "type": "boolean",
                        "description": "Flag to use the CN in the CSR\n"
                    },
                    "useCsrSans": {
                        "type": "boolean",
                        "description": "Flag to use the SANs in the CSR\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendRootCert:SecretBackendRootCert": {
            "properties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The certificate\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of intermediate to create\n"
                },
                "country": {
                    "type": "string",
                    "description": "The country\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "issuingCa": {
                    "type": "string",
                    "description": "The issuing CA\n"
                },
                "keyBits": {
                    "type": "integer",
                    "description": "The number of bits to use\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "The desired key type\n"
                },
                "locality": {
                    "type": "string",
                    "description": "The locality\n"
                },
                "maxPathLength": {
                    "type": "integer",
                    "description": "The maximum path length to encode in the generated certificate\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "ou": {
                    "type": "string",
                    "description": "The organization unit\n"
                },
                "permittedDnsDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of domains for which certificates are allowed to be issued\n"
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code\n"
                },
                "privateKeyFormat": {
                    "type": "string",
                    "description": "The private key format\n"
                },
                "province": {
                    "type": "string",
                    "description": "The province\n"
                },
                "serial": {
                    "type": "string",
                    "description": "The serial\n"
                },
                "streetAddress": {
                    "type": "string",
                    "description": "The street address\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of intermediate to create. Must be either \\\"exported\\\" or \\\"internal\\\"\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n"
                }
            },
            "required": [
                "backend",
                "certificate",
                "commonName",
                "issuingCa",
                "serial",
                "type"
            ],
            "inputProperties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of intermediate to create\n"
                },
                "country": {
                    "type": "string",
                    "description": "The country\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "keyBits": {
                    "type": "integer",
                    "description": "The number of bits to use\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "The desired key type\n"
                },
                "locality": {
                    "type": "string",
                    "description": "The locality\n"
                },
                "maxPathLength": {
                    "type": "integer",
                    "description": "The maximum path length to encode in the generated certificate\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "ou": {
                    "type": "string",
                    "description": "The organization unit\n"
                },
                "permittedDnsDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of domains for which certificates are allowed to be issued\n"
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code\n"
                },
                "privateKeyFormat": {
                    "type": "string",
                    "description": "The private key format\n"
                },
                "province": {
                    "type": "string",
                    "description": "The province\n"
                },
                "streetAddress": {
                    "type": "string",
                    "description": "The street address\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of intermediate to create. Must be either \\\"exported\\\" or \\\"internal\\\"\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n"
                }
            },
            "requiredInputs": [
                "backend",
                "commonName",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRootCert resources.\n",
                "properties": {
                    "altNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative names\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The PKI secret backend the resource belongs to.\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "The certificate\n"
                    },
                    "commonName": {
                        "type": "string",
                        "description": "CN of intermediate to create\n"
                    },
                    "country": {
                        "type": "string",
                        "description": "The country\n"
                    },
                    "excludeCnFromSans": {
                        "type": "boolean",
                        "description": "Flag to exclude CN from SANs\n"
                    },
                    "format": {
                        "type": "string",
                        "description": "The format of data\n"
                    },
                    "ipSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative IPs\n"
                    },
                    "issuingCa": {
                        "type": "string",
                        "description": "The issuing CA\n"
                    },
                    "keyBits": {
                        "type": "integer",
                        "description": "The number of bits to use\n"
                    },
                    "keyType": {
                        "type": "string",
                        "description": "The desired key type\n"
                    },
                    "locality": {
                        "type": "string",
                        "description": "The locality\n"
                    },
                    "maxPathLength": {
                        "type": "integer",
                        "description": "The maximum path length to encode in the generated certificate\n"
                    },
                    "organization": {
                        "type": "string",
                        "description": "The organization\n"
                    },
                    "otherSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of other SANs\n"
                    },
                    "ou": {
                        "type": "string",
                        "description": "The organization unit\n"
                    },
                    "permittedDnsDomains": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of domains for which certificates are allowed to be issued\n"
                    },
                    "postalCode": {
                        "type": "string",
                        "description": "The postal code\n"
                    },
                    "privateKeyFormat": {
                        "type": "string",
                        "description": "The private key format\n"
                    },
                    "province": {
                        "type": "string",
                        "description": "The province\n"
                    },
                    "serial": {
                        "type": "string",
                        "description": "The serial\n"
                    },
                    "streetAddress": {
                        "type": "string",
                        "description": "The street address\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Time to live\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of intermediate to create. Must be either \\\"exported\\\" or \\\"internal\\\"\n"
                    },
                    "uriSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative URIs\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendRootSignIntermediate:SecretBackendRootSignIntermediate": {
            "description": "Creates PKI certificate.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst root = new vault.pkisecret.SecretBackendRootSignIntermediate(\"root\", {\n    backend: vault_mount.root.path,\n    csr: vault_pki_secret_backend_intermediate_cert_request.intermediate.csr,\n    commonName: \"Intermediate CA\",\n    excludeCnFromSans: true,\n    ou: \"My OU\",\n    organization: \"My organization\",\n}, {\n    dependsOn: [vault_pki_secret_backend_intermediate_cert_request.intermediate],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nroot = vault.pki_secret.SecretBackendRootSignIntermediate(\"root\",\n    backend=vault_mount[\"root\"][\"path\"],\n    csr=vault_pki_secret_backend_intermediate_cert_request[\"intermediate\"][\"csr\"],\n    common_name=\"Intermediate CA\",\n    exclude_cn_from_sans=True,\n    ou=\"My OU\",\n    organization=\"My organization\",\n    opts=pulumi.ResourceOptions(depends_on=[vault_pki_secret_backend_intermediate_cert_request[\"intermediate\"]]))\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var root = new Vault.PkiSecret.SecretBackendRootSignIntermediate(\"root\", new Vault.PkiSecret.SecretBackendRootSignIntermediateArgs\n        {\n            Backend = vault_mount.Root.Path,\n            Csr = vault_pki_secret_backend_intermediate_cert_request.Intermediate.Csr,\n            CommonName = \"Intermediate CA\",\n            ExcludeCnFromSans = true,\n            Ou = \"My OU\",\n            Organization = \"My organization\",\n        }, new CustomResourceOptions\n        {\n            DependsOn = \n            {\n                vault_pki_secret_backend_intermediate_cert_request.Intermediate,\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/pkiSecret\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := pkiSecret.NewSecretBackendRootSignIntermediate(ctx, \"root\", \u0026pkiSecret.SecretBackendRootSignIntermediateArgs{\n\t\t\tBackend:           pulumi.Any(vault_mount.Root.Path),\n\t\t\tCsr:               pulumi.Any(vault_pki_secret_backend_intermediate_cert_request.Intermediate.Csr),\n\t\t\tCommonName:        pulumi.String(\"Intermediate CA\"),\n\t\t\tExcludeCnFromSans: pulumi.Bool(true),\n\t\t\tOu:                pulumi.String(\"My OU\"),\n\t\t\tOrganization:      pulumi.String(\"My organization\"),\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\tvault_pki_secret_backend_intermediate_cert_request.Intermediate,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "caChains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of the issuing and intermediate CA certificates in the `format` specified.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The intermediate CA certificate in the `format` specified.\n"
                },
                "certificateBundle": {
                    "type": "string",
                    "description": "The concatenation of the intermediate CA and the issuing CA certificates (PEM encoded). \nRequires the `format` to be set to any of: pem, pem_bundle. The value will be empty for all other formats.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of intermediate to create\n"
                },
                "country": {
                    "type": "string",
                    "description": "The country\n"
                },
                "csr": {
                    "type": "string",
                    "description": "The CSR\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "issuingCa": {
                    "type": "string",
                    "description": "The issuing CA certificate in the `format` specified.\n"
                },
                "locality": {
                    "type": "string",
                    "description": "The locality\n"
                },
                "maxPathLength": {
                    "type": "integer",
                    "description": "The maximum path length to encode in the generated certificate\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "ou": {
                    "type": "string",
                    "description": "The organization unit\n"
                },
                "permittedDnsDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of domains for which certificates are allowed to be issued\n"
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code\n"
                },
                "province": {
                    "type": "string",
                    "description": "The province\n"
                },
                "serial": {
                    "type": "string",
                    "description": "The serial\n"
                },
                "streetAddress": {
                    "type": "string",
                    "description": "The street address\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n"
                },
                "useCsrValues": {
                    "type": "boolean",
                    "description": "Preserve CSR values\n"
                }
            },
            "required": [
                "backend",
                "caChains",
                "certificate",
                "certificateBundle",
                "commonName",
                "csr",
                "issuingCa",
                "serial"
            ],
            "inputProperties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of intermediate to create\n"
                },
                "country": {
                    "type": "string",
                    "description": "The country\n"
                },
                "csr": {
                    "type": "string",
                    "description": "The CSR\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "locality": {
                    "type": "string",
                    "description": "The locality\n"
                },
                "maxPathLength": {
                    "type": "integer",
                    "description": "The maximum path length to encode in the generated certificate\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "ou": {
                    "type": "string",
                    "description": "The organization unit\n"
                },
                "permittedDnsDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of domains for which certificates are allowed to be issued\n"
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code\n"
                },
                "province": {
                    "type": "string",
                    "description": "The province\n"
                },
                "streetAddress": {
                    "type": "string",
                    "description": "The street address\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n"
                },
                "useCsrValues": {
                    "type": "boolean",
                    "description": "Preserve CSR values\n"
                }
            },
            "requiredInputs": [
                "backend",
                "commonName",
                "csr"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRootSignIntermediate resources.\n",
                "properties": {
                    "altNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative names\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The PKI secret backend the resource belongs to.\n"
                    },
                    "caChains": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of the issuing and intermediate CA certificates in the `format` specified.\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "The intermediate CA certificate in the `format` specified.\n"
                    },
                    "certificateBundle": {
                        "type": "string",
                        "description": "The concatenation of the intermediate CA and the issuing CA certificates (PEM encoded). \nRequires the `format` to be set to any of: pem, pem_bundle. The value will be empty for all other formats.\n"
                    },
                    "commonName": {
                        "type": "string",
                        "description": "CN of intermediate to create\n"
                    },
                    "country": {
                        "type": "string",
                        "description": "The country\n"
                    },
                    "csr": {
                        "type": "string",
                        "description": "The CSR\n"
                    },
                    "excludeCnFromSans": {
                        "type": "boolean",
                        "description": "Flag to exclude CN from SANs\n"
                    },
                    "format": {
                        "type": "string",
                        "description": "The format of data\n"
                    },
                    "ipSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative IPs\n"
                    },
                    "issuingCa": {
                        "type": "string",
                        "description": "The issuing CA certificate in the `format` specified.\n"
                    },
                    "locality": {
                        "type": "string",
                        "description": "The locality\n"
                    },
                    "maxPathLength": {
                        "type": "integer",
                        "description": "The maximum path length to encode in the generated certificate\n"
                    },
                    "organization": {
                        "type": "string",
                        "description": "The organization\n"
                    },
                    "otherSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of other SANs\n"
                    },
                    "ou": {
                        "type": "string",
                        "description": "The organization unit\n"
                    },
                    "permittedDnsDomains": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of domains for which certificates are allowed to be issued\n"
                    },
                    "postalCode": {
                        "type": "string",
                        "description": "The postal code\n"
                    },
                    "province": {
                        "type": "string",
                        "description": "The province\n"
                    },
                    "serial": {
                        "type": "string",
                        "description": "The serial\n"
                    },
                    "streetAddress": {
                        "type": "string",
                        "description": "The street address\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Time to live\n"
                    },
                    "uriSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative URIs\n"
                    },
                    "useCsrValues": {
                        "type": "boolean",
                        "description": "Preserve CSR values\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendSign:SecretBackendSign": {
            "properties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "autoRenew": {
                    "type": "boolean",
                    "description": "If set to `true`, certs will be renewed if the expiration is within `min_seconds_remaining`. Default `false`\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "caChains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The CA chain\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The certificate\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of certificate to create\n"
                },
                "csr": {
                    "type": "string",
                    "description": "The CSR\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "expiration": {
                    "type": "integer",
                    "description": "The expiration date of the certificate in unix epoch format\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "issuingCa": {
                    "type": "string",
                    "description": "The issuing CA\n"
                },
                "minSecondsRemaining": {
                    "type": "integer",
                    "description": "Generate a new certificate when the expiration is within this number of seconds, default is 604800 (7 days)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the role to create the certificate against\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "serial": {
                    "type": "string",
                    "description": "The serial\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alterative URIs\n"
                }
            },
            "required": [
                "backend",
                "caChains",
                "certificate",
                "commonName",
                "csr",
                "expiration",
                "issuingCa",
                "name",
                "serial"
            ],
            "inputProperties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "autoRenew": {
                    "type": "boolean",
                    "description": "If set to `true`, certs will be renewed if the expiration is within `min_seconds_remaining`. Default `false`\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of certificate to create\n"
                },
                "csr": {
                    "type": "string",
                    "description": "The CSR\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "minSecondsRemaining": {
                    "type": "integer",
                    "description": "Generate a new certificate when the expiration is within this number of seconds, default is 604800 (7 days)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the role to create the certificate against\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alterative URIs\n"
                }
            },
            "requiredInputs": [
                "backend",
                "commonName",
                "csr"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendSign resources.\n",
                "properties": {
                    "altNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative names\n"
                    },
                    "autoRenew": {
                        "type": "boolean",
                        "description": "If set to `true`, certs will be renewed if the expiration is within `min_seconds_remaining`. Default `false`\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The PKI secret backend the resource belongs to.\n"
                    },
                    "caChains": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The CA chain\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "The certificate\n"
                    },
                    "commonName": {
                        "type": "string",
                        "description": "CN of certificate to create\n"
                    },
                    "csr": {
                        "type": "string",
                        "description": "The CSR\n"
                    },
                    "excludeCnFromSans": {
                        "type": "boolean",
                        "description": "Flag to exclude CN from SANs\n"
                    },
                    "expiration": {
                        "type": "integer",
                        "description": "The expiration date of the certificate in unix epoch format\n"
                    },
                    "format": {
                        "type": "string",
                        "description": "The format of data\n"
                    },
                    "ipSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative IPs\n"
                    },
                    "issuingCa": {
                        "type": "string",
                        "description": "The issuing CA\n"
                    },
                    "minSecondsRemaining": {
                        "type": "integer",
                        "description": "Generate a new certificate when the expiration is within this number of seconds, default is 604800 (7 days)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the role to create the certificate against\n"
                    },
                    "otherSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of other SANs\n"
                    },
                    "serial": {
                        "type": "string",
                        "description": "The serial\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Time to live\n"
                    },
                    "uriSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alterative URIs\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:rabbitMq/secretBackend:SecretBackend": {
            "description": "\n\n\n## Import\n\nRabbitMQ secret backends can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:rabbitMq/secretBackend:SecretBackend rabbitmq rabbitmq\n```\n\n ",
            "properties": {
                "connectionUri": {
                    "type": "string",
                    "description": "Specifies the RabbitMQ connection URI.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials\nissued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Specifies the RabbitMQ management administrator password.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `rabbitmq`.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Specifies the RabbitMQ management administrator username.\n"
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Specifies whether to verify connection URI, username, and password.\nDefaults to `true`.\n"
                }
            },
            "required": [
                "connectionUri",
                "defaultLeaseTtlSeconds",
                "maxLeaseTtlSeconds",
                "password",
                "username"
            ],
            "inputProperties": {
                "connectionUri": {
                    "type": "string",
                    "description": "Specifies the RabbitMQ connection URI.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials\nissued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Specifies the RabbitMQ management administrator password.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `rabbitmq`.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Specifies the RabbitMQ management administrator username.\n"
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Specifies whether to verify connection URI, username, and password.\nDefaults to `true`.\n"
                }
            },
            "requiredInputs": [
                "connectionUri",
                "password",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackend resources.\n",
                "properties": {
                    "connectionUri": {
                        "type": "string",
                        "description": "Specifies the RabbitMQ connection URI.\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The default TTL for credentials\nissued by this backend.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A human-friendly description for this backend.\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "Specifies the RabbitMQ management administrator password.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `rabbitmq`.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Specifies the RabbitMQ management administrator username.\n"
                    },
                    "verifyConnection": {
                        "type": "boolean",
                        "description": "Specifies whether to verify connection URI, username, and password.\nDefaults to `true`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:rabbitMq/secretBackendRole:SecretBackendRole": {
            "description": "\n\n\n## Import\n\nRabbitMQ secret backend roles can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:rabbitMq/secretBackendRole:SecretBackendRole role rabbitmq/roles/deploy\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path the RabbitMQ secret backend is mounted at,\nwith no leading or trailing `/`s.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n"
                },
                "tags": {
                    "type": "string",
                    "description": "Specifies a comma-separated RabbitMQ management tags.\n"
                },
                "vhostTopics": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:rabbitMq/SecretBackendRoleVhostTopic:SecretBackendRoleVhostTopic"
                    },
                    "description": "Specifies a map of virtual hosts and exchanges to topic permissions. This option requires RabbitMQ 3.7.0 or later.\n"
                },
                "vhosts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:rabbitMq/SecretBackendRoleVhost:SecretBackendRoleVhost"
                    },
                    "description": "Specifies a map of virtual hosts to permissions.\n"
                }
            },
            "required": [
                "backend",
                "name"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path the RabbitMQ secret backend is mounted at,\nwith no leading or trailing `/`s.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n"
                },
                "tags": {
                    "type": "string",
                    "description": "Specifies a comma-separated RabbitMQ management tags.\n"
                },
                "vhostTopics": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:rabbitMq/SecretBackendRoleVhostTopic:SecretBackendRoleVhostTopic"
                    },
                    "description": "Specifies a map of virtual hosts and exchanges to topic permissions. This option requires RabbitMQ 3.7.0 or later.\n"
                },
                "vhosts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:rabbitMq/SecretBackendRoleVhost:SecretBackendRoleVhost"
                    },
                    "description": "Specifies a map of virtual hosts to permissions.\n"
                }
            },
            "requiredInputs": [
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the RabbitMQ secret backend is mounted at,\nwith no leading or trailing `/`s.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n"
                    },
                    "tags": {
                        "type": "string",
                        "description": "Specifies a comma-separated RabbitMQ management tags.\n"
                    },
                    "vhostTopics": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:rabbitMq/SecretBackendRoleVhostTopic:SecretBackendRoleVhostTopic"
                        },
                        "description": "Specifies a map of virtual hosts and exchanges to topic permissions. This option requires RabbitMQ 3.7.0 or later.\n"
                    },
                    "vhosts": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:rabbitMq/SecretBackendRoleVhost:SecretBackendRoleVhost"
                        },
                        "description": "Specifies a map of virtual hosts to permissions.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:ssh/secretBackendCa:SecretBackendCa": {
            "description": "Provides a resource to manage CA information in an SSH secret backend\n[SSH secret backend within Vault](https://www.vaultproject.io/docs/secrets/ssh/index.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.Mount(\"example\", {type: \"ssh\"});\nconst foo = new vault.ssh.SecretBackendCa(\"foo\", {backend: example.path});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.Mount(\"example\", type=\"ssh\")\nfoo = vault.ssh.SecretBackendCa(\"foo\", backend=example.path)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.Mount(\"example\", new Vault.MountArgs\n        {\n            Type = \"ssh\",\n        });\n        var foo = new Vault.Ssh.SecretBackendCa(\"foo\", new Vault.Ssh.SecretBackendCaArgs\n        {\n            Backend = example.Path,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/ssh\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := vault.NewMount(ctx, \"example\", \u0026vault.MountArgs{\n\t\t\tType: pulumi.String(\"ssh\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ssh.NewSecretBackendCa(ctx, \"foo\", \u0026ssh.SecretBackendCaArgs{\n\t\t\tBackend: example.Path,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path where the SSH secret backend is mounted. Defaults to 'ssh'\n"
                },
                "generateSigningKey": {
                    "type": "boolean",
                    "description": "Whether Vault should generate the signing key pair internally. Defaults to true\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "The private key part the SSH CA key pair; required if generate_signing_key is false.\n"
                },
                "publicKey": {
                    "type": "string",
                    "description": "The public key part the SSH CA key pair; required if generate_signing_key is false.\n"
                }
            },
            "required": [
                "privateKey",
                "publicKey"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path where the SSH secret backend is mounted. Defaults to 'ssh'\n"
                },
                "generateSigningKey": {
                    "type": "boolean",
                    "description": "Whether Vault should generate the signing key pair internally. Defaults to true\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "The private key part the SSH CA key pair; required if generate_signing_key is false.\n"
                },
                "publicKey": {
                    "type": "string",
                    "description": "The public key part the SSH CA key pair; required if generate_signing_key is false.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendCa resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path where the SSH secret backend is mounted. Defaults to 'ssh'\n"
                    },
                    "generateSigningKey": {
                        "type": "boolean",
                        "description": "Whether Vault should generate the signing key pair internally. Defaults to true\n"
                    },
                    "privateKey": {
                        "type": "string",
                        "description": "The private key part the SSH CA key pair; required if generate_signing_key is false.\n"
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "The public key part the SSH CA key pair; required if generate_signing_key is false.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:ssh/secretBackendRole:SecretBackendRole": {
            "description": "Provides a resource to manage roles in an SSH secret backend\n[SSH secret backend within Vault](https://www.vaultproject.io/docs/secrets/ssh/index.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.Mount(\"example\", {type: \"ssh\"});\nconst foo = new vault.ssh.SecretBackendRole(\"foo\", {\n    backend: example.path,\n    keyType: \"ca\",\n    allowUserCertificates: true,\n});\nconst bar = new vault.ssh.SecretBackendRole(\"bar\", {\n    backend: example.path,\n    keyType: \"otp\",\n    defaultUser: \"default\",\n    allowedUsers: \"default,baz\",\n    cidrList: \"0.0.0.0/0\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.Mount(\"example\", type=\"ssh\")\nfoo = vault.ssh.SecretBackendRole(\"foo\",\n    backend=example.path,\n    key_type=\"ca\",\n    allow_user_certificates=True)\nbar = vault.ssh.SecretBackendRole(\"bar\",\n    backend=example.path,\n    key_type=\"otp\",\n    default_user=\"default\",\n    allowed_users=\"default,baz\",\n    cidr_list=\"0.0.0.0/0\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.Mount(\"example\", new Vault.MountArgs\n        {\n            Type = \"ssh\",\n        });\n        var foo = new Vault.Ssh.SecretBackendRole(\"foo\", new Vault.Ssh.SecretBackendRoleArgs\n        {\n            Backend = example.Path,\n            KeyType = \"ca\",\n            AllowUserCertificates = true,\n        });\n        var bar = new Vault.Ssh.SecretBackendRole(\"bar\", new Vault.Ssh.SecretBackendRoleArgs\n        {\n            Backend = example.Path,\n            KeyType = \"otp\",\n            DefaultUser = \"default\",\n            AllowedUsers = \"default,baz\",\n            CidrList = \"0.0.0.0/0\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/ssh\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := vault.NewMount(ctx, \"example\", \u0026vault.MountArgs{\n\t\t\tType: pulumi.String(\"ssh\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ssh.NewSecretBackendRole(ctx, \"foo\", \u0026ssh.SecretBackendRoleArgs{\n\t\t\tBackend:               example.Path,\n\t\t\tKeyType:               pulumi.String(\"ca\"),\n\t\t\tAllowUserCertificates: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ssh.NewSecretBackendRole(ctx, \"bar\", \u0026ssh.SecretBackendRoleArgs{\n\t\t\tBackend:      example.Path,\n\t\t\tKeyType:      pulumi.String(\"otp\"),\n\t\t\tDefaultUser:  pulumi.String(\"default\"),\n\t\t\tAllowedUsers: pulumi.String(\"default,baz\"),\n\t\t\tCidrList:     pulumi.String(\"0.0.0.0/0\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nSSH secret backend roles can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:ssh/secretBackendRole:SecretBackendRole foo ssh/roles/my-role\n```\n\n ",
            "properties": {
                "algorithmSigner": {
                    "type": "string",
                    "description": "When supplied, this value specifies a signing algorithm for the key. Possible values: ssh-rsa, rsa-sha2-256, rsa-sha2-512.\n"
                },
                "allowBareDomains": {
                    "type": "boolean",
                    "description": "Specifies if host certificates that are requested are allowed to use the base domains listed in `allowed_domains`.\n"
                },
                "allowHostCertificates": {
                    "type": "boolean",
                    "description": "Specifies if certificates are allowed to be signed for use as a 'host'.\n"
                },
                "allowSubdomains": {
                    "type": "boolean",
                    "description": "Specifies if host certificates that are requested are allowed to be subdomains of those listed in `allowed_domains`.\n"
                },
                "allowUserCertificates": {
                    "type": "boolean",
                    "description": "Specifies if certificates are allowed to be signed for use as a 'user'.\n"
                },
                "allowUserKeyIds": {
                    "type": "boolean",
                    "description": "Specifies if users can override the key ID for a signed certificate with the `key_id` field.\n"
                },
                "allowedCriticalOptions": {
                    "type": "string",
                    "description": "Specifies a comma-separated list of critical options that certificates can have when signed.\n"
                },
                "allowedDomains": {
                    "type": "string",
                    "description": "The list of domains for which a client can request a host certificate.\n"
                },
                "allowedExtensions": {
                    "type": "string",
                    "description": "Specifies a comma-separated list of extensions that certificates can have when signed.\n"
                },
                "allowedUserKeyLengths": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies a map of ssh key types and their expected sizes which are allowed to be signed by the CA type.\n"
                },
                "allowedUsers": {
                    "type": "string",
                    "description": "Specifies a comma-separated list of usernames that are to be allowed, only if certain usernames are to be allowed.\n"
                },
                "allowedUsersTemplate": {
                    "type": "boolean",
                    "description": "Specifies if `allowed_users` can be declared using identity template policies. Non-templated users are also permitted.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path where the SSH secret backend is mounted.\n"
                },
                "cidrList": {
                    "type": "string",
                    "description": "The comma-separated string of CIDR blocks for which this role is applicable.\n"
                },
                "defaultCriticalOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies a map of critical options that certificates have when signed.\n"
                },
                "defaultExtensions": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies a map of extensions that certificates have when signed.\n"
                },
                "defaultUser": {
                    "type": "string",
                    "description": "Specifies the default username for which a credential will be generated.\n"
                },
                "keyIdFormat": {
                    "type": "string",
                    "description": "Specifies a custom format for the key id of a signed certificate.\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "Specifies the type of credentials generated by this role. This can be either `otp`, `dynamic` or `ca`.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Specifies the maximum Time To Live value.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the role to create.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Specifies the Time To Live value.\n"
                }
            },
            "required": [
                "algorithmSigner",
                "backend",
                "keyType",
                "maxTtl",
                "name",
                "ttl"
            ],
            "inputProperties": {
                "algorithmSigner": {
                    "type": "string",
                    "description": "When supplied, this value specifies a signing algorithm for the key. Possible values: ssh-rsa, rsa-sha2-256, rsa-sha2-512.\n"
                },
                "allowBareDomains": {
                    "type": "boolean",
                    "description": "Specifies if host certificates that are requested are allowed to use the base domains listed in `allowed_domains`.\n"
                },
                "allowHostCertificates": {
                    "type": "boolean",
                    "description": "Specifies if certificates are allowed to be signed for use as a 'host'.\n"
                },
                "allowSubdomains": {
                    "type": "boolean",
                    "description": "Specifies if host certificates that are requested are allowed to be subdomains of those listed in `allowed_domains`.\n"
                },
                "allowUserCertificates": {
                    "type": "boolean",
                    "description": "Specifies if certificates are allowed to be signed for use as a 'user'.\n"
                },
                "allowUserKeyIds": {
                    "type": "boolean",
                    "description": "Specifies if users can override the key ID for a signed certificate with the `key_id` field.\n"
                },
                "allowedCriticalOptions": {
                    "type": "string",
                    "description": "Specifies a comma-separated list of critical options that certificates can have when signed.\n"
                },
                "allowedDomains": {
                    "type": "string",
                    "description": "The list of domains for which a client can request a host certificate.\n"
                },
                "allowedExtensions": {
                    "type": "string",
                    "description": "Specifies a comma-separated list of extensions that certificates can have when signed.\n"
                },
                "allowedUserKeyLengths": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies a map of ssh key types and their expected sizes which are allowed to be signed by the CA type.\n"
                },
                "allowedUsers": {
                    "type": "string",
                    "description": "Specifies a comma-separated list of usernames that are to be allowed, only if certain usernames are to be allowed.\n"
                },
                "allowedUsersTemplate": {
                    "type": "boolean",
                    "description": "Specifies if `allowed_users` can be declared using identity template policies. Non-templated users are also permitted.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path where the SSH secret backend is mounted.\n"
                },
                "cidrList": {
                    "type": "string",
                    "description": "The comma-separated string of CIDR blocks for which this role is applicable.\n"
                },
                "defaultCriticalOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies a map of critical options that certificates have when signed.\n"
                },
                "defaultExtensions": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies a map of extensions that certificates have when signed.\n"
                },
                "defaultUser": {
                    "type": "string",
                    "description": "Specifies the default username for which a credential will be generated.\n"
                },
                "keyIdFormat": {
                    "type": "string",
                    "description": "Specifies a custom format for the key id of a signed certificate.\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "Specifies the type of credentials generated by this role. This can be either `otp`, `dynamic` or `ca`.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Specifies the maximum Time To Live value.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the role to create.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Specifies the Time To Live value.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "keyType"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRole resources.\n",
                "properties": {
                    "algorithmSigner": {
                        "type": "string",
                        "description": "When supplied, this value specifies a signing algorithm for the key. Possible values: ssh-rsa, rsa-sha2-256, rsa-sha2-512.\n"
                    },
                    "allowBareDomains": {
                        "type": "boolean",
                        "description": "Specifies if host certificates that are requested are allowed to use the base domains listed in `allowed_domains`.\n"
                    },
                    "allowHostCertificates": {
                        "type": "boolean",
                        "description": "Specifies if certificates are allowed to be signed for use as a 'host'.\n"
                    },
                    "allowSubdomains": {
                        "type": "boolean",
                        "description": "Specifies if host certificates that are requested are allowed to be subdomains of those listed in `allowed_domains`.\n"
                    },
                    "allowUserCertificates": {
                        "type": "boolean",
                        "description": "Specifies if certificates are allowed to be signed for use as a 'user'.\n"
                    },
                    "allowUserKeyIds": {
                        "type": "boolean",
                        "description": "Specifies if users can override the key ID for a signed certificate with the `key_id` field.\n"
                    },
                    "allowedCriticalOptions": {
                        "type": "string",
                        "description": "Specifies a comma-separated list of critical options that certificates can have when signed.\n"
                    },
                    "allowedDomains": {
                        "type": "string",
                        "description": "The list of domains for which a client can request a host certificate.\n"
                    },
                    "allowedExtensions": {
                        "type": "string",
                        "description": "Specifies a comma-separated list of extensions that certificates can have when signed.\n"
                    },
                    "allowedUserKeyLengths": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Specifies a map of ssh key types and their expected sizes which are allowed to be signed by the CA type.\n"
                    },
                    "allowedUsers": {
                        "type": "string",
                        "description": "Specifies a comma-separated list of usernames that are to be allowed, only if certain usernames are to be allowed.\n"
                    },
                    "allowedUsersTemplate": {
                        "type": "boolean",
                        "description": "Specifies if `allowed_users` can be declared using identity template policies. Non-templated users are also permitted.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path where the SSH secret backend is mounted.\n"
                    },
                    "cidrList": {
                        "type": "string",
                        "description": "The comma-separated string of CIDR blocks for which this role is applicable.\n"
                    },
                    "defaultCriticalOptions": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Specifies a map of critical options that certificates have when signed.\n"
                    },
                    "defaultExtensions": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Specifies a map of extensions that certificates have when signed.\n"
                    },
                    "defaultUser": {
                        "type": "string",
                        "description": "Specifies the default username for which a credential will be generated.\n"
                    },
                    "keyIdFormat": {
                        "type": "string",
                        "description": "Specifies a custom format for the key id of a signed certificate.\n"
                    },
                    "keyType": {
                        "type": "string",
                        "description": "Specifies the type of credentials generated by this role. This can be either `otp`, `dynamic` or `ca`.\n"
                    },
                    "maxTtl": {
                        "type": "string",
                        "description": "Specifies the maximum Time To Live value.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the name of the role to create.\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Specifies the Time To Live value.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:terraformcloud/secretBackend:SecretBackend": {
            "description": "\n\n\n## Import\n\nTerraform Cloud secret backends can be imported using the `backend`, e.g.\n\n```sh\n $ pulumi import vault:terraformcloud/secretBackend:SecretBackend example terraform\n```\n\n ",
            "properties": {
                "address": {
                    "type": "string",
                    "description": "Specifies the address of the Terraform Cloud instance, provided as \"host:port\" like \"127.0.0.1:8500\".\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Unique name of the Vault Terraform Cloud mount to configure\n"
                },
                "basePath": {
                    "type": "string",
                    "description": "Specifies the base path for the Terraform Cloud or Enterprise API.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials issued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                },
                "token": {
                    "type": "string",
                    "description": "Specifies the Terraform Cloud access token to use.\n"
                }
            },
            "inputProperties": {
                "address": {
                    "type": "string",
                    "description": "Specifies the address of the Terraform Cloud instance, provided as \"host:port\" like \"127.0.0.1:8500\".\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Unique name of the Vault Terraform Cloud mount to configure\n"
                },
                "basePath": {
                    "type": "string",
                    "description": "Specifies the base path for the Terraform Cloud or Enterprise API.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials issued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                },
                "token": {
                    "type": "string",
                    "description": "Specifies the Terraform Cloud access token to use.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackend resources.\n",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "Specifies the address of the Terraform Cloud instance, provided as \"host:port\" like \"127.0.0.1:8500\".\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "Unique name of the Vault Terraform Cloud mount to configure\n"
                    },
                    "basePath": {
                        "type": "string",
                        "description": "Specifies the base path for the Terraform Cloud or Enterprise API.\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The default TTL for credentials issued by this backend.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A human-friendly description for this backend.\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "Specifies the Terraform Cloud access token to use.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:terraformcloud/secretCreds:SecretCreds": {
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Terraform Cloud secret backend to generate tokens from\n"
                },
                "leaseId": {
                    "type": "string",
                    "description": "The lease associated with the token. Only user tokens will have a \nVault lease associated with them.\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization associated with the token provided.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the role.\n"
                },
                "teamId": {
                    "type": "string",
                    "description": "The team id associated with the token provided.\n"
                },
                "token": {
                    "type": "string",
                    "description": "The actual token that was generated and can be used with API calls\nto identify the user of the call.\n"
                },
                "tokenId": {
                    "type": "string",
                    "description": "The public identifier for a specific token. It can be used \nto look up information about a token or to revoke a token.\n"
                }
            },
            "required": [
                "backend",
                "leaseId",
                "organization",
                "role",
                "teamId",
                "token",
                "tokenId"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Terraform Cloud secret backend to generate tokens from\n"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the role.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretCreds resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Terraform Cloud secret backend to generate tokens from\n"
                    },
                    "leaseId": {
                        "type": "string",
                        "description": "The lease associated with the token. Only user tokens will have a \nVault lease associated with them.\n"
                    },
                    "organization": {
                        "type": "string",
                        "description": "The organization associated with the token provided.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "Name of the role.\n"
                    },
                    "teamId": {
                        "type": "string",
                        "description": "The team id associated with the token provided.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "The actual token that was generated and can be used with API calls\nto identify the user of the call.\n"
                    },
                    "tokenId": {
                        "type": "string",
                        "description": "The public identifier for a specific token. It can be used \nto look up information about a token or to revoke a token.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:terraformcloud/secretRole:SecretRole": {
            "description": "\n\n\n## Import\n\nTerraform Cloud secret backend roles can be imported using the `backend`, `/roles/`, and the `name` e.g.\n\n```sh\n $ pulumi import vault:terraformcloud/secretRole:SecretRole example terraform/roles/my-role\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path of the Terraform Cloud Secret Backend the role belongs to.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "Maximum TTL for leases associated with this role, in seconds.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of an existing role against which to create this Terraform Cloud credential\n"
                },
                "organization": {
                    "type": "string",
                    "description": "Name of the Terraform Cloud or Enterprise organization\n"
                },
                "teamId": {
                    "type": "string",
                    "description": "ID of the Terraform Cloud or Enterprise team under organization (e.g., settings/teams/team-xxxxxxxxxxxxx)\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "Specifies the TTL for this role.\n"
                },
                "userId": {
                    "type": "string",
                    "description": "ID of the Terraform Cloud or Enterprise user (e.g., user-xxxxxxxxxxxxxxxx)\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path of the Terraform Cloud Secret Backend the role belongs to.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "Maximum TTL for leases associated with this role, in seconds.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of an existing role against which to create this Terraform Cloud credential\n"
                },
                "organization": {
                    "type": "string",
                    "description": "Name of the Terraform Cloud or Enterprise organization\n"
                },
                "teamId": {
                    "type": "string",
                    "description": "ID of the Terraform Cloud or Enterprise team under organization (e.g., settings/teams/team-xxxxxxxxxxxxx)\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "Specifies the TTL for this role.\n"
                },
                "userId": {
                    "type": "string",
                    "description": "ID of the Terraform Cloud or Enterprise user (e.g., user-xxxxxxxxxxxxxxxx)\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path of the Terraform Cloud Secret Backend the role belongs to.\n"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "Maximum TTL for leases associated with this role, in seconds.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of an existing role against which to create this Terraform Cloud credential\n"
                    },
                    "organization": {
                        "type": "string",
                        "description": "Name of the Terraform Cloud or Enterprise organization\n"
                    },
                    "teamId": {
                        "type": "string",
                        "description": "ID of the Terraform Cloud or Enterprise team under organization (e.g., settings/teams/team-xxxxxxxxxxxxx)\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "Specifies the TTL for this role.\n"
                    },
                    "userId": {
                        "type": "string",
                        "description": "ID of the Terraform Cloud or Enterprise user (e.g., user-xxxxxxxxxxxxxxxx)\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:tokenauth/authBackendRole:AuthBackendRole": {
            "description": "Manages Token auth backend role in a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/token.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.tokenauth.AuthBackendRole(\"example\", {\n    allowedEntityAliases: [\"test_entity\"],\n    allowedPolicies: [\n        \"dev\",\n        \"test\",\n    ],\n    disallowedPolicies: [\"default\"],\n    explicitMaxTtl: \"115200\",\n    orphan: true,\n    pathSuffix: \"path-suffix\",\n    renewable: true,\n    roleName: \"my-role\",\n    tokenPeriod: 86400,\n});\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nToken auth backend roles can be imported with `auth/token/roles/` followed by the `role_name`, e.g.\n\n```sh\n $ pulumi import vault:tokenauth/authBackendRole:AuthBackendRole example auth/token/roles/my-role\n```\n\n ",
            "properties": {
                "allowedEntityAliases": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of allowed entity aliases.\n"
                },
                "allowedPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of allowed policies for given role.\n"
                },
                "allowedPoliciesGlobs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of allowed policies with glob match for given role.\n"
                },
                "disallowedPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of disallowed policies for given role.\n"
                },
                "disallowedPoliciesGlobs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of disallowed policies with glob match for given role.\n"
                },
                "orphan": {
                    "type": "boolean",
                    "description": "If true, tokens created against this policy will be orphan tokens.\n"
                },
                "pathSuffix": {
                    "type": "string",
                    "description": "Tokens created against this role will have the given suffix as part of their path in addition to the role name.\n"
                },
                "renewable": {
                    "type": "boolean",
                    "description": "Whether to disable the ability of the token to be renewed past its initial TTL.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "required": [
                "roleName"
            ],
            "inputProperties": {
                "allowedEntityAliases": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of allowed entity aliases.\n"
                },
                "allowedPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of allowed policies for given role.\n"
                },
                "allowedPoliciesGlobs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of allowed policies with glob match for given role.\n"
                },
                "disallowedPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of disallowed policies for given role.\n"
                },
                "disallowedPoliciesGlobs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of disallowed policies with glob match for given role.\n"
                },
                "orphan": {
                    "type": "boolean",
                    "description": "If true, tokens created against this policy will be orphan tokens.\n"
                },
                "pathSuffix": {
                    "type": "string",
                    "description": "Tokens created against this role will have the given suffix as part of their path in addition to the role name.\n"
                },
                "renewable": {
                    "type": "boolean",
                    "description": "Whether to disable the ability of the token to be renewed past its initial TTL.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "requiredInputs": [
                "roleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "allowedEntityAliases": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of allowed entity aliases.\n"
                    },
                    "allowedPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of allowed policies for given role.\n"
                    },
                    "allowedPoliciesGlobs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of allowed policies with glob match for given role.\n"
                    },
                    "disallowedPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of disallowed policies for given role.\n"
                    },
                    "disallowedPoliciesGlobs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of disallowed policies with glob match for given role.\n"
                    },
                    "orphan": {
                        "type": "boolean",
                        "description": "If true, tokens created against this policy will be orphan tokens.\n"
                    },
                    "pathSuffix": {
                        "type": "string",
                        "description": "Tokens created against this role will have the given suffix as part of their path in addition to the role name.\n"
                    },
                    "renewable": {
                        "type": "boolean",
                        "description": "Whether to disable the ability of the token to be renewed past its initial TTL.\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Generated Token's Policies\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:transform/alphabet:Alphabet": {
            "description": "This resource supports the \"/transform/alphabet/{name}\" Vault endpoint.\n\nIt queries an existing alphabet by the given name.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst mountTransform = new vault.Mount(\"mountTransform\", {\n    path: \"transform\",\n    type: \"transform\",\n});\nconst test = new vault.transform.Alphabet(\"test\", {\n    path: mountTransform.path,\n    alphabet: \"0123456789\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nmount_transform = vault.Mount(\"mountTransform\",\n    path=\"transform\",\n    type=\"transform\")\ntest = vault.transform.Alphabet(\"test\",\n    path=mount_transform.path,\n    alphabet=\"0123456789\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var mountTransform = new Vault.Mount(\"mountTransform\", new Vault.MountArgs\n        {\n            Path = \"transform\",\n            Type = \"transform\",\n        });\n        var test = new Vault.Transform.Alphabet(\"test\", new Vault.Transform.AlphabetArgs\n        {\n            Path = mountTransform.Path,\n            Alphabet = \"0123456789\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/transform\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmountTransform, err := vault.NewMount(ctx, \"mountTransform\", \u0026vault.MountArgs{\n\t\t\tPath: pulumi.String(\"transform\"),\n\t\t\tType: pulumi.String(\"transform\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = transform.NewAlphabet(ctx, \"test\", \u0026transform.AlphabetArgs{\n\t\t\tPath:     mountTransform.Path,\n\t\t\tAlphabet: pulumi.String(\"0123456789\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "alphabet": {
                    "type": "string",
                    "description": "A string of characters that contains the alphabet set.\n",
                    "language": {
                        "csharp": {
                            "name": "AlphabetSet"
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of the alphabet.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to where the back-end is mounted within Vault.\n"
                }
            },
            "required": [
                "name",
                "path"
            ],
            "inputProperties": {
                "alphabet": {
                    "type": "string",
                    "description": "A string of characters that contains the alphabet set.\n",
                    "language": {
                        "csharp": {
                            "name": "AlphabetSet"
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of the alphabet.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to where the back-end is mounted within Vault.\n"
                }
            },
            "requiredInputs": [
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Alphabet resources.\n",
                "properties": {
                    "alphabet": {
                        "type": "string",
                        "description": "A string of characters that contains the alphabet set.\n",
                        "language": {
                            "csharp": {
                                "name": "AlphabetSet"
                            }
                        }
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the alphabet.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Path to where the back-end is mounted within Vault.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:transform/role:Role": {
            "description": "This resource supports the \"/transform/role/{name}\" Vault endpoint.\n\nIt creates or updates the role with the given name. If a role with the name does not exist, it will be created.\nIf the role exists, it will be updated with the new attributes.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst mountTransform = new vault.Mount(\"mountTransform\", {\n    path: \"transform\",\n    type: \"transform\",\n});\nconst test = new vault.transform.Role(\"test\", {\n    path: mountTransform.path,\n    transformations: [\"ccn-fpe\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nmount_transform = vault.Mount(\"mountTransform\",\n    path=\"transform\",\n    type=\"transform\")\ntest = vault.transform.Role(\"test\",\n    path=mount_transform.path,\n    transformations=[\"ccn-fpe\"])\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var mountTransform = new Vault.Mount(\"mountTransform\", new Vault.MountArgs\n        {\n            Path = \"transform\",\n            Type = \"transform\",\n        });\n        var test = new Vault.Transform.Role(\"test\", new Vault.Transform.RoleArgs\n        {\n            Path = mountTransform.Path,\n            Transformations = \n            {\n                \"ccn-fpe\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/transform\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmountTransform, err := vault.NewMount(ctx, \"mountTransform\", \u0026vault.MountArgs{\n\t\t\tPath: pulumi.String(\"transform\"),\n\t\t\tType: pulumi.String(\"transform\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = transform.NewRole(ctx, \"test\", \u0026transform.RoleArgs{\n\t\t\tPath: mountTransform.Path,\n\t\t\tTransformations: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"ccn-fpe\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to where the back-end is mounted within Vault.\n"
                },
                "transformations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A comma separated string or slice of transformations to use.\n"
                }
            },
            "required": [
                "name",
                "path"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to where the back-end is mounted within Vault.\n"
                },
                "transformations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A comma separated string or slice of transformations to use.\n"
                }
            },
            "requiredInputs": [
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Role resources.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Path to where the back-end is mounted within Vault.\n"
                    },
                    "transformations": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A comma separated string or slice of transformations to use.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:transform/template:Template": {
            "properties": {
                "alphabet": {
                    "type": "string",
                    "description": "The alphabet to use for this template. This is only used during FPE transformations.\n"
                },
                "decodeFormats": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "- Optional mapping of name to regular expression template, used to customize\nthe decoded output. (requires Vault Enterprise 1.9+)\n"
                },
                "encodeFormat": {
                    "type": "string",
                    "description": "- The regular expression template used to format encoded values.\n(requires Vault Enterprise 1.9+)\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the template.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to where the back-end is mounted within Vault.\n"
                },
                "pattern": {
                    "type": "string",
                    "description": "The pattern used for matching. Currently, only regular expression pattern is supported.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The pattern type to use for match detection. Currently, only regex is supported.\n"
                }
            },
            "required": [
                "name",
                "path"
            ],
            "inputProperties": {
                "alphabet": {
                    "type": "string",
                    "description": "The alphabet to use for this template. This is only used during FPE transformations.\n"
                },
                "decodeFormats": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "- Optional mapping of name to regular expression template, used to customize\nthe decoded output. (requires Vault Enterprise 1.9+)\n"
                },
                "encodeFormat": {
                    "type": "string",
                    "description": "- The regular expression template used to format encoded values.\n(requires Vault Enterprise 1.9+)\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the template.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to where the back-end is mounted within Vault.\n"
                },
                "pattern": {
                    "type": "string",
                    "description": "The pattern used for matching. Currently, only regular expression pattern is supported.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The pattern type to use for match detection. Currently, only regex is supported.\n"
                }
            },
            "requiredInputs": [
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Template resources.\n",
                "properties": {
                    "alphabet": {
                        "type": "string",
                        "description": "The alphabet to use for this template. This is only used during FPE transformations.\n"
                    },
                    "decodeFormats": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "- Optional mapping of name to regular expression template, used to customize\nthe decoded output. (requires Vault Enterprise 1.9+)\n"
                    },
                    "encodeFormat": {
                        "type": "string",
                        "description": "- The regular expression template used to format encoded values.\n(requires Vault Enterprise 1.9+)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the template.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Path to where the back-end is mounted within Vault.\n"
                    },
                    "pattern": {
                        "type": "string",
                        "description": "The pattern used for matching. Currently, only regular expression pattern is supported.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The pattern type to use for match detection. Currently, only regex is supported.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:transform/transformation:Transformation": {
            "description": "This resource supports the \"/transform/transformation/{name}\" Vault endpoint.\n\nIt creates or updates a transformation with the given name. If a transformation with the name does not exist,\nit will be created. If the transformation exists, it will be updated with the new attributes.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst mountTransform = new vault.Mount(\"mountTransform\", {\n    path: \"transform\",\n    type: \"transform\",\n});\nconst test = new vault.transform.Transformation(\"test\", {\n    path: mountTransform.path,\n    type: \"fpe\",\n    template: \"ccn\",\n    tweakSource: \"internal\",\n    allowedRoles: [\"payments\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nmount_transform = vault.Mount(\"mountTransform\",\n    path=\"transform\",\n    type=\"transform\")\ntest = vault.transform.Transformation(\"test\",\n    path=mount_transform.path,\n    type=\"fpe\",\n    template=\"ccn\",\n    tweak_source=\"internal\",\n    allowed_roles=[\"payments\"])\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var mountTransform = new Vault.Mount(\"mountTransform\", new Vault.MountArgs\n        {\n            Path = \"transform\",\n            Type = \"transform\",\n        });\n        var test = new Vault.Transform.Transformation(\"test\", new Vault.Transform.TransformationArgs\n        {\n            Path = mountTransform.Path,\n            Type = \"fpe\",\n            Template = \"ccn\",\n            TweakSource = \"internal\",\n            AllowedRoles = \n            {\n                \"payments\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/transform\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmountTransform, err := vault.NewMount(ctx, \"mountTransform\", \u0026vault.MountArgs{\n\t\t\tPath: pulumi.String(\"transform\"),\n\t\t\tType: pulumi.String(\"transform\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = transform.NewTransformation(ctx, \"test\", \u0026transform.TransformationArgs{\n\t\t\tPath:        mountTransform.Path,\n\t\t\tType:        pulumi.String(\"fpe\"),\n\t\t\tTemplate:    pulumi.String(\"ccn\"),\n\t\t\tTweakSource: pulumi.String(\"internal\"),\n\t\t\tAllowedRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"payments\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The set of roles allowed to perform this transformation.\n"
                },
                "maskingCharacter": {
                    "type": "string",
                    "description": "The character used to replace data when in masking mode\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the transformation.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to where the back-end is mounted within Vault.\n"
                },
                "template": {
                    "type": "string",
                    "description": "The name of the template to use.\n"
                },
                "templates": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Templates configured for transformation.\n"
                },
                "tweakSource": {
                    "type": "string",
                    "description": "The source of where the tweak value comes from. Only valid when in FPE mode.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of transformation to perform.\n"
                }
            },
            "required": [
                "name",
                "path",
                "templates"
            ],
            "inputProperties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The set of roles allowed to perform this transformation.\n"
                },
                "maskingCharacter": {
                    "type": "string",
                    "description": "The character used to replace data when in masking mode\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the transformation.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to where the back-end is mounted within Vault.\n"
                },
                "template": {
                    "type": "string",
                    "description": "The name of the template to use.\n"
                },
                "templates": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Templates configured for transformation.\n"
                },
                "tweakSource": {
                    "type": "string",
                    "description": "The source of where the tweak value comes from. Only valid when in FPE mode.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of transformation to perform.\n"
                }
            },
            "requiredInputs": [
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Transformation resources.\n",
                "properties": {
                    "allowedRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The set of roles allowed to perform this transformation.\n"
                    },
                    "maskingCharacter": {
                        "type": "string",
                        "description": "The character used to replace data when in masking mode\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the transformation.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Path to where the back-end is mounted within Vault.\n"
                    },
                    "template": {
                        "type": "string",
                        "description": "The name of the template to use.\n"
                    },
                    "templates": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Templates configured for transformation.\n"
                    },
                    "tweakSource": {
                        "type": "string",
                        "description": "The source of where the tweak value comes from. Only valid when in FPE mode.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of transformation to perform.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:transit/secretBackendKey:SecretBackendKey": {
            "description": "Creates an Encryption Keyring on a Transit Secret Backend for Vault.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst transit = new vault.Mount(\"transit\", {\n    path: \"transit\",\n    type: \"transit\",\n    description: \"Example description\",\n    defaultLeaseTtlSeconds: 3600,\n    maxLeaseTtlSeconds: 86400,\n});\nconst key = new vault.transit.SecretBackendKey(\"key\", {backend: transit.path});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntransit = vault.Mount(\"transit\",\n    path=\"transit\",\n    type=\"transit\",\n    description=\"Example description\",\n    default_lease_ttl_seconds=3600,\n    max_lease_ttl_seconds=86400)\nkey = vault.transit.SecretBackendKey(\"key\", backend=transit.path)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var transit = new Vault.Mount(\"transit\", new Vault.MountArgs\n        {\n            Path = \"transit\",\n            Type = \"transit\",\n            Description = \"Example description\",\n            DefaultLeaseTtlSeconds = 3600,\n            MaxLeaseTtlSeconds = 86400,\n        });\n        var key = new Vault.Transit.SecretBackendKey(\"key\", new Vault.Transit.SecretBackendKeyArgs\n        {\n            Backend = transit.Path,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/transit\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttransit, err := vault.NewMount(ctx, \"transit\", \u0026vault.MountArgs{\n\t\t\tPath:                   pulumi.String(\"transit\"),\n\t\t\tType:                   pulumi.String(\"transit\"),\n\t\t\tDescription:            pulumi.String(\"Example description\"),\n\t\t\tDefaultLeaseTtlSeconds: pulumi.Int(3600),\n\t\t\tMaxLeaseTtlSeconds:     pulumi.Int(86400),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = transit.NewSecretBackendKey(ctx, \"key\", \u0026transit.SecretBackendKeyArgs{\n\t\t\tBackend: transit.Path,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nTransit secret backend keys can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:transit/secretBackendKey:SecretBackendKey key transit/keys/my_key\n```\n\n ",
            "properties": {
                "allowPlaintextBackup": {
                    "type": "boolean",
                    "description": "Enables taking backup of entire keyring in the plaintext format. Once set, this cannot be disabled.\n* Refer to Vault API documentation on key backups for more information: [Backup Key](https://www.vaultproject.io/api-docs/secret/transit#backup-key)\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the transit secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "convergentEncryption": {
                    "type": "boolean",
                    "description": "Whether or not to support convergent encryption, where the same plaintext creates the same ciphertext. This requires `derived` to be set to `true`.\n"
                },
                "deletionAllowed": {
                    "type": "boolean",
                    "description": "Specifies if the key is allowed to be deleted.\n"
                },
                "derived": {
                    "type": "boolean",
                    "description": "Specifies if key derivation is to be used. If enabled, all encrypt/decrypt requests to this key must provide a context which is used for key derivation.\n"
                },
                "exportable": {
                    "type": "boolean",
                    "description": "Enables keys to be exportable. This allows for all valid private keys in the keyring to be exported. Once set, this cannot be disabled.\n"
                },
                "keys": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "description": "List of key versions in the keyring. This attribute is zero-indexed and will contain a map of values depending on the `type` of the encryption key.\n* for key types `aes128-gcm96`, `aes256-gcm96` and `chacha20-poly1305`, each key version will be a map of a single value `id` which is just a hash of the key's metadata.\n* for key types `ed25519`, `ecdsa-p256`, `ecdsa-p384`, `ecdsa-p521`, `rsa-2048`, `rsa-3072` and `rsa-4096`, each key version will be a map of the following:\n"
                },
                "latestVersion": {
                    "type": "integer",
                    "description": "Latest key version available. This value is 1-indexed, so if `latest_version` is `1`, then the key's information can be referenced from `keys` by selecting element `0`\n"
                },
                "minAvailableVersion": {
                    "type": "integer",
                    "description": "Minimum key version available for use. If keys have been archived by increasing `min_decryption_version`, this attribute will reflect that change.\n"
                },
                "minDecryptionVersion": {
                    "type": "integer",
                    "description": "Minimum key version to use for decryption.\n"
                },
                "minEncryptionVersion": {
                    "type": "integer",
                    "description": "Minimum key version to use for encryption\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this key within the backend. Must be unique within the backend.\n"
                },
                "supportsDecryption": {
                    "type": "boolean",
                    "description": "Whether or not the key supports decryption, based on key type.\n"
                },
                "supportsDerivation": {
                    "type": "boolean",
                    "description": "Whether or not the key supports derivation, based on key type.\n"
                },
                "supportsEncryption": {
                    "type": "boolean",
                    "description": "Whether or not the key supports encryption, based on key type.\n"
                },
                "supportsSigning": {
                    "type": "boolean",
                    "description": "Whether or not the key supports signing, based on key type.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Specifies the type of key to create. The currently-supported types are: `aes128-gcm96`, `aes256-gcm96` (default), `chacha20-poly1305`, `ed25519`, `ecdsa-p256`, `ecdsa-p384`, `ecdsa-p521`, `rsa-2048`, `rsa-3072` and `rsa-4096`. \n* Refer to the Vault documentation on transit key types for more information: [Key Types](https://www.vaultproject.io/docs/secrets/transit#key-types)\n"
                }
            },
            "required": [
                "backend",
                "keys",
                "latestVersion",
                "minAvailableVersion",
                "name",
                "supportsDecryption",
                "supportsDerivation",
                "supportsEncryption",
                "supportsSigning"
            ],
            "inputProperties": {
                "allowPlaintextBackup": {
                    "type": "boolean",
                    "description": "Enables taking backup of entire keyring in the plaintext format. Once set, this cannot be disabled.\n* Refer to Vault API documentation on key backups for more information: [Backup Key](https://www.vaultproject.io/api-docs/secret/transit#backup-key)\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the transit secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "convergentEncryption": {
                    "type": "boolean",
                    "description": "Whether or not to support convergent encryption, where the same plaintext creates the same ciphertext. This requires `derived` to be set to `true`.\n"
                },
                "deletionAllowed": {
                    "type": "boolean",
                    "description": "Specifies if the key is allowed to be deleted.\n"
                },
                "derived": {
                    "type": "boolean",
                    "description": "Specifies if key derivation is to be used. If enabled, all encrypt/decrypt requests to this key must provide a context which is used for key derivation.\n"
                },
                "exportable": {
                    "type": "boolean",
                    "description": "Enables keys to be exportable. This allows for all valid private keys in the keyring to be exported. Once set, this cannot be disabled.\n"
                },
                "minDecryptionVersion": {
                    "type": "integer",
                    "description": "Minimum key version to use for decryption.\n"
                },
                "minEncryptionVersion": {
                    "type": "integer",
                    "description": "Minimum key version to use for encryption\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this key within the backend. Must be unique within the backend.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Specifies the type of key to create. The currently-supported types are: `aes128-gcm96`, `aes256-gcm96` (default), `chacha20-poly1305`, `ed25519`, `ecdsa-p256`, `ecdsa-p384`, `ecdsa-p521`, `rsa-2048`, `rsa-3072` and `rsa-4096`. \n* Refer to the Vault documentation on transit key types for more information: [Key Types](https://www.vaultproject.io/docs/secrets/transit#key-types)\n"
                }
            },
            "requiredInputs": [
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendKey resources.\n",
                "properties": {
                    "allowPlaintextBackup": {
                        "type": "boolean",
                        "description": "Enables taking backup of entire keyring in the plaintext format. Once set, this cannot be disabled.\n* Refer to Vault API documentation on key backups for more information: [Backup Key](https://www.vaultproject.io/api-docs/secret/transit#backup-key)\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path the transit secret backend is mounted at, with no leading or trailing `/`s.\n"
                    },
                    "convergentEncryption": {
                        "type": "boolean",
                        "description": "Whether or not to support convergent encryption, where the same plaintext creates the same ciphertext. This requires `derived` to be set to `true`.\n"
                    },
                    "deletionAllowed": {
                        "type": "boolean",
                        "description": "Specifies if the key is allowed to be deleted.\n"
                    },
                    "derived": {
                        "type": "boolean",
                        "description": "Specifies if key derivation is to be used. If enabled, all encrypt/decrypt requests to this key must provide a context which is used for key derivation.\n"
                    },
                    "exportable": {
                        "type": "boolean",
                        "description": "Enables keys to be exportable. This allows for all valid private keys in the keyring to be exported. Once set, this cannot be disabled.\n"
                    },
                    "keys": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        },
                        "description": "List of key versions in the keyring. This attribute is zero-indexed and will contain a map of values depending on the `type` of the encryption key.\n* for key types `aes128-gcm96`, `aes256-gcm96` and `chacha20-poly1305`, each key version will be a map of a single value `id` which is just a hash of the key's metadata.\n* for key types `ed25519`, `ecdsa-p256`, `ecdsa-p384`, `ecdsa-p521`, `rsa-2048`, `rsa-3072` and `rsa-4096`, each key version will be a map of the following:\n"
                    },
                    "latestVersion": {
                        "type": "integer",
                        "description": "Latest key version available. This value is 1-indexed, so if `latest_version` is `1`, then the key's information can be referenced from `keys` by selecting element `0`\n"
                    },
                    "minAvailableVersion": {
                        "type": "integer",
                        "description": "Minimum key version available for use. If keys have been archived by increasing `min_decryption_version`, this attribute will reflect that change.\n"
                    },
                    "minDecryptionVersion": {
                        "type": "integer",
                        "description": "Minimum key version to use for decryption.\n"
                    },
                    "minEncryptionVersion": {
                        "type": "integer",
                        "description": "Minimum key version to use for encryption\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name to identify this key within the backend. Must be unique within the backend.\n"
                    },
                    "supportsDecryption": {
                        "type": "boolean",
                        "description": "Whether or not the key supports decryption, based on key type.\n"
                    },
                    "supportsDerivation": {
                        "type": "boolean",
                        "description": "Whether or not the key supports derivation, based on key type.\n"
                    },
                    "supportsEncryption": {
                        "type": "boolean",
                        "description": "Whether or not the key supports encryption, based on key type.\n"
                    },
                    "supportsSigning": {
                        "type": "boolean",
                        "description": "Whether or not the key supports signing, based on key type.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Specifies the type of key to create. The currently-supported types are: `aes128-gcm96`, `aes256-gcm96` (default), `chacha20-poly1305`, `ed25519`, `ecdsa-p256`, `ecdsa-p384`, `ecdsa-p521`, `rsa-2048`, `rsa-3072` and `rsa-4096`. \n* Refer to the Vault documentation on transit key types for more information: [Key Types](https://www.vaultproject.io/docs/secrets/transit#key-types)\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:transit/secretCacheConfig:SecretCacheConfig": {
            "description": "Configure the cache for the Transit Secret Backend in Vault.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst transit = new vault.Mount(\"transit\", {\n    path: \"transit\",\n    type: \"transit\",\n    description: \"Example description\",\n    defaultLeaseTtlSeconds: 3600,\n    maxLeaseTtlSeconds: 86400,\n});\nconst cfg = new vault.transit.SecretCacheConfig(\"cfg\", {\n    backend: transit.path,\n    size: 500,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntransit = vault.Mount(\"transit\",\n    path=\"transit\",\n    type=\"transit\",\n    description=\"Example description\",\n    default_lease_ttl_seconds=3600,\n    max_lease_ttl_seconds=86400)\ncfg = vault.transit.SecretCacheConfig(\"cfg\",\n    backend=transit.path,\n    size=500)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var transit = new Vault.Mount(\"transit\", new Vault.MountArgs\n        {\n            Path = \"transit\",\n            Type = \"transit\",\n            Description = \"Example description\",\n            DefaultLeaseTtlSeconds = 3600,\n            MaxLeaseTtlSeconds = 86400,\n        });\n        var cfg = new Vault.Transit.SecretCacheConfig(\"cfg\", new Vault.Transit.SecretCacheConfigArgs\n        {\n            Backend = transit.Path,\n            Size = 500,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/transit\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttransit, err := vault.NewMount(ctx, \"transit\", \u0026vault.MountArgs{\n\t\t\tPath:                   pulumi.String(\"transit\"),\n\t\t\tType:                   pulumi.String(\"transit\"),\n\t\t\tDescription:            pulumi.String(\"Example description\"),\n\t\t\tDefaultLeaseTtlSeconds: pulumi.Int(3600),\n\t\t\tMaxLeaseTtlSeconds:     pulumi.Int(86400),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = transit.NewSecretCacheConfig(ctx, \"cfg\", \u0026transit.SecretCacheConfigArgs{\n\t\t\tBackend: transit.Path,\n\t\t\tSize:    pulumi.Int(500),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path the transit secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "The number of cache entries. 0 means unlimited.\n"
                }
            },
            "required": [
                "backend",
                "size"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path the transit secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "The number of cache entries. 0 means unlimited.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "size"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretCacheConfig resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the transit secret backend is mounted at, with no leading or trailing `/`s.\n"
                    },
                    "size": {
                        "type": "integer",
                        "description": "The number of cache entries. 0 means unlimited.\n"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "vault:ad/getAccessCredentials:getAccessCredentials": {
            "inputs": {
                "description": "A collection of arguments for invoking getAccessCredentials.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path to the AD secret backend to\nread credentials from, with no leading or trailing `/`s.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the AD secret backend role to read\ncredentials from, with no leading or trailing `/`s.\n"
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "role"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAccessCredentials.\n",
                "properties": {
                    "backend": {
                        "type": "string"
                    },
                    "currentPassword": {
                        "type": "string",
                        "description": "The current set password on the Active Directory service account.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "lastPassword": {
                        "type": "string",
                        "description": "The current set password on the Active Directory service account, provided because AD is eventually consistent.\n"
                    },
                    "role": {
                        "type": "string"
                    },
                    "username": {
                        "type": "string",
                        "description": "The Active Directory service account username.\n"
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "currentPassword",
                    "lastPassword",
                    "role",
                    "username",
                    "id"
                ]
            }
        },
        "vault:appRole/getAuthBackendRoleId:getAuthBackendRoleId": {
            "description": "Reads the Role ID of an AppRole from a Vault server.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst role = vault.appRole.getAuthBackendRoleId({\n    backend: \"my-approle-backend\",\n    roleName: \"my-role\",\n});\nexport const role_id = role.then(role =\u003e role.roleId);\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nrole = vault.appRole.get_auth_backend_role_id(backend=\"my-approle-backend\",\n    role_name=\"my-role\")\npulumi.export(\"role-id\", role.role_id)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var role = Output.Create(Vault.AppRole.GetAuthBackendRoleId.InvokeAsync(new Vault.AppRole.GetAuthBackendRoleIdArgs\n        {\n            Backend = \"my-approle-backend\",\n            RoleName = \"my-role\",\n        }));\n        this.Role_id = role.Apply(role =\u003e role.RoleId);\n    }\n\n    [Output(\"role-id\")]\n    public Output\u003cstring\u003e Role_id { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/appRole\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\topt0 := \"my-approle-backend\"\n\t\trole, err := appRole.GetAuthBackendRoleId(ctx, \u0026approle.GetAuthBackendRoleIdArgs{\n\t\t\tBackend:  \u0026opt0,\n\t\t\tRoleName: \"my-role\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"role-id\", role.RoleId)\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getAuthBackendRoleId.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The unique name for the AppRole backend the role to\nretrieve a RoleID for resides in. Defaults to \"approle\".\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role to retrieve the Role ID for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "roleName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAuthBackendRoleId.\n",
                "properties": {
                    "backend": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "roleId": {
                        "type": "string",
                        "description": "The RoleID of the role.\n"
                    },
                    "roleName": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "roleId",
                    "roleName",
                    "id"
                ]
            }
        },
        "vault:aws/getAccessCredentials:getAccessCredentials": {
            "inputs": {
                "description": "A collection of arguments for invoking getAccessCredentials.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path to the AWS secret backend to\nread credentials from, with no leading or trailing `/`s.\n"
                    },
                    "region": {
                        "type": "string"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the AWS secret backend role to read\ncredentials from, with no leading or trailing `/`s.\n"
                    },
                    "roleArn": {
                        "type": "string",
                        "description": "The specific AWS ARN to use\nfrom the configured role. If the role does not have multiple ARNs, this does\nnot need to be specified.\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Specifies the TTL for the use of the STS token. This\nis specified as a string with a duration suffix. Valid only when\n`credential_type` is `assumed_role` or `federation_token`\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of credentials to read. Defaults\nto `\"creds\"`, which just returns an AWS Access Key ID and Secret\nKey. Can also be set to `\"sts\"`, which will return a security token\nin addition to the keys.\n"
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "role"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAccessCredentials.\n",
                "properties": {
                    "accessKey": {
                        "type": "string",
                        "description": "The AWS Access Key ID returned by Vault.\n"
                    },
                    "backend": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "leaseDuration": {
                        "type": "integer",
                        "description": "The duration of the secret lease, in seconds relative\nto the time the data was requested. Once this time has passed any plan\ngenerated with this data may fail to apply.\n"
                    },
                    "leaseId": {
                        "type": "string",
                        "description": "The lease identifier assigned by Vault.\n"
                    },
                    "leaseRenewable": {
                        "type": "boolean"
                    },
                    "leaseStartTime": {
                        "type": "string"
                    },
                    "region": {
                        "type": "string"
                    },
                    "role": {
                        "type": "string"
                    },
                    "roleArn": {
                        "type": "string"
                    },
                    "secretKey": {
                        "type": "string",
                        "description": "The AWS Secret Key returned by Vault.\n"
                    },
                    "securityToken": {
                        "type": "string",
                        "description": "The STS token returned by Vault, if any.\n"
                    },
                    "ttl": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "accessKey",
                    "backend",
                    "leaseDuration",
                    "leaseId",
                    "leaseRenewable",
                    "leaseStartTime",
                    "role",
                    "secretKey",
                    "securityToken",
                    "id"
                ]
            }
        },
        "vault:azure/getAccessCredentials:getAccessCredentials": {
            "inputs": {
                "description": "A collection of arguments for invoking getAccessCredentials.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path to the Azure secret backend to\nread credentials from, with no leading or trailing `/`s.\n"
                    },
                    "maxCredValidationSeconds": {
                        "type": "integer",
                        "description": "If 'validate_creds' is true, \nthe number of seconds after which to give up validating credentials. Defaults\nto 1,200 (20 minutes).\n"
                    },
                    "numSecondsBetweenTests": {
                        "type": "integer",
                        "description": "If 'validate_creds' is true, \nthe number of seconds to wait between each test of generated credentials.\nDefaults to 7.\n"
                    },
                    "numSequentialSuccesses": {
                        "type": "integer",
                        "description": "If 'validate_creds' is true, \nthe number of sequential successes required to validate generated\ncredentials. Defaults to 8.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the Azure secret backend role to read\ncredentials from, with no leading or trailing `/`s.\n"
                    },
                    "validateCreds": {
                        "type": "boolean",
                        "description": "Whether generated credentials should be \nvalidated before being returned. Defaults to `false`, which returns\ncredentials without checking whether they have fully propagated throughout\nAzure Active Directory. Designating `true` activates testing.\n"
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "role"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAccessCredentials.\n",
                "properties": {
                    "backend": {
                        "type": "string"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client id for credentials to query the Azure APIs.\n"
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "The client secret for credentials to query the Azure APIs.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "leaseDuration": {
                        "type": "integer",
                        "description": "The duration of the secret lease, in seconds relative\nto the time the data was requested. Once this time has passed any plan\ngenerated with this data may fail to apply.\n"
                    },
                    "leaseId": {
                        "type": "string",
                        "description": "The lease identifier assigned by Vault.\n"
                    },
                    "leaseRenewable": {
                        "type": "boolean"
                    },
                    "leaseStartTime": {
                        "type": "string"
                    },
                    "maxCredValidationSeconds": {
                        "type": "integer"
                    },
                    "numSecondsBetweenTests": {
                        "type": "integer"
                    },
                    "numSequentialSuccesses": {
                        "type": "integer"
                    },
                    "role": {
                        "type": "string"
                    },
                    "validateCreds": {
                        "type": "boolean"
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "clientId",
                    "clientSecret",
                    "leaseDuration",
                    "leaseId",
                    "leaseRenewable",
                    "leaseStartTime",
                    "role",
                    "id"
                ]
            }
        },
        "vault:gcp/getAuthBackendRole:getAuthBackendRole": {
            "description": "Reads a GCP auth role from a Vault server.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst role = pulumi.output(vault.gcp.getAuthBackendRole({\n    backend: \"my-gcp-backend\",\n    roleName: \"my-role\",\n}));\n\nexport const role_id = role.roleId;\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nrole = vault.gcp.get_auth_backend_role(backend=\"my-gcp-backend\",\n    role_name=\"my-role\")\npulumi.export(\"role-id\", role.role_id)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var role = Output.Create(Vault.Gcp.GetAuthBackendRole.InvokeAsync(new Vault.Gcp.GetAuthBackendRoleArgs\n        {\n            Backend = \"my-gcp-backend\",\n            RoleName = \"my-role\",\n        }));\n        this.Role_id = role.Apply(role =\u003e role.RoleId);\n    }\n\n    [Output(\"role-id\")]\n    public Output\u003cstring\u003e Role_id { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/gcp\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\topt0 := \"my-gcp-backend\"\n\t\trole, err := gcp.LookupAuthBackendRole(ctx, \u0026gcp.LookupAuthBackendRoleArgs{\n\t\t\tBackend:  \u0026opt0,\n\t\t\tRoleName: \"my-role\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"role-id\", role.RoleId)\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getAuthBackendRole.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The unique name for the GCP backend from which to fetch the role. Defaults to \"gcp\".\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role to retrieve the Role ID for.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "(Optional) If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    }
                },
                "type": "object",
                "required": [
                    "roleName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAuthBackendRole.\n",
                "properties": {
                    "backend": {
                        "type": "string"
                    },
                    "boundInstanceGroups": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "GCP regions bound to the role. Returned when `type` is `gce`.\n"
                    },
                    "boundLabels": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "GCP labels bound to the role. Returned when `type` is `gce`.\n"
                    },
                    "boundProjects": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "GCP projects bound to the role.\n"
                    },
                    "boundRegions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "GCP regions bound to the role. Returned when `type` is `gce`.\n"
                    },
                    "boundServiceAccounts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "GCP service accounts bound to the role. Returned when `type` is `iam`.\n"
                    },
                    "boundZones": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "GCP zones bound to the role. Returned when `type` is `gce`.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "roleId": {
                        "type": "string",
                        "description": "The RoleID of the GCP role.\n"
                    },
                    "roleName": {
                        "type": "string"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "(Optional) If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of GCP role. Expected values are `iam` or `gce`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "boundInstanceGroups",
                    "boundLabels",
                    "boundProjects",
                    "boundRegions",
                    "boundServiceAccounts",
                    "boundZones",
                    "roleId",
                    "roleName",
                    "type",
                    "id"
                ]
            }
        },
        "vault:generic/getSecret:getSecret": {
            "inputs": {
                "description": "A collection of arguments for invoking getSecret.\n",
                "properties": {
                    "path": {
                        "type": "string",
                        "description": "The full logical path from which to request data.\nTo read data from the \"generic\" secret backend mounted in Vault by\ndefault, this should be prefixed with `secret/`. Reading from other backends\nwith this data source is possible; consult each backend's documentation\nto see which endpoints support the `GET` method.\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": "The version of the secret to read. This is used by the\nVault KV secrets engine - version 2 to indicate which version of the secret\nto read.\n"
                    }
                },
                "type": "object",
                "required": [
                    "path"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSecret.\n",
                "properties": {
                    "data": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A mapping whose keys are the top-level data keys returned from\nVault and whose values are the corresponding values. This map can only\nrepresent string data, so any non-string values returned from Vault are\nserialized as JSON.\n"
                    },
                    "dataJson": {
                        "type": "string",
                        "description": "A string containing the full data payload retrieved from\nVault, serialized in JSON format.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "leaseDuration": {
                        "type": "integer",
                        "description": "The duration of the secret lease, in seconds relative\nto the time the data was requested. Once this time has passed any plan\ngenerated with this data may fail to apply.\n"
                    },
                    "leaseId": {
                        "type": "string",
                        "description": "The lease identifier assigned by Vault, if any.\n"
                    },
                    "leaseRenewable": {
                        "type": "boolean"
                    },
                    "leaseStartTime": {
                        "type": "string"
                    },
                    "path": {
                        "type": "string"
                    },
                    "version": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "data",
                    "dataJson",
                    "leaseDuration",
                    "leaseId",
                    "leaseRenewable",
                    "leaseStartTime",
                    "path",
                    "id"
                ]
            }
        },
        "vault:identity/getEntity:getEntity": {
            "inputs": {
                "description": "A collection of arguments for invoking getEntity.\n",
                "properties": {
                    "aliasId": {
                        "type": "string",
                        "description": "ID of the alias.\n"
                    },
                    "aliasMountAccessor": {
                        "type": "string",
                        "description": "Accessor of the mount to which the alias belongs to.\nThis should be supplied in conjunction with `alias_name`.\n"
                    },
                    "aliasName": {
                        "type": "string",
                        "description": "Name of the alias. This should be supplied in conjunction with\n`alias_mount_accessor`.\n"
                    },
                    "entityId": {
                        "type": "string",
                        "description": "ID of the entity.\n"
                    },
                    "entityName": {
                        "type": "string",
                        "description": "Name of the entity.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getEntity.\n",
                "properties": {
                    "aliasId": {
                        "type": "string"
                    },
                    "aliasMountAccessor": {
                        "type": "string"
                    },
                    "aliasName": {
                        "type": "string"
                    },
                    "aliases": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:identity/getEntityAlias:getEntityAlias"
                        },
                        "description": "A list of entity alias. Structure is documented below.\n"
                    },
                    "creationTime": {
                        "type": "string",
                        "description": "Creation time of the Alias\n"
                    },
                    "dataJson": {
                        "type": "string",
                        "description": "A string containing the full data payload retrieved from\nVault, serialized in JSON format.\n"
                    },
                    "directGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Group IDs of which the entity is directly a member of\n"
                    },
                    "disabled": {
                        "type": "boolean",
                        "description": "Whether the entity is disabled\n"
                    },
                    "entityId": {
                        "type": "string"
                    },
                    "entityName": {
                        "type": "string"
                    },
                    "groupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of all Group IDs of which the entity is a member of\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "inheritedGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of all Group IDs of which the entity is a member of transitively\n"
                    },
                    "lastUpdateTime": {
                        "type": "string",
                        "description": "Last update time of the alias\n"
                    },
                    "mergedEntityIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Other entity IDs which is merged with this entity\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Arbitrary metadata\n"
                    },
                    "namespaceId": {
                        "type": "string",
                        "description": "Namespace of which the entity is part of\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies attached to the entity\n"
                    }
                },
                "type": "object",
                "required": [
                    "aliasId",
                    "aliasMountAccessor",
                    "aliasName",
                    "aliases",
                    "creationTime",
                    "dataJson",
                    "directGroupIds",
                    "disabled",
                    "entityId",
                    "entityName",
                    "groupIds",
                    "inheritedGroupIds",
                    "lastUpdateTime",
                    "mergedEntityIds",
                    "metadata",
                    "namespaceId",
                    "policies",
                    "id"
                ]
            }
        },
        "vault:identity/getGroup:getGroup": {
            "inputs": {
                "description": "A collection of arguments for invoking getGroup.\n",
                "properties": {
                    "aliasId": {
                        "type": "string",
                        "description": "ID of the alias.\n"
                    },
                    "aliasMountAccessor": {
                        "type": "string",
                        "description": "Accessor of the mount to which the alias belongs to.\nThis should be supplied in conjunction with `alias_name`.\n"
                    },
                    "aliasName": {
                        "type": "string",
                        "description": "Name of the alias. This should be supplied in conjunction with\n`alias_mount_accessor`.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "ID of the group.\n"
                    },
                    "groupName": {
                        "type": "string",
                        "description": "Name of the group.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getGroup.\n",
                "properties": {
                    "aliasCanonicalId": {
                        "type": "string",
                        "description": "Canonical ID of the Alias\n"
                    },
                    "aliasCreationTime": {
                        "type": "string",
                        "description": "Creation time of the Alias\n"
                    },
                    "aliasId": {
                        "type": "string"
                    },
                    "aliasLastUpdateTime": {
                        "type": "string",
                        "description": "Last update time of the alias\n"
                    },
                    "aliasMergedFromCanonicalIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of canonical IDs merged with this alias\n"
                    },
                    "aliasMetadata": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Arbitrary metadata\n"
                    },
                    "aliasMountAccessor": {
                        "type": "string"
                    },
                    "aliasMountPath": {
                        "type": "string",
                        "description": "Authentication mount path which this alias belongs to\n"
                    },
                    "aliasMountType": {
                        "type": "string",
                        "description": "Authentication mount type which this alias belongs to\n"
                    },
                    "aliasName": {
                        "type": "string"
                    },
                    "creationTime": {
                        "type": "string",
                        "description": "Creation timestamp of the group\n"
                    },
                    "dataJson": {
                        "type": "string",
                        "description": "A string containing the full data payload retrieved from\nVault, serialized in JSON format.\n"
                    },
                    "groupId": {
                        "type": "string"
                    },
                    "groupName": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "lastUpdateTime": {
                        "type": "string",
                        "description": "Last updated time of the group\n"
                    },
                    "memberEntityIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Entity IDs which are members of this group\n"
                    },
                    "memberGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Group IDs which are members of this group\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Arbitrary metadata\n"
                    },
                    "modifyIndex": {
                        "type": "integer",
                        "description": "Modify index of the group\n"
                    },
                    "namespaceId": {
                        "type": "string",
                        "description": "Namespace of which the group is part of\n"
                    },
                    "parentGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Group IDs which are parents of this group.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies attached to the group\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of group\n"
                    }
                },
                "type": "object",
                "required": [
                    "aliasCanonicalId",
                    "aliasCreationTime",
                    "aliasId",
                    "aliasLastUpdateTime",
                    "aliasMergedFromCanonicalIds",
                    "aliasMetadata",
                    "aliasMountAccessor",
                    "aliasMountPath",
                    "aliasMountType",
                    "aliasName",
                    "creationTime",
                    "dataJson",
                    "groupId",
                    "groupName",
                    "lastUpdateTime",
                    "memberEntityIds",
                    "memberGroupIds",
                    "metadata",
                    "modifyIndex",
                    "namespaceId",
                    "parentGroupIds",
                    "policies",
                    "type",
                    "id"
                ]
            }
        },
        "vault:index/getAuthBackend:getAuthBackend": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = pulumi.output(vault.getAuthBackend({\n    path: \"userpass\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.get_auth_backend(path=\"userpass\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = Output.Create(Vault.GetAuthBackend.InvokeAsync(new Vault.GetAuthBackendArgs\n        {\n            Path = \"userpass\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.LookupAuthBackend(ctx, \u0026GetAuthBackendArgs{\n\t\t\tPath: \"userpass\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getAuthBackend.\n",
                "properties": {
                    "path": {
                        "type": "string",
                        "description": "The auth backend mount point.\n"
                    }
                },
                "type": "object",
                "required": [
                    "path"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAuthBackend.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The accessor for this auth method\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The default lease duration in seconds.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description of the auth method.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "listingVisibility": {
                        "type": "string",
                        "description": "Specifies whether to show this mount in the UI-specific listing endpoint.\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Specifies if the auth method is local only.\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The maximum lease duration in seconds.\n"
                    },
                    "path": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string",
                        "description": "The name of the auth method type.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accessor",
                    "defaultLeaseTtlSeconds",
                    "description",
                    "listingVisibility",
                    "local",
                    "maxLeaseTtlSeconds",
                    "path",
                    "type",
                    "id"
                ]
            }
        },
        "vault:index/getNomadAccessToken:getNomadAccessToken": {
            "inputs": {
                "description": "A collection of arguments for invoking getNomadAccessToken.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path to the Nomad secret backend to\nread credentials from, with no leading or trailing `/`s.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the Nomad secret backend role to generate\na token for, with no leading or trailing `/`s.\n"
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "role"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNomadAccessToken.\n",
                "properties": {
                    "accessorId": {
                        "type": "string",
                        "description": "The public identifier for a specific token. It can be used \nto look up information about a token or to revoke a token.\n"
                    },
                    "backend": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "role": {
                        "type": "string"
                    },
                    "secretId": {
                        "type": "string",
                        "description": "The token to be used when making requests to Nomad and should be kept private.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accessorId",
                    "backend",
                    "role",
                    "secretId",
                    "id"
                ]
            }
        },
        "vault:index/getPolicyDocument:getPolicyDocument": {
            "description": "This is a data source which can be used to construct a HCL representation of an Vault policy document, for use with resources which expect policy documents, such as the `vault.Policy` resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst examplePolicyDocument = vault.getPolicyDocument({\n    rules: [{\n        path: \"secret/*\",\n        capabilities: [\n            \"create\",\n            \"read\",\n            \"update\",\n            \"delete\",\n            \"list\",\n        ],\n        description: \"allow all on secrets\",\n    }],\n});\nconst examplePolicy = new vault.Policy(\"examplePolicy\", {policy: examplePolicyDocument.then(examplePolicyDocument =\u003e examplePolicyDocument.hcl)});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample_policy_document = vault.get_policy_document(rules=[vault.GetPolicyDocumentRuleArgs(\n    path=\"secret/*\",\n    capabilities=[\n        \"create\",\n        \"read\",\n        \"update\",\n        \"delete\",\n        \"list\",\n    ],\n    description=\"allow all on secrets\",\n)])\nexample_policy = vault.Policy(\"examplePolicy\", policy=example_policy_document.hcl)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var examplePolicyDocument = Output.Create(Vault.GetPolicyDocument.InvokeAsync(new Vault.GetPolicyDocumentArgs\n        {\n            Rules = \n            {\n                new Vault.Inputs.GetPolicyDocumentRuleArgs\n                {\n                    Path = \"secret/*\",\n                    Capabilities = \n                    {\n                        \"create\",\n                        \"read\",\n                        \"update\",\n                        \"delete\",\n                        \"list\",\n                    },\n                    Description = \"allow all on secrets\",\n                },\n            },\n        }));\n        var examplePolicy = new Vault.Policy(\"examplePolicy\", new Vault.PolicyArgs\n        {\n            Policy = examplePolicyDocument.Apply(examplePolicyDocument =\u003e examplePolicyDocument.Hcl),\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texamplePolicyDocument, err := vault.GetPolicyDocument(ctx, \u0026GetPolicyDocumentArgs{\n\t\t\tRules: []GetPolicyDocumentRule{\n\t\t\t\tGetPolicyDocumentRule{\n\t\t\t\t\tPath: \"secret/*\",\n\t\t\t\t\tCapabilities: []string{\n\t\t\t\t\t\t\"create\",\n\t\t\t\t\t\t\"read\",\n\t\t\t\t\t\t\"update\",\n\t\t\t\t\t\t\"delete\",\n\t\t\t\t\t\t\"list\",\n\t\t\t\t\t},\n\t\t\t\t\tDescription: \"allow all on secrets\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vault.NewPolicy(ctx, \"examplePolicy\", \u0026vault.PolicyArgs{\n\t\t\tPolicy: pulumi.String(examplePolicyDocument.Hcl),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getPolicyDocument.\n",
                "properties": {
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:index/getPolicyDocumentRule:getPolicyDocumentRule"
                        }
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getPolicyDocument.\n",
                "properties": {
                    "hcl": {
                        "type": "string",
                        "description": "The above arguments serialized as a standard Vault HCL policy document.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:index/getPolicyDocumentRule:getPolicyDocumentRule"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "hcl",
                    "rules",
                    "id"
                ]
            }
        },
        "vault:kubernetes/getAuthBackendConfig:getAuthBackendConfig": {
            "description": "Reads the Role of an Kubernetes from a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/api-docs/auth/kubernetes#read-config) for more\ninformation.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAuthBackendConfig.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The unique name for the Kubernetes backend the config to\nretrieve Role attributes for resides in. Defaults to \"kubernetes\".\n"
                    },
                    "disableIssValidation": {
                        "type": "boolean"
                    },
                    "disableLocalCaJwt": {
                        "type": "boolean"
                    },
                    "issuer": {
                        "type": "string",
                        "description": "Optional JWT issuer. If no issuer is specified, `kubernetes.io/serviceaccount` will be used as the default issuer.\n"
                    },
                    "kubernetesCaCert": {
                        "type": "string",
                        "description": "PEM encoded CA cert for use by the TLS client used to talk with the Kubernetes API.\n"
                    },
                    "kubernetesHost": {
                        "type": "string",
                        "description": "Host must be a host string, a host:port pair, or a URL to the base of the Kubernetes API server.\n"
                    },
                    "pemKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Optional list of PEM-formatted public keys or certificates used to verify the signatures of Kubernetes service account JWTs. If a certificate is given, its public key will be extracted. Not every installation of Kubernetes exposes these keys.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getAuthBackendConfig.\n",
                "properties": {
                    "backend": {
                        "type": "string"
                    },
                    "disableIssValidation": {
                        "type": "boolean"
                    },
                    "disableLocalCaJwt": {
                        "type": "boolean"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "issuer": {
                        "type": "string",
                        "description": "Optional JWT issuer. If no issuer is specified, `kubernetes.io/serviceaccount` will be used as the default issuer.\n"
                    },
                    "kubernetesCaCert": {
                        "type": "string",
                        "description": "PEM encoded CA cert for use by the TLS client used to talk with the Kubernetes API.\n"
                    },
                    "kubernetesHost": {
                        "type": "string",
                        "description": "Host must be a host string, a host:port pair, or a URL to the base of the Kubernetes API server.\n"
                    },
                    "pemKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Optional list of PEM-formatted public keys or certificates used to verify the signatures of Kubernetes service account JWTs. If a certificate is given, its public key will be extracted. Not every installation of Kubernetes exposes these keys.\n"
                    }
                },
                "type": "object",
                "required": [
                    "disableIssValidation",
                    "disableLocalCaJwt",
                    "issuer",
                    "kubernetesCaCert",
                    "kubernetesHost",
                    "pemKeys",
                    "id"
                ]
            }
        },
        "vault:kubernetes/getAuthBackendRole:getAuthBackendRole": {
            "description": "Reads the Role of an Kubernetes from a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/api-docs/auth/kubernetes#read-role) for more\ninformation.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAuthBackendRole.\n",
                "properties": {
                    "audience": {
                        "type": "string",
                        "description": "Audience claim to verify in the JWT.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The unique name for the Kubernetes backend the role to\nretrieve Role attributes for resides in. Defaults to \"kubernetes\".\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role to retrieve the Role attributes for.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "(Optional) If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    }
                },
                "type": "object",
                "required": [
                    "roleName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAuthBackendRole.\n",
                "properties": {
                    "aliasNameSource": {
                        "type": "string",
                        "description": "Method used for generating identity aliases. (vault-1.9+)\n"
                    },
                    "audience": {
                        "type": "string",
                        "description": "Audience claim to verify in the JWT.\n"
                    },
                    "backend": {
                        "type": "string"
                    },
                    "boundServiceAccountNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of service account names able to access this role. If set to \"*\" all names are allowed, both this and bound_service_account_namespaces can not be \"*\".\n"
                    },
                    "boundServiceAccountNamespaces": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of namespaces allowed to access this role. If set to \"*\" all namespaces are allowed, both this and bound_service_account_names can not be set to \"*\".\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "roleName": {
                        "type": "string"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "(Optional) If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    }
                },
                "type": "object",
                "required": [
                    "aliasNameSource",
                    "boundServiceAccountNames",
                    "boundServiceAccountNamespaces",
                    "roleName",
                    "id"
                ]
            }
        },
        "vault:transform/getDecode:getDecode": {
            "description": "This data source supports the \"/transform/decode/{role_name}\" Vault endpoint.\n\nIt decodes the provided value using a named role.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDecode.\n",
                "properties": {
                    "batchInputs": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        },
                        "description": "Specifies a list of items to be decoded in a single batch. If this parameter is set, the top-level parameters 'value', 'transformation' and 'tweak' will be ignored. Each batch item within the list can specify these parameters instead.\n"
                    },
                    "batchResults": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        },
                        "description": "The result of decoding a batch.\n"
                    },
                    "decodedValue": {
                        "type": "string",
                        "description": "The result of decoding a value.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Path to where the back-end is mounted within Vault.\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "transformation": {
                        "type": "string",
                        "description": "The transformation to perform. If no value is provided and the role contains a single transformation, this value will be inferred from the role.\n"
                    },
                    "tweak": {
                        "type": "string",
                        "description": "The tweak value to use. Only applicable for FPE transformations\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "The value in which to decode.\n"
                    }
                },
                "type": "object",
                "required": [
                    "path",
                    "roleName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDecode.\n",
                "properties": {
                    "batchInputs": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        }
                    },
                    "batchResults": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        }
                    },
                    "decodedValue": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "path": {
                        "type": "string"
                    },
                    "roleName": {
                        "type": "string"
                    },
                    "transformation": {
                        "type": "string"
                    },
                    "tweak": {
                        "type": "string"
                    },
                    "value": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "batchResults",
                    "decodedValue",
                    "path",
                    "roleName",
                    "id"
                ]
            }
        },
        "vault:transform/getEncode:getEncode": {
            "description": "This data source supports the \"/transform/encode/{role_name}\" Vault endpoint.\n\nIt encodes the provided value using a named role.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getEncode.\n",
                "properties": {
                    "batchInputs": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        },
                        "description": "Specifies a list of items to be encoded in a single batch. If this parameter is set, the parameters 'value', 'transformation' and 'tweak' will be ignored. Each batch item within the list can specify these parameters instead.\n"
                    },
                    "batchResults": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        },
                        "description": "The result of encoding a batch.\n"
                    },
                    "encodedValue": {
                        "type": "string",
                        "description": "The result of encoding a value.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Path to where the back-end is mounted within Vault.\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "transformation": {
                        "type": "string",
                        "description": "The transformation to perform. If no value is provided and the role contains a single transformation, this value will be inferred from the role.\n"
                    },
                    "tweak": {
                        "type": "string",
                        "description": "The tweak value to use. Only applicable for FPE transformations\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "The value in which to encode.\n"
                    }
                },
                "type": "object",
                "required": [
                    "path",
                    "roleName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getEncode.\n",
                "properties": {
                    "batchInputs": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        }
                    },
                    "batchResults": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        }
                    },
                    "encodedValue": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "path": {
                        "type": "string"
                    },
                    "roleName": {
                        "type": "string"
                    },
                    "transformation": {
                        "type": "string"
                    },
                    "tweak": {
                        "type": "string"
                    },
                    "value": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "batchResults",
                    "encodedValue",
                    "path",
                    "roleName",
                    "id"
                ]
            }
        },
        "vault:transit/getDecrypt:getDecrypt": {
            "description": "This is a data source which can be used to decrypt ciphertext using a Vault Transit key.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst test = pulumi.output(vault.transit.getDecrypt({\n    backend: \"transit\",\n    ciphertext: \"vault:v1:S3GtnJ5GUNCWV+/pdL9+g1Feu/nzAv+RlmTmE91Tu0rBkeIU8MEb2nSspC/1IQ==\",\n    key: \"test\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntest = vault.transit.get_decrypt(backend=\"transit\",\n    ciphertext=\"vault:v1:S3GtnJ5GUNCWV+/pdL9+g1Feu/nzAv+RlmTmE91Tu0rBkeIU8MEb2nSspC/1IQ==\",\n    key=\"test\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var test = Output.Create(Vault.Transit.GetDecrypt.InvokeAsync(new Vault.Transit.GetDecryptArgs\n        {\n            Backend = \"transit\",\n            Ciphertext = \"vault:v1:S3GtnJ5GUNCWV+/pdL9+g1Feu/nzAv+RlmTmE91Tu0rBkeIU8MEb2nSspC/1IQ==\",\n            Key = \"test\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v5/go/vault/transit\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := transit.GetDecrypt(ctx, \u0026transit.GetDecryptArgs{\n\t\t\tBackend:    \"transit\",\n\t\t\tCiphertext: \"vault:v1:S3GtnJ5GUNCWV+/pdL9+g1Feu/nzAv+RlmTmE91Tu0rBkeIU8MEb2nSspC/1IQ==\",\n\t\t\tKey:        \"test\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getDecrypt.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the transit secret backend is mounted at, with no leading or trailing `/`.\n"
                    },
                    "ciphertext": {
                        "type": "string",
                        "description": "Ciphertext to be decoded.\n"
                    },
                    "context": {
                        "type": "string",
                        "description": "Context for key derivation. This is required if key derivation is enabled for this key.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "Specifies the name of the transit key to decrypt against.\n"
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "ciphertext",
                    "key"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDecrypt.\n",
                "properties": {
                    "backend": {
                        "type": "string"
                    },
                    "ciphertext": {
                        "type": "string"
                    },
                    "context": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "key": {
                        "type": "string"
                    },
                    "plaintext": {
                        "type": "string",
                        "description": "Decrypted plaintext returned from Vault\n"
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "ciphertext",
                    "key",
                    "plaintext",
                    "id"
                ]
            }
        },
        "vault:transit/getEncrypt:getEncrypt": {
            "description": "This is a data source which can be used to encrypt plaintext using a Vault Transit key.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getEncrypt.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the transit secret backend is mounted at, with no leading or trailing `/`.\n"
                    },
                    "context": {
                        "type": "string",
                        "description": "Context for key derivation. This is required if key derivation is enabled for this key.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "Specifies the name of the transit key to encrypt against.\n"
                    },
                    "keyVersion": {
                        "type": "integer",
                        "description": "The version of the key to use for encryption. If not set, uses the latest version. Must be greater than or equal to the key's `min_encryption_version`, if set.\n"
                    },
                    "plaintext": {
                        "type": "string",
                        "description": "Plaintext to be encoded.\n"
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "key",
                    "plaintext"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getEncrypt.\n",
                "properties": {
                    "backend": {
                        "type": "string"
                    },
                    "ciphertext": {
                        "type": "string",
                        "description": "Encrypted ciphertext returned from Vault\n"
                    },
                    "context": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "key": {
                        "type": "string"
                    },
                    "keyVersion": {
                        "type": "integer"
                    },
                    "plaintext": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "ciphertext",
                    "key",
                    "plaintext",
                    "id"
                ]
            }
        }
    },
    "language": {
        "csharp": {
            "compatibility": "tfbridge20",
            "namespaces": {
                "ad": "AD",
                "alicloud": "AliCloud",
                "appRole": "AppRole",
                "aws": "Aws",
                "azure": "Azure",
                "consul": "Consul",
                "database": "Database",
                "gcp": "Gcp",
                "generic": "Generic",
                "github": "GitHub",
                "identity": "Identity",
                "index": "index",
                "jwt": "Jwt",
                "kmip": "Kmip",
                "kubernetes": "Kubernetes",
                "ldap": "Ldap",
                "okta": "Okta",
                "pkiSecret": "PkiSecret",
                "rabbitMq": "RabbitMQ",
                "ssh": "Ssh",
                "terraformcloud": "TerraformCloud",
                "tokenauth": "TokenAuth",
                "transform": "Transform",
                "transit": "Transit",
                "vault": "Vault"
            },
            "packageReferences": {
                "Pulumi": "3.*"
            }
        },
        "go": {
            "generateExtraInputTypes": true,
            "generateResourceContainerTypes": true,
            "importBasePath": "github.com/pulumi/pulumi-vault/sdk/v5/go/vault"
        },
        "nodejs": {
            "compatibility": "tfbridge20",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^10.0.0"
            },
            "disableUnionOutputTypes": true,
            "packageDescription": "A Pulumi package for creating and managing vault cloud resources.",
            "packageName": "",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/hashicorp/terraform-provider-vault)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi/pulumi-vault` repo](https://github.com/pulumi/pulumi-vault/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`hashicorp/terraform-provider-vault` repo](https://github.com/hashicorp/terraform-provider-vault/issues).",
            "typescriptVersion": ""
        },
        "python": {
            "compatibility": "tfbridge20",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/hashicorp/terraform-provider-vault)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi/pulumi-vault` repo](https://github.com/pulumi/pulumi-vault/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`hashicorp/terraform-provider-vault` repo](https://github.com/hashicorp/terraform-provider-vault/issues).",
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            }
        }
    }
}