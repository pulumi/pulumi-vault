{
    "name": "vault",
    "description": "A Pulumi package for creating and managing vault cloud resources.",
    "keywords": [
        "pulumi",
        "vault"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`vault` Terraform Provider](https://github.com/terraform-providers/terraform-provider-vault).",
    "repository": "https://github.com/pulumi/pulumi-vault",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "config": {
        "variables": {
            "addAddressToEnv": {
                "type": "string",
                "description": "If true, adds the value of the `address` argument to the Terraform process environment.\n"
            },
            "address": {
                "type": "string",
                "description": "URL of the root of the target Vault server.\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_ADDR"
                    ]
                }
            },
            "authLogins": {
                "type": "array",
                "items": {
                    "$ref": "#/types/vault:config/authLogins:authLogins"
                },
                "description": "Login to vault with an existing auth method using auth/\u003cmount\u003e/login\n"
            },
            "caCertDir": {
                "type": "string",
                "description": "Path to directory containing CA certificate files to validate the server's certificate.\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_CAPATH"
                    ]
                }
            },
            "caCertFile": {
                "type": "string",
                "description": "Path to a CA certificate file to validate the server's certificate.\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_CACERT"
                    ]
                }
            },
            "clientAuths": {
                "type": "array",
                "items": {
                    "$ref": "#/types/vault:config/clientAuths:clientAuths"
                },
                "description": "Client authentication credentials.\n"
            },
            "headers": {
                "type": "array",
                "items": {
                    "$ref": "#/types/vault:config/headers:headers"
                },
                "description": "The headers to send with each Vault request.\n"
            },
            "maxLeaseTtlSeconds": {
                "type": "integer",
                "description": "Maximum TTL for secret leases requested by this provider\n",
                "default": 1200,
                "defaultInfo": {
                    "environment": [
                        "TERRAFORM_VAULT_MAX_TTL"
                    ]
                }
            },
            "maxRetries": {
                "type": "integer",
                "description": "Maximum number of retries when a 5xx error code is encountered.\n",
                "default": 2,
                "defaultInfo": {
                    "environment": [
                        "VAULT_MAX_RETRIES"
                    ]
                }
            },
            "namespace": {
                "type": "string",
                "description": "The namespace to use. Available only for Vault Enterprise\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_NAMESPACE"
                    ]
                }
            },
            "skipTlsVerify": {
                "type": "boolean",
                "description": "Set this to true only if the target Vault server is an insecure development instance.\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_SKIP_VERIFY"
                    ]
                }
            },
            "token": {
                "type": "string",
                "description": "Token to use to authenticate to Vault.\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_TOKEN"
                    ]
                }
            },
            "tokenName": {
                "type": "string",
                "description": "Token name to use for creating the Vault child token.\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_TOKEN_NAME"
                    ]
                }
            }
        },
        "defaults": [
            "address",
            "token"
        ]
    },
    "types": {
        "vault:/AuthBackendTune:AuthBackendTune": {
            "properties": {
                "allowedResponseHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of headers to whitelist and allowing\na plugin to include them in the response.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "auditNonHmacRequestKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will\nnot be HMAC'd by audit devices in the request data object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "auditNonHmacResponseKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will\nnot be HMAC'd by audit devices in the response data object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "defaultLeaseTtl": {
                    "type": "string",
                    "description": "Specifies the default time-to-live.\nIf set, this overrides the global default.\nMust be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "listingVisibility": {
                    "type": "string",
                    "description": "Specifies whether to show this mount in\nthe UI-specific listing endpoint. Valid values are \"unauth\" or \"hidden\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxLeaseTtl": {
                    "type": "string",
                    "description": "Specifies the maximum time-to-live.\nIf set, this overrides the global default.\nMust be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "passthroughRequestHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of headers to whitelist and\npass from the request to the backend.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tokenType": {
                    "type": "string",
                    "description": "Specifies the type of tokens that should be returned by\nthe mount. Valid values are \"default-service\", \"default-batch\", \"service\", \"batch\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:/getPolicyDocumentRule:getPolicyDocumentRule": {
            "properties": {
                "allowedParameters": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:/getPolicyDocumentRuleAllowedParameter:getPolicyDocumentRuleAllowedParameter"
                    },
                    "description": "Whitelists a list of keys and values that are permitted on the given path. See Parameters below.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "capabilities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of capabilities that this rule apply to `path`. For example, [\"read\", \"write\"].\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "deniedParameters": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:/getPolicyDocumentRuleDeniedParameter:getPolicyDocumentRuleDeniedParameter"
                    },
                    "description": "Blacklists a list of parameter and values. Any values specified here take precedence over `allowed_parameter`. See Parameters below.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "description": "Description of the rule. Will be added as a commend to rendered rule.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxWrappingTtl": {
                    "type": "string",
                    "description": "The maximum allowed TTL that clients can specify for a wrapped response.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minWrappingTtl": {
                    "type": "string",
                    "description": "The minimum allowed TTL that clients can specify for a wrapped response.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "description": "A path in Vault that this rule applies to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "requiredParameters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of parameters that must be specified.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "capabilities",
                "path"
            ]
        },
        "vault:/getPolicyDocumentRuleAllowedParameter:getPolicyDocumentRuleAllowedParameter": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "name of permitted or denied parameter.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "list of values what are permitted or denied by policy rule.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "key",
                "values"
            ]
        },
        "vault:/getPolicyDocumentRuleDeniedParameter:getPolicyDocumentRuleDeniedParameter": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "name of permitted or denied parameter.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "list of values what are permitted or denied by policy rule.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "key",
                "values"
            ]
        },
        "vault:azure/BackendRoleAzureRole:BackendRoleAzureRole": {
            "properties": {
                "roleId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "scope": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "roleName",
                "scope"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "roleId",
                        "roleName",
                        "scope"
                    ]
                }
            }
        },
        "vault:config/authLogins:authLogins": {
            "properties": {
                "namespace": {
                    "type": "string"
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "path": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "path"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vault:config/clientAuths:clientAuths": {
            "properties": {
                "certFile": {
                    "type": "string"
                },
                "keyFile": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "certFile",
                "keyFile"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vault:config/headers:headers": {
            "properties": {
                "name": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vault:database/SecretBackendConnectionCassandra:SecretBackendConnectionCassandra": {
            "properties": {
                "connectTimeout": {
                    "type": "integer",
                    "description": "The number of seconds to use as a connection\ntimeout.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The hosts to connect to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Whether to skip verification of the server\ncertificate when using TLS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The password to be used in the connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pemBundle": {
                    "type": "string",
                    "description": "Concatenated PEM blocks configuring the certificate\nchain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pemJson": {
                    "type": "string",
                    "description": "A JSON structure configuring the certificate chain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "port": {
                    "type": "integer",
                    "description": "The default port to connect to if no port is specified as\npart of the host.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "protocolVersion": {
                    "type": "integer",
                    "description": "The CQL protocol version to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tls": {
                    "type": "boolean",
                    "description": "Whether to use TLS when connecting to Cassandra.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The username to be used in the connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionElasticsearch:SecretBackendConnectionElasticsearch": {
            "properties": {
                "password": {
                    "type": "string",
                    "description": "The password to be used in the connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "url": {
                    "type": "string",
                    "description": "The URL for Elasticsearch's API. https requires certificate\nby trusted CA if used.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The username to be used in the connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "password",
                "url",
                "username"
            ]
        },
        "vault:database/SecretBackendConnectionHana:SecretBackendConnectionHana": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/oracle.html#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionMongodb:SecretBackendConnectionMongodb": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/oracle.html#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionMssql:SecretBackendConnectionMssql": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/oracle.html#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionMysql:SecretBackendConnectionMysql": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/oracle.html#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionMysqlAurora:SecretBackendConnectionMysqlAurora": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/oracle.html#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionMysqlLegacy:SecretBackendConnectionMysqlLegacy": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/oracle.html#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionMysqlRds:SecretBackendConnectionMysqlRds": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/oracle.html#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionOracle:SecretBackendConnectionOracle": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/oracle.html#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionPostgresql:SecretBackendConnectionPostgresql": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information. See\nthe [Vault\ndocs](https://www.vaultproject.io/api-docs/secret/databases/oracle.html#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:gcp/SecretRolesetBinding:SecretRolesetBinding": {
            "properties": {
                "resource": {
                    "type": "string",
                    "description": "Resource or resource path for which IAM policy information will be bound. The resource path may be specified in a few different [formats](https://www.vaultproject.io/docs/secrets/gcp/index.html#roleset-bindings).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of [GCP IAM roles](https://cloud.google.com/iam/docs/understanding-roles) for the resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "resource",
                "roles"
            ]
        },
        "vault:github/AuthBackendTune:AuthBackendTune": {
            "properties": {
                "allowedResponseHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of headers to whitelist and allowing\na plugin to include them in the response.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "auditNonHmacRequestKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will\nnot be HMAC'd by audit devices in the request data object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "auditNonHmacResponseKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will\nnot be HMAC'd by audit devices in the response data object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "defaultLeaseTtl": {
                    "type": "string",
                    "description": "Specifies the default time-to-live.\nIf set, this overrides the global default.\nMust be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "listingVisibility": {
                    "type": "string",
                    "description": "Specifies whether to show this mount in\nthe UI-specific listing endpoint. Valid values are \"unauth\" or \"hidden\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxLeaseTtl": {
                    "type": "string",
                    "description": "Specifies the maximum time-to-live.\nIf set, this overrides the global default.\nMust be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "passthroughRequestHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of headers to whitelist and\npass from the request to the backend.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tokenType": {
                    "type": "string",
                    "description": "Specifies the type of tokens that should be returned by\nthe mount. Valid values are \"default-service\", \"default-batch\", \"service\", \"batch\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:identity/getEntityAlias:getEntityAlias": {
            "properties": {
                "canonicalId": {
                    "type": "string",
                    "description": "Canonical ID of the Alias\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "creationTime": {
                    "type": "string",
                    "description": "Creation time of the Alias\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "ID of the alias\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lastUpdateTime": {
                    "type": "string",
                    "description": "Last update time of the alias\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mergedFromCanonicalIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of canonical IDs merged with this alias\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Arbitrary metadata\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "Authentication mount acccessor which this alias belongs to\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mountPath": {
                    "type": "string",
                    "description": "Authentication mount path which this alias belongs to\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mountType": {
                    "type": "string",
                    "description": "Authentication mount type which this alias belongs to\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of the alias\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "canonicalId",
                "creationTime",
                "id",
                "lastUpdateTime",
                "mergedFromCanonicalIds",
                "metadata",
                "mountAccessor",
                "mountPath",
                "mountType",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vault:index/ProviderAuthLogin:ProviderAuthLogin": {
            "properties": {
                "namespace": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "path"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": []
                }
            }
        },
        "vault:index/ProviderClientAuth:ProviderClientAuth": {
            "properties": {
                "certFile": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyFile": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "certFile",
                "keyFile"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": []
                }
            }
        },
        "vault:index/ProviderHeader:ProviderHeader": {
            "properties": {
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": []
                }
            }
        },
        "vault:jwt/AuthBackendTune:AuthBackendTune": {
            "properties": {
                "allowedResponseHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of headers to whitelist and allowing\na plugin to include them in the response.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "auditNonHmacRequestKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will\nnot be HMAC'd by audit devices in the request data object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "auditNonHmacResponseKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will\nnot be HMAC'd by audit devices in the response data object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "defaultLeaseTtl": {
                    "type": "string",
                    "description": "Specifies the default time-to-live.\nIf set, this overrides the global default.\nMust be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "listingVisibility": {
                    "type": "string",
                    "description": "Specifies whether to show this mount in\nthe UI-specific listing endpoint. Valid values are \"unauth\" or \"hidden\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxLeaseTtl": {
                    "type": "string",
                    "description": "Specifies the maximum time-to-live.\nIf set, this overrides the global default.\nMust be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "passthroughRequestHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of headers to whitelist and\npass from the request to the backend.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tokenType": {
                    "type": "string",
                    "description": "Specifies the type of tokens that should be returned by\nthe mount. Valid values are \"default-service\", \"default-batch\", \"service\", \"batch\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:okta/AuthBackendGroup:AuthBackendGroup": {
            "properties": {
                "groupName": {
                    "type": "string",
                    "description": "Name of the group within the Okta\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Vault policies to associate with this user\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "groupName",
                "policies"
            ]
        },
        "vault:okta/AuthBackendUser:AuthBackendUser": {
            "properties": {
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Okta groups to associate with this user\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Vault policies to associate with this user\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "Name of the user within Okta\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "groups",
                "username"
            ]
        },
        "vault:rabbitMq/SecretBackendRoleVhost:SecretBackendRoleVhost": {
            "properties": {
                "configure": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "read": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "write": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "configure",
                "host",
                "read",
                "write"
            ]
        }
    },
    "provider": {
        "description": "The provider type for the vault package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "inputProperties": {
            "addAddressToEnv": {
                "type": "string",
                "description": "If true, adds the value of the `address` argument to the Terraform process environment.\n"
            },
            "address": {
                "type": "string",
                "description": "URL of the root of the target Vault server.\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_ADDR"
                    ]
                }
            },
            "authLogins": {
                "type": "array",
                "items": {
                    "$ref": "#/types/vault:index/ProviderAuthLogin:ProviderAuthLogin"
                },
                "description": "Login to vault with an existing auth method using auth/\u003cmount\u003e/login\n"
            },
            "caCertDir": {
                "type": "string",
                "description": "Path to directory containing CA certificate files to validate the server's certificate.\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_CAPATH"
                    ]
                }
            },
            "caCertFile": {
                "type": "string",
                "description": "Path to a CA certificate file to validate the server's certificate.\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_CACERT"
                    ]
                }
            },
            "clientAuths": {
                "type": "array",
                "items": {
                    "$ref": "#/types/vault:index/ProviderClientAuth:ProviderClientAuth"
                },
                "description": "Client authentication credentials.\n"
            },
            "headers": {
                "type": "array",
                "items": {
                    "$ref": "#/types/vault:index/ProviderHeader:ProviderHeader"
                },
                "description": "The headers to send with each Vault request.\n"
            },
            "maxLeaseTtlSeconds": {
                "type": "integer",
                "description": "Maximum TTL for secret leases requested by this provider\n",
                "default": 1200,
                "defaultInfo": {
                    "environment": [
                        "TERRAFORM_VAULT_MAX_TTL"
                    ]
                }
            },
            "maxRetries": {
                "type": "integer",
                "description": "Maximum number of retries when a 5xx error code is encountered.\n",
                "default": 2,
                "defaultInfo": {
                    "environment": [
                        "VAULT_MAX_RETRIES"
                    ]
                }
            },
            "namespace": {
                "type": "string",
                "description": "The namespace to use. Available only for Vault Enterprise\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_NAMESPACE"
                    ]
                }
            },
            "skipTlsVerify": {
                "type": "boolean",
                "description": "Set this to true only if the target Vault server is an insecure development instance.\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_SKIP_VERIFY"
                    ]
                }
            },
            "token": {
                "type": "string",
                "description": "Token to use to authenticate to Vault.\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_TOKEN"
                    ]
                }
            },
            "tokenName": {
                "type": "string",
                "description": "Token name to use for creating the Vault child token.\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_TOKEN_NAME"
                    ]
                }
            }
        }
    },
    "resources": {
        "vault:alicloud/authBackendRole:AuthBackendRole": {
            "properties": {
                "arn": {
                    "type": "string",
                    "description": "The role's arn.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Auth backend.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the role. Must correspond with the name of the role reflected in the arn.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n"
                }
            },
            "required": [
                "arn",
                "role"
            ],
            "inputProperties": {
                "arn": {
                    "type": "string",
                    "description": "The role's arn.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Auth backend.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the role. Must correspond with the name of the role reflected in the arn.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n"
                }
            },
            "requiredInputs": [
                "arn",
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "arn": {
                        "type": "string",
                        "description": "The role's arn.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "Auth backend.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "Name of the role. Must correspond with the name of the role reflected in the arn.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime of the generated token\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "Generated Token's Period\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Generated Token's Policies\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The initial ttl of the token to generate in seconds\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token to generate, service or batch\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:appRole/authBackendLogin:AuthBackendLogin": {
            "description": "Logs into Vault using the AppRole auth backend. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/approle) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst approle = new vault.AuthBackend(\"approle\", {\n    type: \"approle\",\n});\nconst example = new vault.appRole.AuthBackendRole(\"example\", {\n    backend: approle.path,\n    policies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    roleName: \"test-role\",\n});\nconst id = new vault.appRole.AuthBackendRoleSecretID(\"id\", {\n    backend: approle.path,\n    roleName: example.roleName,\n});\nconst login = new vault.appRole.AuthBackendLogin(\"login\", {\n    backend: approle.path,\n    roleId: example.roleId,\n    secretId: id.secretId,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\napprole = vault.AuthBackend(\"approle\", type=\"approle\")\nexample = vault.app_role.AuthBackendRole(\"example\",\n    backend=approle.path,\n    policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    role_name=\"test-role\")\nid = vault.app_role.AuthBackendRoleSecretID(\"id\",\n    backend=approle.path,\n    role_name=example.role_name)\nlogin = vault.app_role.AuthBackendLogin(\"login\",\n    backend=approle.path,\n    role_id=example.role_id,\n    secret_id=id.secret_id)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var approle = new Vault.AuthBackend(\"approle\", new Vault.AuthBackendArgs\n        {\n            Type = \"approle\",\n        });\n        var example = new Vault.AppRole.AuthBackendRole(\"example\", new Vault.AppRole.AuthBackendRoleArgs\n        {\n            Backend = approle.Path,\n            Policies = \n            {\n                \"default\",\n                \"dev\",\n                \"prod\",\n            },\n            RoleName = \"test-role\",\n        });\n        var id = new Vault.AppRole.AuthBackendRoleSecretID(\"id\", new Vault.AppRole.AuthBackendRoleSecretIDArgs\n        {\n            Backend = approle.Path,\n            RoleName = example.RoleName,\n        });\n        var login = new Vault.AppRole.AuthBackendLogin(\"login\", new Vault.AppRole.AuthBackendLoginArgs\n        {\n            Backend = approle.Path,\n            RoleId = example.RoleId,\n            SecretId = id.SecretId,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/appRole\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tapprole, err := vault.NewAuthBackend(ctx, \"approle\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"approle\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texample, err := appRole.NewAuthBackendRole(ctx, \"example\", \u0026appRole.AuthBackendRoleArgs{\n\t\t\tBackend: approle.Path,\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t\tRoleName: pulumi.String(\"test-role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tid, err := appRole.NewAuthBackendRoleSecretID(ctx, \"id\", \u0026appRole.AuthBackendRoleSecretIDArgs{\n\t\t\tBackend:  approle.Path,\n\t\t\tRoleName: example.RoleName,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = appRole.NewAuthBackendLogin(ctx, \"login\", \u0026appRole.AuthBackendLoginArgs{\n\t\t\tBackend:  approle.Path,\n\t\t\tRoleId:   example.RoleId,\n\t\t\tSecretId: id.SecretId,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The accessor for the token.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique path of the Vault backend to log in with.\n"
                },
                "clientToken": {
                    "type": "string",
                    "description": "The Vault token created.\n"
                },
                "leaseDuration": {
                    "type": "integer",
                    "description": "How long the token is valid for, in seconds.\n"
                },
                "leaseStarted": {
                    "type": "string",
                    "description": "The date and time the lease started, in RFC 3339 format.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The metadata associated with the token.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of policies applied to the token.\n"
                },
                "renewable": {
                    "type": "boolean",
                    "description": "Whether the token is renewable or not.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "The ID of the role to log in with.\n"
                },
                "secretId": {
                    "type": "string",
                    "description": "The secret ID of the role to log in with. Required\nunless `bind_secret_id` is set to false on the role.\n"
                }
            },
            "required": [
                "accessor",
                "clientToken",
                "leaseDuration",
                "leaseStarted",
                "metadata",
                "policies",
                "renewable",
                "roleId"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The unique path of the Vault backend to log in with.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "The ID of the role to log in with.\n"
                },
                "secretId": {
                    "type": "string",
                    "description": "The secret ID of the role to log in with. Required\nunless `bind_secret_id` is set to false on the role.\n"
                }
            },
            "requiredInputs": [
                "roleId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendLogin resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The accessor for the token.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The unique path of the Vault backend to log in with.\n"
                    },
                    "clientToken": {
                        "type": "string",
                        "description": "The Vault token created.\n"
                    },
                    "leaseDuration": {
                        "type": "integer",
                        "description": "How long the token is valid for, in seconds.\n"
                    },
                    "leaseStarted": {
                        "type": "string",
                        "description": "The date and time the lease started, in RFC 3339 format.\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "The metadata associated with the token.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of policies applied to the token.\n"
                    },
                    "renewable": {
                        "type": "boolean",
                        "description": "Whether the token is renewable or not.\n"
                    },
                    "roleId": {
                        "type": "string",
                        "description": "The ID of the role to log in with.\n"
                    },
                    "secretId": {
                        "type": "string",
                        "description": "The secret ID of the role to log in with. Required\nunless `bind_secret_id` is set to false on the role.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:appRole/authBackendRole:AuthBackendRole": {
            "description": "Manages an AppRole auth backend role in a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/approle) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst approle = new vault.AuthBackend(\"approle\", {type: \"approle\"});\nconst example = new vault.appRole.AuthBackendRole(\"example\", {\n    backend: approle.path,\n    roleName: \"test-role\",\n    tokenPolicies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\napprole = vault.AuthBackend(\"approle\", type=\"approle\")\nexample = vault.app_role.AuthBackendRole(\"example\",\n    backend=approle.path,\n    role_name=\"test-role\",\n    token_policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ])\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var approle = new Vault.AuthBackend(\"approle\", new Vault.AuthBackendArgs\n        {\n            Type = \"approle\",\n        });\n        var example = new Vault.AppRole.AuthBackendRole(\"example\", new Vault.AppRole.AuthBackendRoleArgs\n        {\n            Backend = approle.Path,\n            RoleName = \"test-role\",\n            TokenPolicies = \n            {\n                \"default\",\n                \"dev\",\n                \"prod\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/appRole\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tapprole, err := vault.NewAuthBackend(ctx, \"approle\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"approle\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = appRole.NewAuthBackendRole(ctx, \"example\", \u0026appRole.AuthBackendRoleArgs{\n\t\t\tBackend:  approle.Path,\n\t\t\tRoleName: pulumi.String(\"test-role\"),\n\t\t\tTokenPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of the auth backend to configure.\nDefaults to `approle`.\n"
                },
                "bindSecretId": {
                    "type": "boolean",
                    "description": "Whether or not to require `secret_id` to be\npresented when logging in using this AppRole. Defaults to `true`.\n"
                },
                "boundCidrLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set,\nspecifies blocks of IP addresses which can perform the login operation.\n",
                    "deprecationMessage": "use `secret_id_bound_cidrs` instead"
                },
                "period": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings\nspecifying the policies to be set on tokens issued using this role.\n",
                    "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                },
                "roleId": {
                    "type": "string",
                    "description": "The RoleID of this role. If not specified, one will be\nauto-generated.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "secretIdBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set,\nspecifies blocks of IP addresses which can perform the login operation.\n"
                },
                "secretIdNumUses": {
                    "type": "integer",
                    "description": "The number of times any particular SecretID\ncan be used to fetch a token from this AppRole, after which the SecretID will\nexpire. A value of zero will allow unlimited uses.\n"
                },
                "secretIdTtl": {
                    "type": "integer",
                    "description": "The number of seconds after which any SecretID\nexpires.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "required": [
                "roleId",
                "roleName"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of the auth backend to configure.\nDefaults to `approle`.\n"
                },
                "bindSecretId": {
                    "type": "boolean",
                    "description": "Whether or not to require `secret_id` to be\npresented when logging in using this AppRole. Defaults to `true`.\n"
                },
                "boundCidrLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set,\nspecifies blocks of IP addresses which can perform the login operation.\n",
                    "deprecationMessage": "use `secret_id_bound_cidrs` instead"
                },
                "period": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings\nspecifying the policies to be set on tokens issued using this role.\n",
                    "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                },
                "roleId": {
                    "type": "string",
                    "description": "The RoleID of this role. If not specified, one will be\nauto-generated.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "secretIdBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set,\nspecifies blocks of IP addresses which can perform the login operation.\n"
                },
                "secretIdNumUses": {
                    "type": "integer",
                    "description": "The number of times any particular SecretID\ncan be used to fetch a token from this AppRole, after which the SecretID will\nexpire. A value of zero will allow unlimited uses.\n"
                },
                "secretIdTtl": {
                    "type": "integer",
                    "description": "The number of seconds after which any SecretID\nexpires.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "requiredInputs": [
                "roleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The unique name of the auth backend to configure.\nDefaults to `approle`.\n"
                    },
                    "bindSecretId": {
                        "type": "boolean",
                        "description": "Whether or not to require `secret_id` to be\npresented when logging in using this AppRole. Defaults to `true`.\n"
                    },
                    "boundCidrLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set,\nspecifies blocks of IP addresses which can perform the login operation.\n",
                        "deprecationMessage": "use `secret_id_bound_cidrs` instead"
                    },
                    "period": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n",
                        "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of strings\nspecifying the policies to be set on tokens issued using this role.\n",
                        "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                    },
                    "roleId": {
                        "type": "string",
                        "description": "The RoleID of this role. If not specified, one will be\nauto-generated.\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "secretIdBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set,\nspecifies blocks of IP addresses which can perform the login operation.\n"
                    },
                    "secretIdNumUses": {
                        "type": "integer",
                        "description": "The number of times any particular SecretID\ncan be used to fetch a token from this AppRole, after which the SecretID will\nexpire. A value of zero will allow unlimited uses.\n"
                    },
                    "secretIdTtl": {
                        "type": "integer",
                        "description": "The number of seconds after which any SecretID\nexpires.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:appRole/authBackendRoleSecretID:AuthBackendRoleSecretID": {
            "description": "Manages an AppRole auth backend SecretID in a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/approle) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst approle = new vault.AuthBackend(\"approle\", {\n    type: \"approle\",\n});\nconst example = new vault.appRole.AuthBackendRole(\"example\", {\n    backend: approle.path,\n    policies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    roleName: \"test-role\",\n});\nconst id = new vault.appRole.AuthBackendRoleSecretID(\"id\", {\n    backend: approle.path,\n    metadata: `{\n  \"hello\": \"world\"\n}\n`,\n    roleName: example.roleName,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\napprole = vault.AuthBackend(\"approle\", type=\"approle\")\nexample = vault.app_role.AuthBackendRole(\"example\",\n    backend=approle.path,\n    policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    role_name=\"test-role\")\nid = vault.app_role.AuthBackendRoleSecretID(\"id\",\n    backend=approle.path,\n    metadata=\"\"\"{\n  \"hello\": \"world\"\n}\n\n\"\"\",\n    role_name=example.role_name)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var approle = new Vault.AuthBackend(\"approle\", new Vault.AuthBackendArgs\n        {\n            Type = \"approle\",\n        });\n        var example = new Vault.AppRole.AuthBackendRole(\"example\", new Vault.AppRole.AuthBackendRoleArgs\n        {\n            Backend = approle.Path,\n            Policies = \n            {\n                \"default\",\n                \"dev\",\n                \"prod\",\n            },\n            RoleName = \"test-role\",\n        });\n        var id = new Vault.AppRole.AuthBackendRoleSecretID(\"id\", new Vault.AppRole.AuthBackendRoleSecretIDArgs\n        {\n            Backend = approle.Path,\n            Metadata = @\"{\n  \"\"hello\"\": \"\"world\"\"\n}\n\n\",\n            RoleName = example.RoleName,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/appRole\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tapprole, err := vault.NewAuthBackend(ctx, \"approle\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"approle\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texample, err := appRole.NewAuthBackendRole(ctx, \"example\", \u0026appRole.AuthBackendRoleArgs{\n\t\t\tBackend: approle.Path,\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t\tRoleName: pulumi.String(\"test-role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = appRole.NewAuthBackendRoleSecretID(ctx, \"id\", \u0026appRole.AuthBackendRoleSecretIDArgs{\n\t\t\tBackend:  approle.Path,\n\t\t\tMetadata: pulumi.String(fmt.Sprintf(\"%v%v%v%v\", \"{\\n\", \"  \\\"hello\\\": \\\"world\\\"\\n\", \"}\\n\", \"\\n\")),\n\t\t\tRoleName: example.RoleName,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The unique ID for this SecretID that can be safely logged.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Unique name of the auth backend to configure.\n"
                },
                "cidrLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, specifies blocks of IP addresses which can\nperform the login operation using this SecretID.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "A JSON-encoded string containing metadata in\nkey-value pairs to be set on tokens issued with this SecretID.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role to create the SecretID for.\n"
                },
                "secretId": {
                    "type": "string",
                    "description": "The SecretID to be created. If set, uses \"Push\"\nmode.  Defaults to Vault auto-generating SecretIDs.\n"
                },
                "wrappingAccessor": {
                    "type": "string",
                    "description": "The unique ID for the response-wrapped SecretID that can\nbe safely logged.\n"
                },
                "wrappingToken": {
                    "type": "string",
                    "description": "The token used to retrieve a response-wrapped SecretID.\n"
                },
                "wrappingTtl": {
                    "type": "string",
                    "description": "If set, the SecretID response will be\n[response-wrapped](https://www.vaultproject.io/docs/concepts/response-wrapping)\nand available for the duration specified. Only a single unwrapping of the\ntoken is allowed.\n"
                }
            },
            "required": [
                "accessor",
                "roleName",
                "secretId",
                "wrappingAccessor",
                "wrappingToken"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Unique name of the auth backend to configure.\n"
                },
                "cidrLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, specifies blocks of IP addresses which can\nperform the login operation using this SecretID.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "A JSON-encoded string containing metadata in\nkey-value pairs to be set on tokens issued with this SecretID.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role to create the SecretID for.\n"
                },
                "secretId": {
                    "type": "string",
                    "description": "The SecretID to be created. If set, uses \"Push\"\nmode.  Defaults to Vault auto-generating SecretIDs.\n"
                },
                "wrappingTtl": {
                    "type": "string",
                    "description": "If set, the SecretID response will be\n[response-wrapped](https://www.vaultproject.io/docs/concepts/response-wrapping)\nand available for the duration specified. Only a single unwrapping of the\ntoken is allowed.\n"
                }
            },
            "requiredInputs": [
                "roleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRoleSecretID resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The unique ID for this SecretID that can be safely logged.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "Unique name of the auth backend to configure.\n"
                    },
                    "cidrLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, specifies blocks of IP addresses which can\nperform the login operation using this SecretID.\n"
                    },
                    "metadata": {
                        "type": "string",
                        "description": "A JSON-encoded string containing metadata in\nkey-value pairs to be set on tokens issued with this SecretID.\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role to create the SecretID for.\n"
                    },
                    "secretId": {
                        "type": "string",
                        "description": "The SecretID to be created. If set, uses \"Push\"\nmode.  Defaults to Vault auto-generating SecretIDs.\n"
                    },
                    "wrappingAccessor": {
                        "type": "string",
                        "description": "The unique ID for the response-wrapped SecretID that can\nbe safely logged.\n"
                    },
                    "wrappingToken": {
                        "type": "string",
                        "description": "The token used to retrieve a response-wrapped SecretID.\n"
                    },
                    "wrappingTtl": {
                        "type": "string",
                        "description": "If set, the SecretID response will be\n[response-wrapped](https://www.vaultproject.io/docs/concepts/response-wrapping)\nand available for the duration specified. Only a single unwrapping of the\ntoken is allowed.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendCert:AuthBackendCert": {
            "properties": {
                "awsPublicCert": {
                    "type": "string",
                    "description": "The  Base64 encoded AWS Public key required to\nverify PKCS7 signature of the EC2 instance metadata. You can find this key in\nthe [AWS\ndocumentation](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-identity-documents.html).\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                },
                "certName": {
                    "type": "string",
                    "description": "The name of the certificate.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Either \"pkcs7\" or \"identity\", indicating the type of\ndocument which can be verified using the given certificate. Defaults to\n\"pkcs7\".\n"
                }
            },
            "required": [
                "awsPublicCert",
                "certName"
            ],
            "inputProperties": {
                "awsPublicCert": {
                    "type": "string",
                    "description": "The  Base64 encoded AWS Public key required to\nverify PKCS7 signature of the EC2 instance metadata. You can find this key in\nthe [AWS\ndocumentation](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-identity-documents.html).\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                },
                "certName": {
                    "type": "string",
                    "description": "The name of the certificate.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Either \"pkcs7\" or \"identity\", indicating the type of\ndocument which can be verified using the given certificate. Defaults to\n\"pkcs7\".\n"
                }
            },
            "requiredInputs": [
                "awsPublicCert",
                "certName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendCert resources.\n",
                "properties": {
                    "awsPublicCert": {
                        "type": "string",
                        "description": "The  Base64 encoded AWS Public key required to\nverify PKCS7 signature of the EC2 instance metadata. You can find this key in\nthe [AWS\ndocumentation](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-identity-documents.html).\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                    },
                    "certName": {
                        "type": "string",
                        "description": "The name of the certificate.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Either \"pkcs7\" or \"identity\", indicating the type of\ndocument which can be verified using the given certificate. Defaults to\n\"pkcs7\".\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendClient:AuthBackendClient": {
            "properties": {
                "accessKey": {
                    "type": "string",
                    "description": "The AWS access key that Vault should use for the\nauth backend.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                },
                "ec2Endpoint": {
                    "type": "string",
                    "description": "Override the URL Vault uses when making EC2 API\ncalls.\n"
                },
                "iamEndpoint": {
                    "type": "string",
                    "description": "Override the URL Vault uses when making IAM API\ncalls.\n"
                },
                "iamServerIdHeaderValue": {
                    "type": "string",
                    "description": "The value to require in the\n`X-Vault-AWS-IAM-Server-ID` header as part of `GetCallerIdentity` requests\nthat are used in the IAM auth method.\n"
                },
                "secretKey": {
                    "type": "string",
                    "description": "The AWS secret key that Vault should use for the\nauth backend.\n"
                },
                "stsEndpoint": {
                    "type": "string",
                    "description": "Override the URL Vault uses when making STS API\ncalls.\n"
                }
            },
            "inputProperties": {
                "accessKey": {
                    "type": "string",
                    "description": "The AWS access key that Vault should use for the\nauth backend.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                },
                "ec2Endpoint": {
                    "type": "string",
                    "description": "Override the URL Vault uses when making EC2 API\ncalls.\n"
                },
                "iamEndpoint": {
                    "type": "string",
                    "description": "Override the URL Vault uses when making IAM API\ncalls.\n"
                },
                "iamServerIdHeaderValue": {
                    "type": "string",
                    "description": "The value to require in the\n`X-Vault-AWS-IAM-Server-ID` header as part of `GetCallerIdentity` requests\nthat are used in the IAM auth method.\n"
                },
                "secretKey": {
                    "type": "string",
                    "description": "The AWS secret key that Vault should use for the\nauth backend.\n"
                },
                "stsEndpoint": {
                    "type": "string",
                    "description": "Override the URL Vault uses when making STS API\ncalls.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendClient resources.\n",
                "properties": {
                    "accessKey": {
                        "type": "string",
                        "description": "The AWS access key that Vault should use for the\nauth backend.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                    },
                    "ec2Endpoint": {
                        "type": "string",
                        "description": "Override the URL Vault uses when making EC2 API\ncalls.\n"
                    },
                    "iamEndpoint": {
                        "type": "string",
                        "description": "Override the URL Vault uses when making IAM API\ncalls.\n"
                    },
                    "iamServerIdHeaderValue": {
                        "type": "string",
                        "description": "The value to require in the\n`X-Vault-AWS-IAM-Server-ID` header as part of `GetCallerIdentity` requests\nthat are used in the IAM auth method.\n"
                    },
                    "secretKey": {
                        "type": "string",
                        "description": "The AWS secret key that Vault should use for the\nauth backend.\n"
                    },
                    "stsEndpoint": {
                        "type": "string",
                        "description": "Override the URL Vault uses when making STS API\ncalls.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendIdentityWhitelist:AuthBackendIdentityWhitelist": {
            "description": "Configures the periodic tidying operation of the whitelisted identity entries.\n\nFor more information, see the\n[Vault docs](https://www.vaultproject.io/api-docs/auth/aws#configure-identity-whitelist-tidy-operation).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst exampleAuthBackend = new vault.AuthBackend(\"example\", {\n    type: \"aws\",\n});\nconst exampleAuthBackendIdentityWhitelist = new vault.aws.AuthBackendIdentityWhitelist(\"example\", {\n    backend: exampleAuthBackend.path,\n    safetyBuffer: 3600,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample_auth_backend = vault.AuthBackend(\"exampleAuthBackend\", type=\"aws\")\nexample_auth_backend_identity_whitelist = vault.aws.AuthBackendIdentityWhitelist(\"exampleAuthBackendIdentityWhitelist\",\n    backend=example_auth_backend.path,\n    safety_buffer=3600)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleAuthBackend = new Vault.AuthBackend(\"exampleAuthBackend\", new Vault.AuthBackendArgs\n        {\n            Type = \"aws\",\n        });\n        var exampleAuthBackendIdentityWhitelist = new Vault.Aws.AuthBackendIdentityWhitelist(\"exampleAuthBackendIdentityWhitelist\", new Vault.Aws.AuthBackendIdentityWhitelistArgs\n        {\n            Backend = exampleAuthBackend.Path,\n            SafetyBuffer = 3600,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/aws\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleAuthBackend, err := vault.NewAuthBackend(ctx, \"exampleAuthBackend\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"aws\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = aws.NewAuthBackendIdentityWhitelist(ctx, \"exampleAuthBackendIdentityWhitelist\", \u0026aws.AuthBackendIdentityWhitelistArgs{\n\t\t\tBackend:      exampleAuthBackend.Path,\n\t\t\tSafetyBuffer: pulumi.Int(3600),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path of the AWS backend being configured.\n"
                },
                "disablePeriodicTidy": {
                    "type": "boolean",
                    "description": "If set to true, disables the periodic\ntidying of the identity-whitelist entries.\n"
                },
                "safetyBuffer": {
                    "type": "integer",
                    "description": "The amount of extra time, in minutes, that must\nhave passed beyond the roletag expiration, before it is removed from the\nbackend storage.\n"
                }
            },
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path of the AWS backend being configured.\n"
                },
                "disablePeriodicTidy": {
                    "type": "boolean",
                    "description": "If set to true, disables the periodic\ntidying of the identity-whitelist entries.\n"
                },
                "safetyBuffer": {
                    "type": "integer",
                    "description": "The amount of extra time, in minutes, that must\nhave passed beyond the roletag expiration, before it is removed from the\nbackend storage.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendIdentityWhitelist resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path of the AWS backend being configured.\n"
                    },
                    "disablePeriodicTidy": {
                        "type": "boolean",
                        "description": "If set to true, disables the periodic\ntidying of the identity-whitelist entries.\n"
                    },
                    "safetyBuffer": {
                        "type": "integer",
                        "description": "The amount of extra time, in minutes, that must\nhave passed beyond the roletag expiration, before it is removed from the\nbackend storage.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendLogin:AuthBackendLogin": {
            "description": "Logs into a Vault server using an AWS auth backend. Login can be\naccomplished using a signed identity request from IAM or using ec2\ninstance metadata. For more information, see the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/aws.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst aws = new vault.AuthBackend(\"aws\", {\n    type: \"aws\",\n});\nconst exampleAuthBackendClient = new vault.aws.AuthBackendClient(\"example\", {\n    accessKey: \"123456789012\",\n    backend: aws.path,\n    secretKey: \"AWSSECRETKEYGOESHERE\",\n});\nconst exampleAuthBackendRole = new vault.aws.AuthBackendRole(\"example\", {\n    authType: \"ec2\",\n    backend: aws.path,\n    boundAccountId: \"123456789012\",\n    boundAmiId: \"ami-8c1be5f6\",\n    boundIamInstanceProfileArn: \"arn:aws:iam::123456789012:instance-profile/MyProfile\",\n    boundSubnetId: \"vpc-133128f1\",\n    boundVpcId: \"vpc-b61106d4\",\n    maxTtl: 120,\n    role: \"test-role\",\n    tokenPolicies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    ttl: 60,\n}, { dependsOn: [exampleAuthBackendClient] });\nconst exampleAuthBackendLogin = new vault.aws.AuthBackendLogin(\"example\", {\n    backend: vault_auth_backend_example.path,\n    identity: \"BASE64ENCODEDIDENTITYDOCUMENT\",\n    role: exampleAuthBackendRole.role,\n    signature: \"BASE64ENCODEDSHA256IDENTITYDOCUMENTSIGNATURE\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\naws = vault.AuthBackend(\"aws\", type=\"aws\")\nexample_auth_backend_client = vault.aws.AuthBackendClient(\"exampleAuthBackendClient\",\n    access_key=\"123456789012\",\n    backend=aws.path,\n    secret_key=\"AWSSECRETKEYGOESHERE\")\nexample_auth_backend_role = vault.aws.AuthBackendRole(\"exampleAuthBackendRole\",\n    auth_type=\"ec2\",\n    backend=aws.path,\n    bound_account_id=\"123456789012\",\n    bound_ami_id=\"ami-8c1be5f6\",\n    bound_iam_instance_profile_arn=\"arn:aws:iam::123456789012:instance-profile/MyProfile\",\n    bound_subnet_id=\"vpc-133128f1\",\n    bound_vpc_id=\"vpc-b61106d4\",\n    max_ttl=120,\n    role=\"test-role\",\n    token_policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    ttl=60,\n    opts=ResourceOptions(depends_on=[\"vault_aws_auth_backend_client.example\"]))\nexample_auth_backend_login = vault.aws.AuthBackendLogin(\"exampleAuthBackendLogin\",\n    backend=vault_auth_backend[\"example\"][\"path\"],\n    identity=\"BASE64ENCODEDIDENTITYDOCUMENT\",\n    role=example_auth_backend_role.role,\n    signature=\"BASE64ENCODEDSHA256IDENTITYDOCUMENTSIGNATURE\")\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The token's accessor.\n"
                },
                "authType": {
                    "type": "string",
                    "description": "The authentication type used to generate this token.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique name of the AWS auth backend. Defaults to\n'aws'.\n"
                },
                "clientToken": {
                    "type": "string",
                    "description": "The token returned by Vault.\n"
                },
                "iamHttpRequestMethod": {
                    "type": "string",
                    "description": "The HTTP method used in the signed IAM\nrequest.\n"
                },
                "iamRequestBody": {
                    "type": "string",
                    "description": "The base64-encoded body of the signed\nrequest.\n"
                },
                "iamRequestHeaders": {
                    "type": "string",
                    "description": "The base64-encoded, JSON serialized\nrepresentation of the GetCallerIdentity HTTP request headers.\n"
                },
                "iamRequestUrl": {
                    "type": "string",
                    "description": "The base64-encoded HTTP URL used in the signed\nrequest.\n"
                },
                "identity": {
                    "type": "string",
                    "description": "The base64-encoded EC2 instance identity document to\nauthenticate with. Can be retrieved from the EC2 metadata server.\n"
                },
                "leaseDuration": {
                    "type": "integer",
                    "description": "The duration in seconds the token will be valid, relative\nto the time in `lease_start_time`.\n"
                },
                "leaseStartTime": {
                    "type": "string",
                    "description": "Time at which the lease was read, using the clock of the system where Terraform was running\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of information returned by the Vault server about the\nauthentication used to generate this token.\n"
                },
                "nonce": {
                    "type": "string",
                    "description": "The unique nonce to be used for login requests. Can be\nset to a user-specified value, or will contain the server-generated value\nonce a token is issued. EC2 instances can only acquire a single token until\nthe whitelist is tidied again unless they keep track of this nonce.\n"
                },
                "pkcs7": {
                    "type": "string",
                    "description": "The PKCS#7 signature of the identity document to\nauthenticate with, with all newline characters removed. Can be retrieved from\nthe EC2 metadata server.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The Vault policies assigned to this token.\n"
                },
                "renewable": {
                    "type": "boolean",
                    "description": "Set to true if the token can be extended through renewal.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the AWS auth backend role to create tokens\nagainst.\n"
                },
                "signature": {
                    "type": "string",
                    "description": "The base64-encoded SHA256 RSA signature of the\ninstance identity document to authenticate with, with all newline characters\nremoved. Can be retrieved from the EC2 metadata server.\n"
                }
            },
            "required": [
                "accessor",
                "authType",
                "clientToken",
                "leaseDuration",
                "leaseStartTime",
                "metadata",
                "nonce",
                "policies",
                "renewable",
                "role"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of the AWS auth backend. Defaults to\n'aws'.\n"
                },
                "iamHttpRequestMethod": {
                    "type": "string",
                    "description": "The HTTP method used in the signed IAM\nrequest.\n"
                },
                "iamRequestBody": {
                    "type": "string",
                    "description": "The base64-encoded body of the signed\nrequest.\n"
                },
                "iamRequestHeaders": {
                    "type": "string",
                    "description": "The base64-encoded, JSON serialized\nrepresentation of the GetCallerIdentity HTTP request headers.\n"
                },
                "iamRequestUrl": {
                    "type": "string",
                    "description": "The base64-encoded HTTP URL used in the signed\nrequest.\n"
                },
                "identity": {
                    "type": "string",
                    "description": "The base64-encoded EC2 instance identity document to\nauthenticate with. Can be retrieved from the EC2 metadata server.\n"
                },
                "nonce": {
                    "type": "string",
                    "description": "The unique nonce to be used for login requests. Can be\nset to a user-specified value, or will contain the server-generated value\nonce a token is issued. EC2 instances can only acquire a single token until\nthe whitelist is tidied again unless they keep track of this nonce.\n"
                },
                "pkcs7": {
                    "type": "string",
                    "description": "The PKCS#7 signature of the identity document to\nauthenticate with, with all newline characters removed. Can be retrieved from\nthe EC2 metadata server.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the AWS auth backend role to create tokens\nagainst.\n"
                },
                "signature": {
                    "type": "string",
                    "description": "The base64-encoded SHA256 RSA signature of the\ninstance identity document to authenticate with, with all newline characters\nremoved. Can be retrieved from the EC2 metadata server.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendLogin resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The token's accessor.\n"
                    },
                    "authType": {
                        "type": "string",
                        "description": "The authentication type used to generate this token.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The unique name of the AWS auth backend. Defaults to\n'aws'.\n"
                    },
                    "clientToken": {
                        "type": "string",
                        "description": "The token returned by Vault.\n"
                    },
                    "iamHttpRequestMethod": {
                        "type": "string",
                        "description": "The HTTP method used in the signed IAM\nrequest.\n"
                    },
                    "iamRequestBody": {
                        "type": "string",
                        "description": "The base64-encoded body of the signed\nrequest.\n"
                    },
                    "iamRequestHeaders": {
                        "type": "string",
                        "description": "The base64-encoded, JSON serialized\nrepresentation of the GetCallerIdentity HTTP request headers.\n"
                    },
                    "iamRequestUrl": {
                        "type": "string",
                        "description": "The base64-encoded HTTP URL used in the signed\nrequest.\n"
                    },
                    "identity": {
                        "type": "string",
                        "description": "The base64-encoded EC2 instance identity document to\nauthenticate with. Can be retrieved from the EC2 metadata server.\n"
                    },
                    "leaseDuration": {
                        "type": "integer",
                        "description": "The duration in seconds the token will be valid, relative\nto the time in `lease_start_time`.\n"
                    },
                    "leaseStartTime": {
                        "type": "string",
                        "description": "Time at which the lease was read, using the clock of the system where Terraform was running\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A map of information returned by the Vault server about the\nauthentication used to generate this token.\n"
                    },
                    "nonce": {
                        "type": "string",
                        "description": "The unique nonce to be used for login requests. Can be\nset to a user-specified value, or will contain the server-generated value\nonce a token is issued. EC2 instances can only acquire a single token until\nthe whitelist is tidied again unless they keep track of this nonce.\n"
                    },
                    "pkcs7": {
                        "type": "string",
                        "description": "The PKCS#7 signature of the identity document to\nauthenticate with, with all newline characters removed. Can be retrieved from\nthe EC2 metadata server.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The Vault policies assigned to this token.\n"
                    },
                    "renewable": {
                        "type": "boolean",
                        "description": "Set to true if the token can be extended through renewal.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the AWS auth backend role to create tokens\nagainst.\n"
                    },
                    "signature": {
                        "type": "string",
                        "description": "The base64-encoded SHA256 RSA signature of the\ninstance identity document to authenticate with, with all newline characters\nremoved. Can be retrieved from the EC2 metadata server.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendRole:AuthBackendRole": {
            "description": "Manages an AWS auth backend role in a Vault server. Roles constrain the\ninstances or principals that can perform the login operation against the\nbackend. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/aws.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst aws = new vault.AuthBackend(\"aws\", {type: \"aws\"});\nconst example = new vault.aws.AuthBackendRole(\"example\", {\n    backend: aws.path,\n    role: \"test-role\",\n    authType: \"iam\",\n    boundAmiIds: [\"ami-8c1be5f6\"],\n    boundAccountIds: [\"123456789012\"],\n    boundVpcIds: [\"vpc-b61106d4\"],\n    boundSubnetIds: [\"vpc-133128f1\"],\n    boundIamRoleArns: [\"arn:aws:iam::123456789012:role/MyRole\"],\n    boundIamInstanceProfileArns: [\"arn:aws:iam::123456789012:instance-profile/MyProfile\"],\n    inferredEntityType: \"ec2_instance\",\n    inferredAwsRegion: \"us-east-1\",\n    tokenTtl: 60,\n    tokenMaxTtl: 120,\n    tokenPolicies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\naws = vault.AuthBackend(\"aws\", type=\"aws\")\nexample = vault.aws.AuthBackendRole(\"example\",\n    backend=aws.path,\n    role=\"test-role\",\n    auth_type=\"iam\",\n    bound_ami_ids=[\"ami-8c1be5f6\"],\n    bound_account_ids=[\"123456789012\"],\n    bound_vpc_ids=[\"vpc-b61106d4\"],\n    bound_subnet_ids=[\"vpc-133128f1\"],\n    bound_iam_role_arns=[\"arn:aws:iam::123456789012:role/MyRole\"],\n    bound_iam_instance_profile_arns=[\"arn:aws:iam::123456789012:instance-profile/MyProfile\"],\n    inferred_entity_type=\"ec2_instance\",\n    inferred_aws_region=\"us-east-1\",\n    token_ttl=60,\n    token_max_ttl=120,\n    token_policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ])\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var aws = new Vault.AuthBackend(\"aws\", new Vault.AuthBackendArgs\n        {\n            Type = \"aws\",\n        });\n        var example = new Vault.Aws.AuthBackendRole(\"example\", new Vault.Aws.AuthBackendRoleArgs\n        {\n            Backend = aws.Path,\n            Role = \"test-role\",\n            AuthType = \"iam\",\n            BoundAmiIds = \n            {\n                \"ami-8c1be5f6\",\n            },\n            BoundAccountIds = \n            {\n                \"123456789012\",\n            },\n            BoundVpcIds = \n            {\n                \"vpc-b61106d4\",\n            },\n            BoundSubnetIds = \n            {\n                \"vpc-133128f1\",\n            },\n            BoundIamRoleArns = \n            {\n                \"arn:aws:iam::123456789012:role/MyRole\",\n            },\n            BoundIamInstanceProfileArns = \n            {\n                \"arn:aws:iam::123456789012:instance-profile/MyProfile\",\n            },\n            InferredEntityType = \"ec2_instance\",\n            InferredAwsRegion = \"us-east-1\",\n            TokenTtl = 60,\n            TokenMaxTtl = 120,\n            TokenPolicies = \n            {\n                \"default\",\n                \"dev\",\n                \"prod\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/aws\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\taws, err := vault.NewAuthBackend(ctx, \"aws\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"aws\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = aws.NewAuthBackendRole(ctx, \"example\", \u0026aws.AuthBackendRoleArgs{\n\t\t\tBackend:  aws.Path,\n\t\t\tRole:     pulumi.String(\"test-role\"),\n\t\t\tAuthType: pulumi.String(\"iam\"),\n\t\t\tBoundAmiIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"ami-8c1be5f6\"),\n\t\t\t},\n\t\t\tBoundAccountIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"123456789012\"),\n\t\t\t},\n\t\t\tBoundVpcIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vpc-b61106d4\"),\n\t\t\t},\n\t\t\tBoundSubnetIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vpc-133128f1\"),\n\t\t\t},\n\t\t\tBoundIamRoleArns: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"arn:aws:iam::123456789012:role/MyRole\"),\n\t\t\t},\n\t\t\tBoundIamInstanceProfileArns: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"arn:aws:iam::123456789012:instance-profile/MyProfile\"),\n\t\t\t},\n\t\t\tInferredEntityType: pulumi.String(\"ec2_instance\"),\n\t\t\tInferredAwsRegion:  pulumi.String(\"us-east-1\"),\n\t\t\tTokenTtl:           pulumi.Int(60),\n\t\t\tTokenMaxTtl:        pulumi.Int(120),\n\t\t\tTokenPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "allowInstanceMigration": {
                    "type": "boolean",
                    "description": "If set to `true`, allows migration of\nthe underlying instance where the client resides.\n"
                },
                "authType": {
                    "type": "string",
                    "description": "The auth type permitted for this role. Valid choices\nare `ec2` and `iam`. Defaults to `iam`.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Unique name of the auth backend to configure.\n"
                },
                "boundAccountIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they should be using the\naccount ID specified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundAmiIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they should be using the AMI ID\nspecified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundEc2InstanceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Only EC2 instances that match this instance ID will be permitted to log in.\n"
                },
                "boundIamInstanceProfileArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on\nthe EC2 instances that can perform the login operation that they must be\nassociated with an IAM instance profile ARN which has a prefix that matches\nthe value specified by this field. The value is prefix-matched as though it\nwere a glob ending in `*`. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundIamPrincipalArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines the IAM principal that\nmust be authenticated when `auth_type` is set to `iam`. Wildcards are\nsupported at the end of the ARN.\n"
                },
                "boundIamRoleArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they must match the IAM\nrole ARN specified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that the region in their identity\ndocument must match the one specified by this field. `auth_type` must be set\nto `ec2` or `inferred_entity_type` must be set to `ec2_instance` to use this\nconstraint.\n"
                },
                "boundSubnetIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they be associated with\nthe subnet ID that matches the value specified by this field. `auth_type`\nmust be set to `ec2` or `inferred_entity_type` must be set to `ec2_instance`\nto use this constraint.\n"
                },
                "boundVpcIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they be associated with the VPC ID\nthat matches the value specified by this field. `auth_type` must be set to\n`ec2` or `inferred_entity_type` must be set to `ec2_instance` to use this\nconstraint.\n"
                },
                "disallowReauthentication": {
                    "type": "boolean",
                    "description": "IF set to `true`, only allows a\nsingle token to be granted per instance ID. This can only be set when\n`auth_type` is set to `ec2`.\n"
                },
                "inferredAwsRegion": {
                    "type": "string",
                    "description": "When `inferred_entity_type` is set, this\nis the region to search for the inferred entities. Required if\n`inferred_entity_type` is set. This only applies when `auth_type` is set to\n`iam`.\n"
                },
                "inferredEntityType": {
                    "type": "string",
                    "description": "If set, instructs Vault to turn on\ninferencing. The only valid value is `ec2_instance`, which instructs Vault to\ninfer that the role comes from an EC2 instance in an IAM instance profile.\nThis only applies when `auth_type` is set to `iam`.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum allowed lifetime of tokens\nissued using this role, provided as a number of seconds.\n",
                    "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "period": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings\nspecifying the policies to be set on tokens issued using this role.\n",
                    "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                },
                "resolveAwsUniqueIds": {
                    "type": "boolean",
                    "description": "If set to `true`, the\n`bound_iam_principal_arns` are resolved to [AWS Unique\nIDs](http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-unique-ids)\nfor the bound principal ARN. This field is ignored when a\n`bound_iam_principal_arn` ends in a wildcard. Resolving to unique IDs more\nclosely mimics the behavior of AWS services in that if an IAM user or role is\ndeleted and a new one is recreated with the same name, those new users or\nroles won't get access to roles in Vault that were permissioned to the prior\nprincipals of the same name. Defaults to `true`.\nOnce set to `true`, this cannot be changed to `false` without recreating the role.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "roleTag": {
                    "type": "string",
                    "description": "If set, enable role tags for this role. The value set\nfor this field should be the key of the tag on the EC2 instance. `auth_type`\nmust be set to `ec2` or `inferred_entity_type` must be set to `ec2_instance`\nto use this constraint.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The TTL period of tokens issued\nusing this role, provided as a number of seconds.\n",
                    "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                }
            },
            "required": [
                "role"
            ],
            "inputProperties": {
                "allowInstanceMigration": {
                    "type": "boolean",
                    "description": "If set to `true`, allows migration of\nthe underlying instance where the client resides.\n"
                },
                "authType": {
                    "type": "string",
                    "description": "The auth type permitted for this role. Valid choices\nare `ec2` and `iam`. Defaults to `iam`.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Unique name of the auth backend to configure.\n"
                },
                "boundAccountIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they should be using the\naccount ID specified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundAmiIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they should be using the AMI ID\nspecified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundEc2InstanceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Only EC2 instances that match this instance ID will be permitted to log in.\n"
                },
                "boundIamInstanceProfileArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on\nthe EC2 instances that can perform the login operation that they must be\nassociated with an IAM instance profile ARN which has a prefix that matches\nthe value specified by this field. The value is prefix-matched as though it\nwere a glob ending in `*`. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundIamPrincipalArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines the IAM principal that\nmust be authenticated when `auth_type` is set to `iam`. Wildcards are\nsupported at the end of the ARN.\n"
                },
                "boundIamRoleArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they must match the IAM\nrole ARN specified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that the region in their identity\ndocument must match the one specified by this field. `auth_type` must be set\nto `ec2` or `inferred_entity_type` must be set to `ec2_instance` to use this\nconstraint.\n"
                },
                "boundSubnetIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they be associated with\nthe subnet ID that matches the value specified by this field. `auth_type`\nmust be set to `ec2` or `inferred_entity_type` must be set to `ec2_instance`\nto use this constraint.\n"
                },
                "boundVpcIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they be associated with the VPC ID\nthat matches the value specified by this field. `auth_type` must be set to\n`ec2` or `inferred_entity_type` must be set to `ec2_instance` to use this\nconstraint.\n"
                },
                "disallowReauthentication": {
                    "type": "boolean",
                    "description": "IF set to `true`, only allows a\nsingle token to be granted per instance ID. This can only be set when\n`auth_type` is set to `ec2`.\n"
                },
                "inferredAwsRegion": {
                    "type": "string",
                    "description": "When `inferred_entity_type` is set, this\nis the region to search for the inferred entities. Required if\n`inferred_entity_type` is set. This only applies when `auth_type` is set to\n`iam`.\n"
                },
                "inferredEntityType": {
                    "type": "string",
                    "description": "If set, instructs Vault to turn on\ninferencing. The only valid value is `ec2_instance`, which instructs Vault to\ninfer that the role comes from an EC2 instance in an IAM instance profile.\nThis only applies when `auth_type` is set to `iam`.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum allowed lifetime of tokens\nissued using this role, provided as a number of seconds.\n",
                    "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "period": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings\nspecifying the policies to be set on tokens issued using this role.\n",
                    "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                },
                "resolveAwsUniqueIds": {
                    "type": "boolean",
                    "description": "If set to `true`, the\n`bound_iam_principal_arns` are resolved to [AWS Unique\nIDs](http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-unique-ids)\nfor the bound principal ARN. This field is ignored when a\n`bound_iam_principal_arn` ends in a wildcard. Resolving to unique IDs more\nclosely mimics the behavior of AWS services in that if an IAM user or role is\ndeleted and a new one is recreated with the same name, those new users or\nroles won't get access to roles in Vault that were permissioned to the prior\nprincipals of the same name. Defaults to `true`.\nOnce set to `true`, this cannot be changed to `false` without recreating the role.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "roleTag": {
                    "type": "string",
                    "description": "If set, enable role tags for this role. The value set\nfor this field should be the key of the tag on the EC2 instance. `auth_type`\nmust be set to `ec2` or `inferred_entity_type` must be set to `ec2_instance`\nto use this constraint.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The TTL period of tokens issued\nusing this role, provided as a number of seconds.\n",
                    "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                }
            },
            "requiredInputs": [
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "allowInstanceMigration": {
                        "type": "boolean",
                        "description": "If set to `true`, allows migration of\nthe underlying instance where the client resides.\n"
                    },
                    "authType": {
                        "type": "string",
                        "description": "The auth type permitted for this role. Valid choices\nare `ec2` and `iam`. Defaults to `iam`.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "Unique name of the auth backend to configure.\n"
                    },
                    "boundAccountIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they should be using the\naccount ID specified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                    },
                    "boundAmiIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they should be using the AMI ID\nspecified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                    },
                    "boundEc2InstanceIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Only EC2 instances that match this instance ID will be permitted to log in.\n"
                    },
                    "boundIamInstanceProfileArns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on\nthe EC2 instances that can perform the login operation that they must be\nassociated with an IAM instance profile ARN which has a prefix that matches\nthe value specified by this field. The value is prefix-matched as though it\nwere a glob ending in `*`. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                    },
                    "boundIamPrincipalArns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines the IAM principal that\nmust be authenticated when `auth_type` is set to `iam`. Wildcards are\nsupported at the end of the ARN.\n"
                    },
                    "boundIamRoleArns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they must match the IAM\nrole ARN specified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                    },
                    "boundRegions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that the region in their identity\ndocument must match the one specified by this field. `auth_type` must be set\nto `ec2` or `inferred_entity_type` must be set to `ec2_instance` to use this\nconstraint.\n"
                    },
                    "boundSubnetIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they be associated with\nthe subnet ID that matches the value specified by this field. `auth_type`\nmust be set to `ec2` or `inferred_entity_type` must be set to `ec2_instance`\nto use this constraint.\n"
                    },
                    "boundVpcIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they be associated with the VPC ID\nthat matches the value specified by this field. `auth_type` must be set to\n`ec2` or `inferred_entity_type` must be set to `ec2_instance` to use this\nconstraint.\n"
                    },
                    "disallowReauthentication": {
                        "type": "boolean",
                        "description": "IF set to `true`, only allows a\nsingle token to be granted per instance ID. This can only be set when\n`auth_type` is set to `ec2`.\n"
                    },
                    "inferredAwsRegion": {
                        "type": "string",
                        "description": "When `inferred_entity_type` is set, this\nis the region to search for the inferred entities. Required if\n`inferred_entity_type` is set. This only applies when `auth_type` is set to\n`iam`.\n"
                    },
                    "inferredEntityType": {
                        "type": "string",
                        "description": "If set, instructs Vault to turn on\ninferencing. The only valid value is `ec2_instance`, which instructs Vault to\ninfer that the role comes from an EC2 instance in an IAM instance profile.\nThis only applies when `auth_type` is set to `iam`.\n"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "The maximum allowed lifetime of tokens\nissued using this role, provided as a number of seconds.\n",
                        "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                    },
                    "period": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n",
                        "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of strings\nspecifying the policies to be set on tokens issued using this role.\n",
                        "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                    },
                    "resolveAwsUniqueIds": {
                        "type": "boolean",
                        "description": "If set to `true`, the\n`bound_iam_principal_arns` are resolved to [AWS Unique\nIDs](http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-unique-ids)\nfor the bound principal ARN. This field is ignored when a\n`bound_iam_principal_arn` ends in a wildcard. Resolving to unique IDs more\nclosely mimics the behavior of AWS services in that if an IAM user or role is\ndeleted and a new one is recreated with the same name, those new users or\nroles won't get access to roles in Vault that were permissioned to the prior\nprincipals of the same name. Defaults to `true`.\nOnce set to `true`, this cannot be changed to `false` without recreating the role.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "roleTag": {
                        "type": "string",
                        "description": "If set, enable role tags for this role. The value set\nfor this field should be the key of the tag on the EC2 instance. `auth_type`\nmust be set to `ec2` or `inferred_entity_type` must be set to `ec2_instance`\nto use this constraint.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "The TTL period of tokens issued\nusing this role, provided as a number of seconds.\n",
                        "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendRoleTag:AuthBackendRoleTag": {
            "description": "Reads role tag information from an AWS auth backend in Vault. \n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst aws = new vault.AuthBackend(\"aws\", {\n    path: \"%s\",\n    type: \"aws\",\n});\nconst role = new vault.aws.AuthBackendRole(\"role\", {\n    authType: \"ec2\",\n    backend: aws.path,\n    boundAccountId: \"123456789012\",\n    policies: [\n        \"dev\",\n        \"prod\",\n        \"qa\",\n        \"test\",\n    ],\n    role: \"%s\",\n    roleTag: \"VaultRoleTag\",\n});\nconst test = new vault.aws.AuthBackendRoleTag(\"test\", {\n    backend: aws.path,\n    instanceId: \"i-1234567\",\n    maxTtl: \"1h\",\n    policies: [\n        \"prod\",\n        \"dev\",\n        \"test\",\n    ],\n    role: role.role,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\naws = vault.AuthBackend(\"aws\",\n    path=\"%s\",\n    type=\"aws\")\nrole = vault.aws.AuthBackendRole(\"role\",\n    auth_type=\"ec2\",\n    backend=aws.path,\n    bound_account_id=\"123456789012\",\n    policies=[\n        \"dev\",\n        \"prod\",\n        \"qa\",\n        \"test\",\n    ],\n    role=\"%s\",\n    role_tag=\"VaultRoleTag\")\ntest = vault.aws.AuthBackendRoleTag(\"test\",\n    backend=aws.path,\n    instance_id=\"i-1234567\",\n    max_ttl=\"1h\",\n    policies=[\n        \"prod\",\n        \"dev\",\n        \"test\",\n    ],\n    role=role.role)\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "allowInstanceMigration": {
                    "type": "boolean",
                    "description": "If set, allows migration of the underlying instances where the client resides. Use with caution.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path to the AWS auth backend to\nread role tags from, with no leading or trailing `/`s. Defaults to \"aws\".\n"
                },
                "disallowReauthentication": {
                    "type": "boolean",
                    "description": "If set, only allows a single token to be granted per instance ID.\n"
                },
                "instanceId": {
                    "type": "string",
                    "description": "Instance ID for which this tag is intended for. If set, the created tag can only be used by the instance with the given ID.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "The maximum TTL of the tokens issued using this role.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The policies to be associated with the tag. Must be a subset of the policies associated with the role.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the AWS auth backend role to read\nrole tags from, with no leading or trailing `/`s.\n"
                },
                "tagKey": {
                    "type": "string",
                    "description": "The key of the role tag.\n"
                },
                "tagValue": {
                    "type": "string",
                    "description": "The value to set the role key.\n"
                }
            },
            "required": [
                "role",
                "tagKey",
                "tagValue"
            ],
            "inputProperties": {
                "allowInstanceMigration": {
                    "type": "boolean",
                    "description": "If set, allows migration of the underlying instances where the client resides. Use with caution.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path to the AWS auth backend to\nread role tags from, with no leading or trailing `/`s. Defaults to \"aws\".\n"
                },
                "disallowReauthentication": {
                    "type": "boolean",
                    "description": "If set, only allows a single token to be granted per instance ID.\n"
                },
                "instanceId": {
                    "type": "string",
                    "description": "Instance ID for which this tag is intended for. If set, the created tag can only be used by the instance with the given ID.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "The maximum TTL of the tokens issued using this role.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The policies to be associated with the tag. Must be a subset of the policies associated with the role.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the AWS auth backend role to read\nrole tags from, with no leading or trailing `/`s.\n"
                }
            },
            "requiredInputs": [
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRoleTag resources.\n",
                "properties": {
                    "allowInstanceMigration": {
                        "type": "boolean",
                        "description": "If set, allows migration of the underlying instances where the client resides. Use with caution.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path to the AWS auth backend to\nread role tags from, with no leading or trailing `/`s. Defaults to \"aws\".\n"
                    },
                    "disallowReauthentication": {
                        "type": "boolean",
                        "description": "If set, only allows a single token to be granted per instance ID.\n"
                    },
                    "instanceId": {
                        "type": "string",
                        "description": "Instance ID for which this tag is intended for. If set, the created tag can only be used by the instance with the given ID.\n"
                    },
                    "maxTtl": {
                        "type": "string",
                        "description": "The maximum TTL of the tokens issued using this role.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The policies to be associated with the tag. Must be a subset of the policies associated with the role.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the AWS auth backend role to read\nrole tags from, with no leading or trailing `/`s.\n"
                    },
                    "tagKey": {
                        "type": "string",
                        "description": "The key of the role tag.\n"
                    },
                    "tagValue": {
                        "type": "string",
                        "description": "The value to set the role key.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendRoletagBlacklist:AuthBackendRoletagBlacklist": {
            "description": "Configures the periodic tidying operation of the blacklisted role tag entries.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst exampleAuthBackend = new vault.AuthBackend(\"example\", {\n    type: \"aws\",\n});\nconst exampleAuthBackendRoletagBlacklist = new vault.aws.AuthBackendRoletagBlacklist(\"example\", {\n    backend: exampleAuthBackend.path,\n    safetyBuffer: 360,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample_auth_backend = vault.AuthBackend(\"exampleAuthBackend\", type=\"aws\")\nexample_auth_backend_roletag_blacklist = vault.aws.AuthBackendRoletagBlacklist(\"exampleAuthBackendRoletagBlacklist\",\n    backend=example_auth_backend.path,\n    safety_buffer=360)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleAuthBackend = new Vault.AuthBackend(\"exampleAuthBackend\", new Vault.AuthBackendArgs\n        {\n            Type = \"aws\",\n        });\n        var exampleAuthBackendRoletagBlacklist = new Vault.Aws.AuthBackendRoletagBlacklist(\"exampleAuthBackendRoletagBlacklist\", new Vault.Aws.AuthBackendRoletagBlacklistArgs\n        {\n            Backend = exampleAuthBackend.Path,\n            SafetyBuffer = 360,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/aws\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleAuthBackend, err := vault.NewAuthBackend(ctx, \"exampleAuthBackend\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"aws\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = aws.NewAuthBackendRoletagBlacklist(ctx, \"exampleAuthBackendRoletagBlacklist\", \u0026aws.AuthBackendRoletagBlacklistArgs{\n\t\t\tBackend:      exampleAuthBackend.Path,\n\t\t\tSafetyBuffer: pulumi.Int(360),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.\n"
                },
                "disablePeriodicTidy": {
                    "type": "boolean",
                    "description": "If set to true, disables the periodic\ntidying of the roletag blacklist entries. Defaults to false.\n"
                },
                "safetyBuffer": {
                    "type": "integer",
                    "description": "The amount of extra time that must have passed\nbeyond the roletag expiration, before it is removed from the backend storage.\nDefaults to 259,200 seconds, or 72 hours.\n"
                }
            },
            "required": [
                "backend"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.\n"
                },
                "disablePeriodicTidy": {
                    "type": "boolean",
                    "description": "If set to true, disables the periodic\ntidying of the roletag blacklist entries. Defaults to false.\n"
                },
                "safetyBuffer": {
                    "type": "integer",
                    "description": "The amount of extra time that must have passed\nbeyond the roletag expiration, before it is removed from the backend storage.\nDefaults to 259,200 seconds, or 72 hours.\n"
                }
            },
            "requiredInputs": [
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRoletagBlacklist resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the AWS auth backend being configured was\nmounted at.\n"
                    },
                    "disablePeriodicTidy": {
                        "type": "boolean",
                        "description": "If set to true, disables the periodic\ntidying of the roletag blacklist entries. Defaults to false.\n"
                    },
                    "safetyBuffer": {
                        "type": "integer",
                        "description": "The amount of extra time that must have passed\nbeyond the roletag expiration, before it is removed from the backend storage.\nDefaults to 259,200 seconds, or 72 hours.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendStsRole:AuthBackendStsRole": {
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The AWS account ID to configure the STS role for.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                },
                "stsRole": {
                    "type": "string",
                    "description": "The STS role to assume when verifying requests made\nby EC2 instances in the account specified by `account_id`.\n"
                }
            },
            "required": [
                "accountId",
                "stsRole"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The AWS account ID to configure the STS role for.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                },
                "stsRole": {
                    "type": "string",
                    "description": "The STS role to assume when verifying requests made\nby EC2 instances in the account specified by `account_id`.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "stsRole"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendStsRole resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The AWS account ID to configure the STS role for.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                    },
                    "stsRole": {
                        "type": "string",
                        "description": "The STS role to assume when verifying requests made\nby EC2 instances in the account specified by `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/secretBackend:SecretBackend": {
            "properties": {
                "accessKey": {
                    "type": "string",
                    "description": "The AWS Access Key ID this backend should use to\nissue new credentials. Vault uses the official AWS SDK to authenticate, and thus can also use standard AWS environment credentials, shared file credentials or IAM role/ECS task credentials.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials\nissued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `aws`.\n"
                },
                "region": {
                    "type": "string",
                    "description": "The AWS region for API calls. Defaults to `us-east-1`.\n"
                },
                "secretKey": {
                    "type": "string",
                    "description": "The AWS Secret Key this backend should use to\nissue new credentials. Vault uses the official AWS SDK to authenticate, and thus can also use standard AWS environment credentials, shared file credentials or IAM role/ECS task credentials.\n"
                }
            },
            "required": [
                "defaultLeaseTtlSeconds",
                "maxLeaseTtlSeconds",
                "region"
            ],
            "inputProperties": {
                "accessKey": {
                    "type": "string",
                    "description": "The AWS Access Key ID this backend should use to\nissue new credentials. Vault uses the official AWS SDK to authenticate, and thus can also use standard AWS environment credentials, shared file credentials or IAM role/ECS task credentials.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials\nissued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `aws`.\n"
                },
                "region": {
                    "type": "string",
                    "description": "The AWS region for API calls. Defaults to `us-east-1`.\n"
                },
                "secretKey": {
                    "type": "string",
                    "description": "The AWS Secret Key this backend should use to\nissue new credentials. Vault uses the official AWS SDK to authenticate, and thus can also use standard AWS environment credentials, shared file credentials or IAM role/ECS task credentials.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackend resources.\n",
                "properties": {
                    "accessKey": {
                        "type": "string",
                        "description": "The AWS Access Key ID this backend should use to\nissue new credentials. Vault uses the official AWS SDK to authenticate, and thus can also use standard AWS environment credentials, shared file credentials or IAM role/ECS task credentials.\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The default TTL for credentials\nissued by this backend.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A human-friendly description for this backend.\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `aws`.\n"
                    },
                    "region": {
                        "type": "string",
                        "description": "The AWS region for API calls. Defaults to `us-east-1`.\n"
                    },
                    "secretKey": {
                        "type": "string",
                        "description": "The AWS Secret Key this backend should use to\nissue new credentials. Vault uses the official AWS SDK to authenticate, and thus can also use standard AWS environment credentials, shared file credentials or IAM role/ECS task credentials.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/secretBackendRole:SecretBackendRole": {
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path the AWS secret backend is mounted at,\nwith no leading or trailing `/`s.\n"
                },
                "credentialType": {
                    "type": "string",
                    "description": "Specifies the type of credential to be used when\nretrieving credentials from the role. Must be one of `iam_user`, `assumed_role`, or\n`federation_token`.\n"
                },
                "defaultStsTtl": {
                    "type": "integer",
                    "description": "The default TTL in seconds for STS credentials.\nWhen a TTL is not specified when STS credentials are requested,\nand a default TTL is specified on the role,\nthen this default TTL will be used. Valid only when `credential_type` is one of\n`assumed_role` or `federation_token`.\n"
                },
                "maxStsTtl": {
                    "type": "integer",
                    "description": "The max allowed TTL in seconds for STS credentials\n(credentials TTL are capped to `max_sts_ttl`). Valid only when `credential_type` is\none of `assumed_role` or `federation_token`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n"
                },
                "policyArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies a list of AWS managed policy ARNs. The\nbehavior depends on the credential type. With `iam_user`, the policies will be\nattached to IAM users when they are requested. With `assumed_role` and\n`federation_token`, the policy ARNs will act as a filter on what the credentials\ncan do, similar to `policy_document`. When `credential_type` is `iam_user` or\n`federation_token`, at least one of `policy_document` or `policy_arns` must\nbe specified.\n"
                },
                "policyDocument": {
                    "type": "string",
                    "description": "The IAM policy document for the role. The\nbehavior depends on the credential type. With `iam_user`, the policy document\nwill be attached to the IAM user generated and augment the permissions the IAM\nuser has. With `assumed_role` and `federation_token`, the policy document will\nact as a filter on what the credentials can do, similar to `policy_arns`.\n"
                },
                "roleArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the ARNs of the AWS roles this Vault role\nis allowed to assume. Required when `credential_type` is `assumed_role` and\nprohibited otherwise.\n"
                }
            },
            "required": [
                "backend",
                "credentialType",
                "defaultStsTtl",
                "maxStsTtl",
                "name"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path the AWS secret backend is mounted at,\nwith no leading or trailing `/`s.\n"
                },
                "credentialType": {
                    "type": "string",
                    "description": "Specifies the type of credential to be used when\nretrieving credentials from the role. Must be one of `iam_user`, `assumed_role`, or\n`federation_token`.\n"
                },
                "defaultStsTtl": {
                    "type": "integer",
                    "description": "The default TTL in seconds for STS credentials.\nWhen a TTL is not specified when STS credentials are requested,\nand a default TTL is specified on the role,\nthen this default TTL will be used. Valid only when `credential_type` is one of\n`assumed_role` or `federation_token`.\n"
                },
                "maxStsTtl": {
                    "type": "integer",
                    "description": "The max allowed TTL in seconds for STS credentials\n(credentials TTL are capped to `max_sts_ttl`). Valid only when `credential_type` is\none of `assumed_role` or `federation_token`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n"
                },
                "policyArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies a list of AWS managed policy ARNs. The\nbehavior depends on the credential type. With `iam_user`, the policies will be\nattached to IAM users when they are requested. With `assumed_role` and\n`federation_token`, the policy ARNs will act as a filter on what the credentials\ncan do, similar to `policy_document`. When `credential_type` is `iam_user` or\n`federation_token`, at least one of `policy_document` or `policy_arns` must\nbe specified.\n"
                },
                "policyDocument": {
                    "type": "string",
                    "description": "The IAM policy document for the role. The\nbehavior depends on the credential type. With `iam_user`, the policy document\nwill be attached to the IAM user generated and augment the permissions the IAM\nuser has. With `assumed_role` and `federation_token`, the policy document will\nact as a filter on what the credentials can do, similar to `policy_arns`.\n"
                },
                "roleArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the ARNs of the AWS roles this Vault role\nis allowed to assume. Required when `credential_type` is `assumed_role` and\nprohibited otherwise.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "credentialType"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the AWS secret backend is mounted at,\nwith no leading or trailing `/`s.\n"
                    },
                    "credentialType": {
                        "type": "string",
                        "description": "Specifies the type of credential to be used when\nretrieving credentials from the role. Must be one of `iam_user`, `assumed_role`, or\n`federation_token`.\n"
                    },
                    "defaultStsTtl": {
                        "type": "integer",
                        "description": "The default TTL in seconds for STS credentials.\nWhen a TTL is not specified when STS credentials are requested,\nand a default TTL is specified on the role,\nthen this default TTL will be used. Valid only when `credential_type` is one of\n`assumed_role` or `federation_token`.\n"
                    },
                    "maxStsTtl": {
                        "type": "integer",
                        "description": "The max allowed TTL in seconds for STS credentials\n(credentials TTL are capped to `max_sts_ttl`). Valid only when `credential_type` is\none of `assumed_role` or `federation_token`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n"
                    },
                    "policyArns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies a list of AWS managed policy ARNs. The\nbehavior depends on the credential type. With `iam_user`, the policies will be\nattached to IAM users when they are requested. With `assumed_role` and\n`federation_token`, the policy ARNs will act as a filter on what the credentials\ncan do, similar to `policy_document`. When `credential_type` is `iam_user` or\n`federation_token`, at least one of `policy_document` or `policy_arns` must\nbe specified.\n"
                    },
                    "policyDocument": {
                        "type": "string",
                        "description": "The IAM policy document for the role. The\nbehavior depends on the credential type. With `iam_user`, the policy document\nwill be attached to the IAM user generated and augment the permissions the IAM\nuser has. With `assumed_role` and `federation_token`, the policy document will\nact as a filter on what the credentials can do, similar to `policy_arns`.\n"
                    },
                    "roleArns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the ARNs of the AWS roles this Vault role\nis allowed to assume. Required when `credential_type` is `assumed_role` and\nprohibited otherwise.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:azure/authBackendConfig:AuthBackendConfig": {
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path the Azure auth backend being configured was\nmounted at.  Defaults to `azure`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client id for credentials to query the Azure APIs.\nCurrently read permissions to query compute resources are required.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client secret for credentials to query the\nAzure APIs.\n"
                },
                "environment": {
                    "type": "string",
                    "description": "The Azure cloud environment. Valid values:\nAzurePublicCloud, AzureUSGovernmentCloud, AzureChinaCloud,\nAzureGermanCloud.  Defaults to `AzurePublicCloud`.\n"
                },
                "resource": {
                    "type": "string",
                    "description": "The configured URL for the application registered in\nAzure Active Directory.\n"
                },
                "tenantId": {
                    "type": "string",
                    "description": "The tenant id for the Azure Active Directory\norganization.\n"
                }
            },
            "required": [
                "resource",
                "tenantId"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path the Azure auth backend being configured was\nmounted at.  Defaults to `azure`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client id for credentials to query the Azure APIs.\nCurrently read permissions to query compute resources are required.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client secret for credentials to query the\nAzure APIs.\n"
                },
                "environment": {
                    "type": "string",
                    "description": "The Azure cloud environment. Valid values:\nAzurePublicCloud, AzureUSGovernmentCloud, AzureChinaCloud,\nAzureGermanCloud.  Defaults to `AzurePublicCloud`.\n"
                },
                "resource": {
                    "type": "string",
                    "description": "The configured URL for the application registered in\nAzure Active Directory.\n"
                },
                "tenantId": {
                    "type": "string",
                    "description": "The tenant id for the Azure Active Directory\norganization.\n"
                }
            },
            "requiredInputs": [
                "resource",
                "tenantId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendConfig resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the Azure auth backend being configured was\nmounted at.  Defaults to `azure`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client id for credentials to query the Azure APIs.\nCurrently read permissions to query compute resources are required.\n"
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "The client secret for credentials to query the\nAzure APIs.\n"
                    },
                    "environment": {
                        "type": "string",
                        "description": "The Azure cloud environment. Valid values:\nAzurePublicCloud, AzureUSGovernmentCloud, AzureChinaCloud,\nAzureGermanCloud.  Defaults to `AzurePublicCloud`.\n"
                    },
                    "resource": {
                        "type": "string",
                        "description": "The configured URL for the application registered in\nAzure Active Directory.\n"
                    },
                    "tenantId": {
                        "type": "string",
                        "description": "The tenant id for the Azure Active Directory\norganization.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:azure/authBackendRole:AuthBackendRole": {
            "description": "Manages an Azure auth backend role in a Vault server. Roles constrain the\ninstances or principals that can perform the login operation against the\nbackend. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/azure.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst azure = new vault.AuthBackend(\"azure\", {\n    type: \"azure\",\n});\nconst example = new vault.azure.AuthBackendRole(\"example\", {\n    backend: azure.path,\n    boundResourceGroups: [\"123456789012\"],\n    boundSubscriptionIds: [\"11111111-2222-3333-4444-555555555555\"],\n    role: \"test-role\",\n    tokenMaxTtl: 120,\n    tokenPolicies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    tokenTtl: 60,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nazure = vault.AuthBackend(\"azure\", type=\"azure\")\nexample = vault.azure.AuthBackendRole(\"example\",\n    backend=azure.path,\n    bound_resource_groups=[\"123456789012\"],\n    bound_subscription_ids=[\"11111111-2222-3333-4444-555555555555\"],\n    role=\"test-role\",\n    token_max_ttl=120,\n    token_policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    token_ttl=60)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var azure = new Vault.AuthBackend(\"azure\", new Vault.AuthBackendArgs\n        {\n            Type = \"azure\",\n        });\n        var example = new Vault.Azure.AuthBackendRole(\"example\", new Vault.Azure.AuthBackendRoleArgs\n        {\n            Backend = azure.Path,\n            BoundResourceGroups = \n            {\n                \"123456789012\",\n            },\n            BoundSubscriptionIds = \n            {\n                \"11111111-2222-3333-4444-555555555555\",\n            },\n            Role = \"test-role\",\n            TokenMaxTtl = 120,\n            TokenPolicies = \n            {\n                \"default\",\n                \"dev\",\n                \"prod\",\n            },\n            TokenTtl = 60,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/azure\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tazure, err := vault.NewAuthBackend(ctx, \"azure\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"azure\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = azure.NewAuthBackendRole(ctx, \"example\", \u0026azure.AuthBackendRoleArgs{\n\t\t\tBackend: azure.Path,\n\t\t\tBoundResourceGroups: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"123456789012\"),\n\t\t\t},\n\t\t\tBoundSubscriptionIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"11111111-2222-3333-4444-555555555555\"),\n\t\t\t},\n\t\t\tRole:        pulumi.String(\"test-role\"),\n\t\t\tTokenMaxTtl: pulumi.Int(120),\n\t\t\tTokenPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t\tTokenTtl: pulumi.Int(60),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Unique name of the auth backend to configure.\n"
                },
                "boundGroupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the groups\nthat can perform the login operation that they should be using the group\nID specified by this field.\n"
                },
                "boundLocations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the virtual machines\nthat can perform the login operation that the location in their identity\ndocument must match the one specified by this field.\n"
                },
                "boundResourceGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the virtual\nmachiness that can perform the login operation that they be associated with\nthe resource group that matches the value specified by this field.\n"
                },
                "boundScaleSets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the virtual\nmachines that can perform the login operation that they must match the scale set\nspecified by this field.\n"
                },
                "boundServicePrincipalIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the\nservice principals that can perform the login operation that they should be possess\nthe ids specified by this field.\n"
                },
                "boundSubscriptionIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the subscriptions\nthat can perform the login operation to ones which  matches the value specified by this\nfield.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum allowed lifetime of tokens\nissued using this role, provided as a number of seconds.\n",
                    "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "period": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings\nspecifying the policies to be set on tokens issued using this role.\n",
                    "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The TTL period of tokens issued\nusing this role, provided as a number of seconds.\n",
                    "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                }
            },
            "required": [
                "role"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Unique name of the auth backend to configure.\n"
                },
                "boundGroupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the groups\nthat can perform the login operation that they should be using the group\nID specified by this field.\n"
                },
                "boundLocations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the virtual machines\nthat can perform the login operation that the location in their identity\ndocument must match the one specified by this field.\n"
                },
                "boundResourceGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the virtual\nmachiness that can perform the login operation that they be associated with\nthe resource group that matches the value specified by this field.\n"
                },
                "boundScaleSets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the virtual\nmachines that can perform the login operation that they must match the scale set\nspecified by this field.\n"
                },
                "boundServicePrincipalIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the\nservice principals that can perform the login operation that they should be possess\nthe ids specified by this field.\n"
                },
                "boundSubscriptionIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the subscriptions\nthat can perform the login operation to ones which  matches the value specified by this\nfield.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum allowed lifetime of tokens\nissued using this role, provided as a number of seconds.\n",
                    "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "period": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings\nspecifying the policies to be set on tokens issued using this role.\n",
                    "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The TTL period of tokens issued\nusing this role, provided as a number of seconds.\n",
                    "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                }
            },
            "requiredInputs": [
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Unique name of the auth backend to configure.\n"
                    },
                    "boundGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the groups\nthat can perform the login operation that they should be using the group\nID specified by this field.\n"
                    },
                    "boundLocations": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the virtual machines\nthat can perform the login operation that the location in their identity\ndocument must match the one specified by this field.\n"
                    },
                    "boundResourceGroups": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the virtual\nmachiness that can perform the login operation that they be associated with\nthe resource group that matches the value specified by this field.\n"
                    },
                    "boundScaleSets": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the virtual\nmachines that can perform the login operation that they must match the scale set\nspecified by this field.\n"
                    },
                    "boundServicePrincipalIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the\nservice principals that can perform the login operation that they should be possess\nthe ids specified by this field.\n"
                    },
                    "boundSubscriptionIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the subscriptions\nthat can perform the login operation to ones which  matches the value specified by this\nfield.\n"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "The maximum allowed lifetime of tokens\nissued using this role, provided as a number of seconds.\n",
                        "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                    },
                    "period": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n",
                        "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of strings\nspecifying the policies to be set on tokens issued using this role.\n",
                        "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "The TTL period of tokens issued\nusing this role, provided as a number of seconds.\n",
                        "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                    }
                },
                "type": "object"
            }
        },
        "vault:azure/backend:Backend": {
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The client id for credentials to query the Azure APIs. Currently read permissions to query compute resources are\nrequired.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client secret for credentials to query the Azure APIs\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the backend.\n"
                },
                "environment": {
                    "type": "string",
                    "description": "The Azure cloud environment. Valid values: AzurePublicCloud, AzureUSGovernmentCloud, AzureChinaCloud, AzureGermanCloud.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to mount the backend at.\n"
                },
                "subscriptionId": {
                    "type": "string",
                    "description": "The subscription id for the Azure Active Directory.\n"
                },
                "tenantId": {
                    "type": "string",
                    "description": "The tenant id for the Azure Active Directory organization.\n"
                }
            },
            "required": [
                "subscriptionId",
                "tenantId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The client id for credentials to query the Azure APIs. Currently read permissions to query compute resources are\nrequired.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client secret for credentials to query the Azure APIs\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the backend.\n"
                },
                "environment": {
                    "type": "string",
                    "description": "The Azure cloud environment. Valid values: AzurePublicCloud, AzureUSGovernmentCloud, AzureChinaCloud, AzureGermanCloud.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to mount the backend at.\n"
                },
                "subscriptionId": {
                    "type": "string",
                    "description": "The subscription id for the Azure Active Directory.\n"
                },
                "tenantId": {
                    "type": "string",
                    "description": "The tenant id for the Azure Active Directory organization.\n"
                }
            },
            "requiredInputs": [
                "subscriptionId",
                "tenantId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Backend resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The client id for credentials to query the Azure APIs. Currently read permissions to query compute resources are\nrequired.\n"
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "The client secret for credentials to query the Azure APIs\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Human-friendly description of the mount for the backend.\n"
                    },
                    "environment": {
                        "type": "string",
                        "description": "The Azure cloud environment. Valid values: AzurePublicCloud, AzureUSGovernmentCloud, AzureChinaCloud, AzureGermanCloud.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Path to mount the backend at.\n"
                    },
                    "subscriptionId": {
                        "type": "string",
                        "description": "The subscription id for the Azure Active Directory.\n"
                    },
                    "tenantId": {
                        "type": "string",
                        "description": "The tenant id for the Azure Active Directory organization.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:azure/backendRole:BackendRole": {
            "properties": {
                "applicationObjectId": {
                    "type": "string",
                    "description": "Application Object ID for an existing service principal that will\nbe used instead of creating dynamic service principals. If present, `azure_roles` will be ignored.\n"
                },
                "azureRoles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:azure/BackendRoleAzureRole:BackendRoleAzureRole"
                    },
                    "description": "List of Azure roles to be assigned to the generated service principal.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Path to the mounted Azure auth backend\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the backend.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Specifies the maximum TTL for service principals generated using this role. Accepts time\nsuffixed strings (\"1h\") or an integer number of seconds. Defaults to the system/engine max TTL time.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the Azure role\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Specifies the default TTL for service principals generated using this role.\nAccepts time suffixed strings (\"1h\") or an integer number of seconds. Defaults to the system/engine default TTL time.\n"
                }
            },
            "required": [
                "role"
            ],
            "inputProperties": {
                "applicationObjectId": {
                    "type": "string",
                    "description": "Application Object ID for an existing service principal that will\nbe used instead of creating dynamic service principals. If present, `azure_roles` will be ignored.\n"
                },
                "azureRoles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:azure/BackendRoleAzureRole:BackendRoleAzureRole"
                    },
                    "description": "List of Azure roles to be assigned to the generated service principal.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Path to the mounted Azure auth backend\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the backend.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Specifies the maximum TTL for service principals generated using this role. Accepts time\nsuffixed strings (\"1h\") or an integer number of seconds. Defaults to the system/engine max TTL time.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the Azure role\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Specifies the default TTL for service principals generated using this role.\nAccepts time suffixed strings (\"1h\") or an integer number of seconds. Defaults to the system/engine default TTL time.\n"
                }
            },
            "requiredInputs": [
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering BackendRole resources.\n",
                "properties": {
                    "applicationObjectId": {
                        "type": "string",
                        "description": "Application Object ID for an existing service principal that will\nbe used instead of creating dynamic service principals. If present, `azure_roles` will be ignored.\n"
                    },
                    "azureRoles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:azure/BackendRoleAzureRole:BackendRoleAzureRole"
                        },
                        "description": "List of Azure roles to be assigned to the generated service principal.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "Path to the mounted Azure auth backend\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Human-friendly description of the mount for the backend.\n"
                    },
                    "maxTtl": {
                        "type": "string",
                        "description": "Specifies the maximum TTL for service principals generated using this role. Accepts time\nsuffixed strings (\"1h\") or an integer number of seconds. Defaults to the system/engine max TTL time.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "Name of the Azure role\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Specifies the default TTL for service principals generated using this role.\nAccepts time suffixed strings (\"1h\") or an integer number of seconds. Defaults to the system/engine default TTL time.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:consul/secretBackend:SecretBackend": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "Specifies the address of the Consul instance, provided as \"host:port\" like \"127.0.0.1:8500\".\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials issued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique location this backend should be mounted at. Must not begin or end with a `/`. Defaults to `consul`.\n"
                },
                "scheme": {
                    "type": "string",
                    "description": "Specifies the URL scheme to use. Defaults to `http`.\n"
                },
                "token": {
                    "type": "string",
                    "description": "The Consul management token this backend should use to issue new tokens.\n"
                }
            },
            "required": [
                "address",
                "token"
            ],
            "inputProperties": {
                "address": {
                    "type": "string",
                    "description": "Specifies the address of the Consul instance, provided as \"host:port\" like \"127.0.0.1:8500\".\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials issued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique location this backend should be mounted at. Must not begin or end with a `/`. Defaults to `consul`.\n"
                },
                "scheme": {
                    "type": "string",
                    "description": "Specifies the URL scheme to use. Defaults to `http`.\n"
                },
                "token": {
                    "type": "string",
                    "description": "The Consul management token this backend should use to issue new tokens.\n"
                }
            },
            "requiredInputs": [
                "address",
                "token"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackend resources.\n",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "Specifies the address of the Consul instance, provided as \"host:port\" like \"127.0.0.1:8500\".\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The default TTL for credentials issued by this backend.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A human-friendly description for this backend.\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The unique location this backend should be mounted at. Must not begin or end with a `/`. Defaults to `consul`.\n"
                    },
                    "scheme": {
                        "type": "string",
                        "description": "Specifies the URL scheme to use. Defaults to `http`.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "The Consul management token this backend should use to issue new tokens.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:consul/secretBackendRole:SecretBackendRole": {
            "description": "Manages a Consul secrets role for a Consul secrets engine in Vault. Consul secret backends can then issue Consul tokens.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst test = new vault.consul.SecretBackend(\"test\", {\n    path: \"consul\",\n    description: \"Manages the Consul backend\",\n    address: \"127.0.0.1:8500\",\n    token: \"4240861b-ce3d-8530-115a-521ff070dd29\",\n});\nconst example = new vault.consul.SecretBackendRole(\"example\", {\n    backend: test.path,\n    policies: [\"example-policy\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntest = vault.consul.SecretBackend(\"test\",\n    path=\"consul\",\n    description=\"Manages the Consul backend\",\n    address=\"127.0.0.1:8500\",\n    token=\"4240861b-ce3d-8530-115a-521ff070dd29\")\nexample = vault.consul.SecretBackendRole(\"example\",\n    backend=test.path,\n    policies=[\"example-policy\"])\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var test = new Vault.Consul.SecretBackend(\"test\", new Vault.Consul.SecretBackendArgs\n        {\n            Path = \"consul\",\n            Description = \"Manages the Consul backend\",\n            Address = \"127.0.0.1:8500\",\n            Token = \"4240861b-ce3d-8530-115a-521ff070dd29\",\n        });\n        var example = new Vault.Consul.SecretBackendRole(\"example\", new Vault.Consul.SecretBackendRoleArgs\n        {\n            Backend = test.Path,\n            Policies = \n            {\n                \"example-policy\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := consul.NewSecretBackend(ctx, \"test\", \u0026consul.SecretBackendArgs{\n\t\t\tPath:        pulumi.String(\"consul\"),\n\t\t\tDescription: pulumi.String(\"Manages the Consul backend\"),\n\t\t\tAddress:     pulumi.String(\"127.0.0.1:8500\"),\n\t\t\tToken:       pulumi.String(\"4240861b-ce3d-8530-115a-521ff070dd29\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = consul.NewSecretBackendRole(ctx, \"example\", \u0026consul.SecretBackendRoleArgs{\n\t\t\tBackend: test.Path,\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"example-policy\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of an existing Consul secrets backend mount. Must not begin or end with a `/`. One of `path` or `backend` is required.\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Indicates that the token should not be replicated globally and instead be local to the current datacenter.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "Maximum TTL for leases associated with this role, in seconds.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Consul secrets engine role to create.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique name of an existing Consul secrets backend mount. Must not begin or end with a `/`. **Deprecated**\n",
                    "deprecationMessage": "use `backend` instead"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of Consul ACL policies to associate with these roles.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "Specifies the type of token to create when using this role. Valid values are \"client\" or \"management\".\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "Specifies the TTL for this role.\n"
                }
            },
            "required": [
                "name",
                "policies"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of an existing Consul secrets backend mount. Must not begin or end with a `/`. One of `path` or `backend` is required.\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Indicates that the token should not be replicated globally and instead be local to the current datacenter.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "Maximum TTL for leases associated with this role, in seconds.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Consul secrets engine role to create.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique name of an existing Consul secrets backend mount. Must not begin or end with a `/`. **Deprecated**\n",
                    "deprecationMessage": "use `backend` instead"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of Consul ACL policies to associate with these roles.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "Specifies the type of token to create when using this role. Valid values are \"client\" or \"management\".\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "Specifies the TTL for this role.\n"
                }
            },
            "requiredInputs": [
                "policies"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The unique name of an existing Consul secrets backend mount. Must not begin or end with a `/`. One of `path` or `backend` is required.\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Indicates that the token should not be replicated globally and instead be local to the current datacenter.\n"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "Maximum TTL for leases associated with this role, in seconds.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Consul secrets engine role to create.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The unique name of an existing Consul secrets backend mount. Must not begin or end with a `/`. **Deprecated**\n",
                        "deprecationMessage": "use `backend` instead"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of Consul ACL policies to associate with these roles.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "Specifies the type of token to create when using this role. Valid values are \"client\" or \"management\".\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "Specifies the TTL for this role.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:database/secretBackendConnection:SecretBackendConnection": {
            "properties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of roles that are allowed to use this\nconnection.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique name of the Vault mount to configure.\n"
                },
                "cassandra": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionCassandra:SecretBackendConnectionCassandra",
                    "description": "A nested block containing configuration options for Cassandra connections.\n"
                },
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n"
                },
                "elasticsearch": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionElasticsearch:SecretBackendConnectionElasticsearch",
                    "description": "A nested block containing configuration options for Elasticsearch connections.\n"
                },
                "hana": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionHana:SecretBackendConnectionHana",
                    "description": "A nested block containing configuration options for SAP HanaDB connections.\n"
                },
                "mongodb": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMongodb:SecretBackendConnectionMongodb",
                    "description": "A nested block containing configuration options for MongoDB connections.\n"
                },
                "mssql": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMssql:SecretBackendConnectionMssql",
                    "description": "A nested block containing configuration options for MSSQL connections.\n"
                },
                "mysql": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysql:SecretBackendConnectionMysql",
                    "description": "A nested block containing configuration options for MySQL connections.\n"
                },
                "mysqlAurora": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysqlAurora:SecretBackendConnectionMysqlAurora",
                    "description": "A nested block containing configuration options for Aurora MySQL connections.\n"
                },
                "mysqlLegacy": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysqlLegacy:SecretBackendConnectionMysqlLegacy",
                    "description": "A nested block containing configuration options for legacy MySQL connections.\n"
                },
                "mysqlRds": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysqlRds:SecretBackendConnectionMysqlRds",
                    "description": "A nested block containing configuration options for RDS MySQL connections.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to give the database connection.\n"
                },
                "oracle": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionOracle:SecretBackendConnectionOracle",
                    "description": "A nested block containing configuration options for Oracle connections.\n"
                },
                "postgresql": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionPostgresql:SecretBackendConnectionPostgresql",
                    "description": "A nested block containing configuration options for PostgreSQL connections.\n"
                },
                "rootRotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of database statements to be executed to rotate the root user's credentials.\n"
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Whether the connection should be verified on\ninitial configuration or not.\n"
                }
            },
            "required": [
                "backend",
                "name"
            ],
            "inputProperties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of roles that are allowed to use this\nconnection.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique name of the Vault mount to configure.\n"
                },
                "cassandra": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionCassandra:SecretBackendConnectionCassandra",
                    "description": "A nested block containing configuration options for Cassandra connections.\n"
                },
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n"
                },
                "elasticsearch": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionElasticsearch:SecretBackendConnectionElasticsearch",
                    "description": "A nested block containing configuration options for Elasticsearch connections.\n"
                },
                "hana": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionHana:SecretBackendConnectionHana",
                    "description": "A nested block containing configuration options for SAP HanaDB connections.\n"
                },
                "mongodb": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMongodb:SecretBackendConnectionMongodb",
                    "description": "A nested block containing configuration options for MongoDB connections.\n"
                },
                "mssql": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMssql:SecretBackendConnectionMssql",
                    "description": "A nested block containing configuration options for MSSQL connections.\n"
                },
                "mysql": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysql:SecretBackendConnectionMysql",
                    "description": "A nested block containing configuration options for MySQL connections.\n"
                },
                "mysqlAurora": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysqlAurora:SecretBackendConnectionMysqlAurora",
                    "description": "A nested block containing configuration options for Aurora MySQL connections.\n"
                },
                "mysqlLegacy": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysqlLegacy:SecretBackendConnectionMysqlLegacy",
                    "description": "A nested block containing configuration options for legacy MySQL connections.\n"
                },
                "mysqlRds": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysqlRds:SecretBackendConnectionMysqlRds",
                    "description": "A nested block containing configuration options for RDS MySQL connections.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to give the database connection.\n"
                },
                "oracle": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionOracle:SecretBackendConnectionOracle",
                    "description": "A nested block containing configuration options for Oracle connections.\n"
                },
                "postgresql": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionPostgresql:SecretBackendConnectionPostgresql",
                    "description": "A nested block containing configuration options for PostgreSQL connections.\n"
                },
                "rootRotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of database statements to be executed to rotate the root user's credentials.\n"
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Whether the connection should be verified on\ninitial configuration or not.\n"
                }
            },
            "requiredInputs": [
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendConnection resources.\n",
                "properties": {
                    "allowedRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of roles that are allowed to use this\nconnection.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The unique name of the Vault mount to configure.\n"
                    },
                    "cassandra": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionCassandra:SecretBackendConnectionCassandra",
                        "description": "A nested block containing configuration options for Cassandra connections.\n"
                    },
                    "data": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n"
                    },
                    "elasticsearch": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionElasticsearch:SecretBackendConnectionElasticsearch",
                        "description": "A nested block containing configuration options for Elasticsearch connections.\n"
                    },
                    "hana": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionHana:SecretBackendConnectionHana",
                        "description": "A nested block containing configuration options for SAP HanaDB connections.\n"
                    },
                    "mongodb": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionMongodb:SecretBackendConnectionMongodb",
                        "description": "A nested block containing configuration options for MongoDB connections.\n"
                    },
                    "mssql": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionMssql:SecretBackendConnectionMssql",
                        "description": "A nested block containing configuration options for MSSQL connections.\n"
                    },
                    "mysql": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionMysql:SecretBackendConnectionMysql",
                        "description": "A nested block containing configuration options for MySQL connections.\n"
                    },
                    "mysqlAurora": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionMysqlAurora:SecretBackendConnectionMysqlAurora",
                        "description": "A nested block containing configuration options for Aurora MySQL connections.\n"
                    },
                    "mysqlLegacy": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionMysqlLegacy:SecretBackendConnectionMysqlLegacy",
                        "description": "A nested block containing configuration options for legacy MySQL connections.\n"
                    },
                    "mysqlRds": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionMysqlRds:SecretBackendConnectionMysqlRds",
                        "description": "A nested block containing configuration options for RDS MySQL connections.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name to give the database connection.\n"
                    },
                    "oracle": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionOracle:SecretBackendConnectionOracle",
                        "description": "A nested block containing configuration options for Oracle connections.\n"
                    },
                    "postgresql": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionPostgresql:SecretBackendConnectionPostgresql",
                        "description": "A nested block containing configuration options for PostgreSQL connections.\n"
                    },
                    "rootRotationStatements": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of database statements to be executed to rotate the root user's credentials.\n"
                    },
                    "verifyConnection": {
                        "type": "boolean",
                        "description": "Whether the connection should be verified on\ninitial configuration or not.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:database/secretBackendRole:SecretBackendRole": {
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of the Vault mount to configure.\n"
                },
                "creationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\ncreating a user.\n"
                },
                "dbName": {
                    "type": "string",
                    "description": "The unique name of the database connection to use for\nthe role.\n"
                },
                "defaultTtl": {
                    "type": "integer",
                    "description": "The default number of seconds for leases for this\nrole.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum number of seconds for leases for this\nrole.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to give the role.\n"
                },
                "renewStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\nrenewing a user.\n"
                },
                "revocationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\nrevoking a user.\n"
                },
                "rollbackStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\nrolling back creation due to an error.\n"
                }
            },
            "required": [
                "backend",
                "creationStatements",
                "dbName",
                "name"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of the Vault mount to configure.\n"
                },
                "creationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\ncreating a user.\n"
                },
                "dbName": {
                    "type": "string",
                    "description": "The unique name of the database connection to use for\nthe role.\n"
                },
                "defaultTtl": {
                    "type": "integer",
                    "description": "The default number of seconds for leases for this\nrole.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum number of seconds for leases for this\nrole.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to give the role.\n"
                },
                "renewStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\nrenewing a user.\n"
                },
                "revocationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\nrevoking a user.\n"
                },
                "rollbackStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\nrolling back creation due to an error.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "creationStatements",
                "dbName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The unique name of the Vault mount to configure.\n"
                    },
                    "creationStatements": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The database statements to execute when\ncreating a user.\n"
                    },
                    "dbName": {
                        "type": "string",
                        "description": "The unique name of the database connection to use for\nthe role.\n"
                    },
                    "defaultTtl": {
                        "type": "integer",
                        "description": "The default number of seconds for leases for this\nrole.\n"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "The maximum number of seconds for leases for this\nrole.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name to give the role.\n"
                    },
                    "renewStatements": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The database statements to execute when\nrenewing a user.\n"
                    },
                    "revocationStatements": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The database statements to execute when\nrevoking a user.\n"
                    },
                    "rollbackStatements": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The database statements to execute when\nrolling back creation due to an error.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:database/secretBackendStaticRole:SecretBackendStaticRole": {
            "description": "Creates a Database Secret Backend static role in Vault. Database secret backend\nstatic roles can be used to manage 1-to-1 mapping of a Vault Role to a user in a\ndatabase for the database.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst db = new vault.Mount(\"db\", {\n    path: \"postgres\",\n    type: \"database\",\n});\nconst postgres = new vault.database.SecretBackendConnection(\"postgres\", {\n    allowedRoles: [\"*\"],\n    backend: db.path,\n    postgresql: {\n        connectionUrl: \"postgres://username:password@host:port/database\",\n    },\n});\nconst staticRole = new vault.database.SecretBackendStaticRole(\"static_role\", {\n    backend: db.path,\n    dbName: postgres.name,\n    rotationPeriod: 3600,\n    rotationStatements: [\"ALTER USER \\\"{{name}}\\\" WITH PASSWORD '{{password}}';\"],\n    username: \"example\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ndb = vault.Mount(\"db\",\n    path=\"postgres\",\n    type=\"database\")\npostgres = vault.database.SecretBackendConnection(\"postgres\",\n    allowed_roles=[\"*\"],\n    backend=db.path,\n    postgresql={\n        \"connectionUrl\": \"postgres://username:password@host:port/database\",\n    })\nstatic_role = vault.database.SecretBackendStaticRole(\"staticRole\",\n    backend=db.path,\n    db_name=postgres.name,\n    rotation_period=\"3600\",\n    rotation_statements=[\"ALTER USER \\\"{{name}}\\\" WITH PASSWORD '{{password}}';\"],\n    username=\"example\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var db = new Vault.Mount(\"db\", new Vault.MountArgs\n        {\n            Path = \"postgres\",\n            Type = \"database\",\n        });\n        var postgres = new Vault.Database.SecretBackendConnection(\"postgres\", new Vault.Database.SecretBackendConnectionArgs\n        {\n            AllowedRoles = \n            {\n                \"*\",\n            },\n            Backend = db.Path,\n            Postgresql = new Vault.Database.Inputs.SecretBackendConnectionPostgresqlArgs\n            {\n                ConnectionUrl = \"postgres://username:password@host:port/database\",\n            },\n        });\n        var staticRole = new Vault.Database.SecretBackendStaticRole(\"staticRole\", new Vault.Database.SecretBackendStaticRoleArgs\n        {\n            Backend = db.Path,\n            DbName = postgres.Name,\n            RotationPeriod = 3600,\n            RotationStatements = \n            {\n                \"ALTER USER \\\"{{name}}\\\" WITH PASSWORD '{{password}}';\",\n            },\n            Username = \"example\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/database\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdb, err := vault.NewMount(ctx, \"db\", \u0026vault.MountArgs{\n\t\t\tPath: pulumi.String(\"postgres\"),\n\t\t\tType: pulumi.String(\"database\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpostgres, err := database.NewSecretBackendConnection(ctx, \"postgres\", \u0026database.SecretBackendConnectionArgs{\n\t\t\tAllowedRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"*\"),\n\t\t\t},\n\t\t\tBackend: db.Path,\n\t\t\tPostgresql: \u0026database.SecretBackendConnectionPostgresqlArgs{\n\t\t\t\tConnectionUrl: pulumi.String(\"postgres://username:password@host:port/database\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = database.NewSecretBackendStaticRole(ctx, \"staticRole\", \u0026database.SecretBackendStaticRoleArgs{\n\t\t\tBackend:        db.Path,\n\t\t\tDbName:         postgres.Name,\n\t\t\tRotationPeriod: pulumi.Int(3600),\n\t\t\tRotationStatements: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"ALTER USER \\\"{{name}}\\\" WITH PASSWORD '{{password}}';\"),\n\t\t\t},\n\t\t\tUsername: pulumi.String(\"example\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of the Vault mount to configure.\n"
                },
                "dbName": {
                    "type": "string",
                    "description": "The unique name of the database connection to use for the static role.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to give the static role.\n"
                },
                "rotationPeriod": {
                    "type": "integer",
                    "description": "The amount of time Vault should wait before rotating the password, in seconds.\n"
                },
                "rotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Database statements to execute to rotate the password for the configured database user.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The database username that this static role corresponds to.\n"
                }
            },
            "required": [
                "backend",
                "dbName",
                "name",
                "rotationPeriod",
                "username"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of the Vault mount to configure.\n"
                },
                "dbName": {
                    "type": "string",
                    "description": "The unique name of the database connection to use for the static role.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to give the static role.\n"
                },
                "rotationPeriod": {
                    "type": "integer",
                    "description": "The amount of time Vault should wait before rotating the password, in seconds.\n"
                },
                "rotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Database statements to execute to rotate the password for the configured database user.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The database username that this static role corresponds to.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "dbName",
                "rotationPeriod",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendStaticRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The unique name of the Vault mount to configure.\n"
                    },
                    "dbName": {
                        "type": "string",
                        "description": "The unique name of the database connection to use for the static role.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name to give the static role.\n"
                    },
                    "rotationPeriod": {
                        "type": "integer",
                        "description": "The amount of time Vault should wait before rotating the password, in seconds.\n"
                    },
                    "rotationStatements": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Database statements to execute to rotate the password for the configured database user.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "The database username that this static role corresponds to.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:gcp/authBackend:AuthBackend": {
            "description": "Provides a resource to configure the [GCP auth backend within Vault](https://www.vaultproject.io/docs/auth/gcp.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as fs from \"fs\";\nimport * as vault from \"@pulumi/vault\";\n\nconst gcp = new vault.gcp.AuthBackend(\"gcp\", {\n    credentials: fs.readFileSync(\"vault-gcp-credentials.json\", \"utf-8\"),\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ngcp = vault.gcp.AuthBackend(\"gcp\", credentials=(lambda path: open(path).read())(\"vault-gcp-credentials.json\"))\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var gcp = new Vault.Gcp.AuthBackend(\"gcp\", new Vault.Gcp.AuthBackendArgs\n        {\n            Credentials = File.ReadAllText(\"vault-gcp-credentials.json\"),\n        });\n    }\n\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "clientEmail": {
                    "type": "string",
                    "description": "The clients email associated with the credentials\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The Client ID of the credentials\n"
                },
                "credentials": {
                    "type": "string",
                    "description": "A JSON string containing the contents of a GCP credentials file. If this value is empty, Vault will try to use Application Default Credentials from the machine on which the Vault server is running.\n"
                },
                "description": {
                    "type": "string"
                },
                "path": {
                    "type": "string"
                },
                "privateKeyId": {
                    "type": "string",
                    "description": "The ID of the private key from the credentials\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The GCP Project ID\n"
                }
            },
            "required": [
                "clientEmail",
                "clientId",
                "privateKeyId",
                "projectId"
            ],
            "inputProperties": {
                "clientEmail": {
                    "type": "string",
                    "description": "The clients email associated with the credentials\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The Client ID of the credentials\n"
                },
                "credentials": {
                    "type": "string",
                    "description": "A JSON string containing the contents of a GCP credentials file. If this value is empty, Vault will try to use Application Default Credentials from the machine on which the Vault server is running.\n"
                },
                "description": {
                    "type": "string"
                },
                "path": {
                    "type": "string"
                },
                "privateKeyId": {
                    "type": "string",
                    "description": "The ID of the private key from the credentials\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The GCP Project ID\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackend resources.\n",
                "properties": {
                    "clientEmail": {
                        "type": "string",
                        "description": "The clients email associated with the credentials\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The Client ID of the credentials\n"
                    },
                    "credentials": {
                        "type": "string",
                        "description": "A JSON string containing the contents of a GCP credentials file. If this value is empty, Vault will try to use Application Default Credentials from the machine on which the Vault server is running.\n"
                    },
                    "description": {
                        "type": "string"
                    },
                    "path": {
                        "type": "string"
                    },
                    "privateKeyId": {
                        "type": "string",
                        "description": "The ID of the private key from the credentials\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The GCP Project ID\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:gcp/authBackendRole:AuthBackendRole": {
            "description": "Provides a resource to create a role in an [GCP auth backend within Vault](https://www.vaultproject.io/docs/auth/gcp.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst gcpAuthBackend = new vault.AuthBackend(\"gcpAuthBackend\", {\n    path: \"gcp\",\n    type: \"gcp\",\n});\nconst gcpAuthBackendRole = new vault.gcp.AuthBackendRole(\"gcpAuthBackendRole\", {\n    backend: gcpAuthBackend.path,\n    projectId: \"foo-bar-baz\",\n    boundServiceAccounts: [\"database-server@foo-bar-baz.iam.gserviceaccount.com\"],\n    tokenPolicies: [\"database-server\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ngcp_auth_backend = vault.AuthBackend(\"gcpAuthBackend\",\n    path=\"gcp\",\n    type=\"gcp\")\ngcp_auth_backend_role = vault.gcp.AuthBackendRole(\"gcpAuthBackendRole\",\n    backend=gcp_auth_backend.path,\n    project_id=\"foo-bar-baz\",\n    bound_service_accounts=[\"database-server@foo-bar-baz.iam.gserviceaccount.com\"],\n    token_policies=[\"database-server\"])\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "addGroupAliases": {
                    "type": "boolean"
                },
                "allowGceInference": {
                    "type": "boolean",
                    "description": "A flag to determine if this role should allow GCE instances to authenticate by inferring service accounts from the GCE identity metadata token.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Path to the mounted GCP auth backend\n"
                },
                "boundInstanceGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The instance groups that an authorized instance must belong to in order to be authenticated. If specified, either `bound_zones` or `bound_regions` must be set too.\n"
                },
                "boundLabels": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A comma-separated list of GCP labels formatted as `\"key:value\"` strings that must be set on authorized GCE instances. Because GCP labels are not currently ACL'd, we recommend that this be used in conjunction with other restrictions.\n"
                },
                "boundProjects": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "GCP Projects that the role exists within\n"
                },
                "boundRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of regions that a GCE instance must belong to in order to be authenticated. If bound_instance_groups is provided, it is assumed to be a regional group and the group must belong to this region. If bound_zones are provided, this attribute is ignored.\n"
                },
                "boundServiceAccounts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "GCP Service Accounts allowed to issue tokens under this role. (Note: **Required** if role is `iam`)\n"
                },
                "boundZones": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of zones that a GCE instance must belong to in order to be authenticated. If bound_instance_groups is provided, it is assumed to be a zonal group and the group must belong to this zone.\n"
                },
                "maxJwtExp": {
                    "type": "string",
                    "description": "The number of seconds past the time of authentication that the login param JWT must expire within. For example, if a user attempts to login with a token that expires within an hour and this is set to 15 minutes, Vault will return an error prompting the user to create a new signed JWT with a shorter `exp`. The GCE metadata tokens currently do not allow the `exp` claim to be customized.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "The maximum allowed lifetime of tokens\nissued using this role, provided as a number of seconds.\n",
                    "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "period": {
                    "type": "string",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings\nspecifying the policies to be set on tokens issued using this role.\n",
                    "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the GCP role\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "The TTL period of tokens issued\nusing this role, provided as a number of seconds.\n",
                    "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "type": {
                    "type": "string",
                    "description": "Type of GCP authentication role (either `gce` or `iam`)\n"
                }
            },
            "required": [
                "addGroupAliases",
                "allowGceInference",
                "boundInstanceGroups",
                "boundLabels",
                "boundRegions",
                "boundServiceAccounts",
                "boundZones",
                "maxJwtExp",
                "maxTtl",
                "period",
                "policies",
                "role",
                "ttl",
                "type"
            ],
            "inputProperties": {
                "addGroupAliases": {
                    "type": "boolean"
                },
                "allowGceInference": {
                    "type": "boolean",
                    "description": "A flag to determine if this role should allow GCE instances to authenticate by inferring service accounts from the GCE identity metadata token.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Path to the mounted GCP auth backend\n"
                },
                "boundInstanceGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The instance groups that an authorized instance must belong to in order to be authenticated. If specified, either `bound_zones` or `bound_regions` must be set too.\n"
                },
                "boundLabels": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A comma-separated list of GCP labels formatted as `\"key:value\"` strings that must be set on authorized GCE instances. Because GCP labels are not currently ACL'd, we recommend that this be used in conjunction with other restrictions.\n"
                },
                "boundProjects": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "GCP Projects that the role exists within\n"
                },
                "boundRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of regions that a GCE instance must belong to in order to be authenticated. If bound_instance_groups is provided, it is assumed to be a regional group and the group must belong to this region. If bound_zones are provided, this attribute is ignored.\n"
                },
                "boundServiceAccounts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "GCP Service Accounts allowed to issue tokens under this role. (Note: **Required** if role is `iam`)\n"
                },
                "boundZones": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of zones that a GCE instance must belong to in order to be authenticated. If bound_instance_groups is provided, it is assumed to be a zonal group and the group must belong to this zone.\n"
                },
                "maxJwtExp": {
                    "type": "string",
                    "description": "The number of seconds past the time of authentication that the login param JWT must expire within. For example, if a user attempts to login with a token that expires within an hour and this is set to 15 minutes, Vault will return an error prompting the user to create a new signed JWT with a shorter `exp`. The GCE metadata tokens currently do not allow the `exp` claim to be customized.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "The maximum allowed lifetime of tokens\nissued using this role, provided as a number of seconds.\n",
                    "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "period": {
                    "type": "string",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings\nspecifying the policies to be set on tokens issued using this role.\n",
                    "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the GCP role\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "The TTL period of tokens issued\nusing this role, provided as a number of seconds.\n",
                    "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "type": {
                    "type": "string",
                    "description": "Type of GCP authentication role (either `gce` or `iam`)\n"
                }
            },
            "requiredInputs": [
                "role",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "addGroupAliases": {
                        "type": "boolean"
                    },
                    "allowGceInference": {
                        "type": "boolean",
                        "description": "A flag to determine if this role should allow GCE instances to authenticate by inferring service accounts from the GCE identity metadata token.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "Path to the mounted GCP auth backend\n"
                    },
                    "boundInstanceGroups": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The instance groups that an authorized instance must belong to in order to be authenticated. If specified, either `bound_zones` or `bound_regions` must be set too.\n"
                    },
                    "boundLabels": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A comma-separated list of GCP labels formatted as `\"key:value\"` strings that must be set on authorized GCE instances. Because GCP labels are not currently ACL'd, we recommend that this be used in conjunction with other restrictions.\n"
                    },
                    "boundProjects": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "GCP Projects that the role exists within\n"
                    },
                    "boundRegions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of regions that a GCE instance must belong to in order to be authenticated. If bound_instance_groups is provided, it is assumed to be a regional group and the group must belong to this region. If bound_zones are provided, this attribute is ignored.\n"
                    },
                    "boundServiceAccounts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "GCP Service Accounts allowed to issue tokens under this role. (Note: **Required** if role is `iam`)\n"
                    },
                    "boundZones": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of zones that a GCE instance must belong to in order to be authenticated. If bound_instance_groups is provided, it is assumed to be a zonal group and the group must belong to this zone.\n"
                    },
                    "maxJwtExp": {
                        "type": "string",
                        "description": "The number of seconds past the time of authentication that the login param JWT must expire within. For example, if a user attempts to login with a token that expires within an hour and this is set to 15 minutes, Vault will return an error prompting the user to create a new signed JWT with a shorter `exp`. The GCE metadata tokens currently do not allow the `exp` claim to be customized.\n"
                    },
                    "maxTtl": {
                        "type": "string",
                        "description": "The maximum allowed lifetime of tokens\nissued using this role, provided as a number of seconds.\n",
                        "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                    },
                    "period": {
                        "type": "string",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n",
                        "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of strings\nspecifying the policies to be set on tokens issued using this role.\n",
                        "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                    },
                    "role": {
                        "type": "string",
                        "description": "Name of the GCP role\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "The TTL period of tokens issued\nusing this role, provided as a number of seconds.\n",
                        "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of GCP authentication role (either `gce` or `iam`)\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:gcp/secretBackend:SecretBackend": {
            "properties": {
                "credentials": {
                    "type": "string",
                    "description": "The GCP service account credentials in JSON format.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials\nissued by this backend. Defaults to '0'.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend. Defaults to '0'.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `gcp`.\n"
                }
            },
            "inputProperties": {
                "credentials": {
                    "type": "string",
                    "description": "The GCP service account credentials in JSON format.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials\nissued by this backend. Defaults to '0'.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend. Defaults to '0'.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `gcp`.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackend resources.\n",
                "properties": {
                    "credentials": {
                        "type": "string",
                        "description": "The GCP service account credentials in JSON format.\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The default TTL for credentials\nissued by this backend. Defaults to '0'.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A human-friendly description for this backend.\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The maximum TTL that can be requested\nfor credentials issued by this backend. Defaults to '0'.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `gcp`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:gcp/secretRoleset:SecretRoleset": {
            "description": "Creates a Roleset in the [GCP Secrets Engine](https://www.vaultproject.io/docs/secrets/gcp/index.html) for Vault.\n\nEach Roleset is [tied](https://www.vaultproject.io/docs/secrets/gcp/index.html#service-accounts-are-tied-to-rolesets) to a Service Account, and can have one or more [bindings](https://www.vaultproject.io/docs/secrets/gcp/index.html#roleset-bindings) associated with it.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as fs from \"fs\";\nimport * as vault from \"@pulumi/vault\";\n\nconst project = \"my-awesome-project\";\nconst gcp = new vault.gcp.SecretBackend(\"gcp\", {\n    credentials: fs.readFileSync(\"credentials.json\", \"utf-8\"),\n    path: \"gcp\",\n});\nconst roleset = new vault.gcp.SecretRoleset(\"roleset\", {\n    backend: gcp.path,\n    bindings: [{\n        resource: `//cloudresourcemanager.googleapis.com/projects/${project}`,\n        roles: [\"roles/viewer\"],\n    }],\n    project: project,\n    roleset: \"project_viewer\",\n    secretType: \"access_token\",\n    tokenScopes: [\"https://www.googleapis.com/auth/cloud-platform\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nproject = \"my-awesome-project\"\ngcp = vault.gcp.SecretBackend(\"gcp\",\n    credentials=(lambda path: open(path).read())(\"credentials.json\"),\n    path=\"gcp\")\nroleset = vault.gcp.SecretRoleset(\"roleset\",\n    backend=gcp.path,\n    bindings=[{\n        \"resource\": f\"//cloudresourcemanager.googleapis.com/projects/{project}\",\n        \"roles\": [\"roles/viewer\"],\n    }],\n    project=project,\n    roleset=\"project_viewer\",\n    secret_type=\"access_token\",\n    token_scopes=[\"https://www.googleapis.com/auth/cloud-platform\"])\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var project = \"my-awesome-project\";\n        var gcp = new Vault.Gcp.SecretBackend(\"gcp\", new Vault.Gcp.SecretBackendArgs\n        {\n            Credentials = File.ReadAllText(\"credentials.json\"),\n            Path = \"gcp\",\n        });\n        var roleset = new Vault.Gcp.SecretRoleset(\"roleset\", new Vault.Gcp.SecretRolesetArgs\n        {\n            Backend = gcp.Path,\n            Bindings = \n            {\n                new Vault.Gcp.Inputs.SecretRolesetBindingArgs\n                {\n                    Resource = $\"//cloudresourcemanager.googleapis.com/projects/{project}\",\n                    Roles = \n                    {\n                        \"roles/viewer\",\n                    },\n                },\n            },\n            Project = project,\n            Roleset = \"project_viewer\",\n            SecretType = \"access_token\",\n            TokenScopes = \n            {\n                \"https://www.googleapis.com/auth/cloud-platform\",\n            },\n        });\n    }\n\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the GCP Secrets Engine is mounted\n"
                },
                "bindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:gcp/SecretRolesetBinding:SecretRolesetBinding"
                    },
                    "description": "Bindings to create for this roleset. This can be specified multiple times for multiple bindings. Structure is documented below.\n"
                },
                "project": {
                    "type": "string",
                    "description": "Name of the GCP project that this roleset's service account will belong to.\n"
                },
                "roleset": {
                    "type": "string",
                    "description": "Name of the Roleset to create\n"
                },
                "secretType": {
                    "type": "string",
                    "description": "Type of secret generated for this role set. Accepted values: `access_token`, `service_account_key`. Defaults to `access_token`.\n"
                },
                "serviceAccountEmail": {
                    "type": "string",
                    "description": "Email of the service account created by Vault for this Roleset\n"
                },
                "tokenScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of OAuth scopes to assign to `access_token` secrets generated under this role set (`access_token` role sets only).\n"
                }
            },
            "required": [
                "backend",
                "bindings",
                "project",
                "roleset",
                "secretType",
                "serviceAccountEmail"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the GCP Secrets Engine is mounted\n"
                },
                "bindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:gcp/SecretRolesetBinding:SecretRolesetBinding"
                    },
                    "description": "Bindings to create for this roleset. This can be specified multiple times for multiple bindings. Structure is documented below.\n"
                },
                "project": {
                    "type": "string",
                    "description": "Name of the GCP project that this roleset's service account will belong to.\n"
                },
                "roleset": {
                    "type": "string",
                    "description": "Name of the Roleset to create\n"
                },
                "secretType": {
                    "type": "string",
                    "description": "Type of secret generated for this role set. Accepted values: `access_token`, `service_account_key`. Defaults to `access_token`.\n"
                },
                "tokenScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of OAuth scopes to assign to `access_token` secrets generated under this role set (`access_token` role sets only).\n"
                }
            },
            "requiredInputs": [
                "backend",
                "bindings",
                "project",
                "roleset"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretRoleset resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Path where the GCP Secrets Engine is mounted\n"
                    },
                    "bindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:gcp/SecretRolesetBinding:SecretRolesetBinding"
                        },
                        "description": "Bindings to create for this roleset. This can be specified multiple times for multiple bindings. Structure is documented below.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "Name of the GCP project that this roleset's service account will belong to.\n"
                    },
                    "roleset": {
                        "type": "string",
                        "description": "Name of the Roleset to create\n"
                    },
                    "secretType": {
                        "type": "string",
                        "description": "Type of secret generated for this role set. Accepted values: `access_token`, `service_account_key`. Defaults to `access_token`.\n"
                    },
                    "serviceAccountEmail": {
                        "type": "string",
                        "description": "Email of the service account created by Vault for this Roleset\n"
                    },
                    "tokenScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of OAuth scopes to assign to `access_token` secrets generated under this role set (`access_token` role sets only).\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:generic/endpoint:Endpoint": {
            "properties": {
                "dataJson": {
                    "type": "string",
                    "description": "String containing a JSON-encoded object that will be\nwritten to the given path as the secret data.\n"
                },
                "disableDelete": {
                    "type": "boolean",
                    "description": "Don't attempt to delete the path from Vault if true\n"
                },
                "disableRead": {
                    "type": "boolean",
                    "description": "True/false. Set this to true if your vault\nauthentication is not able to read the data or if the endpoint does\nnot support the `GET` method. Setting this to `true` will break drift\ndetection. You should set this to `true` for endpoints that are\nwrite-only. Defaults to false.\n"
                },
                "ignoreAbsentFields": {
                    "type": "boolean",
                    "description": "When reading, disregard fields not present in data_json\n"
                },
                "path": {
                    "type": "string",
                    "description": "The full logical path at which to write the given\ndata. Consult each backend's documentation to see which endpoints\nsupport the `PUT` methods and to determine whether they also support\n`DELETE` and `GET`.\n"
                },
                "writeData": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of strings returned by write operation\n"
                },
                "writeDataJson": {
                    "type": "string",
                    "description": "JSON data returned by write operation\n"
                },
                "writeFields": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Top-level fields returned by write to persist in state\n"
                }
            },
            "required": [
                "dataJson",
                "path",
                "writeData",
                "writeDataJson"
            ],
            "inputProperties": {
                "dataJson": {
                    "type": "string",
                    "description": "String containing a JSON-encoded object that will be\nwritten to the given path as the secret data.\n"
                },
                "disableDelete": {
                    "type": "boolean",
                    "description": "Don't attempt to delete the path from Vault if true\n"
                },
                "disableRead": {
                    "type": "boolean",
                    "description": "True/false. Set this to true if your vault\nauthentication is not able to read the data or if the endpoint does\nnot support the `GET` method. Setting this to `true` will break drift\ndetection. You should set this to `true` for endpoints that are\nwrite-only. Defaults to false.\n"
                },
                "ignoreAbsentFields": {
                    "type": "boolean",
                    "description": "When reading, disregard fields not present in data_json\n"
                },
                "path": {
                    "type": "string",
                    "description": "The full logical path at which to write the given\ndata. Consult each backend's documentation to see which endpoints\nsupport the `PUT` methods and to determine whether they also support\n`DELETE` and `GET`.\n"
                },
                "writeFields": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Top-level fields returned by write to persist in state\n"
                }
            },
            "requiredInputs": [
                "dataJson",
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Endpoint resources.\n",
                "properties": {
                    "dataJson": {
                        "type": "string",
                        "description": "String containing a JSON-encoded object that will be\nwritten to the given path as the secret data.\n"
                    },
                    "disableDelete": {
                        "type": "boolean",
                        "description": "Don't attempt to delete the path from Vault if true\n"
                    },
                    "disableRead": {
                        "type": "boolean",
                        "description": "True/false. Set this to true if your vault\nauthentication is not able to read the data or if the endpoint does\nnot support the `GET` method. Setting this to `true` will break drift\ndetection. You should set this to `true` for endpoints that are\nwrite-only. Defaults to false.\n"
                    },
                    "ignoreAbsentFields": {
                        "type": "boolean",
                        "description": "When reading, disregard fields not present in data_json\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The full logical path at which to write the given\ndata. Consult each backend's documentation to see which endpoints\nsupport the `PUT` methods and to determine whether they also support\n`DELETE` and `GET`.\n"
                    },
                    "writeData": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of strings returned by write operation\n"
                    },
                    "writeDataJson": {
                        "type": "string",
                        "description": "JSON data returned by write operation\n"
                    },
                    "writeFields": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Top-level fields returned by write to persist in state\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:generic/secret:Secret": {
            "properties": {
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A mapping whose keys are the top-level data keys returned from\nVault and whose values are the corresponding values. This map can only\nrepresent string data, so any non-string values returned from Vault are\nserialized as JSON.\n"
                },
                "dataJson": {
                    "type": "string",
                    "description": "String containing a JSON-encoded object that will be\nwritten as the secret data at the given path.\n"
                },
                "disableRead": {
                    "type": "boolean",
                    "description": "True/false. Set this to true if your vault\nauthentication is not able to read the data. Setting this to `true` will\nbreak drift detection. Defaults to false.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The full logical path at which to write the given data.\nTo write data into the \"generic\" secret backend mounted in Vault by default,\nthis should be prefixed with `secret/`. Writing to other backends with this\nresource is possible; consult each backend's documentation to see which\nendpoints support the `PUT` and `DELETE` methods.\n"
                }
            },
            "required": [
                "data",
                "dataJson",
                "path"
            ],
            "inputProperties": {
                "dataJson": {
                    "type": "string",
                    "description": "String containing a JSON-encoded object that will be\nwritten as the secret data at the given path.\n"
                },
                "disableRead": {
                    "type": "boolean",
                    "description": "True/false. Set this to true if your vault\nauthentication is not able to read the data. Setting this to `true` will\nbreak drift detection. Defaults to false.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The full logical path at which to write the given data.\nTo write data into the \"generic\" secret backend mounted in Vault by default,\nthis should be prefixed with `secret/`. Writing to other backends with this\nresource is possible; consult each backend's documentation to see which\nendpoints support the `PUT` and `DELETE` methods.\n"
                }
            },
            "requiredInputs": [
                "dataJson",
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Secret resources.\n",
                "properties": {
                    "data": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A mapping whose keys are the top-level data keys returned from\nVault and whose values are the corresponding values. This map can only\nrepresent string data, so any non-string values returned from Vault are\nserialized as JSON.\n"
                    },
                    "dataJson": {
                        "type": "string",
                        "description": "String containing a JSON-encoded object that will be\nwritten as the secret data at the given path.\n"
                    },
                    "disableRead": {
                        "type": "boolean",
                        "description": "True/false. Set this to true if your vault\nauthentication is not able to read the data. Setting this to `true` will\nbreak drift detection. Defaults to false.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The full logical path at which to write the given data.\nTo write data into the \"generic\" secret backend mounted in Vault by default,\nthis should be prefixed with `secret/`. Writing to other backends with this\nresource is possible; consult each backend's documentation to see which\nendpoints support the `PUT` and `DELETE` methods.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:github/authBackend:AuthBackend": {
            "description": "Manages a Github Auth mount in a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/github/) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.github.AuthBackend(\"example\", {\n    organization: \"myorg\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.github.AuthBackend(\"example\", organization=\"myorg\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.GitHub.AuthBackend(\"example\", new Vault.GitHub.AuthBackendArgs\n        {\n            Organization = \"myorg\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/github\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := github.NewAuthBackend(ctx, \"example\", \u0026github.AuthBackendArgs{\n\t\t\tOrganization: pulumi.String(\"myorg\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The mount accessor related to the auth mount. It is useful for integration with [Identity Secrets Engine](https://www.vaultproject.io/docs/secrets/identity/index.html).\n"
                },
                "baseUrl": {
                    "type": "string",
                    "description": "The API endpoint to use. Useful if you\nare running GitHub Enterprise or an API-compatible authentication server.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Specifies the description of the mount.\nThis overrides the current stored value, if any.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "(Optional; Deprecated, use `token_max_ttl` instead if you are running Vault \u003e= 1.2) The maximum allowed lifetime of tokens\nissued using this role. This must be a valid [duration string](https://golang.org/pkg/time/#ParseDuration).\n",
                    "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization configured users must be part of.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path where the auth backend is mounted. Defaults to `auth/github`\nif not specified.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Optional) List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "(Optional) If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "(Optional) The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "(Optional) If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "(Optional) The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "(Optional) If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Optional) List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "(Optional) The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "Specifies the type of tokens that should be returned by\nthe mount. Valid values are \"default-service\", \"default-batch\", \"service\", \"batch\".\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "(Optional; Deprecated, use `token_ttl` instead if you are running Vault \u003e= 1.2) The TTL period of tokens issued\nusing this role. This must be a valid [duration string](https://golang.org/pkg/time/#ParseDuration).\n",
                    "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "tune": {
                    "$ref": "#/types/vault:github/AuthBackendTune:AuthBackendTune"
                }
            },
            "required": [
                "accessor",
                "organization",
                "tune"
            ],
            "inputProperties": {
                "baseUrl": {
                    "type": "string",
                    "description": "The API endpoint to use. Useful if you\nare running GitHub Enterprise or an API-compatible authentication server.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Specifies the description of the mount.\nThis overrides the current stored value, if any.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "(Optional; Deprecated, use `token_max_ttl` instead if you are running Vault \u003e= 1.2) The maximum allowed lifetime of tokens\nissued using this role. This must be a valid [duration string](https://golang.org/pkg/time/#ParseDuration).\n",
                    "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization configured users must be part of.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path where the auth backend is mounted. Defaults to `auth/github`\nif not specified.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Optional) List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "(Optional) If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "(Optional) The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "(Optional) If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "(Optional) The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "(Optional) If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Optional) List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "(Optional) The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "Specifies the type of tokens that should be returned by\nthe mount. Valid values are \"default-service\", \"default-batch\", \"service\", \"batch\".\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "(Optional; Deprecated, use `token_ttl` instead if you are running Vault \u003e= 1.2) The TTL period of tokens issued\nusing this role. This must be a valid [duration string](https://golang.org/pkg/time/#ParseDuration).\n",
                    "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "tune": {
                    "$ref": "#/types/vault:github/AuthBackendTune:AuthBackendTune"
                }
            },
            "requiredInputs": [
                "organization"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackend resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The mount accessor related to the auth mount. It is useful for integration with [Identity Secrets Engine](https://www.vaultproject.io/docs/secrets/identity/index.html).\n"
                    },
                    "baseUrl": {
                        "type": "string",
                        "description": "The API endpoint to use. Useful if you\nare running GitHub Enterprise or an API-compatible authentication server.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Specifies the description of the mount.\nThis overrides the current stored value, if any.\n"
                    },
                    "maxTtl": {
                        "type": "string",
                        "description": "(Optional; Deprecated, use `token_max_ttl` instead if you are running Vault \u003e= 1.2) The maximum allowed lifetime of tokens\nissued using this role. This must be a valid [duration string](https://golang.org/pkg/time/#ParseDuration).\n",
                        "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                    },
                    "organization": {
                        "type": "string",
                        "description": "The organization configured users must be part of.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Path where the auth backend is mounted. Defaults to `auth/github`\nif not specified.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(Optional) List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "(Optional) If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "(Optional) The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "(Optional) If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "(Optional) The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "(Optional) If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(Optional) List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "(Optional) The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "Specifies the type of tokens that should be returned by\nthe mount. Valid values are \"default-service\", \"default-batch\", \"service\", \"batch\".\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "(Optional; Deprecated, use `token_ttl` instead if you are running Vault \u003e= 1.2) The TTL period of tokens issued\nusing this role. This must be a valid [duration string](https://golang.org/pkg/time/#ParseDuration).\n",
                        "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                    },
                    "tune": {
                        "$ref": "#/types/vault:github/AuthBackendTune:AuthBackendTune"
                    }
                },
                "type": "object"
            }
        },
        "vault:github/team:Team": {
            "description": "Manages policy mappings for Github Teams authenticated via Github. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/github/) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.github.AuthBackend(\"example\", {organization: \"myorg\"});\nconst tfDevs = new vault.github.Team(\"tfDevs\", {\n    backend: example.id,\n    team: \"terraform-developers\",\n    policies: [\n        \"developer\",\n        \"read-only\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.github.AuthBackend(\"example\", organization=\"myorg\")\ntf_devs = vault.github.Team(\"tfDevs\",\n    backend=example.id,\n    team=\"terraform-developers\",\n    policies=[\n        \"developer\",\n        \"read-only\",\n    ])\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.GitHub.AuthBackend(\"example\", new Vault.GitHub.AuthBackendArgs\n        {\n            Organization = \"myorg\",\n        });\n        var tfDevs = new Vault.GitHub.Team(\"tfDevs\", new Vault.GitHub.TeamArgs\n        {\n            Backend = example.Id,\n            Team = \"terraform-developers\",\n            Policies = \n            {\n                \"developer\",\n                \"read-only\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/github\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := github.NewAuthBackend(ctx, \"example\", \u0026github.AuthBackendArgs{\n\t\t\tOrganization: pulumi.String(\"myorg\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = github.NewTeam(ctx, \"tfDevs\", \u0026github.TeamArgs{\n\t\t\tBackend: example.ID(),\n\t\t\tTeam:    pulumi.String(\"terraform-developers\"),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"developer\"),\n\t\t\t\tpulumi.String(\"read-only\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the github auth backend is mounted. Defaults to `github`\nif not specified.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings specifying the policies to be set on tokens\nissued using this role.\n"
                },
                "team": {
                    "type": "string",
                    "description": "GitHub team name in \"slugified\" format.\n",
                    "language": {
                        "csharp": {
                            "name": "TeamCity"
                        }
                    }
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                }
            },
            "required": [
                "team"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the github auth backend is mounted. Defaults to `github`\nif not specified.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings specifying the policies to be set on tokens\nissued using this role.\n"
                },
                "team": {
                    "type": "string",
                    "description": "GitHub team name in \"slugified\" format.\n",
                    "language": {
                        "csharp": {
                            "name": "TeamCity"
                        }
                    }
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                }
            },
            "requiredInputs": [
                "team"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Team resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Path where the github auth backend is mounted. Defaults to `github`\nif not specified.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of strings specifying the policies to be set on tokens\nissued using this role.\n"
                    },
                    "team": {
                        "type": "string",
                        "description": "GitHub team name in \"slugified\" format.\n",
                        "language": {
                            "csharp": {
                                "name": "TeamCity"
                            }
                        }
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "Generated Token's Explicit Maximum TTL in seconds\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime of the generated token\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If true, the 'default' policy will not automatically be added to generated tokens\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The maximum number of times a token may be used, a value of zero means unlimited\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "Generated Token's Period\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Generated Token's Policies\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The initial ttl of the token to generate in seconds\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token to generate, service or batch\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    }
                },
                "type": "object"
            }
        },
        "vault:github/user:User": {
            "description": "Manages policy mappings for Github Users authenticated via Github. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/github/) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.github.AuthBackend(\"example\", {organization: \"myorg\"});\nconst tfUser = new vault.github.User(\"tfUser\", {\n    backend: example.id,\n    user: \"john.doe\",\n    policies: [\n        \"developer\",\n        \"read-only\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.github.AuthBackend(\"example\", organization=\"myorg\")\ntf_user = vault.github.User(\"tfUser\",\n    backend=example.id,\n    user=\"john.doe\",\n    policies=[\n        \"developer\",\n        \"read-only\",\n    ])\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.GitHub.AuthBackend(\"example\", new Vault.GitHub.AuthBackendArgs\n        {\n            Organization = \"myorg\",\n        });\n        var tfUser = new Vault.GitHub.User(\"tfUser\", new Vault.GitHub.UserArgs\n        {\n            Backend = example.Id,\n            User = \"john.doe\",\n            Policies = \n            {\n                \"developer\",\n                \"read-only\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/github\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := github.NewAuthBackend(ctx, \"example\", \u0026github.AuthBackendArgs{\n\t\t\tOrganization: pulumi.String(\"myorg\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = github.NewUser(ctx, \"tfUser\", \u0026github.UserArgs{\n\t\t\tBackend: example.ID(),\n\t\t\tUser:    pulumi.String(\"john.doe\"),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"developer\"),\n\t\t\t\tpulumi.String(\"read-only\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the github auth backend is mounted. Defaults to `github`\nif not specified.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings specifying the policies to be set on tokens issued\nusing this role.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "user": {
                    "type": "string",
                    "description": "GitHub user name.\n",
                    "language": {
                        "csharp": {
                            "name": "UserName"
                        }
                    }
                }
            },
            "required": [
                "user"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the github auth backend is mounted. Defaults to `github`\nif not specified.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings specifying the policies to be set on tokens issued\nusing this role.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "user": {
                    "type": "string",
                    "description": "GitHub user name.\n",
                    "language": {
                        "csharp": {
                            "name": "UserName"
                        }
                    }
                }
            },
            "requiredInputs": [
                "user"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering User resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Path where the github auth backend is mounted. Defaults to `github`\nif not specified.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of strings specifying the policies to be set on tokens issued\nusing this role.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "Generated Token's Explicit Maximum TTL in seconds\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime of the generated token\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If true, the 'default' policy will not automatically be added to generated tokens\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The maximum number of times a token may be used, a value of zero means unlimited\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "Generated Token's Period\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Generated Token's Policies\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The initial ttl of the token to generate in seconds\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token to generate, service or batch\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "user": {
                        "type": "string",
                        "description": "GitHub user name.\n",
                        "language": {
                            "csharp": {
                                "name": "UserName"
                            }
                        }
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/entity:Entity": {
            "properties": {
                "disabled": {
                    "type": "boolean",
                    "description": "True/false Is this entity currently disabled. Defaults to `false`\n"
                },
                "externalPolicies": {
                    "type": "boolean",
                    "description": "`false` by default. If set to `true`, this resource will ignore any policies return from Vault or specified in the resource. You can use `vault.identity.EntityPolicies` to manage policies for this entity in a decoupled manner.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A Map of additional metadata to associate with the user.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the identity entity to create.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of policies to apply to the entity.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "disabled": {
                    "type": "boolean",
                    "description": "True/false Is this entity currently disabled. Defaults to `false`\n"
                },
                "externalPolicies": {
                    "type": "boolean",
                    "description": "`false` by default. If set to `true`, this resource will ignore any policies return from Vault or specified in the resource. You can use `vault.identity.EntityPolicies` to manage policies for this entity in a decoupled manner.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A Map of additional metadata to associate with the user.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the identity entity to create.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of policies to apply to the entity.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Entity resources.\n",
                "properties": {
                    "disabled": {
                        "type": "boolean",
                        "description": "True/false Is this entity currently disabled. Defaults to `false`\n"
                    },
                    "externalPolicies": {
                        "type": "boolean",
                        "description": "`false` by default. If set to `true`, this resource will ignore any policies return from Vault or specified in the resource. You can use `vault.identity.EntityPolicies` to manage policies for this entity in a decoupled manner.\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A Map of additional metadata to associate with the user.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the identity entity to create.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of policies to apply to the entity.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/entityAlias:EntityAlias": {
            "properties": {
                "canonicalId": {
                    "type": "string",
                    "description": "Entity ID to which this alias belongs to.\n"
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "Accessor of the mount to which the alias should belong to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the alias. Name should be the identifier of the client in the authentication source. For example, if the alias belongs to userpass backend, the name should be a valid username within userpass backend. If alias belongs to GitHub, it should be the GitHub username.\n"
                }
            },
            "required": [
                "canonicalId",
                "mountAccessor",
                "name"
            ],
            "inputProperties": {
                "canonicalId": {
                    "type": "string",
                    "description": "Entity ID to which this alias belongs to.\n"
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "Accessor of the mount to which the alias should belong to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the alias. Name should be the identifier of the client in the authentication source. For example, if the alias belongs to userpass backend, the name should be a valid username within userpass backend. If alias belongs to GitHub, it should be the GitHub username.\n"
                }
            },
            "requiredInputs": [
                "canonicalId",
                "mountAccessor"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EntityAlias resources.\n",
                "properties": {
                    "canonicalId": {
                        "type": "string",
                        "description": "Entity ID to which this alias belongs to.\n"
                    },
                    "mountAccessor": {
                        "type": "string",
                        "description": "Accessor of the mount to which the alias should belong to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the alias. Name should be the identifier of the client in the authentication source. For example, if the alias belongs to userpass backend, the name should be a valid username within userpass backend. If alias belongs to GitHub, it should be the GitHub username.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/entityPolicies:EntityPolicies": {
            "description": "Manages policies for an Identity Entity for Vault. The [Identity secrets engine](https://www.vaultproject.io/docs/secrets/identity/index.html) is the identity management solution for Vault.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Exclusive Policies\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst entity = new vault.identity.Entity(\"entity\", {externalPolicies: true});\nconst policies = new vault.identity.EntityPolicies(\"policies\", {\n    policies: [\n        \"default\",\n        \"test\",\n    ],\n    exclusive: true,\n    entityId: entity.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nentity = vault.identity.Entity(\"entity\", external_policies=True)\npolicies = vault.identity.EntityPolicies(\"policies\",\n    policies=[\n        \"default\",\n        \"test\",\n    ],\n    exclusive=True,\n    entity_id=entity.id)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var entity = new Vault.Identity.Entity(\"entity\", new Vault.Identity.EntityArgs\n        {\n            ExternalPolicies = true,\n        });\n        var policies = new Vault.Identity.EntityPolicies(\"policies\", new Vault.Identity.EntityPoliciesArgs\n        {\n            Policies = \n            {\n                \"default\",\n                \"test\",\n            },\n            Exclusive = true,\n            EntityId = entity.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tentity, err := identity.NewEntity(ctx, \"entity\", \u0026identity.EntityArgs{\n\t\t\tExternalPolicies: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewEntityPolicies(ctx, \"policies\", \u0026identity.EntityPoliciesArgs{\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tExclusive: pulumi.Bool(true),\n\t\t\tEntityId:  entity.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% example %}}\n### Non-exclusive Policies\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst entity = new vault.identity.Entity(\"entity\", {externalPolicies: true});\nconst _default = new vault.identity.EntityPolicies(\"default\", {\n    policies: [\n        \"default\",\n        \"test\",\n    ],\n    exclusive: false,\n    entityId: entity.id,\n});\nconst others = new vault.identity.EntityPolicies(\"others\", {\n    policies: [\"others\"],\n    exclusive: false,\n    entityId: entity.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nentity = vault.identity.Entity(\"entity\", external_policies=True)\ndefault = vault.identity.EntityPolicies(\"default\",\n    policies=[\n        \"default\",\n        \"test\",\n    ],\n    exclusive=False,\n    entity_id=entity.id)\nothers = vault.identity.EntityPolicies(\"others\",\n    policies=[\"others\"],\n    exclusive=False,\n    entity_id=entity.id)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var entity = new Vault.Identity.Entity(\"entity\", new Vault.Identity.EntityArgs\n        {\n            ExternalPolicies = true,\n        });\n        var @default = new Vault.Identity.EntityPolicies(\"default\", new Vault.Identity.EntityPoliciesArgs\n        {\n            Policies = \n            {\n                \"default\",\n                \"test\",\n            },\n            Exclusive = false,\n            EntityId = entity.Id,\n        });\n        var others = new Vault.Identity.EntityPolicies(\"others\", new Vault.Identity.EntityPoliciesArgs\n        {\n            Policies = \n            {\n                \"others\",\n            },\n            Exclusive = false,\n            EntityId = entity.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tentity, err := identity.NewEntity(ctx, \"entity\", \u0026identity.EntityArgs{\n\t\t\tExternalPolicies: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewEntityPolicies(ctx, \"_default\", \u0026identity.EntityPoliciesArgs{\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tExclusive: pulumi.Bool(false),\n\t\t\tEntityId:  entity.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewEntityPolicies(ctx, \"others\", \u0026identity.EntityPoliciesArgs{\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"others\"),\n\t\t\t},\n\t\t\tExclusive: pulumi.Bool(false),\n\t\t\tEntityId:  entity.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "entityId": {
                    "type": "string",
                    "description": "Entity ID to assign policies to.\n"
                },
                "entityName": {
                    "type": "string",
                    "description": "The name of the entity that are assigned the policies.\n"
                },
                "exclusive": {
                    "type": "boolean",
                    "description": "Defaults to `true`.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to assign to the entity\n"
                }
            },
            "required": [
                "entityId",
                "entityName",
                "policies"
            ],
            "inputProperties": {
                "entityId": {
                    "type": "string",
                    "description": "Entity ID to assign policies to.\n"
                },
                "exclusive": {
                    "type": "boolean",
                    "description": "Defaults to `true`.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to assign to the entity\n"
                }
            },
            "requiredInputs": [
                "entityId",
                "policies"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EntityPolicies resources.\n",
                "properties": {
                    "entityId": {
                        "type": "string",
                        "description": "Entity ID to assign policies to.\n"
                    },
                    "entityName": {
                        "type": "string",
                        "description": "The name of the entity that are assigned the policies.\n"
                    },
                    "exclusive": {
                        "type": "boolean",
                        "description": "Defaults to `true`.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to assign to the entity\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/group:Group": {
            "description": "Creates an Identity Group for Vault. The [Identity secrets engine](https://www.vaultproject.io/docs/secrets/identity/index.html) is the identity management solution for Vault.\n\nA group can contain multiple entities as its members. A group can also have subgroups. Policies set on the group is granted to all members of the group. During request time, when the token's entity ID is being evaluated for the policies that it has access to; along with the policies on the entity itself, policies that are inherited due to group memberships are also granted.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Internal Group\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst internal = new vault.identity.Group(\"internal\", {\n    metadata: {\n        version: \"2\",\n    },\n    policies: [\n        \"dev\",\n        \"test\",\n    ],\n    type: \"internal\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ninternal = vault.identity.Group(\"internal\",\n    metadata={\n        \"version\": \"2\",\n    },\n    policies=[\n        \"dev\",\n        \"test\",\n    ],\n    type=\"internal\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var @internal = new Vault.Identity.Group(\"internal\", new Vault.Identity.GroupArgs\n        {\n            Metadata = \n            {\n                { \"version\", \"2\" },\n            },\n            Policies = \n            {\n                \"dev\",\n                \"test\",\n            },\n            Type = \"internal\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := identity.NewGroup(ctx, \"internal\", \u0026identity.GroupArgs{\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"version\": pulumi.String(\"2\"),\n\t\t\t},\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"internal\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% example %}}\n### External Group\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst group = new vault.identity.Group(\"group\", {\n    metadata: {\n        version: \"1\",\n    },\n    policies: [\"test\"],\n    type: \"external\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ngroup = vault.identity.Group(\"group\",\n    metadata={\n        \"version\": \"1\",\n    },\n    policies=[\"test\"],\n    type=\"external\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var @group = new Vault.Identity.Group(\"group\", new Vault.Identity.GroupArgs\n        {\n            Metadata = \n            {\n                { \"version\", \"1\" },\n            },\n            Policies = \n            {\n                \"test\",\n            },\n            Type = \"external\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := identity.NewGroup(ctx, \"group\", \u0026identity.GroupArgs{\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"version\": pulumi.String(\"1\"),\n\t\t\t},\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"external\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "externalMemberEntityIds": {
                    "type": "boolean",
                    "description": "`false` by default. If set to `true`, this resource will ignore any Entity IDs returned from Vault or specified in the resource. You can use `vault.identity.GroupMemberEntityIds` to manage Entity IDs for this group in a decoupled manner.\n"
                },
                "externalPolicies": {
                    "type": "boolean",
                    "description": "`false` by default. If set to `true`, this resource will ignore any policies returned from Vault or specified in the resource. You can use `vault.identity.GroupPolicies` to manage policies for this group in a decoupled manner.\n"
                },
                "memberEntityIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of Entity IDs to be assigned as group members. Not allowed on `external` groups.\n"
                },
                "memberGroupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of Group IDs to be assigned as group members. Not allowed on `external` groups.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A Map of additional metadata to associate with the group.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the identity group to create.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of policies to apply to the group.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the group, internal or external. Defaults to `internal`.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "externalMemberEntityIds": {
                    "type": "boolean",
                    "description": "`false` by default. If set to `true`, this resource will ignore any Entity IDs returned from Vault or specified in the resource. You can use `vault.identity.GroupMemberEntityIds` to manage Entity IDs for this group in a decoupled manner.\n"
                },
                "externalPolicies": {
                    "type": "boolean",
                    "description": "`false` by default. If set to `true`, this resource will ignore any policies returned from Vault or specified in the resource. You can use `vault.identity.GroupPolicies` to manage policies for this group in a decoupled manner.\n"
                },
                "memberEntityIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of Entity IDs to be assigned as group members. Not allowed on `external` groups.\n"
                },
                "memberGroupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of Group IDs to be assigned as group members. Not allowed on `external` groups.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A Map of additional metadata to associate with the group.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the identity group to create.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of policies to apply to the group.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the group, internal or external. Defaults to `internal`.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Group resources.\n",
                "properties": {
                    "externalMemberEntityIds": {
                        "type": "boolean",
                        "description": "`false` by default. If set to `true`, this resource will ignore any Entity IDs returned from Vault or specified in the resource. You can use `vault.identity.GroupMemberEntityIds` to manage Entity IDs for this group in a decoupled manner.\n"
                    },
                    "externalPolicies": {
                        "type": "boolean",
                        "description": "`false` by default. If set to `true`, this resource will ignore any policies returned from Vault or specified in the resource. You can use `vault.identity.GroupPolicies` to manage policies for this group in a decoupled manner.\n"
                    },
                    "memberEntityIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of Entity IDs to be assigned as group members. Not allowed on `external` groups.\n"
                    },
                    "memberGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of Group IDs to be assigned as group members. Not allowed on `external` groups.\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A Map of additional metadata to associate with the group.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the identity group to create.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of policies to apply to the group.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of the group, internal or external. Defaults to `internal`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/groupAlias:GroupAlias": {
            "description": "Creates an Identity Group Alias for Vault. The [Identity secrets engine](https://www.vaultproject.io/docs/secrets/identity/index.html) is the identity management solution for Vault.\n\nGroup aliases allows entity membership in external groups to be managed semi-automatically. External group serves as a mapping to a group that is outside of the identity store. External groups can have one (and only one) alias. This alias should map to a notion of group that is outside of the identity store. For example, groups in LDAP, and teams in GitHub. A username in LDAP, belonging to a group in LDAP, can get its entity ID added as a member of a group in Vault automatically during logins and token renewals. This works only if the group in Vault is an external group and has an alias that maps to the group in LDAP. If the user is removed from the group in LDAP, that change gets reflected in Vault only upon the subsequent login or renewal operation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst group = new vault.identity.Group(\"group\", {\n    policies: [\"test\"],\n    type: \"external\",\n});\nconst github = new vault.AuthBackend(\"github\", {\n    path: \"github\",\n    type: \"github\",\n});\nconst group_alias = new vault.identity.GroupAlias(\"group-alias\", {\n    canonicalId: group.id,\n    mountAccessor: github.accessor,\n    name: \"Github_Team_Slug\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ngroup = vault.identity.Group(\"group\",\n    policies=[\"test\"],\n    type=\"external\")\ngithub = vault.AuthBackend(\"github\",\n    path=\"github\",\n    type=\"github\")\ngroup_alias = vault.identity.GroupAlias(\"group-alias\",\n    canonical_id=group.id,\n    mount_accessor=github.accessor,\n    name=\"Github_Team_Slug\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var @group = new Vault.Identity.Group(\"group\", new Vault.Identity.GroupArgs\n        {\n            Policies = \n            {\n                \"test\",\n            },\n            Type = \"external\",\n        });\n        var github = new Vault.AuthBackend(\"github\", new Vault.AuthBackendArgs\n        {\n            Path = \"github\",\n            Type = \"github\",\n        });\n        var group_alias = new Vault.Identity.GroupAlias(\"group-alias\", new Vault.Identity.GroupAliasArgs\n        {\n            CanonicalId = @group.Id,\n            MountAccessor = github.Accessor,\n            Name = \"Github_Team_Slug\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tgroup, err := identity.NewGroup(ctx, \"group\", \u0026identity.GroupArgs{\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"external\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgithub, err := vault.NewAuthBackend(ctx, \"github\", \u0026vault.AuthBackendArgs{\n\t\t\tPath: pulumi.String(\"github\"),\n\t\t\tType: pulumi.String(\"github\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewGroupAlias(ctx, \"group_alias\", \u0026identity.GroupAliasArgs{\n\t\t\tCanonicalId:   group.ID(),\n\t\t\tMountAccessor: github.Accessor,\n\t\t\tName:          pulumi.String(\"Github_Team_Slug\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "canonicalId": {
                    "type": "string",
                    "description": "ID of the group to which this is an alias.\n"
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "Mount accessor of the authentication backend to which this alias belongs to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the group alias to create.\n"
                }
            },
            "required": [
                "canonicalId",
                "mountAccessor",
                "name"
            ],
            "inputProperties": {
                "canonicalId": {
                    "type": "string",
                    "description": "ID of the group to which this is an alias.\n"
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "Mount accessor of the authentication backend to which this alias belongs to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the group alias to create.\n"
                }
            },
            "requiredInputs": [
                "canonicalId",
                "mountAccessor",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupAlias resources.\n",
                "properties": {
                    "canonicalId": {
                        "type": "string",
                        "description": "ID of the group to which this is an alias.\n"
                    },
                    "mountAccessor": {
                        "type": "string",
                        "description": "Mount accessor of the authentication backend to which this alias belongs to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the group alias to create.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/groupMemberEntityIds:GroupMemberEntityIds": {
            "description": "Manages member entities for an Identity Group for Vault. The [Identity secrets engine](https://www.vaultproject.io/docs/secrets/identity/index.html) is the identity management solution for Vault.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Exclusive Member Entities\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst internal = new vault.identity.Group(\"internal\", {\n    type: \"internal\",\n    externalMemberEntityIds: true,\n    metadata: {\n        version: \"2\",\n    },\n});\nconst user = new vault.identity.Entity(\"user\", {});\nconst members = new vault.identity.GroupMemberEntityIds(\"members\", {\n    exclusive: true,\n    memberEntityIds: [user.id],\n    groupId: internal.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ninternal = vault.identity.Group(\"internal\",\n    type=\"internal\",\n    external_member_entity_ids=True,\n    metadata={\n        \"version\": \"2\",\n    })\nuser = vault.identity.Entity(\"user\")\nmembers = vault.identity.GroupMemberEntityIds(\"members\",\n    exclusive=True,\n    member_entity_ids=[user.id],\n    group_id=internal.id)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var @internal = new Vault.Identity.Group(\"internal\", new Vault.Identity.GroupArgs\n        {\n            Type = \"internal\",\n            ExternalMemberEntityIds = true,\n            Metadata = \n            {\n                { \"version\", \"2\" },\n            },\n        });\n        var user = new Vault.Identity.Entity(\"user\", new Vault.Identity.EntityArgs\n        {\n        });\n        var members = new Vault.Identity.GroupMemberEntityIds(\"members\", new Vault.Identity.GroupMemberEntityIdsArgs\n        {\n            Exclusive = true,\n            MemberEntityIds = \n            {\n                user.Id,\n            },\n            GroupId = @internal.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tinternal, err := identity.NewGroup(ctx, \"internal\", \u0026identity.GroupArgs{\n\t\t\tType:                    pulumi.String(\"internal\"),\n\t\t\tExternalMemberEntityIds: pulumi.Bool(true),\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"version\": pulumi.String(\"2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tuser, err := identity.NewEntity(ctx, \"user\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewGroupMemberEntityIds(ctx, \"members\", \u0026identity.GroupMemberEntityIdsArgs{\n\t\t\tExclusive: pulumi.Bool(true),\n\t\t\tMemberEntityIds: pulumi.StringArray{\n\t\t\t\tuser.ID(),\n\t\t\t},\n\t\t\tGroupId: internal.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% example %}}\n### Non-exclusive Member Entities\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst internal = new vault.identity.Group(\"internal\", {\n    type: \"internal\",\n    externalMemberEntityIds: true,\n    metadata: {\n        version: \"2\",\n    },\n});\nconst testUser = new vault.identity.Entity(\"testUser\", {});\nconst secondTestUser = new vault.identity.Entity(\"secondTestUser\", {});\nconst devUser = new vault.identity.Entity(\"devUser\", {});\nconst test = new vault.identity.GroupMemberEntityIds(\"test\", {\n    memberEntityIds: [\n        testUser.id,\n        secondTestUser.id,\n    ],\n    exclusive: false,\n    groupId: internal.id,\n});\nconst others = new vault.identity.GroupMemberEntityIds(\"others\", {\n    memberEntityIds: [devUser.id],\n    exclusive: false,\n    groupId: internal.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ninternal = vault.identity.Group(\"internal\",\n    type=\"internal\",\n    external_member_entity_ids=True,\n    metadata={\n        \"version\": \"2\",\n    })\ntest_user = vault.identity.Entity(\"testUser\")\nsecond_test_user = vault.identity.Entity(\"secondTestUser\")\ndev_user = vault.identity.Entity(\"devUser\")\ntest = vault.identity.GroupMemberEntityIds(\"test\",\n    member_entity_ids=[\n        test_user.id,\n        second_test_user.id,\n    ],\n    exclusive=False,\n    group_id=internal.id)\nothers = vault.identity.GroupMemberEntityIds(\"others\",\n    member_entity_ids=[dev_user.id],\n    exclusive=False,\n    group_id=internal.id)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var @internal = new Vault.Identity.Group(\"internal\", new Vault.Identity.GroupArgs\n        {\n            Type = \"internal\",\n            ExternalMemberEntityIds = true,\n            Metadata = \n            {\n                { \"version\", \"2\" },\n            },\n        });\n        var testUser = new Vault.Identity.Entity(\"testUser\", new Vault.Identity.EntityArgs\n        {\n        });\n        var secondTestUser = new Vault.Identity.Entity(\"secondTestUser\", new Vault.Identity.EntityArgs\n        {\n        });\n        var devUser = new Vault.Identity.Entity(\"devUser\", new Vault.Identity.EntityArgs\n        {\n        });\n        var test = new Vault.Identity.GroupMemberEntityIds(\"test\", new Vault.Identity.GroupMemberEntityIdsArgs\n        {\n            MemberEntityIds = \n            {\n                testUser.Id,\n                secondTestUser.Id,\n            },\n            Exclusive = false,\n            GroupId = @internal.Id,\n        });\n        var others = new Vault.Identity.GroupMemberEntityIds(\"others\", new Vault.Identity.GroupMemberEntityIdsArgs\n        {\n            MemberEntityIds = \n            {\n                devUser.Id,\n            },\n            Exclusive = false,\n            GroupId = @internal.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tinternal, err := identity.NewGroup(ctx, \"internal\", \u0026identity.GroupArgs{\n\t\t\tType:                    pulumi.String(\"internal\"),\n\t\t\tExternalMemberEntityIds: pulumi.Bool(true),\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"version\": pulumi.String(\"2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestUser, err := identity.NewEntity(ctx, \"testUser\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsecondTestUser, err := identity.NewEntity(ctx, \"secondTestUser\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdevUser, err := identity.NewEntity(ctx, \"devUser\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewGroupMemberEntityIds(ctx, \"test\", \u0026identity.GroupMemberEntityIdsArgs{\n\t\t\tMemberEntityIds: pulumi.StringArray{\n\t\t\t\ttestUser.ID(),\n\t\t\t\tsecondTestUser.ID(),\n\t\t\t},\n\t\t\tExclusive: pulumi.Bool(false),\n\t\t\tGroupId:   internal.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewGroupMemberEntityIds(ctx, \"others\", \u0026identity.GroupMemberEntityIdsArgs{\n\t\t\tMemberEntityIds: pulumi.StringArray{\n\t\t\t\tdevUser.ID(),\n\t\t\t},\n\t\t\tExclusive: pulumi.Bool(false),\n\t\t\tGroupId:   internal.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "exclusive": {
                    "type": "boolean",
                    "description": "Defaults to `true`.\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "Group ID to assign member entities to.\n"
                },
                "groupName": {
                    "type": "string",
                    "description": "The name of the group that are assigned the member entities.\n"
                },
                "memberEntityIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of member entities that belong to the group\n"
                }
            },
            "required": [
                "groupId",
                "groupName"
            ],
            "inputProperties": {
                "exclusive": {
                    "type": "boolean",
                    "description": "Defaults to `true`.\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "Group ID to assign member entities to.\n"
                },
                "memberEntityIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of member entities that belong to the group\n"
                }
            },
            "requiredInputs": [
                "groupId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupMemberEntityIds resources.\n",
                "properties": {
                    "exclusive": {
                        "type": "boolean",
                        "description": "Defaults to `true`.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "Group ID to assign member entities to.\n"
                    },
                    "groupName": {
                        "type": "string",
                        "description": "The name of the group that are assigned the member entities.\n"
                    },
                    "memberEntityIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of member entities that belong to the group\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/groupPolicies:GroupPolicies": {
            "description": "Manages policies for an Identity Group for Vault. The [Identity secrets engine](https://www.vaultproject.io/docs/secrets/identity/index.html) is the identity management solution for Vault.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Exclusive Policies\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst internal = new vault.identity.Group(\"internal\", {\n    type: \"internal\",\n    externalPolicies: true,\n    metadata: {\n        version: \"2\",\n    },\n});\nconst policies = new vault.identity.GroupPolicies(\"policies\", {\n    policies: [\n        \"default\",\n        \"test\",\n    ],\n    exclusive: true,\n    groupId: internal.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ninternal = vault.identity.Group(\"internal\",\n    type=\"internal\",\n    external_policies=True,\n    metadata={\n        \"version\": \"2\",\n    })\npolicies = vault.identity.GroupPolicies(\"policies\",\n    policies=[\n        \"default\",\n        \"test\",\n    ],\n    exclusive=True,\n    group_id=internal.id)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var @internal = new Vault.Identity.Group(\"internal\", new Vault.Identity.GroupArgs\n        {\n            Type = \"internal\",\n            ExternalPolicies = true,\n            Metadata = \n            {\n                { \"version\", \"2\" },\n            },\n        });\n        var policies = new Vault.Identity.GroupPolicies(\"policies\", new Vault.Identity.GroupPoliciesArgs\n        {\n            Policies = \n            {\n                \"default\",\n                \"test\",\n            },\n            Exclusive = true,\n            GroupId = @internal.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tinternal, err := identity.NewGroup(ctx, \"internal\", \u0026identity.GroupArgs{\n\t\t\tType:             pulumi.String(\"internal\"),\n\t\t\tExternalPolicies: pulumi.Bool(true),\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"version\": pulumi.String(\"2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewGroupPolicies(ctx, \"policies\", \u0026identity.GroupPoliciesArgs{\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tExclusive: pulumi.Bool(true),\n\t\t\tGroupId:   internal.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% example %}}\n### Non-exclusive Policies\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst internal = new vault.identity.Group(\"internal\", {\n    type: \"internal\",\n    externalPolicies: true,\n    metadata: {\n        version: \"2\",\n    },\n});\nconst _default = new vault.identity.GroupPolicies(\"default\", {\n    policies: [\n        \"default\",\n        \"test\",\n    ],\n    exclusive: false,\n    groupId: internal.id,\n});\nconst others = new vault.identity.GroupPolicies(\"others\", {\n    policies: [\"others\"],\n    exclusive: false,\n    groupId: internal.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ninternal = vault.identity.Group(\"internal\",\n    type=\"internal\",\n    external_policies=True,\n    metadata={\n        \"version\": \"2\",\n    })\ndefault = vault.identity.GroupPolicies(\"default\",\n    policies=[\n        \"default\",\n        \"test\",\n    ],\n    exclusive=False,\n    group_id=internal.id)\nothers = vault.identity.GroupPolicies(\"others\",\n    policies=[\"others\"],\n    exclusive=False,\n    group_id=internal.id)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var @internal = new Vault.Identity.Group(\"internal\", new Vault.Identity.GroupArgs\n        {\n            Type = \"internal\",\n            ExternalPolicies = true,\n            Metadata = \n            {\n                { \"version\", \"2\" },\n            },\n        });\n        var @default = new Vault.Identity.GroupPolicies(\"default\", new Vault.Identity.GroupPoliciesArgs\n        {\n            Policies = \n            {\n                \"default\",\n                \"test\",\n            },\n            Exclusive = false,\n            GroupId = @internal.Id,\n        });\n        var others = new Vault.Identity.GroupPolicies(\"others\", new Vault.Identity.GroupPoliciesArgs\n        {\n            Policies = \n            {\n                \"others\",\n            },\n            Exclusive = false,\n            GroupId = @internal.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tinternal, err := identity.NewGroup(ctx, \"internal\", \u0026identity.GroupArgs{\n\t\t\tType:             pulumi.String(\"internal\"),\n\t\t\tExternalPolicies: pulumi.Bool(true),\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"version\": pulumi.String(\"2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewGroupPolicies(ctx, \"_default\", \u0026identity.GroupPoliciesArgs{\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tExclusive: pulumi.Bool(false),\n\t\t\tGroupId:   internal.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewGroupPolicies(ctx, \"others\", \u0026identity.GroupPoliciesArgs{\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"others\"),\n\t\t\t},\n\t\t\tExclusive: pulumi.Bool(false),\n\t\t\tGroupId:   internal.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "exclusive": {
                    "type": "boolean",
                    "description": "Defaults to `true`.\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "Group ID to assign policies to.\n"
                },
                "groupName": {
                    "type": "string",
                    "description": "The name of the group that are assigned the policies.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to assign to the group\n"
                }
            },
            "required": [
                "groupId",
                "groupName",
                "policies"
            ],
            "inputProperties": {
                "exclusive": {
                    "type": "boolean",
                    "description": "Defaults to `true`.\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "Group ID to assign policies to.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to assign to the group\n"
                }
            },
            "requiredInputs": [
                "groupId",
                "policies"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupPolicies resources.\n",
                "properties": {
                    "exclusive": {
                        "type": "boolean",
                        "description": "Defaults to `true`.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "Group ID to assign policies to.\n"
                    },
                    "groupName": {
                        "type": "string",
                        "description": "The name of the group that are assigned the policies.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to assign to the group\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/oidc:Oidc": {
            "description": "Configure the [Identity Tokens Backend](https://www.vaultproject.io/docs/secrets/identity/index.html#identity-tokens).\n\nThe Identity secrets engine is the identity management solution for Vault. It internally maintains\nthe clients who are recognized by Vault.\n\n\u003e **NOTE:** Each Vault server may only have one Identity Tokens Backend configuration. Multiple configurations of the resource against the same Vault server will cause a perpetual difference.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst server = new vault.identity.Oidc(\"server\", {\n    issuer: \"https://www.acme.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nserver = vault.identity.Oidc(\"server\", issuer=\"https://www.acme.com\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var server = new Vault.Identity.Oidc(\"server\", new Vault.Identity.OidcArgs\n        {\n            Issuer = \"https://www.acme.com\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := identity.NewOidc(ctx, \"server\", \u0026identity.OidcArgs{\n\t\t\tIssuer: pulumi.String(\"https://www.acme.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "issuer": {
                    "type": "string",
                    "description": "Issuer URL to be used in the iss claim of the token. If not set, Vault's\n`api_addr` will be used. The issuer is a case sensitive URL using the https scheme that contains\nscheme, host, and optionally, port number and path components, but no query or fragment\ncomponents.\n"
                }
            },
            "required": [
                "issuer"
            ],
            "inputProperties": {
                "issuer": {
                    "type": "string",
                    "description": "Issuer URL to be used in the iss claim of the token. If not set, Vault's\n`api_addr` will be used. The issuer is a case sensitive URL using the https scheme that contains\nscheme, host, and optionally, port number and path components, but no query or fragment\ncomponents.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Oidc resources.\n",
                "properties": {
                    "issuer": {
                        "type": "string",
                        "description": "Issuer URL to be used in the iss claim of the token. If not set, Vault's\n`api_addr` will be used. The issuer is a case sensitive URL using the https scheme that contains\nscheme, host, and optionally, port number and path components, but no query or fragment\ncomponents.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/oidcKey:OidcKey": {
            "properties": {
                "algorithm": {
                    "type": "string",
                    "description": "Signing algorithm to use. Signing algorithm to use.\nAllowed values are: RS256 (default), RS384, RS512, ES256, ES384, ES512, EdDSA.\n"
                },
                "allowedClientIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Array of role client ids allowed to use this key for signing. If empty, no roles are allowed. If \"*\", all roles are\nallowed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the OIDC Key to create.\n"
                },
                "rotationPeriod": {
                    "type": "integer",
                    "description": "How often to generate a new signing key in number of seconds\n"
                },
                "verificationTtl": {
                    "type": "integer",
                    "description": "\"Controls how long the public portion of a signing key will be\navailable for verification after being rotated in seconds.\n"
                }
            },
            "required": [
                "allowedClientIds",
                "name"
            ],
            "inputProperties": {
                "algorithm": {
                    "type": "string",
                    "description": "Signing algorithm to use. Signing algorithm to use.\nAllowed values are: RS256 (default), RS384, RS512, ES256, ES384, ES512, EdDSA.\n"
                },
                "allowedClientIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Array of role client ids allowed to use this key for signing. If empty, no roles are allowed. If \"*\", all roles are\nallowed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the OIDC Key to create.\n"
                },
                "rotationPeriod": {
                    "type": "integer",
                    "description": "How often to generate a new signing key in number of seconds\n"
                },
                "verificationTtl": {
                    "type": "integer",
                    "description": "\"Controls how long the public portion of a signing key will be\navailable for verification after being rotated in seconds.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OidcKey resources.\n",
                "properties": {
                    "algorithm": {
                        "type": "string",
                        "description": "Signing algorithm to use. Signing algorithm to use.\nAllowed values are: RS256 (default), RS384, RS512, ES256, ES384, ES512, EdDSA.\n"
                    },
                    "allowedClientIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Array of role client ids allowed to use this key for signing. If empty, no roles are allowed. If \"*\", all roles are\nallowed.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the OIDC Key to create.\n"
                    },
                    "rotationPeriod": {
                        "type": "integer",
                        "description": "How often to generate a new signing key in number of seconds\n"
                    },
                    "verificationTtl": {
                        "type": "integer",
                        "description": "\"Controls how long the public portion of a signing key will be\navailable for verification after being rotated in seconds.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/oidcKeyAllowedClientID:OidcKeyAllowedClientID": {
            "properties": {
                "allowedClientId": {
                    "type": "string",
                    "description": "Client ID to allow usage with the OIDC named key\n"
                },
                "keyName": {
                    "type": "string",
                    "description": "Name of the OIDC Key allow the Client ID.\n"
                }
            },
            "required": [
                "allowedClientId",
                "keyName"
            ],
            "inputProperties": {
                "allowedClientId": {
                    "type": "string",
                    "description": "Client ID to allow usage with the OIDC named key\n"
                },
                "keyName": {
                    "type": "string",
                    "description": "Name of the OIDC Key allow the Client ID.\n"
                }
            },
            "requiredInputs": [
                "allowedClientId",
                "keyName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OidcKeyAllowedClientID resources.\n",
                "properties": {
                    "allowedClientId": {
                        "type": "string",
                        "description": "Client ID to allow usage with the OIDC named key\n"
                    },
                    "keyName": {
                        "type": "string",
                        "description": "Name of the OIDC Key allow the Client ID.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/oidcRole:OidcRole": {
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The value that will be included in the `aud` field of all the OIDC identity\ntokens issued by this role\n"
                },
                "key": {
                    "type": "string",
                    "description": "A configured named key, the key must already exist\nbefore tokens can be issued.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the OIDC Role to create.\n"
                },
                "template": {
                    "type": "string",
                    "description": "The template string to use for generating tokens. This may be in\nstring-ified JSON or base64 format. See the\n[documentation](https://www.vaultproject.io/docs/secrets/identity/index.html#token-contents-and-templates)\nfor the template format.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "TTL of the tokens generated against the role in number of seconds.\n"
                }
            },
            "required": [
                "clientId",
                "key",
                "name"
            ],
            "inputProperties": {
                "key": {
                    "type": "string",
                    "description": "A configured named key, the key must already exist\nbefore tokens can be issued.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the OIDC Role to create.\n"
                },
                "template": {
                    "type": "string",
                    "description": "The template string to use for generating tokens. This may be in\nstring-ified JSON or base64 format. See the\n[documentation](https://www.vaultproject.io/docs/secrets/identity/index.html#token-contents-and-templates)\nfor the template format.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "TTL of the tokens generated against the role in number of seconds.\n"
                }
            },
            "requiredInputs": [
                "key"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OidcRole resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The value that will be included in the `aud` field of all the OIDC identity\ntokens issued by this role\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "A configured named key, the key must already exist\nbefore tokens can be issued.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the OIDC Role to create.\n"
                    },
                    "template": {
                        "type": "string",
                        "description": "The template string to use for generating tokens. This may be in\nstring-ified JSON or base64 format. See the\n[documentation](https://www.vaultproject.io/docs/secrets/identity/index.html#token-contents-and-templates)\nfor the template format.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "TTL of the tokens generated against the role in number of seconds.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/audit:Audit": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n### File Audit Device)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst test = new vault.Audit(\"test\", {\n    options: {\n        file_path: \"C:/temp/audit.txt\",\n    },\n    type: \"file\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntest = vault.Audit(\"test\",\n    options={\n        \"file_path\": \"C:/temp/audit.txt\",\n    },\n    type=\"file\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var test = new Vault.Audit(\"test\", new Vault.AuditArgs\n        {\n            Options = \n            {\n                { \"file_path\", \"C:/temp/audit.txt\" },\n            },\n            Type = \"file\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewAudit(ctx, \"test\", \u0026vault.AuditArgs{\n\t\t\tOptions: pulumi.StringMap{\n\t\t\t\t\"file_path\": pulumi.String(\"C:/temp/audit.txt\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"file\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Socket Audit Device)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst test = new vault.Audit(\"test\", {\n    options: {\n        address: \"127.0.0.1:8000\",\n        description: \"application x socket\",\n        socket_type: \"tcp\",\n    },\n    path: \"app_socket\",\n    type: \"socket\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntest = vault.Audit(\"test\",\n    options={\n        \"address\": \"127.0.0.1:8000\",\n        \"description\": \"application x socket\",\n        \"socket_type\": \"tcp\",\n    },\n    path=\"app_socket\",\n    type=\"socket\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var test = new Vault.Audit(\"test\", new Vault.AuditArgs\n        {\n            Options = \n            {\n                { \"address\", \"127.0.0.1:8000\" },\n                { \"description\", \"application x socket\" },\n                { \"socket_type\", \"tcp\" },\n            },\n            Path = \"app_socket\",\n            Type = \"socket\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewAudit(ctx, \"test\", \u0026vault.AuditArgs{\n\t\t\tOptions: pulumi.StringMap{\n\t\t\t\t\"address\":     pulumi.String(\"127.0.0.1:8000\"),\n\t\t\t\t\"description\": pulumi.String(\"application x socket\"),\n\t\t\t\t\"socket_type\": pulumi.String(\"tcp\"),\n\t\t\t},\n\t\t\tPath: pulumi.String(\"app_socket\"),\n\t\t\tType: pulumi.String(\"socket\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the audit device.\n"
                },
                "options": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Configuration options to pass to the audit device itself.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path to mount the audit device. This defaults to the type.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the audit device, such as 'file'.\n"
                }
            },
            "required": [
                "options",
                "path",
                "type"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the audit device.\n"
                },
                "options": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Configuration options to pass to the audit device itself.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path to mount the audit device. This defaults to the type.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the audit device, such as 'file'.\n"
                }
            },
            "requiredInputs": [
                "options",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Audit resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Human-friendly description of the audit device.\n"
                    },
                    "options": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Configuration options to pass to the audit device itself.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path to mount the audit device. This defaults to the type.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of the audit device, such as 'file'.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/authBackend:AuthBackend": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.AuthBackend(\"example\", {\n    tune: {\n        listingVisibility: \"unauth\",\n        maxLeaseTtl: \"90000s\",\n    },\n    type: \"github\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.AuthBackend(\"example\",\n    tune={\n        \"listing_visibility\": \"unauth\",\n        \"maxLeaseTtl\": \"90000s\",\n    },\n    type=\"github\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.AuthBackend(\"example\", new Vault.AuthBackendArgs\n        {\n            Tune = new Vault.Inputs.AuthBackendTuneArgs\n            {\n                ListingVisibility = \"unauth\",\n                MaxLeaseTtl = \"90000s\",\n            },\n            Type = \"github\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewAuthBackend(ctx, \"example\", \u0026vault.AuthBackendArgs{\n\t\t\tTune: \u0026vault.AuthBackendTuneArgs{\n\t\t\t\tListingVisibility: pulumi.String(\"unauth\"),\n\t\t\t\tMaxLeaseTtl:       pulumi.String(\"90000s\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"github\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The accessor for this auth method\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "(Optional; Deprecated, use `tune.default_lease_ttl` if you are using Vault provider version \u003e= 1.8) The default lease duration in seconds.\n",
                    "deprecationMessage": "Use the tune configuration block to avoid forcing creation of new resource on an update"
                },
                "description": {
                    "type": "string",
                    "description": "A description of the auth method\n"
                },
                "listingVisibility": {
                    "type": "string",
                    "description": "Specifies whether to show this mount in\nthe UI-specific listing endpoint. Valid values are \"unauth\" or \"hidden\".\n",
                    "deprecationMessage": "Use the tune configuration block to avoid forcing creation of new resource on an update"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the auth method is local only.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "(Optional; Deprecated, use `tune.max_lease_ttl` if you are using Vault provider version \u003e= 1.8) The maximum lease duration in seconds.\n",
                    "deprecationMessage": "Use the tune configuration block to avoid forcing creation of new resource on an update"
                },
                "path": {
                    "type": "string",
                    "description": "The path to mount the auth method  this defaults to the name of the type\n"
                },
                "tune": {
                    "$ref": "#/types/vault:/AuthBackendTune:AuthBackendTune",
                    "description": "Extra configuration block. Structure is documented below.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The name of the auth method type\n"
                }
            },
            "required": [
                "accessor",
                "defaultLeaseTtlSeconds",
                "listingVisibility",
                "maxLeaseTtlSeconds",
                "path",
                "tune",
                "type"
            ],
            "inputProperties": {
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "(Optional; Deprecated, use `tune.default_lease_ttl` if you are using Vault provider version \u003e= 1.8) The default lease duration in seconds.\n",
                    "deprecationMessage": "Use the tune configuration block to avoid forcing creation of new resource on an update"
                },
                "description": {
                    "type": "string",
                    "description": "A description of the auth method\n"
                },
                "listingVisibility": {
                    "type": "string",
                    "description": "Specifies whether to show this mount in\nthe UI-specific listing endpoint. Valid values are \"unauth\" or \"hidden\".\n",
                    "deprecationMessage": "Use the tune configuration block to avoid forcing creation of new resource on an update"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the auth method is local only.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "(Optional; Deprecated, use `tune.max_lease_ttl` if you are using Vault provider version \u003e= 1.8) The maximum lease duration in seconds.\n",
                    "deprecationMessage": "Use the tune configuration block to avoid forcing creation of new resource on an update"
                },
                "path": {
                    "type": "string",
                    "description": "The path to mount the auth method  this defaults to the name of the type\n"
                },
                "tune": {
                    "$ref": "#/types/vault:/AuthBackendTune:AuthBackendTune",
                    "description": "Extra configuration block. Structure is documented below.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The name of the auth method type\n"
                }
            },
            "requiredInputs": [
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackend resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The accessor for this auth method\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "(Optional; Deprecated, use `tune.default_lease_ttl` if you are using Vault provider version \u003e= 1.8) The default lease duration in seconds.\n",
                        "deprecationMessage": "Use the tune configuration block to avoid forcing creation of new resource on an update"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description of the auth method\n"
                    },
                    "listingVisibility": {
                        "type": "string",
                        "description": "Specifies whether to show this mount in\nthe UI-specific listing endpoint. Valid values are \"unauth\" or \"hidden\".\n",
                        "deprecationMessage": "Use the tune configuration block to avoid forcing creation of new resource on an update"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Specifies if the auth method is local only.\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "(Optional; Deprecated, use `tune.max_lease_ttl` if you are using Vault provider version \u003e= 1.8) The maximum lease duration in seconds.\n",
                        "deprecationMessage": "Use the tune configuration block to avoid forcing creation of new resource on an update"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path to mount the auth method  this defaults to the name of the type\n"
                    },
                    "tune": {
                        "$ref": "#/types/vault:/AuthBackendTune:AuthBackendTune",
                        "description": "Extra configuration block. Structure is documented below.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The name of the auth method type\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/certAuthBackendRole:CertAuthBackendRole": {
            "description": "Provides a resource to create a role in an [Cert auth backend within Vault](https://www.vaultproject.io/docs/auth/cert.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\nimport * from \"fs\";\n\nconst certAuthBackend = new vault.AuthBackend(\"certAuthBackend\", {\n    path: \"cert\",\n    type: \"cert\",\n});\nconst certCertAuthBackendRole = new vault.CertAuthBackendRole(\"certCertAuthBackendRole\", {\n    certificate: fs.readFileSync(\"/path/to/certs/ca-cert.pem\"),\n    backend: certAuthBackend.path,\n    allowedNames: [\n        \"foo.example.org\",\n        \"baz.example.org\",\n    ],\n    tokenTtl: 300,\n    tokenMaxTtl: 600,\n    tokenPolicies: [\"foo\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ncert_auth_backend = vault.AuthBackend(\"certAuthBackend\",\n    path=\"cert\",\n    type=\"cert\")\ncert_cert_auth_backend_role = vault.CertAuthBackendRole(\"certCertAuthBackendRole\",\n    certificate=(lambda path: open(path).read())(\"/path/to/certs/ca-cert.pem\"),\n    backend=cert_auth_backend.path,\n    allowed_names=[\n        \"foo.example.org\",\n        \"baz.example.org\",\n    ],\n    token_ttl=300,\n    token_max_ttl=600,\n    token_policies=[\"foo\"])\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var certAuthBackend = new Vault.AuthBackend(\"certAuthBackend\", new Vault.AuthBackendArgs\n        {\n            Path = \"cert\",\n            Type = \"cert\",\n        });\n        var certCertAuthBackendRole = new Vault.CertAuthBackendRole(\"certCertAuthBackendRole\", new Vault.CertAuthBackendRoleArgs\n        {\n            Certificate = File.ReadAllText(\"/path/to/certs/ca-cert.pem\"),\n            Backend = certAuthBackend.Path,\n            AllowedNames = \n            {\n                \"foo.example.org\",\n                \"baz.example.org\",\n            },\n            TokenTtl = 300,\n            TokenMaxTtl = 600,\n            TokenPolicies = \n            {\n                \"foo\",\n            },\n        });\n    }\n\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "allowedCommonNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed the common names for authenticated client certificates\n"
                },
                "allowedDnsSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed alternative dns names for authenticated client certificates\n"
                },
                "allowedEmailSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed emails for authenticated client certificates\n"
                },
                "allowedNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed subject names for authenticated client certificates\n"
                },
                "allowedOrganizationUnits": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed organization units for authenticated client certificates\n"
                },
                "allowedUriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed URIs for authenticated client certificates\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Path to the mounted Cert auth backend\n"
                },
                "boundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Restriction usage of the\ncertificates to client IPs falling within the range of the specified CIDRs\n",
                    "deprecationMessage": "use `token_bound_cidrs` instead if you are running Vault \u003e= 1.2"
                },
                "certificate": {
                    "type": "string",
                    "description": "CA certificate used to validate client certificates\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "The name to display on tokens issued under this role.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "The maximum allowed lifetime of tokens\nissued using this role, provided as a number of seconds.\n",
                    "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the role\n"
                },
                "period": {
                    "type": "string",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings\nspecifying the policies to be set on tokens issued using this role.\n",
                    "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                },
                "requiredExtensions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "TLS extensions required on client certificates\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "The TTL period of tokens issued\nusing this role, provided as a number of seconds.\n",
                    "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                }
            },
            "required": [
                "allowedCommonNames",
                "allowedDnsSans",
                "allowedEmailSans",
                "allowedNames",
                "allowedOrganizationUnits",
                "allowedUriSans",
                "boundCidrs",
                "certificate",
                "displayName",
                "maxTtl",
                "name",
                "period",
                "policies",
                "requiredExtensions",
                "ttl"
            ],
            "inputProperties": {
                "allowedCommonNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed the common names for authenticated client certificates\n"
                },
                "allowedDnsSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed alternative dns names for authenticated client certificates\n"
                },
                "allowedEmailSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed emails for authenticated client certificates\n"
                },
                "allowedNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed subject names for authenticated client certificates\n"
                },
                "allowedOrganizationUnits": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed organization units for authenticated client certificates\n"
                },
                "allowedUriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed URIs for authenticated client certificates\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Path to the mounted Cert auth backend\n"
                },
                "boundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Restriction usage of the\ncertificates to client IPs falling within the range of the specified CIDRs\n",
                    "deprecationMessage": "use `token_bound_cidrs` instead if you are running Vault \u003e= 1.2"
                },
                "certificate": {
                    "type": "string",
                    "description": "CA certificate used to validate client certificates\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "The name to display on tokens issued under this role.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "The maximum allowed lifetime of tokens\nissued using this role, provided as a number of seconds.\n",
                    "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the role\n"
                },
                "period": {
                    "type": "string",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings\nspecifying the policies to be set on tokens issued using this role.\n",
                    "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                },
                "requiredExtensions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "TLS extensions required on client certificates\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "The TTL period of tokens issued\nusing this role, provided as a number of seconds.\n",
                    "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                }
            },
            "requiredInputs": [
                "certificate"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CertAuthBackendRole resources.\n",
                "properties": {
                    "allowedCommonNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Allowed the common names for authenticated client certificates\n"
                    },
                    "allowedDnsSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Allowed alternative dns names for authenticated client certificates\n"
                    },
                    "allowedEmailSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Allowed emails for authenticated client certificates\n"
                    },
                    "allowedNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Allowed subject names for authenticated client certificates\n"
                    },
                    "allowedOrganizationUnits": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Allowed organization units for authenticated client certificates\n"
                    },
                    "allowedUriSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Allowed URIs for authenticated client certificates\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "Path to the mounted Cert auth backend\n"
                    },
                    "boundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Restriction usage of the\ncertificates to client IPs falling within the range of the specified CIDRs\n",
                        "deprecationMessage": "use `token_bound_cidrs` instead if you are running Vault \u003e= 1.2"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "CA certificate used to validate client certificates\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "The name to display on tokens issued under this role.\n"
                    },
                    "maxTtl": {
                        "type": "string",
                        "description": "The maximum allowed lifetime of tokens\nissued using this role, provided as a number of seconds.\n",
                        "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the role\n"
                    },
                    "period": {
                        "type": "string",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n",
                        "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of strings\nspecifying the policies to be set on tokens issued using this role.\n",
                        "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                    },
                    "requiredExtensions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "TLS extensions required on client certificates\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "The TTL period of tokens issued\nusing this role, provided as a number of seconds.\n",
                        "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/egpPolicy:EgpPolicy": {
            "description": "Provides a resource to manage Endpoint Governing Policy (EGP) via [Sentinel](https://www.vaultproject.io/docs/enterprise/sentinel/index.html).\n\n**Note** this feature is available only with Vault Enterprise.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst allow_all = new vault.EgpPolicy(\"allow-all\", {\n    enforcementLevel: \"soft-mandatory\",\n    paths: [\"*\"],\n    policy: `main = rule {\n  true\n}\n`,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nallow_all = vault.EgpPolicy(\"allow-all\",\n    enforcement_level=\"soft-mandatory\",\n    paths=[\"*\"],\n    policy=\"\"\"main = rule {\n  true\n}\n\n\"\"\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var allow_all = new Vault.EgpPolicy(\"allow-all\", new Vault.EgpPolicyArgs\n        {\n            EnforcementLevel = \"soft-mandatory\",\n            Paths = \n            {\n                \"*\",\n            },\n            Policy = @\"main = rule {\n  true\n}\n\n\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewEgpPolicy(ctx, \"allow_all\", \u0026vault.EgpPolicyArgs{\n\t\t\tEnforcementLevel: pulumi.String(\"soft-mandatory\"),\n\t\t\tPaths: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"*\"),\n\t\t\t},\n\t\t\tPolicy: pulumi.String(fmt.Sprintf(\"%v%v%v%v\", \"main = rule {\\n\", \"  true\\n\", \"}\\n\", \"\\n\")),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "enforcementLevel": {
                    "type": "string",
                    "description": "Enforcement level of Sentinel policy. Can be either `advisory` or `soft-mandatory` or `hard-mandatory`\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the policy\n"
                },
                "paths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of paths to which the policy will be applied to\n"
                },
                "policy": {
                    "type": "string",
                    "description": "String containing a Sentinel policy\n"
                }
            },
            "required": [
                "enforcementLevel",
                "name",
                "paths",
                "policy"
            ],
            "inputProperties": {
                "enforcementLevel": {
                    "type": "string",
                    "description": "Enforcement level of Sentinel policy. Can be either `advisory` or `soft-mandatory` or `hard-mandatory`\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the policy\n"
                },
                "paths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of paths to which the policy will be applied to\n"
                },
                "policy": {
                    "type": "string",
                    "description": "String containing a Sentinel policy\n"
                }
            },
            "requiredInputs": [
                "enforcementLevel",
                "paths",
                "policy"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EgpPolicy resources.\n",
                "properties": {
                    "enforcementLevel": {
                        "type": "string",
                        "description": "Enforcement level of Sentinel policy. Can be either `advisory` or `soft-mandatory` or `hard-mandatory`\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the policy\n"
                    },
                    "paths": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of paths to which the policy will be applied to\n"
                    },
                    "policy": {
                        "type": "string",
                        "description": "String containing a Sentinel policy\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/mfaDuo:MfaDuo": {
            "description": "Provides a resource to manage [Duo MFA](https://www.vaultproject.io/docs/enterprise/mfa/mfa-duo.html).\n\n**Note** this feature is available only with Vault Enterprise.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst userpass = new vault.AuthBackend(\"userpass\", {\n    path: \"userpass\",\n    type: \"userpass\",\n});\nconst myDuo = new vault.MfaDuo(\"my_duo\", {\n    apiHostname: \"api-2b5c39f5.duosecurity.com\",\n    integrationKey: \"BIACEUEAXI20BNWTEYXT\",\n    mountAccessor: userpass.accessor,\n    secretKey: \"8C7THtrIigh2rPZQMbguugt8IUftWhMRCOBzbuyz\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nuserpass = vault.AuthBackend(\"userpass\",\n    path=\"userpass\",\n    type=\"userpass\")\nmy_duo = vault.MfaDuo(\"myDuo\",\n    api_hostname=\"api-2b5c39f5.duosecurity.com\",\n    integration_key=\"BIACEUEAXI20BNWTEYXT\",\n    mount_accessor=userpass.accessor,\n    secret_key=\"8C7THtrIigh2rPZQMbguugt8IUftWhMRCOBzbuyz\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var userpass = new Vault.AuthBackend(\"userpass\", new Vault.AuthBackendArgs\n        {\n            Path = \"userpass\",\n            Type = \"userpass\",\n        });\n        var myDuo = new Vault.MfaDuo(\"myDuo\", new Vault.MfaDuoArgs\n        {\n            ApiHostname = \"api-2b5c39f5.duosecurity.com\",\n            IntegrationKey = \"BIACEUEAXI20BNWTEYXT\",\n            MountAccessor = userpass.Accessor,\n            SecretKey = \"8C7THtrIigh2rPZQMbguugt8IUftWhMRCOBzbuyz\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tuserpass, err := vault.NewAuthBackend(ctx, \"userpass\", \u0026vault.AuthBackendArgs{\n\t\t\tPath: pulumi.String(\"userpass\"),\n\t\t\tType: pulumi.String(\"userpass\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vault.NewMfaDuo(ctx, \"myDuo\", \u0026vault.MfaDuoArgs{\n\t\t\tApiHostname:    pulumi.String(\"api-2b5c39f5.duosecurity.com\"),\n\t\t\tIntegrationKey: pulumi.String(\"BIACEUEAXI20BNWTEYXT\"),\n\t\t\tMountAccessor:  userpass.Accessor,\n\t\t\tSecretKey:      pulumi.String(\"8C7THtrIigh2rPZQMbguugt8IUftWhMRCOBzbuyz\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "apiHostname": {
                    "type": "string",
                    "description": "API hostname for Duo.\n"
                },
                "integrationKey": {
                    "type": "string",
                    "description": "Integration key for Duo.\n"
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "The mount to tie this method to for use in automatic mappings. The mapping will use the Name field of Aliases associated\nwith this mount as the username in the mapping.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the MFA method.\n"
                },
                "pushInfo": {
                    "type": "string",
                    "description": "Push information for Duo.\n"
                },
                "secretKey": {
                    "type": "string",
                    "description": "Secret key for Duo.\n"
                },
                "usernameFormat": {
                    "type": "string",
                    "description": "A format string for mapping Identity names to MFA method names. Values to substitute should be placed in `{{}}`.\n"
                }
            },
            "required": [
                "apiHostname",
                "integrationKey",
                "mountAccessor",
                "name",
                "secretKey"
            ],
            "inputProperties": {
                "apiHostname": {
                    "type": "string",
                    "description": "API hostname for Duo.\n"
                },
                "integrationKey": {
                    "type": "string",
                    "description": "Integration key for Duo.\n"
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "The mount to tie this method to for use in automatic mappings. The mapping will use the Name field of Aliases associated\nwith this mount as the username in the mapping.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the MFA method.\n"
                },
                "pushInfo": {
                    "type": "string",
                    "description": "Push information for Duo.\n"
                },
                "secretKey": {
                    "type": "string",
                    "description": "Secret key for Duo.\n"
                },
                "usernameFormat": {
                    "type": "string",
                    "description": "A format string for mapping Identity names to MFA method names. Values to substitute should be placed in `{{}}`.\n"
                }
            },
            "requiredInputs": [
                "apiHostname",
                "integrationKey",
                "mountAccessor",
                "secretKey"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MfaDuo resources.\n",
                "properties": {
                    "apiHostname": {
                        "type": "string",
                        "description": "API hostname for Duo.\n"
                    },
                    "integrationKey": {
                        "type": "string",
                        "description": "Integration key for Duo.\n"
                    },
                    "mountAccessor": {
                        "type": "string",
                        "description": "The mount to tie this method to for use in automatic mappings. The mapping will use the Name field of Aliases associated\nwith this mount as the username in the mapping.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the MFA method.\n"
                    },
                    "pushInfo": {
                        "type": "string",
                        "description": "Push information for Duo.\n"
                    },
                    "secretKey": {
                        "type": "string",
                        "description": "Secret key for Duo.\n"
                    },
                    "usernameFormat": {
                        "type": "string",
                        "description": "A format string for mapping Identity names to MFA method names. Values to substitute should be placed in `{{}}`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/mount:Mount": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.Mount(\"example\", {\n    description: \"This is an example mount\",\n    path: \"dummy\",\n    type: \"generic\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.Mount(\"example\",\n    description=\"This is an example mount\",\n    path=\"dummy\",\n    type=\"generic\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.Mount(\"example\", new Vault.MountArgs\n        {\n            Description = \"This is an example mount\",\n            Path = \"dummy\",\n            Type = \"generic\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewMount(ctx, \"example\", \u0026vault.MountArgs{\n\t\t\tDescription: pulumi.String(\"This is an example mount\"),\n\t\t\tPath:        pulumi.String(\"dummy\"),\n\t\t\tType:        pulumi.String(\"generic\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The accessor for this mount.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Default lease duration for tokens and secrets in seconds\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount\n"
                },
                "externalEntropyAccess": {
                    "type": "boolean",
                    "description": "Boolean flag that can be explicitly set to true to enable the secrets engine to access Vault's external entropy source\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Boolean flag that can be explicitly set to true to enforce local mount in HA environment\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Maximum possible lease duration for tokens and secrets in seconds\n"
                },
                "options": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies mount type specific options that are passed to the backend\n"
                },
                "path": {
                    "type": "string",
                    "description": "Where the secret backend will be mounted\n"
                },
                "sealWrap": {
                    "type": "boolean",
                    "description": "Boolean flag that can be explicitly set to true to enable seal wrapping for the mount, causing values stored by the mount to be wrapped by the seal's encryption capability\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the backend, such as \"aws\"\n"
                }
            },
            "required": [
                "accessor",
                "defaultLeaseTtlSeconds",
                "maxLeaseTtlSeconds",
                "path",
                "sealWrap",
                "type"
            ],
            "inputProperties": {
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Default lease duration for tokens and secrets in seconds\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount\n"
                },
                "externalEntropyAccess": {
                    "type": "boolean",
                    "description": "Boolean flag that can be explicitly set to true to enable the secrets engine to access Vault's external entropy source\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Boolean flag that can be explicitly set to true to enforce local mount in HA environment\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Maximum possible lease duration for tokens and secrets in seconds\n"
                },
                "options": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies mount type specific options that are passed to the backend\n"
                },
                "path": {
                    "type": "string",
                    "description": "Where the secret backend will be mounted\n"
                },
                "sealWrap": {
                    "type": "boolean",
                    "description": "Boolean flag that can be explicitly set to true to enable seal wrapping for the mount, causing values stored by the mount to be wrapped by the seal's encryption capability\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the backend, such as \"aws\"\n"
                }
            },
            "requiredInputs": [
                "path",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Mount resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The accessor for this mount.\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "Default lease duration for tokens and secrets in seconds\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Human-friendly description of the mount\n"
                    },
                    "externalEntropyAccess": {
                        "type": "boolean",
                        "description": "Boolean flag that can be explicitly set to true to enable the secrets engine to access Vault's external entropy source\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Boolean flag that can be explicitly set to true to enforce local mount in HA environment\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "Maximum possible lease duration for tokens and secrets in seconds\n"
                    },
                    "options": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Specifies mount type specific options that are passed to the backend\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Where the secret backend will be mounted\n"
                    },
                    "sealWrap": {
                        "type": "boolean",
                        "description": "Boolean flag that can be explicitly set to true to enable seal wrapping for the mount, causing values stored by the mount to be wrapped by the seal's encryption capability\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of the backend, such as \"aws\"\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/namespace:Namespace": {
            "description": "Provides a resource to manage [Namespaces](https://www.vaultproject.io/docs/enterprise/namespaces/index.html).\n\n**Note** this feature is available only with Vault Enterprise.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst ns1 = new vault.Namespace(\"ns1\", {\n    path: \"ns1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nns1 = vault.Namespace(\"ns1\", path=\"ns1\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var ns1 = new Vault.Namespace(\"ns1\", new Vault.NamespaceArgs\n        {\n            Path = \"ns1\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewNamespace(ctx, \"ns1\", \u0026vault.NamespaceArgs{\n\t\t\tPath: pulumi.String(\"ns1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "namespaceId": {
                    "type": "string",
                    "description": "ID of the namepsace.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path of the namespace. Must not have a trailing `/`\n"
                }
            },
            "required": [
                "namespaceId",
                "path"
            ],
            "inputProperties": {
                "path": {
                    "type": "string",
                    "description": "The path of the namespace. Must not have a trailing `/`\n"
                }
            },
            "requiredInputs": [
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Namespace resources.\n",
                "properties": {
                    "namespaceId": {
                        "type": "string",
                        "description": "ID of the namepsace.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path of the namespace. Must not have a trailing `/`\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/policy:Policy": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.Policy(\"example\", {\n    policy: `path \"secret/my_app\" {\n  capabilities = [\"write\"]\n}\n`,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.Policy(\"example\", policy=\"\"\"path \"secret/my_app\" {\n  capabilities = [\"write\"]\n}\n\n\"\"\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.Policy(\"example\", new Vault.PolicyArgs\n        {\n            Policy = @\"path \"\"secret/my_app\"\" {\n  capabilities = [\"\"write\"\"]\n}\n\n\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewPolicy(ctx, \"example\", \u0026vault.PolicyArgs{\n\t\t\tPolicy: pulumi.String(fmt.Sprintf(\"%v%v%v%v\", \"path \\\"secret/my_app\\\" {\\n\", \"  capabilities = [\\\"write\\\"]\\n\", \"}\\n\", \"\\n\")),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the policy\n"
                },
                "policy": {
                    "type": "string",
                    "description": "String containing a Vault policy\n",
                    "language": {
                        "csharp": {
                            "name": "PolicyContents"
                        }
                    }
                }
            },
            "required": [
                "name",
                "policy"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "The name of the policy\n"
                },
                "policy": {
                    "type": "string",
                    "description": "String containing a Vault policy\n",
                    "language": {
                        "csharp": {
                            "name": "PolicyContents"
                        }
                    }
                }
            },
            "requiredInputs": [
                "policy"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Policy resources.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the policy\n"
                    },
                    "policy": {
                        "type": "string",
                        "description": "String containing a Vault policy\n",
                        "language": {
                            "csharp": {
                                "name": "PolicyContents"
                            }
                        }
                    }
                },
                "type": "object"
            }
        },
        "vault:index/rgpPolicy:RgpPolicy": {
            "description": "Provides a resource to manage Role Governing Policy (RGP) via [Sentinel](https://www.vaultproject.io/docs/enterprise/sentinel/index.html).\n\n**Note** this feature is available only with Vault Enterprise.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst allow_all = new vault.RgpPolicy(\"allow-all\", {\n    enforcementLevel: \"soft-mandatory\",\n    policy: `main = rule {\n  true\n}\n`,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nallow_all = vault.RgpPolicy(\"allow-all\",\n    enforcement_level=\"soft-mandatory\",\n    policy=\"\"\"main = rule {\n  true\n}\n\n\"\"\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var allow_all = new Vault.RgpPolicy(\"allow-all\", new Vault.RgpPolicyArgs\n        {\n            EnforcementLevel = \"soft-mandatory\",\n            Policy = @\"main = rule {\n  true\n}\n\n\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewRgpPolicy(ctx, \"allow_all\", \u0026vault.RgpPolicyArgs{\n\t\t\tEnforcementLevel: pulumi.String(\"soft-mandatory\"),\n\t\t\tPolicy:           pulumi.String(fmt.Sprintf(\"%v%v%v%v\", \"main = rule {\\n\", \"  true\\n\", \"}\\n\", \"\\n\")),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "enforcementLevel": {
                    "type": "string",
                    "description": "Enforcement level of Sentinel policy. Can be either `advisory` or `soft-mandatory` or `hard-mandatory`\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the policy\n"
                },
                "policy": {
                    "type": "string",
                    "description": "String containing a Sentinel policy\n"
                }
            },
            "required": [
                "enforcementLevel",
                "name",
                "policy"
            ],
            "inputProperties": {
                "enforcementLevel": {
                    "type": "string",
                    "description": "Enforcement level of Sentinel policy. Can be either `advisory` or `soft-mandatory` or `hard-mandatory`\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the policy\n"
                },
                "policy": {
                    "type": "string",
                    "description": "String containing a Sentinel policy\n"
                }
            },
            "requiredInputs": [
                "enforcementLevel",
                "policy"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RgpPolicy resources.\n",
                "properties": {
                    "enforcementLevel": {
                        "type": "string",
                        "description": "Enforcement level of Sentinel policy. Can be either `advisory` or `soft-mandatory` or `hard-mandatory`\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the policy\n"
                    },
                    "policy": {
                        "type": "string",
                        "description": "String containing a Sentinel policy\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/token:Token": {
            "properties": {
                "clientToken": {
                    "type": "string",
                    "description": "String containing the client token if stored in present file\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "String containing the token display name\n"
                },
                "encryptedClientToken": {
                    "type": "string",
                    "description": "String containing the client token encrypted with the given `pgp_key` if stored in present file\n"
                },
                "explicitMaxTtl": {
                    "type": "string",
                    "description": "The explicit max TTL of this token\n"
                },
                "leaseDuration": {
                    "type": "integer",
                    "description": "String containing the token lease duration if present in state file\n"
                },
                "leaseStarted": {
                    "type": "string",
                    "description": "String containing the token lease started time if present in state file\n"
                },
                "noDefaultPolicy": {
                    "type": "boolean",
                    "description": "Flag to not attach the default policy to this token\n"
                },
                "noParent": {
                    "type": "boolean",
                    "description": "Flag to create a token without parent\n"
                },
                "numUses": {
                    "type": "integer",
                    "description": "The number of allowed uses of this token\n"
                },
                "period": {
                    "type": "string",
                    "description": "The period of this token\n"
                },
                "pgpKey": {
                    "type": "string",
                    "description": "The PGP key (base64 encoded) to encrypt the token.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to attach to this token\n"
                },
                "renewIncrement": {
                    "type": "integer",
                    "description": "The renew increment\n"
                },
                "renewMinLease": {
                    "type": "integer",
                    "description": "The minimal lease to renew this token\n"
                },
                "renewable": {
                    "type": "boolean",
                    "description": "Flag to allow to renew this token\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The token role name\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "The TTL period of this token\n"
                },
                "wrappedToken": {
                    "type": "string",
                    "description": "The client wrapped token.\n"
                },
                "wrappingAccessor": {
                    "type": "string",
                    "description": "The client wrapping accessor.\n"
                },
                "wrappingTtl": {
                    "type": "string",
                    "description": "The TTL period of the wrapped token.\n"
                }
            },
            "required": [
                "clientToken",
                "encryptedClientToken",
                "leaseDuration",
                "leaseStarted",
                "noParent",
                "numUses",
                "renewable",
                "wrappedToken",
                "wrappingAccessor"
            ],
            "inputProperties": {
                "displayName": {
                    "type": "string",
                    "description": "String containing the token display name\n"
                },
                "explicitMaxTtl": {
                    "type": "string",
                    "description": "The explicit max TTL of this token\n"
                },
                "noDefaultPolicy": {
                    "type": "boolean",
                    "description": "Flag to not attach the default policy to this token\n"
                },
                "noParent": {
                    "type": "boolean",
                    "description": "Flag to create a token without parent\n"
                },
                "numUses": {
                    "type": "integer",
                    "description": "The number of allowed uses of this token\n"
                },
                "period": {
                    "type": "string",
                    "description": "The period of this token\n"
                },
                "pgpKey": {
                    "type": "string",
                    "description": "The PGP key (base64 encoded) to encrypt the token.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to attach to this token\n"
                },
                "renewIncrement": {
                    "type": "integer",
                    "description": "The renew increment\n"
                },
                "renewMinLease": {
                    "type": "integer",
                    "description": "The minimal lease to renew this token\n"
                },
                "renewable": {
                    "type": "boolean",
                    "description": "Flag to allow to renew this token\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The token role name\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "The TTL period of this token\n"
                },
                "wrappingTtl": {
                    "type": "string",
                    "description": "The TTL period of the wrapped token.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Token resources.\n",
                "properties": {
                    "clientToken": {
                        "type": "string",
                        "description": "String containing the client token if stored in present file\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "String containing the token display name\n"
                    },
                    "encryptedClientToken": {
                        "type": "string",
                        "description": "String containing the client token encrypted with the given `pgp_key` if stored in present file\n"
                    },
                    "explicitMaxTtl": {
                        "type": "string",
                        "description": "The explicit max TTL of this token\n"
                    },
                    "leaseDuration": {
                        "type": "integer",
                        "description": "String containing the token lease duration if present in state file\n"
                    },
                    "leaseStarted": {
                        "type": "string",
                        "description": "String containing the token lease started time if present in state file\n"
                    },
                    "noDefaultPolicy": {
                        "type": "boolean",
                        "description": "Flag to not attach the default policy to this token\n"
                    },
                    "noParent": {
                        "type": "boolean",
                        "description": "Flag to create a token without parent\n"
                    },
                    "numUses": {
                        "type": "integer",
                        "description": "The number of allowed uses of this token\n"
                    },
                    "period": {
                        "type": "string",
                        "description": "The period of this token\n"
                    },
                    "pgpKey": {
                        "type": "string",
                        "description": "The PGP key (base64 encoded) to encrypt the token.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to attach to this token\n"
                    },
                    "renewIncrement": {
                        "type": "integer",
                        "description": "The renew increment\n"
                    },
                    "renewMinLease": {
                        "type": "integer",
                        "description": "The minimal lease to renew this token\n"
                    },
                    "renewable": {
                        "type": "boolean",
                        "description": "Flag to allow to renew this token\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The token role name\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "The TTL period of this token\n"
                    },
                    "wrappedToken": {
                        "type": "string",
                        "description": "The client wrapped token.\n"
                    },
                    "wrappingAccessor": {
                        "type": "string",
                        "description": "The client wrapping accessor.\n"
                    },
                    "wrappingTtl": {
                        "type": "string",
                        "description": "The TTL period of the wrapped token.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:jwt/authBackend:AuthBackend": {
            "description": "Provides a resource for managing an\n[JWT auth backend within Vault](https://www.vaultproject.io/docs/auth/jwt.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nManage JWT auth backend:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.jwt.AuthBackend(\"example\", {\n    boundIssuer: \"https://myco.auth0.com/\",\n    description: \"Demonstration of the Terraform JWT auth backend\",\n    oidcDiscoveryUrl: \"https://myco.auth0.com/\",\n    path: \"jwt\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.jwt.AuthBackend(\"example\",\n    bound_issuer=\"https://myco.auth0.com/\",\n    description=\"Demonstration of the Terraform JWT auth backend\",\n    oidc_discovery_url=\"https://myco.auth0.com/\",\n    path=\"jwt\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.Jwt.AuthBackend(\"example\", new Vault.Jwt.AuthBackendArgs\n        {\n            BoundIssuer = \"https://myco.auth0.com/\",\n            Description = \"Demonstration of the Terraform JWT auth backend\",\n            OidcDiscoveryUrl = \"https://myco.auth0.com/\",\n            Path = \"jwt\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/jwt\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := jwt.NewAuthBackend(ctx, \"example\", \u0026jwt.AuthBackendArgs{\n\t\t\tBoundIssuer:      pulumi.String(\"https://myco.auth0.com/\"),\n\t\t\tDescription:      pulumi.String(\"Demonstration of the Terraform JWT auth backend\"),\n\t\t\tOidcDiscoveryUrl: pulumi.String(\"https://myco.auth0.com/\"),\n\t\t\tPath:             pulumi.String(\"jwt\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\nManage OIDC auth backend:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.jwt.AuthBackend(\"example\", {\n    boundIssuer: \"https://myco.auth0.com/\",\n    description: \"Demonstration of the Terraform JWT auth backend\",\n    oidcClientId: \"1234567890\",\n    oidcClientSecret: \"secret123456\",\n    oidcDiscoveryUrl: \"https://myco.auth0.com/\",\n    path: \"oidc\",\n    tune: {\n        listingVisibility: \"unauth\",\n    },\n    type: \"oidc\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.jwt.AuthBackend(\"example\",\n    bound_issuer=\"https://myco.auth0.com/\",\n    description=\"Demonstration of the Terraform JWT auth backend\",\n    oidc_client_id=\"1234567890\",\n    oidc_client_secret=\"secret123456\",\n    oidc_discovery_url=\"https://myco.auth0.com/\",\n    path=\"oidc\",\n    tune={\n        \"listing_visibility\": \"unauth\",\n    },\n    type=\"oidc\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.Jwt.AuthBackend(\"example\", new Vault.Jwt.AuthBackendArgs\n        {\n            BoundIssuer = \"https://myco.auth0.com/\",\n            Description = \"Demonstration of the Terraform JWT auth backend\",\n            OidcClientId = \"1234567890\",\n            OidcClientSecret = \"secret123456\",\n            OidcDiscoveryUrl = \"https://myco.auth0.com/\",\n            Path = \"oidc\",\n            Tune = new Vault.Jwt.Inputs.AuthBackendTuneArgs\n            {\n                ListingVisibility = \"unauth\",\n            },\n            Type = \"oidc\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/jwt\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := jwt.NewAuthBackend(ctx, \"example\", \u0026jwt.AuthBackendArgs{\n\t\t\tBoundIssuer:      pulumi.String(\"https://myco.auth0.com/\"),\n\t\t\tDescription:      pulumi.String(\"Demonstration of the Terraform JWT auth backend\"),\n\t\t\tOidcClientId:     pulumi.String(\"1234567890\"),\n\t\t\tOidcClientSecret: pulumi.String(\"secret123456\"),\n\t\t\tOidcDiscoveryUrl: pulumi.String(\"https://myco.auth0.com/\"),\n\t\t\tPath:             pulumi.String(\"oidc\"),\n\t\t\tTune: \u0026jwt.AuthBackendTuneArgs{\n\t\t\t\tListingVisibility: pulumi.String(\"unauth\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"oidc\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The accessor of the JWT auth backend\n"
                },
                "boundIssuer": {
                    "type": "string",
                    "description": "The value against which to match the iss claim in a JWT\n"
                },
                "defaultRole": {
                    "type": "string",
                    "description": "The default role to use if none is provided during login\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the auth backend\n"
                },
                "jwksCaPem": {
                    "type": "string",
                    "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the JWKS URL. If not set, system certificates are used.\n"
                },
                "jwksUrl": {
                    "type": "string",
                    "description": "JWKS URL to use to authenticate signatures. Cannot be used with \"oidc_discovery_url\" or \"jwt_validation_pubkeys\".\n"
                },
                "jwtSupportedAlgs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of supported signing algorithms. Vault 1.1.0 defaults to [RS256] but future or past versions of Vault may differ\n"
                },
                "jwtValidationPubkeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of PEM-encoded public keys to use to authenticate signatures locally. Cannot be used in combination with `oidc_discovery_url`\n"
                },
                "oidcClientId": {
                    "type": "string",
                    "description": "Client ID used for OIDC backends\n"
                },
                "oidcClientSecret": {
                    "type": "string",
                    "description": "Client Secret used for OIDC backends\n"
                },
                "oidcDiscoveryCaPem": {
                    "type": "string",
                    "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the OIDC Discovery URL. If not set, system certificates are used\n"
                },
                "oidcDiscoveryUrl": {
                    "type": "string",
                    "description": "The OIDC Discovery URL, without any .well-known component (base path). Cannot be used in combination with `jwt_validation_pubkeys`\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to mount the JWT/OIDC auth backend\n"
                },
                "tune": {
                    "$ref": "#/types/vault:jwt/AuthBackendTune:AuthBackendTune"
                },
                "type": {
                    "type": "string",
                    "description": "Type of auth backend. Should be one of `jwt` or `oidc`. Default - `jwt`\n"
                }
            },
            "required": [
                "accessor",
                "tune"
            ],
            "inputProperties": {
                "boundIssuer": {
                    "type": "string",
                    "description": "The value against which to match the iss claim in a JWT\n"
                },
                "defaultRole": {
                    "type": "string",
                    "description": "The default role to use if none is provided during login\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the auth backend\n"
                },
                "jwksCaPem": {
                    "type": "string",
                    "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the JWKS URL. If not set, system certificates are used.\n"
                },
                "jwksUrl": {
                    "type": "string",
                    "description": "JWKS URL to use to authenticate signatures. Cannot be used with \"oidc_discovery_url\" or \"jwt_validation_pubkeys\".\n"
                },
                "jwtSupportedAlgs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of supported signing algorithms. Vault 1.1.0 defaults to [RS256] but future or past versions of Vault may differ\n"
                },
                "jwtValidationPubkeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of PEM-encoded public keys to use to authenticate signatures locally. Cannot be used in combination with `oidc_discovery_url`\n"
                },
                "oidcClientId": {
                    "type": "string",
                    "description": "Client ID used for OIDC backends\n"
                },
                "oidcClientSecret": {
                    "type": "string",
                    "description": "Client Secret used for OIDC backends\n"
                },
                "oidcDiscoveryCaPem": {
                    "type": "string",
                    "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the OIDC Discovery URL. If not set, system certificates are used\n"
                },
                "oidcDiscoveryUrl": {
                    "type": "string",
                    "description": "The OIDC Discovery URL, without any .well-known component (base path). Cannot be used in combination with `jwt_validation_pubkeys`\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to mount the JWT/OIDC auth backend\n"
                },
                "tune": {
                    "$ref": "#/types/vault:jwt/AuthBackendTune:AuthBackendTune"
                },
                "type": {
                    "type": "string",
                    "description": "Type of auth backend. Should be one of `jwt` or `oidc`. Default - `jwt`\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackend resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The accessor of the JWT auth backend\n"
                    },
                    "boundIssuer": {
                        "type": "string",
                        "description": "The value against which to match the iss claim in a JWT\n"
                    },
                    "defaultRole": {
                        "type": "string",
                        "description": "The default role to use if none is provided during login\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the auth backend\n"
                    },
                    "jwksCaPem": {
                        "type": "string",
                        "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the JWKS URL. If not set, system certificates are used.\n"
                    },
                    "jwksUrl": {
                        "type": "string",
                        "description": "JWKS URL to use to authenticate signatures. Cannot be used with \"oidc_discovery_url\" or \"jwt_validation_pubkeys\".\n"
                    },
                    "jwtSupportedAlgs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of supported signing algorithms. Vault 1.1.0 defaults to [RS256] but future or past versions of Vault may differ\n"
                    },
                    "jwtValidationPubkeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of PEM-encoded public keys to use to authenticate signatures locally. Cannot be used in combination with `oidc_discovery_url`\n"
                    },
                    "oidcClientId": {
                        "type": "string",
                        "description": "Client ID used for OIDC backends\n"
                    },
                    "oidcClientSecret": {
                        "type": "string",
                        "description": "Client Secret used for OIDC backends\n"
                    },
                    "oidcDiscoveryCaPem": {
                        "type": "string",
                        "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the OIDC Discovery URL. If not set, system certificates are used\n"
                    },
                    "oidcDiscoveryUrl": {
                        "type": "string",
                        "description": "The OIDC Discovery URL, without any .well-known component (base path). Cannot be used in combination with `jwt_validation_pubkeys`\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Path to mount the JWT/OIDC auth backend\n"
                    },
                    "tune": {
                        "$ref": "#/types/vault:jwt/AuthBackendTune:AuthBackendTune"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of auth backend. Should be one of `jwt` or `oidc`. Default - `jwt`\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:jwt/authBackendRole:AuthBackendRole": {
            "description": "Manages an JWT/OIDC auth backend role in a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/jwt.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nRole for JWT backend:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst jwt = new vault.jwt.AuthBackend(\"jwt\", {path: \"jwt\"});\nconst example = new vault.jwt.AuthBackendRole(\"example\", {\n    backend: jwt.path,\n    roleName: \"test-role\",\n    tokenPolicies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    boundAudiences: [\"https://myco.test\"],\n    userClaim: \"https://vault/user\",\n    roleType: \"jwt\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\njwt = vault.jwt.AuthBackend(\"jwt\", path=\"jwt\")\nexample = vault.jwt.AuthBackendRole(\"example\",\n    backend=jwt.path,\n    role_name=\"test-role\",\n    token_policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    bound_audiences=[\"https://myco.test\"],\n    user_claim=\"https://vault/user\",\n    role_type=\"jwt\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var jwt = new Vault.Jwt.AuthBackend(\"jwt\", new Vault.Jwt.AuthBackendArgs\n        {\n            Path = \"jwt\",\n        });\n        var example = new Vault.Jwt.AuthBackendRole(\"example\", new Vault.Jwt.AuthBackendRoleArgs\n        {\n            Backend = jwt.Path,\n            RoleName = \"test-role\",\n            TokenPolicies = \n            {\n                \"default\",\n                \"dev\",\n                \"prod\",\n            },\n            BoundAudiences = \n            {\n                \"https://myco.test\",\n            },\n            UserClaim = \"https://vault/user\",\n            RoleType = \"jwt\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/jwt\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tjwt, err := jwt.NewAuthBackend(ctx, \"jwt\", \u0026jwt.AuthBackendArgs{\n\t\t\tPath: pulumi.String(\"jwt\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = jwt.NewAuthBackendRole(ctx, \"example\", \u0026jwt.AuthBackendRoleArgs{\n\t\t\tBackend:  jwt.Path,\n\t\t\tRoleName: pulumi.String(\"test-role\"),\n\t\t\tTokenPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t\tBoundAudiences: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"https://myco.test\"),\n\t\t\t},\n\t\t\tUserClaim: pulumi.String(\"https://vault/user\"),\n\t\t\tRoleType:  pulumi.String(\"jwt\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\nRole for OIDC backend:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst oidc = new vault.jwt.AuthBackend(\"oidc\", {\n    path: \"oidc\",\n    defaultRole: \"test-role\",\n});\nconst example = new vault.jwt.AuthBackendRole(\"example\", {\n    backend: oidc.path,\n    roleName: \"test-role\",\n    tokenPolicies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    userClaim: \"https://vault/user\",\n    roleType: \"oidc\",\n    allowedRedirectUris: [\"http://localhost:8200/ui/vault/auth/oidc/oidc/callback\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\noidc = vault.jwt.AuthBackend(\"oidc\",\n    path=\"oidc\",\n    default_role=\"test-role\")\nexample = vault.jwt.AuthBackendRole(\"example\",\n    backend=oidc.path,\n    role_name=\"test-role\",\n    token_policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    user_claim=\"https://vault/user\",\n    role_type=\"oidc\",\n    allowed_redirect_uris=[\"http://localhost:8200/ui/vault/auth/oidc/oidc/callback\"])\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var oidc = new Vault.Jwt.AuthBackend(\"oidc\", new Vault.Jwt.AuthBackendArgs\n        {\n            Path = \"oidc\",\n            DefaultRole = \"test-role\",\n        });\n        var example = new Vault.Jwt.AuthBackendRole(\"example\", new Vault.Jwt.AuthBackendRoleArgs\n        {\n            Backend = oidc.Path,\n            RoleName = \"test-role\",\n            TokenPolicies = \n            {\n                \"default\",\n                \"dev\",\n                \"prod\",\n            },\n            UserClaim = \"https://vault/user\",\n            RoleType = \"oidc\",\n            AllowedRedirectUris = \n            {\n                \"http://localhost:8200/ui/vault/auth/oidc/oidc/callback\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/jwt\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\toidc, err := jwt.NewAuthBackend(ctx, \"oidc\", \u0026jwt.AuthBackendArgs{\n\t\t\tPath:        pulumi.String(\"oidc\"),\n\t\t\tDefaultRole: pulumi.String(\"test-role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = jwt.NewAuthBackendRole(ctx, \"example\", \u0026jwt.AuthBackendRoleArgs{\n\t\t\tBackend:  oidc.Path,\n\t\t\tRoleName: pulumi.String(\"test-role\"),\n\t\t\tTokenPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t\tUserClaim: pulumi.String(\"https://vault/user\"),\n\t\t\tRoleType:  pulumi.String(\"oidc\"),\n\t\t\tAllowedRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8200/ui/vault/auth/oidc/oidc/callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "allowedRedirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of allowed values for redirect_uri during OIDC logins.\nRequired for OIDC roles\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique name of the auth backend to configure.\nDefaults to `jwt`.\n"
                },
                "boundAudiences": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Required for roles of type `jwt`, optional for roles of\ntype `oidc`) List of `aud` claims to match against. Any match is sufficient.\n"
                },
                "boundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, a list of\nCIDRs valid as the source address for login requests. This value is also encoded into any resulting token.\n",
                    "deprecationMessage": "use `token_bound_cidrs` instead if you are running Vault \u003e= 1.2"
                },
                "boundClaims": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "If set, a map of claims/values to match against.\nThe expected value may be a single string or a list of strings.\n"
                },
                "boundSubject": {
                    "type": "string",
                    "description": "If set, requires that the `sub` claim matches\nthis value.\n"
                },
                "claimMappings": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "If set, a map of claims (keys) to be copied\nto specified metadata fields (values).\n"
                },
                "clockSkewLeeway": {
                    "type": "integer",
                    "description": "The amount of leeway to add to all claims to account for clock skew, in\nseconds. Defaults to `60` seconds if set to `0` and can be disabled if set to `-1`.\nOnly applicable with \"jwt\" roles.\n"
                },
                "expirationLeeway": {
                    "type": "integer",
                    "description": "The amount of leeway to add to expiration (`exp`) claims to account for\nclock skew, in seconds. Defaults to `60` seconds if set to `0` and can be disabled if set to `-1`.\nOnly applicable with \"jwt\" roles.\n"
                },
                "groupsClaim": {
                    "type": "string",
                    "description": "The claim to use to uniquely identify\nthe set of groups to which the user belongs; this will be used as the names\nfor the Identity group aliases created due to a successful login. The claim\nvalue must be a list of strings.\n"
                },
                "groupsClaimDelimiterPattern": {
                    "type": "string",
                    "description": "(Optional; Deprecated. This field has been\nremoved since Vault 1.1. If the groups claim is not at the top level, it can\nnow be specified as a [JSONPointer](https://tools.ietf.org/html/rfc6901).)\nA pattern of delimiters\nused to allow the groups_claim to live outside of the top-level JWT structure.\nFor instance, a groups_claim of meta/user.name/groups with this field\nset to // will expect nested structures named meta, user.name, and groups.\nIf this field was set to /./ the groups information would expect to be\nvia nested structures of meta, user, name, and groups.\n",
                    "deprecationMessage": "`groups_claim_delimiter_pattern` has been removed since Vault 1.1. If the groups claim is not at the top level, it can now be specified as a JSONPointer."
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum allowed lifetime of tokens\nissued using this role, provided as a number of seconds.\n",
                    "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "notBeforeLeeway": {
                    "type": "integer",
                    "description": "The amount of leeway to add to not before (`nbf`) claims to account for\nclock skew, in seconds. Defaults to `60` seconds if set to `0` and can be disabled if set to `-1`.\nOnly applicable with \"jwt\" roles.\n"
                },
                "numUses": {
                    "type": "integer",
                    "description": "If set, puts a use-count\nlimitation on the issued token.\n",
                    "deprecationMessage": "use `token_num_uses` instead if you are running Vault \u003e= 1.2"
                },
                "oidcScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, a list of OIDC scopes to be used with an OIDC role.\nThe standard scope \"openid\" is automatically included and need not be specified.\n"
                },
                "period": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings\nspecifying the policies to be set on tokens issued using this role.\n",
                    "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "roleType": {
                    "type": "string",
                    "description": "Type of role, either \"oidc\" (default) or \"jwt\".\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The TTL period of tokens issued\nusing this role, provided as a number of seconds.\n",
                    "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "userClaim": {
                    "type": "string",
                    "description": "The claim to use to uniquely identify\nthe user; this will be used as the name for the Identity entity alias created\ndue to a successful login.\n"
                },
                "verboseOidcLogging": {
                    "type": "boolean",
                    "description": "Log received OIDC tokens and claims when debug-level\nlogging is active. Not recommended in production since sensitive information may be present\nin OIDC responses.\n"
                }
            },
            "required": [
                "roleName",
                "roleType",
                "userClaim"
            ],
            "inputProperties": {
                "allowedRedirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of allowed values for redirect_uri during OIDC logins.\nRequired for OIDC roles\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique name of the auth backend to configure.\nDefaults to `jwt`.\n"
                },
                "boundAudiences": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Required for roles of type `jwt`, optional for roles of\ntype `oidc`) List of `aud` claims to match against. Any match is sufficient.\n"
                },
                "boundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, a list of\nCIDRs valid as the source address for login requests. This value is also encoded into any resulting token.\n",
                    "deprecationMessage": "use `token_bound_cidrs` instead if you are running Vault \u003e= 1.2"
                },
                "boundClaims": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "If set, a map of claims/values to match against.\nThe expected value may be a single string or a list of strings.\n"
                },
                "boundSubject": {
                    "type": "string",
                    "description": "If set, requires that the `sub` claim matches\nthis value.\n"
                },
                "claimMappings": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "If set, a map of claims (keys) to be copied\nto specified metadata fields (values).\n"
                },
                "clockSkewLeeway": {
                    "type": "integer",
                    "description": "The amount of leeway to add to all claims to account for clock skew, in\nseconds. Defaults to `60` seconds if set to `0` and can be disabled if set to `-1`.\nOnly applicable with \"jwt\" roles.\n"
                },
                "expirationLeeway": {
                    "type": "integer",
                    "description": "The amount of leeway to add to expiration (`exp`) claims to account for\nclock skew, in seconds. Defaults to `60` seconds if set to `0` and can be disabled if set to `-1`.\nOnly applicable with \"jwt\" roles.\n"
                },
                "groupsClaim": {
                    "type": "string",
                    "description": "The claim to use to uniquely identify\nthe set of groups to which the user belongs; this will be used as the names\nfor the Identity group aliases created due to a successful login. The claim\nvalue must be a list of strings.\n"
                },
                "groupsClaimDelimiterPattern": {
                    "type": "string",
                    "description": "(Optional; Deprecated. This field has been\nremoved since Vault 1.1. If the groups claim is not at the top level, it can\nnow be specified as a [JSONPointer](https://tools.ietf.org/html/rfc6901).)\nA pattern of delimiters\nused to allow the groups_claim to live outside of the top-level JWT structure.\nFor instance, a groups_claim of meta/user.name/groups with this field\nset to // will expect nested structures named meta, user.name, and groups.\nIf this field was set to /./ the groups information would expect to be\nvia nested structures of meta, user, name, and groups.\n",
                    "deprecationMessage": "`groups_claim_delimiter_pattern` has been removed since Vault 1.1. If the groups claim is not at the top level, it can now be specified as a JSONPointer."
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum allowed lifetime of tokens\nissued using this role, provided as a number of seconds.\n",
                    "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "notBeforeLeeway": {
                    "type": "integer",
                    "description": "The amount of leeway to add to not before (`nbf`) claims to account for\nclock skew, in seconds. Defaults to `60` seconds if set to `0` and can be disabled if set to `-1`.\nOnly applicable with \"jwt\" roles.\n"
                },
                "numUses": {
                    "type": "integer",
                    "description": "If set, puts a use-count\nlimitation on the issued token.\n",
                    "deprecationMessage": "use `token_num_uses` instead if you are running Vault \u003e= 1.2"
                },
                "oidcScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, a list of OIDC scopes to be used with an OIDC role.\nThe standard scope \"openid\" is automatically included and need not be specified.\n"
                },
                "period": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings\nspecifying the policies to be set on tokens issued using this role.\n",
                    "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "roleType": {
                    "type": "string",
                    "description": "Type of role, either \"oidc\" (default) or \"jwt\".\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The TTL period of tokens issued\nusing this role, provided as a number of seconds.\n",
                    "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "userClaim": {
                    "type": "string",
                    "description": "The claim to use to uniquely identify\nthe user; this will be used as the name for the Identity entity alias created\ndue to a successful login.\n"
                },
                "verboseOidcLogging": {
                    "type": "boolean",
                    "description": "Log received OIDC tokens and claims when debug-level\nlogging is active. Not recommended in production since sensitive information may be present\nin OIDC responses.\n"
                }
            },
            "requiredInputs": [
                "roleName",
                "userClaim"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "allowedRedirectUris": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of allowed values for redirect_uri during OIDC logins.\nRequired for OIDC roles\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The unique name of the auth backend to configure.\nDefaults to `jwt`.\n"
                    },
                    "boundAudiences": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(Required for roles of type `jwt`, optional for roles of\ntype `oidc`) List of `aud` claims to match against. Any match is sufficient.\n"
                    },
                    "boundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, a list of\nCIDRs valid as the source address for login requests. This value is also encoded into any resulting token.\n",
                        "deprecationMessage": "use `token_bound_cidrs` instead if you are running Vault \u003e= 1.2"
                    },
                    "boundClaims": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "If set, a map of claims/values to match against.\nThe expected value may be a single string or a list of strings.\n"
                    },
                    "boundSubject": {
                        "type": "string",
                        "description": "If set, requires that the `sub` claim matches\nthis value.\n"
                    },
                    "claimMappings": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "If set, a map of claims (keys) to be copied\nto specified metadata fields (values).\n"
                    },
                    "clockSkewLeeway": {
                        "type": "integer",
                        "description": "The amount of leeway to add to all claims to account for clock skew, in\nseconds. Defaults to `60` seconds if set to `0` and can be disabled if set to `-1`.\nOnly applicable with \"jwt\" roles.\n"
                    },
                    "expirationLeeway": {
                        "type": "integer",
                        "description": "The amount of leeway to add to expiration (`exp`) claims to account for\nclock skew, in seconds. Defaults to `60` seconds if set to `0` and can be disabled if set to `-1`.\nOnly applicable with \"jwt\" roles.\n"
                    },
                    "groupsClaim": {
                        "type": "string",
                        "description": "The claim to use to uniquely identify\nthe set of groups to which the user belongs; this will be used as the names\nfor the Identity group aliases created due to a successful login. The claim\nvalue must be a list of strings.\n"
                    },
                    "groupsClaimDelimiterPattern": {
                        "type": "string",
                        "description": "(Optional; Deprecated. This field has been\nremoved since Vault 1.1. If the groups claim is not at the top level, it can\nnow be specified as a [JSONPointer](https://tools.ietf.org/html/rfc6901).)\nA pattern of delimiters\nused to allow the groups_claim to live outside of the top-level JWT structure.\nFor instance, a groups_claim of meta/user.name/groups with this field\nset to // will expect nested structures named meta, user.name, and groups.\nIf this field was set to /./ the groups information would expect to be\nvia nested structures of meta, user, name, and groups.\n",
                        "deprecationMessage": "`groups_claim_delimiter_pattern` has been removed since Vault 1.1. If the groups claim is not at the top level, it can now be specified as a JSONPointer."
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "The maximum allowed lifetime of tokens\nissued using this role, provided as a number of seconds.\n",
                        "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                    },
                    "notBeforeLeeway": {
                        "type": "integer",
                        "description": "The amount of leeway to add to not before (`nbf`) claims to account for\nclock skew, in seconds. Defaults to `60` seconds if set to `0` and can be disabled if set to `-1`.\nOnly applicable with \"jwt\" roles.\n"
                    },
                    "numUses": {
                        "type": "integer",
                        "description": "If set, puts a use-count\nlimitation on the issued token.\n",
                        "deprecationMessage": "use `token_num_uses` instead if you are running Vault \u003e= 1.2"
                    },
                    "oidcScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, a list of OIDC scopes to be used with an OIDC role.\nThe standard scope \"openid\" is automatically included and need not be specified.\n"
                    },
                    "period": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n",
                        "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of strings\nspecifying the policies to be set on tokens issued using this role.\n",
                        "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "roleType": {
                        "type": "string",
                        "description": "Type of role, either \"oidc\" (default) or \"jwt\".\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "The TTL period of tokens issued\nusing this role, provided as a number of seconds.\n",
                        "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                    },
                    "userClaim": {
                        "type": "string",
                        "description": "The claim to use to uniquely identify\nthe user; this will be used as the name for the Identity entity alias created\ndue to a successful login.\n"
                    },
                    "verboseOidcLogging": {
                        "type": "boolean",
                        "description": "Log received OIDC tokens and claims when debug-level\nlogging is active. Not recommended in production since sensitive information may be present\nin OIDC responses.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:kubernetes/authBackendConfig:AuthBackendConfig": {
            "description": "Manages an Kubernetes auth backend config in a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/kubernetes.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst kubernetes = new vault.AuthBackend(\"kubernetes\", {\n    type: \"kubernetes\",\n});\nconst example = new vault.kubernetes.AuthBackendConfig(\"example\", {\n    backend: kubernetes.path,\n    issuer: \"api\",\n    kubernetesCaCert: `-----BEGIN CERTIFICATE-----\nexample\n-----END CERTIFICATE-----`,\n    kubernetesHost: \"http://example.com:443\",\n    tokenReviewerJwt: \"ZXhhbXBsZQo=\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nkubernetes = vault.AuthBackend(\"kubernetes\", type=\"kubernetes\")\nexample = vault.kubernetes.AuthBackendConfig(\"example\",\n    backend=kubernetes.path,\n    issuer=\"api\",\n    kubernetes_ca_cert=\"\"\"-----BEGIN CERTIFICATE-----\nexample\n-----END CERTIFICATE-----\n\"\"\",\n    kubernetes_host=\"http://example.com:443\",\n    token_reviewer_jwt=\"ZXhhbXBsZQo=\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var kubernetes = new Vault.AuthBackend(\"kubernetes\", new Vault.AuthBackendArgs\n        {\n            Type = \"kubernetes\",\n        });\n        var example = new Vault.Kubernetes.AuthBackendConfig(\"example\", new Vault.Kubernetes.AuthBackendConfigArgs\n        {\n            Backend = kubernetes.Path,\n            Issuer = \"api\",\n            KubernetesCaCert = @\"-----BEGIN CERTIFICATE-----\nexample\n-----END CERTIFICATE-----\n\",\n            KubernetesHost = \"http://example.com:443\",\n            TokenReviewerJwt = \"ZXhhbXBsZQo=\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/kubernetes\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tkubernetes, err := vault.NewAuthBackend(ctx, \"kubernetes\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"kubernetes\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = kubernetes.NewAuthBackendConfig(ctx, \"example\", \u0026kubernetes.AuthBackendConfigArgs{\n\t\t\tBackend:          kubernetes.Path,\n\t\t\tIssuer:           pulumi.String(\"api\"),\n\t\t\tKubernetesCaCert: pulumi.String(fmt.Sprintf(\"%v%v%v\", \"-----BEGIN CERTIFICATE-----\\n\", \"example\\n\", \"-----END CERTIFICATE-----\\n\")),\n\t\t\tKubernetesHost:   pulumi.String(\"http://example.com:443\"),\n\t\t\tTokenReviewerJwt: pulumi.String(\"ZXhhbXBsZQo=\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Unique name of the kubernetes backend to configure.\n"
                },
                "issuer": {
                    "type": "string",
                    "description": "Optional JWT issuer. If no issuer is specified, `kubernetes.io/serviceaccount` will be used as the default issuer.\n"
                },
                "kubernetesCaCert": {
                    "type": "string",
                    "description": "PEM encoded CA cert for use by the TLS client used to talk with the Kubernetes API.\n"
                },
                "kubernetesHost": {
                    "type": "string",
                    "description": "Host must be a host string, a host:port pair, or a URL to the base of the Kubernetes API server.\n"
                },
                "pemKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of PEM-formatted public keys or certificates used to verify the signatures of Kubernetes service account JWTs. If a certificate is given, its public key will be extracted. Not every installation of Kubernetes exposes these keys.\n"
                },
                "tokenReviewerJwt": {
                    "type": "string",
                    "description": "A service account JWT used to access the TokenReview API to validate other JWTs during login. If not set the JWT used for login will be used to access the API.\n"
                }
            },
            "required": [
                "kubernetesHost"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Unique name of the kubernetes backend to configure.\n"
                },
                "issuer": {
                    "type": "string",
                    "description": "Optional JWT issuer. If no issuer is specified, `kubernetes.io/serviceaccount` will be used as the default issuer.\n"
                },
                "kubernetesCaCert": {
                    "type": "string",
                    "description": "PEM encoded CA cert for use by the TLS client used to talk with the Kubernetes API.\n"
                },
                "kubernetesHost": {
                    "type": "string",
                    "description": "Host must be a host string, a host:port pair, or a URL to the base of the Kubernetes API server.\n"
                },
                "pemKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of PEM-formatted public keys or certificates used to verify the signatures of Kubernetes service account JWTs. If a certificate is given, its public key will be extracted. Not every installation of Kubernetes exposes these keys.\n"
                },
                "tokenReviewerJwt": {
                    "type": "string",
                    "description": "A service account JWT used to access the TokenReview API to validate other JWTs during login. If not set the JWT used for login will be used to access the API.\n"
                }
            },
            "requiredInputs": [
                "kubernetesHost"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendConfig resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Unique name of the kubernetes backend to configure.\n"
                    },
                    "issuer": {
                        "type": "string",
                        "description": "Optional JWT issuer. If no issuer is specified, `kubernetes.io/serviceaccount` will be used as the default issuer.\n"
                    },
                    "kubernetesCaCert": {
                        "type": "string",
                        "description": "PEM encoded CA cert for use by the TLS client used to talk with the Kubernetes API.\n"
                    },
                    "kubernetesHost": {
                        "type": "string",
                        "description": "Host must be a host string, a host:port pair, or a URL to the base of the Kubernetes API server.\n"
                    },
                    "pemKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of PEM-formatted public keys or certificates used to verify the signatures of Kubernetes service account JWTs. If a certificate is given, its public key will be extracted. Not every installation of Kubernetes exposes these keys.\n"
                    },
                    "tokenReviewerJwt": {
                        "type": "string",
                        "description": "A service account JWT used to access the TokenReview API to validate other JWTs during login. If not set the JWT used for login will be used to access the API.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:kubernetes/authBackendRole:AuthBackendRole": {
            "description": "Manages an Kubernetes auth backend role in a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/kubernetes.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst kubernetes = new vault.AuthBackend(\"kubernetes\", {type: \"kubernetes\"});\nconst example = new vault.kubernetes.AuthBackendRole(\"example\", {\n    backend: kubernetes.path,\n    roleName: \"example-role\",\n    boundServiceAccountNames: [\"example\"],\n    boundServiceAccountNamespaces: [\"example\"],\n    tokenTtl: 3600,\n    tokenPolicies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    audience: \"vault\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nkubernetes = vault.AuthBackend(\"kubernetes\", type=\"kubernetes\")\nexample = vault.kubernetes.AuthBackendRole(\"example\",\n    backend=kubernetes.path,\n    role_name=\"example-role\",\n    bound_service_account_names=[\"example\"],\n    bound_service_account_namespaces=[\"example\"],\n    token_ttl=3600,\n    token_policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    audience=\"vault\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var kubernetes = new Vault.AuthBackend(\"kubernetes\", new Vault.AuthBackendArgs\n        {\n            Type = \"kubernetes\",\n        });\n        var example = new Vault.Kubernetes.AuthBackendRole(\"example\", new Vault.Kubernetes.AuthBackendRoleArgs\n        {\n            Backend = kubernetes.Path,\n            RoleName = \"example-role\",\n            BoundServiceAccountNames = \n            {\n                \"example\",\n            },\n            BoundServiceAccountNamespaces = \n            {\n                \"example\",\n            },\n            TokenTtl = 3600,\n            TokenPolicies = \n            {\n                \"default\",\n                \"dev\",\n                \"prod\",\n            },\n            Audience = \"vault\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/kubernetes\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tkubernetes, err := vault.NewAuthBackend(ctx, \"kubernetes\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"kubernetes\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = kubernetes.NewAuthBackendRole(ctx, \"example\", \u0026kubernetes.AuthBackendRoleArgs{\n\t\t\tBackend:  kubernetes.Path,\n\t\t\tRoleName: pulumi.String(\"example-role\"),\n\t\t\tBoundServiceAccountNames: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"example\"),\n\t\t\t},\n\t\t\tBoundServiceAccountNamespaces: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"example\"),\n\t\t\t},\n\t\t\tTokenTtl: pulumi.Int(3600),\n\t\t\tTokenPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t\tAudience: pulumi.String(\"vault\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "audience": {
                    "type": "string",
                    "description": "Audience claim to verify in the JWT.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Unique name of the kubernetes backend to configure.\n"
                },
                "boundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, a list of\nCIDRs valid as the source address for login requests. This value is also encoded into any resulting token.\n",
                    "deprecationMessage": "use `token_bound_cidrs` instead if you are running Vault \u003e= 1.2"
                },
                "boundServiceAccountNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of service account names able to access this role. If set to `[\"*\"]` all names are allowed, both this and bound_service_account_namespaces can not be \"*\".\n"
                },
                "boundServiceAccountNamespaces": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of namespaces allowed to access this role. If set to `[\"*\"]` all namespaces are allowed, both this and bound_service_account_names can not be set to \"*\".\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum allowed lifetime of tokens\nissued using this role, provided as a number of seconds.\n",
                    "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "numUses": {
                    "type": "integer",
                    "description": "If set, puts a use-count\nlimitation on the issued token.\n",
                    "deprecationMessage": "use `token_num_uses` instead if you are running Vault \u003e= 1.2"
                },
                "period": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings\nspecifying the policies to be set on tokens issued using this role.\n",
                    "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                },
                "roleName": {
                    "type": "string",
                    "description": "Name of the role.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The TTL period of tokens issued\nusing this role, provided as a number of seconds.\n",
                    "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                }
            },
            "required": [
                "boundServiceAccountNames",
                "boundServiceAccountNamespaces",
                "roleName"
            ],
            "inputProperties": {
                "audience": {
                    "type": "string",
                    "description": "Audience claim to verify in the JWT.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Unique name of the kubernetes backend to configure.\n"
                },
                "boundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, a list of\nCIDRs valid as the source address for login requests. This value is also encoded into any resulting token.\n",
                    "deprecationMessage": "use `token_bound_cidrs` instead if you are running Vault \u003e= 1.2"
                },
                "boundServiceAccountNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of service account names able to access this role. If set to `[\"*\"]` all names are allowed, both this and bound_service_account_namespaces can not be \"*\".\n"
                },
                "boundServiceAccountNamespaces": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of namespaces allowed to access this role. If set to `[\"*\"]` all namespaces are allowed, both this and bound_service_account_names can not be set to \"*\".\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum allowed lifetime of tokens\nissued using this role, provided as a number of seconds.\n",
                    "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "numUses": {
                    "type": "integer",
                    "description": "If set, puts a use-count\nlimitation on the issued token.\n",
                    "deprecationMessage": "use `token_num_uses` instead if you are running Vault \u003e= 1.2"
                },
                "period": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings\nspecifying the policies to be set on tokens issued using this role.\n",
                    "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                },
                "roleName": {
                    "type": "string",
                    "description": "Name of the role.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The TTL period of tokens issued\nusing this role, provided as a number of seconds.\n",
                    "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                }
            },
            "requiredInputs": [
                "boundServiceAccountNames",
                "boundServiceAccountNamespaces",
                "roleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "audience": {
                        "type": "string",
                        "description": "Audience claim to verify in the JWT.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "Unique name of the kubernetes backend to configure.\n"
                    },
                    "boundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, a list of\nCIDRs valid as the source address for login requests. This value is also encoded into any resulting token.\n",
                        "deprecationMessage": "use `token_bound_cidrs` instead if you are running Vault \u003e= 1.2"
                    },
                    "boundServiceAccountNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of service account names able to access this role. If set to `[\"*\"]` all names are allowed, both this and bound_service_account_namespaces can not be \"*\".\n"
                    },
                    "boundServiceAccountNamespaces": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of namespaces allowed to access this role. If set to `[\"*\"]` all namespaces are allowed, both this and bound_service_account_names can not be set to \"*\".\n"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "The maximum allowed lifetime of tokens\nissued using this role, provided as a number of seconds.\n",
                        "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                    },
                    "numUses": {
                        "type": "integer",
                        "description": "If set, puts a use-count\nlimitation on the issued token.\n",
                        "deprecationMessage": "use `token_num_uses` instead if you are running Vault \u003e= 1.2"
                    },
                    "period": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n",
                        "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of strings\nspecifying the policies to be set on tokens issued using this role.\n",
                        "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "Name of the role.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "The TTL period of tokens issued\nusing this role, provided as a number of seconds.\n",
                        "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                    }
                },
                "type": "object"
            }
        },
        "vault:ldap/authBackend:AuthBackend": {
            "description": "Provides a resource for managing an [LDAP auth backend within Vault](https://www.vaultproject.io/docs/auth/ldap.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst ldap = new vault.ldap.AuthBackend(\"ldap\", {\n    discoverdn: false,\n    groupdn: \"OU=Groups,DC=example,DC=org\",\n    groupfilter: \"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n    path: \"ldap\",\n    upndomain: \"EXAMPLE.ORG\",\n    url: \"ldaps://dc-01.example.org\",\n    userattr: \"sAMAccountName\",\n    userdn: \"OU=Users,OU=Accounts,DC=example,DC=org\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nldap = vault.ldap.AuthBackend(\"ldap\",\n    discoverdn=False,\n    groupdn=\"OU=Groups,DC=example,DC=org\",\n    groupfilter=\"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n    path=\"ldap\",\n    upndomain=\"EXAMPLE.ORG\",\n    url=\"ldaps://dc-01.example.org\",\n    userattr=\"sAMAccountName\",\n    userdn=\"OU=Users,OU=Accounts,DC=example,DC=org\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var ldap = new Vault.Ldap.AuthBackend(\"ldap\", new Vault.Ldap.AuthBackendArgs\n        {\n            Discoverdn = false,\n            Groupdn = \"OU=Groups,DC=example,DC=org\",\n            Groupfilter = \"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n            Path = \"ldap\",\n            Upndomain = \"EXAMPLE.ORG\",\n            Url = \"ldaps://dc-01.example.org\",\n            Userattr = \"sAMAccountName\",\n            Userdn = \"OU=Users,OU=Accounts,DC=example,DC=org\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := ldap.NewAuthBackend(ctx, \"ldap\", \u0026ldap.AuthBackendArgs{\n\t\t\tDiscoverdn:  pulumi.Bool(false),\n\t\t\tGroupdn:     pulumi.String(\"OU=Groups,DC=example,DC=org\"),\n\t\t\tGroupfilter: pulumi.String(\"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\"),\n\t\t\tPath:        pulumi.String(\"ldap\"),\n\t\t\tUpndomain:   pulumi.String(\"EXAMPLE.ORG\"),\n\t\t\tUrl:         pulumi.String(\"ldaps://dc-01.example.org\"),\n\t\t\tUserattr:    pulumi.String(\"sAMAccountName\"),\n\t\t\tUserdn:      pulumi.String(\"OU=Users,OU=Accounts,DC=example,DC=org\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The accessor for this auth mount.\n"
                },
                "binddn": {
                    "type": "string",
                    "description": "DN of object to bind when performing user search\n"
                },
                "bindpass": {
                    "type": "string",
                    "description": "Password to use with `binddn` when performing user search\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "Trusted CA to validate TLS certificate\n"
                },
                "denyNullBind": {
                    "type": "boolean"
                },
                "description": {
                    "type": "string",
                    "description": "Description for the LDAP auth backend mount\n"
                },
                "discoverdn": {
                    "type": "boolean"
                },
                "groupattr": {
                    "type": "string",
                    "description": "LDAP attribute to follow on objects returned by groupfilter\n"
                },
                "groupdn": {
                    "type": "string",
                    "description": "Base DN under which to perform group search\n"
                },
                "groupfilter": {
                    "type": "string",
                    "description": "Go template used to construct group membership query\n"
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Control whether or TLS certificates must be validated\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to mount the LDAP auth backend under\n"
                },
                "starttls": {
                    "type": "boolean",
                    "description": "Control use of TLS when conecting to LDAP\n"
                },
                "tlsMaxVersion": {
                    "type": "string",
                    "description": "Maximum acceptable version of TLS\n"
                },
                "tlsMinVersion": {
                    "type": "string",
                    "description": "Minimum acceptable version of TLS\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                },
                "upndomain": {
                    "type": "string",
                    "description": "The userPrincipalDomain used to construct UPN string\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL of the LDAP server\n"
                },
                "useTokenGroups": {
                    "type": "boolean",
                    "description": "Use the Active Directory tokenGroups constructed attribute of the user to find the group memberships\n"
                },
                "userattr": {
                    "type": "string",
                    "description": "Attribute on user object matching username passed in\n"
                },
                "userdn": {
                    "type": "string",
                    "description": "Base DN under which to perform user search\n"
                }
            },
            "required": [
                "accessor",
                "binddn",
                "bindpass",
                "certificate",
                "denyNullBind",
                "description",
                "discoverdn",
                "groupattr",
                "groupdn",
                "groupfilter",
                "insecureTls",
                "starttls",
                "tlsMaxVersion",
                "tlsMinVersion",
                "upndomain",
                "url",
                "useTokenGroups",
                "userattr",
                "userdn"
            ],
            "inputProperties": {
                "binddn": {
                    "type": "string",
                    "description": "DN of object to bind when performing user search\n"
                },
                "bindpass": {
                    "type": "string",
                    "description": "Password to use with `binddn` when performing user search\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "Trusted CA to validate TLS certificate\n"
                },
                "denyNullBind": {
                    "type": "boolean"
                },
                "description": {
                    "type": "string",
                    "description": "Description for the LDAP auth backend mount\n"
                },
                "discoverdn": {
                    "type": "boolean"
                },
                "groupattr": {
                    "type": "string",
                    "description": "LDAP attribute to follow on objects returned by groupfilter\n"
                },
                "groupdn": {
                    "type": "string",
                    "description": "Base DN under which to perform group search\n"
                },
                "groupfilter": {
                    "type": "string",
                    "description": "Go template used to construct group membership query\n"
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Control whether or TLS certificates must be validated\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to mount the LDAP auth backend under\n"
                },
                "starttls": {
                    "type": "boolean",
                    "description": "Control use of TLS when conecting to LDAP\n"
                },
                "tlsMaxVersion": {
                    "type": "string",
                    "description": "Maximum acceptable version of TLS\n"
                },
                "tlsMinVersion": {
                    "type": "string",
                    "description": "Minimum acceptable version of TLS\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                },
                "upndomain": {
                    "type": "string",
                    "description": "The userPrincipalDomain used to construct UPN string\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL of the LDAP server\n"
                },
                "useTokenGroups": {
                    "type": "boolean",
                    "description": "Use the Active Directory tokenGroups constructed attribute of the user to find the group memberships\n"
                },
                "userattr": {
                    "type": "string",
                    "description": "Attribute on user object matching username passed in\n"
                },
                "userdn": {
                    "type": "string",
                    "description": "Base DN under which to perform user search\n"
                }
            },
            "requiredInputs": [
                "url"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackend resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The accessor for this auth mount.\n"
                    },
                    "binddn": {
                        "type": "string",
                        "description": "DN of object to bind when performing user search\n"
                    },
                    "bindpass": {
                        "type": "string",
                        "description": "Password to use with `binddn` when performing user search\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "Trusted CA to validate TLS certificate\n"
                    },
                    "denyNullBind": {
                        "type": "boolean"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description for the LDAP auth backend mount\n"
                    },
                    "discoverdn": {
                        "type": "boolean"
                    },
                    "groupattr": {
                        "type": "string",
                        "description": "LDAP attribute to follow on objects returned by groupfilter\n"
                    },
                    "groupdn": {
                        "type": "string",
                        "description": "Base DN under which to perform group search\n"
                    },
                    "groupfilter": {
                        "type": "string",
                        "description": "Go template used to construct group membership query\n"
                    },
                    "insecureTls": {
                        "type": "boolean",
                        "description": "Control whether or TLS certificates must be validated\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Path to mount the LDAP auth backend under\n"
                    },
                    "starttls": {
                        "type": "boolean",
                        "description": "Control use of TLS when conecting to LDAP\n"
                    },
                    "tlsMaxVersion": {
                        "type": "string",
                        "description": "Maximum acceptable version of TLS\n"
                    },
                    "tlsMinVersion": {
                        "type": "string",
                        "description": "Minimum acceptable version of TLS\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    },
                    "upndomain": {
                        "type": "string",
                        "description": "The userPrincipalDomain used to construct UPN string\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "The URL of the LDAP server\n"
                    },
                    "useTokenGroups": {
                        "type": "boolean",
                        "description": "Use the Active Directory tokenGroups constructed attribute of the user to find the group memberships\n"
                    },
                    "userattr": {
                        "type": "string",
                        "description": "Attribute on user object matching username passed in\n"
                    },
                    "userdn": {
                        "type": "string",
                        "description": "Base DN under which to perform user search\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:ldap/authBackendGroup:AuthBackendGroup": {
            "description": "Provides a resource to create a group in an [LDAP auth backend within Vault](https://www.vaultproject.io/docs/auth/ldap.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst ldap = new vault.ldap.AuthBackend(\"ldap\", {\n    discoverdn: false,\n    groupdn: \"OU=Groups,DC=example,DC=org\",\n    groupfilter: \"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n    path: \"ldap\",\n    upndomain: \"EXAMPLE.ORG\",\n    url: \"ldaps://dc-01.example.org\",\n    userattr: \"sAMAccountName\",\n    userdn: \"OU=Users,OU=Accounts,DC=example,DC=org\",\n});\nconst group = new vault.ldap.AuthBackendGroup(\"group\", {\n    backend: ldap.path,\n    groupname: \"dba\",\n    policies: [\"dba\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nldap = vault.ldap.AuthBackend(\"ldap\",\n    discoverdn=False,\n    groupdn=\"OU=Groups,DC=example,DC=org\",\n    groupfilter=\"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n    path=\"ldap\",\n    upndomain=\"EXAMPLE.ORG\",\n    url=\"ldaps://dc-01.example.org\",\n    userattr=\"sAMAccountName\",\n    userdn=\"OU=Users,OU=Accounts,DC=example,DC=org\")\ngroup = vault.ldap.AuthBackendGroup(\"group\",\n    backend=ldap.path,\n    groupname=\"dba\",\n    policies=[\"dba\"])\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var ldap = new Vault.Ldap.AuthBackend(\"ldap\", new Vault.Ldap.AuthBackendArgs\n        {\n            Discoverdn = false,\n            Groupdn = \"OU=Groups,DC=example,DC=org\",\n            Groupfilter = \"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n            Path = \"ldap\",\n            Upndomain = \"EXAMPLE.ORG\",\n            Url = \"ldaps://dc-01.example.org\",\n            Userattr = \"sAMAccountName\",\n            Userdn = \"OU=Users,OU=Accounts,DC=example,DC=org\",\n        });\n        var @group = new Vault.Ldap.AuthBackendGroup(\"group\", new Vault.Ldap.AuthBackendGroupArgs\n        {\n            Backend = ldap.Path,\n            Groupname = \"dba\",\n            Policies = \n            {\n                \"dba\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tldap, err := ldap.NewAuthBackend(ctx, \"ldap\", \u0026ldap.AuthBackendArgs{\n\t\t\tDiscoverdn:  pulumi.Bool(false),\n\t\t\tGroupdn:     pulumi.String(\"OU=Groups,DC=example,DC=org\"),\n\t\t\tGroupfilter: pulumi.String(\"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\"),\n\t\t\tPath:        pulumi.String(\"ldap\"),\n\t\t\tUpndomain:   pulumi.String(\"EXAMPLE.ORG\"),\n\t\t\tUrl:         pulumi.String(\"ldaps://dc-01.example.org\"),\n\t\t\tUserattr:    pulumi.String(\"sAMAccountName\"),\n\t\t\tUserdn:      pulumi.String(\"OU=Users,OU=Accounts,DC=example,DC=org\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewAuthBackendGroup(ctx, \"group\", \u0026ldap.AuthBackendGroupArgs{\n\t\t\tBackend:   ldap.Path,\n\t\t\tGroupname: pulumi.String(\"dba\"),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dba\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Path to the authentication backend\n"
                },
                "groupname": {
                    "type": "string",
                    "description": "The LDAP groupname\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Policies which should be granted to members of the group\n"
                }
            },
            "required": [
                "groupname",
                "policies"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Path to the authentication backend\n"
                },
                "groupname": {
                    "type": "string",
                    "description": "The LDAP groupname\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Policies which should be granted to members of the group\n"
                }
            },
            "requiredInputs": [
                "groupname"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendGroup resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Path to the authentication backend\n"
                    },
                    "groupname": {
                        "type": "string",
                        "description": "The LDAP groupname\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Policies which should be granted to members of the group\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:ldap/authBackendUser:AuthBackendUser": {
            "description": "Provides a resource to create a user in an [LDAP auth backend within Vault](https://www.vaultproject.io/docs/auth/ldap.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst ldap = new vault.ldap.AuthBackend(\"ldap\", {\n    discoverdn: false,\n    groupdn: \"OU=Groups,DC=example,DC=org\",\n    groupfilter: \"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n    path: \"ldap\",\n    upndomain: \"EXAMPLE.ORG\",\n    url: \"ldaps://dc-01.example.org\",\n    userattr: \"sAMAccountName\",\n    userdn: \"OU=Users,OU=Accounts,DC=example,DC=org\",\n});\nconst user = new vault.ldap.AuthBackendUser(\"user\", {\n    backend: ldap.path,\n    policies: [\n        \"dba\",\n        \"sysops\",\n    ],\n    username: \"test-user\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nldap = vault.ldap.AuthBackend(\"ldap\",\n    discoverdn=False,\n    groupdn=\"OU=Groups,DC=example,DC=org\",\n    groupfilter=\"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n    path=\"ldap\",\n    upndomain=\"EXAMPLE.ORG\",\n    url=\"ldaps://dc-01.example.org\",\n    userattr=\"sAMAccountName\",\n    userdn=\"OU=Users,OU=Accounts,DC=example,DC=org\")\nuser = vault.ldap.AuthBackendUser(\"user\",\n    backend=ldap.path,\n    policies=[\n        \"dba\",\n        \"sysops\",\n    ],\n    username=\"test-user\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var ldap = new Vault.Ldap.AuthBackend(\"ldap\", new Vault.Ldap.AuthBackendArgs\n        {\n            Discoverdn = false,\n            Groupdn = \"OU=Groups,DC=example,DC=org\",\n            Groupfilter = \"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n            Path = \"ldap\",\n            Upndomain = \"EXAMPLE.ORG\",\n            Url = \"ldaps://dc-01.example.org\",\n            Userattr = \"sAMAccountName\",\n            Userdn = \"OU=Users,OU=Accounts,DC=example,DC=org\",\n        });\n        var user = new Vault.Ldap.AuthBackendUser(\"user\", new Vault.Ldap.AuthBackendUserArgs\n        {\n            Backend = ldap.Path,\n            Policies = \n            {\n                \"dba\",\n                \"sysops\",\n            },\n            Username = \"test-user\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tldap, err := ldap.NewAuthBackend(ctx, \"ldap\", \u0026ldap.AuthBackendArgs{\n\t\t\tDiscoverdn:  pulumi.Bool(false),\n\t\t\tGroupdn:     pulumi.String(\"OU=Groups,DC=example,DC=org\"),\n\t\t\tGroupfilter: pulumi.String(\"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\"),\n\t\t\tPath:        pulumi.String(\"ldap\"),\n\t\t\tUpndomain:   pulumi.String(\"EXAMPLE.ORG\"),\n\t\t\tUrl:         pulumi.String(\"ldaps://dc-01.example.org\"),\n\t\t\tUserattr:    pulumi.String(\"sAMAccountName\"),\n\t\t\tUserdn:      pulumi.String(\"OU=Users,OU=Accounts,DC=example,DC=org\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewAuthBackendUser(ctx, \"user\", \u0026ldap.AuthBackendUserArgs{\n\t\t\tBackend: ldap.Path,\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dba\"),\n\t\t\t\tpulumi.String(\"sysops\"),\n\t\t\t},\n\t\t\tUsername: pulumi.String(\"test-user\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Path to the authentication backend\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Override LDAP groups which should be granted to user\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Policies which should be granted to user\n"
                },
                "username": {
                    "type": "string",
                    "description": "The LDAP username\n"
                }
            },
            "required": [
                "groups",
                "policies",
                "username"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Path to the authentication backend\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Override LDAP groups which should be granted to user\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Policies which should be granted to user\n"
                },
                "username": {
                    "type": "string",
                    "description": "The LDAP username\n"
                }
            },
            "requiredInputs": [
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendUser resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Path to the authentication backend\n"
                    },
                    "groups": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Override LDAP groups which should be granted to user\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Policies which should be granted to user\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "The LDAP username\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:okta/authBackend:AuthBackend": {
            "description": "Provides a resource for managing an\n[Okta auth backend within Vault](https://www.vaultproject.io/docs/auth/okta.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.okta.AuthBackend(\"example\", {\n    description: \"Demonstration of the Terraform Okta auth backend\",\n    groups: [{\n        groupName: \"foo\",\n        policies: [\n            \"one\",\n            \"two\",\n        ],\n    }],\n    organization: \"example\",\n    token: \"something that should be kept secret\",\n    users: [{\n        groups: [\"foo\"],\n        username: \"bar\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.okta.AuthBackend(\"example\",\n    description=\"Demonstration of the Terraform Okta auth backend\",\n    groups=[{\n        \"group_name\": \"foo\",\n        \"policies\": [\n            \"one\",\n            \"two\",\n        ],\n    }],\n    organization=\"example\",\n    token=\"something that should be kept secret\",\n    users=[{\n        \"groups\": [\"foo\"],\n        \"username\": \"bar\",\n    }])\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.Okta.AuthBackend(\"example\", new Vault.Okta.AuthBackendArgs\n        {\n            Description = \"Demonstration of the Terraform Okta auth backend\",\n            Groups = \n            {\n                new Vault.Okta.Inputs.AuthBackendGroupArgs\n                {\n                    GroupName = \"foo\",\n                    Policies = \n                    {\n                        \"one\",\n                        \"two\",\n                    },\n                },\n            },\n            Organization = \"example\",\n            Token = \"something that should be kept secret\",\n            Users = \n            {\n                new Vault.Okta.Inputs.AuthBackendUserArgs\n                {\n                    Groups = \n                    {\n                        \"foo\",\n                    },\n                    Username = \"bar\",\n                },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/okta\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := okta.NewAuthBackend(ctx, \"example\", \u0026okta.AuthBackendArgs{\n\t\t\tDescription: pulumi.String(\"Demonstration of the Terraform Okta auth backend\"),\n\t\t\tGroups: okta.AuthBackendGroupArray{\n\t\t\t\t\u0026okta.AuthBackendGroupArgs{\n\t\t\t\t\tGroupName: pulumi.String(\"foo\"),\n\t\t\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"one\"),\n\t\t\t\t\t\tpulumi.String(\"two\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tOrganization: pulumi.String(\"example\"),\n\t\t\tToken:        pulumi.String(\"something that should be kept secret\"),\n\t\t\tUsers: okta.AuthBackendUserArray{\n\t\t\t\t\u0026okta.AuthBackendUserArgs{\n\t\t\t\t\tGroups: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"foo\"),\n\t\t\t\t\t},\n\t\t\t\t\tUsername: pulumi.String(\"bar\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The mount accessor related to the auth mount. It is useful for integration with [Identity Secrets Engine](https://www.vaultproject.io/docs/secrets/identity/index.html).\n"
                },
                "baseUrl": {
                    "type": "string",
                    "description": "The Okta url. Examples: oktapreview.com, okta.com\n"
                },
                "bypassOktaMfa": {
                    "type": "boolean",
                    "description": "When true, requests by Okta for a MFA check will be bypassed. This also disallows certain status checks on the account, such as whether the password is expired.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the auth backend\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:okta/AuthBackendGroup:AuthBackendGroup"
                    },
                    "description": "Associate Okta groups with policies within Vault.\nSee below for more details.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Maximum duration after which authentication will be expired\n[See the documentation for info on valid duration formats](https://golang.org/pkg/time/#ParseDuration).\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The Okta organization. This will be the first part of the url `https://XXX.okta.com`\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to mount the Okta auth backend\n"
                },
                "token": {
                    "type": "string",
                    "description": "The Okta API token. This is required to query Okta for user group membership.\nIf this is not supplied only locally configured groups will be enabled.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Duration after which authentication will be expired.\n[See the documentation for info on valid duration formats](https://golang.org/pkg/time/#ParseDuration).\n"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:okta/AuthBackendUser:AuthBackendUser"
                    },
                    "description": "Associate Okta users with groups or policies within Vault.\nSee below for more details.\n"
                }
            },
            "required": [
                "accessor",
                "groups",
                "organization",
                "users"
            ],
            "inputProperties": {
                "baseUrl": {
                    "type": "string",
                    "description": "The Okta url. Examples: oktapreview.com, okta.com\n"
                },
                "bypassOktaMfa": {
                    "type": "boolean",
                    "description": "When true, requests by Okta for a MFA check will be bypassed. This also disallows certain status checks on the account, such as whether the password is expired.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the auth backend\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:okta/AuthBackendGroup:AuthBackendGroup"
                    },
                    "description": "Associate Okta groups with policies within Vault.\nSee below for more details.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Maximum duration after which authentication will be expired\n[See the documentation for info on valid duration formats](https://golang.org/pkg/time/#ParseDuration).\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The Okta organization. This will be the first part of the url `https://XXX.okta.com`\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to mount the Okta auth backend\n"
                },
                "token": {
                    "type": "string",
                    "description": "The Okta API token. This is required to query Okta for user group membership.\nIf this is not supplied only locally configured groups will be enabled.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Duration after which authentication will be expired.\n[See the documentation for info on valid duration formats](https://golang.org/pkg/time/#ParseDuration).\n"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:okta/AuthBackendUser:AuthBackendUser"
                    },
                    "description": "Associate Okta users with groups or policies within Vault.\nSee below for more details.\n"
                }
            },
            "requiredInputs": [
                "organization"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackend resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The mount accessor related to the auth mount. It is useful for integration with [Identity Secrets Engine](https://www.vaultproject.io/docs/secrets/identity/index.html).\n"
                    },
                    "baseUrl": {
                        "type": "string",
                        "description": "The Okta url. Examples: oktapreview.com, okta.com\n"
                    },
                    "bypassOktaMfa": {
                        "type": "boolean",
                        "description": "When true, requests by Okta for a MFA check will be bypassed. This also disallows certain status checks on the account, such as whether the password is expired.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the auth backend\n"
                    },
                    "groups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:okta/AuthBackendGroup:AuthBackendGroup"
                        },
                        "description": "Associate Okta groups with policies within Vault.\nSee below for more details.\n"
                    },
                    "maxTtl": {
                        "type": "string",
                        "description": "Maximum duration after which authentication will be expired\n[See the documentation for info on valid duration formats](https://golang.org/pkg/time/#ParseDuration).\n"
                    },
                    "organization": {
                        "type": "string",
                        "description": "The Okta organization. This will be the first part of the url `https://XXX.okta.com`\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Path to mount the Okta auth backend\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "The Okta API token. This is required to query Okta for user group membership.\nIf this is not supplied only locally configured groups will be enabled.\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Duration after which authentication will be expired.\n[See the documentation for info on valid duration formats](https://golang.org/pkg/time/#ParseDuration).\n"
                    },
                    "users": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:okta/AuthBackendUser:AuthBackendUser"
                        },
                        "description": "Associate Okta users with groups or policies within Vault.\nSee below for more details.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:okta/authBackendGroup:AuthBackendGroup": {
            "description": "Provides a resource to create a group in an\n[Okta auth backend within Vault](https://www.vaultproject.io/docs/auth/okta.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.okta.AuthBackend(\"example\", {\n    organization: \"dummy\",\n    path: \"group_okta\",\n});\nconst foo = new vault.okta.AuthBackendGroup(\"foo\", {\n    groupName: \"foo\",\n    path: example.path,\n    policies: [\n        \"one\",\n        \"two\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.okta.AuthBackend(\"example\",\n    organization=\"dummy\",\n    path=\"group_okta\")\nfoo = vault.okta.AuthBackendGroup(\"foo\",\n    group_name=\"foo\",\n    path=example.path,\n    policies=[\n        \"one\",\n        \"two\",\n    ])\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.Okta.AuthBackend(\"example\", new Vault.Okta.AuthBackendArgs\n        {\n            Organization = \"dummy\",\n            Path = \"group_okta\",\n        });\n        var foo = new Vault.Okta.AuthBackendGroup(\"foo\", new Vault.Okta.AuthBackendGroupArgs\n        {\n            GroupName = \"foo\",\n            Path = example.Path,\n            Policies = \n            {\n                \"one\",\n                \"two\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/okta\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := okta.NewAuthBackend(ctx, \"example\", \u0026okta.AuthBackendArgs{\n\t\t\tOrganization: pulumi.String(\"dummy\"),\n\t\t\tPath:         pulumi.String(\"group_okta\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = okta.NewAuthBackendGroup(ctx, \"foo\", \u0026okta.AuthBackendGroupArgs{\n\t\t\tGroupName: pulumi.String(\"foo\"),\n\t\t\tPath:      example.Path,\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"one\"),\n\t\t\t\tpulumi.String(\"two\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "groupName": {
                    "type": "string",
                    "description": "Name of the group within the Okta\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path where the Okta auth backend is mounted\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Vault policies to associate with this group\n"
                }
            },
            "required": [
                "groupName",
                "path"
            ],
            "inputProperties": {
                "groupName": {
                    "type": "string",
                    "description": "Name of the group within the Okta\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path where the Okta auth backend is mounted\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Vault policies to associate with this group\n"
                }
            },
            "requiredInputs": [
                "groupName",
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendGroup resources.\n",
                "properties": {
                    "groupName": {
                        "type": "string",
                        "description": "Name of the group within the Okta\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path where the Okta auth backend is mounted\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Vault policies to associate with this group\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:okta/authBackendUser:AuthBackendUser": {
            "description": "Provides a resource to create a user in an\n[Okta auth backend within Vault](https://www.vaultproject.io/docs/auth/okta.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.okta.AuthBackend(\"example\", {\n    organization: \"dummy\",\n    path: \"user_okta\",\n});\nconst foo = new vault.okta.AuthBackendUser(\"foo\", {\n    groups: [\n        \"one\",\n        \"two\",\n    ],\n    path: example.path,\n    username: \"foo\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.okta.AuthBackend(\"example\",\n    organization=\"dummy\",\n    path=\"user_okta\")\nfoo = vault.okta.AuthBackendUser(\"foo\",\n    groups=[\n        \"one\",\n        \"two\",\n    ],\n    path=example.path,\n    username=\"foo\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.Okta.AuthBackend(\"example\", new Vault.Okta.AuthBackendArgs\n        {\n            Organization = \"dummy\",\n            Path = \"user_okta\",\n        });\n        var foo = new Vault.Okta.AuthBackendUser(\"foo\", new Vault.Okta.AuthBackendUserArgs\n        {\n            Groups = \n            {\n                \"one\",\n                \"two\",\n            },\n            Path = example.Path,\n            Username = \"foo\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/okta\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := okta.NewAuthBackend(ctx, \"example\", \u0026okta.AuthBackendArgs{\n\t\t\tOrganization: pulumi.String(\"dummy\"),\n\t\t\tPath:         pulumi.String(\"user_okta\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = okta.NewAuthBackendUser(ctx, \"foo\", \u0026okta.AuthBackendUserArgs{\n\t\t\tGroups: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"one\"),\n\t\t\t\tpulumi.String(\"two\"),\n\t\t\t},\n\t\t\tPath:     example.Path,\n\t\t\tUsername: pulumi.String(\"foo\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Okta groups to associate with this user\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path where the Okta auth backend is mounted\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Vault policies to associate with this user\n"
                },
                "username": {
                    "type": "string",
                    "description": "Name of the user within Okta\n"
                }
            },
            "required": [
                "path",
                "username"
            ],
            "inputProperties": {
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Okta groups to associate with this user\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path where the Okta auth backend is mounted\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Vault policies to associate with this user\n"
                },
                "username": {
                    "type": "string",
                    "description": "Name of the user within Okta\n"
                }
            },
            "requiredInputs": [
                "path",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendUser resources.\n",
                "properties": {
                    "groups": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Okta groups to associate with this user\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path where the Okta auth backend is mounted\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Vault policies to associate with this user\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Name of the user within Okta\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackend:SecretBackend": {
            "description": "Creates an PKI Secret Backend for Vault. PKI secret backends can then issue certificates, once a role has been added to\nthe backend.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst pki = new vault.pkiSecret.SecretBackend(\"pki\", {\n    defaultLeaseTtlSeconds: 3600,\n    maxLeaseTtlSeconds: 86400,\n    path: \"pki\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\npki = vault.pki_secret.SecretBackend(\"pki\",\n    default_lease_ttl_seconds=3600,\n    max_lease_ttl_seconds=86400,\n    path=\"pki\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var pki = new Vault.PkiSecret.SecretBackend(\"pki\", new Vault.PkiSecret.SecretBackendArgs\n        {\n            DefaultLeaseTtlSeconds = 3600,\n            MaxLeaseTtlSeconds = 86400,\n            Path = \"pki\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/pkiSecret\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := pkiSecret.NewSecretBackend(ctx, \"pki\", \u0026pkiSecret.SecretBackendArgs{\n\t\t\tDefaultLeaseTtlSeconds: pulumi.Int(3600),\n\t\t\tMaxLeaseTtlSeconds:     pulumi.Int(86400),\n\t\t\tPath:                   pulumi.String(\"pki\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials issued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested for credentials issued by this backend.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must not begin or end with a `/`.\n"
                }
            },
            "required": [
                "defaultLeaseTtlSeconds",
                "maxLeaseTtlSeconds",
                "path"
            ],
            "inputProperties": {
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials issued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested for credentials issued by this backend.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must not begin or end with a `/`.\n"
                }
            },
            "requiredInputs": [
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackend resources.\n",
                "properties": {
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The default TTL for credentials issued by this backend.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A human-friendly description for this backend.\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The maximum TTL that can be requested for credentials issued by this backend.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must not begin or end with a `/`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendCert:SecretBackendCert": {
            "properties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "autoRenew": {
                    "type": "boolean",
                    "description": "If set to `true`, certs will be renewed if the expiration is within `min_seconds_remaining`. Default `false`\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "caChain": {
                    "type": "string",
                    "description": "The CA chain\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The certificate\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of certificate to create\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "expiration": {
                    "type": "integer",
                    "description": "The expiration date of the certificate in unix epoch format\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "issuingCa": {
                    "type": "string",
                    "description": "The issuing CA\n"
                },
                "minSecondsRemaining": {
                    "type": "integer",
                    "description": "Generate a new certificate when the expiration is within this number of seconds, default is 604800 (7 days)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the role to create the certificate against\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "The private key\n"
                },
                "privateKeyFormat": {
                    "type": "string",
                    "description": "The private key format\n"
                },
                "privateKeyType": {
                    "type": "string",
                    "description": "The private key type\n"
                },
                "serialNumber": {
                    "type": "string",
                    "description": "The serial number\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                }
            },
            "required": [
                "backend",
                "caChain",
                "certificate",
                "commonName",
                "expiration",
                "issuingCa",
                "name",
                "privateKey",
                "privateKeyType",
                "serialNumber"
            ],
            "inputProperties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "autoRenew": {
                    "type": "boolean",
                    "description": "If set to `true`, certs will be renewed if the expiration is within `min_seconds_remaining`. Default `false`\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of certificate to create\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "minSecondsRemaining": {
                    "type": "integer",
                    "description": "Generate a new certificate when the expiration is within this number of seconds, default is 604800 (7 days)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the role to create the certificate against\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "privateKeyFormat": {
                    "type": "string",
                    "description": "The private key format\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                }
            },
            "requiredInputs": [
                "backend",
                "commonName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendCert resources.\n",
                "properties": {
                    "altNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative names\n"
                    },
                    "autoRenew": {
                        "type": "boolean",
                        "description": "If set to `true`, certs will be renewed if the expiration is within `min_seconds_remaining`. Default `false`\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The PKI secret backend the resource belongs to.\n"
                    },
                    "caChain": {
                        "type": "string",
                        "description": "The CA chain\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "The certificate\n"
                    },
                    "commonName": {
                        "type": "string",
                        "description": "CN of certificate to create\n"
                    },
                    "excludeCnFromSans": {
                        "type": "boolean",
                        "description": "Flag to exclude CN from SANs\n"
                    },
                    "expiration": {
                        "type": "integer",
                        "description": "The expiration date of the certificate in unix epoch format\n"
                    },
                    "format": {
                        "type": "string",
                        "description": "The format of data\n"
                    },
                    "ipSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative IPs\n"
                    },
                    "issuingCa": {
                        "type": "string",
                        "description": "The issuing CA\n"
                    },
                    "minSecondsRemaining": {
                        "type": "integer",
                        "description": "Generate a new certificate when the expiration is within this number of seconds, default is 604800 (7 days)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the role to create the certificate against\n"
                    },
                    "otherSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of other SANs\n"
                    },
                    "privateKey": {
                        "type": "string",
                        "description": "The private key\n"
                    },
                    "privateKeyFormat": {
                        "type": "string",
                        "description": "The private key format\n"
                    },
                    "privateKeyType": {
                        "type": "string",
                        "description": "The private key type\n"
                    },
                    "serialNumber": {
                        "type": "string",
                        "description": "The serial number\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Time to live\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendConfigCa:SecretBackendConfigCa": {
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "pemBundle": {
                    "type": "string",
                    "description": "The key and certificate PEM bundle\n"
                }
            },
            "required": [
                "backend",
                "pemBundle"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "pemBundle": {
                    "type": "string",
                    "description": "The key and certificate PEM bundle\n"
                }
            },
            "requiredInputs": [
                "backend",
                "pemBundle"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendConfigCa resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The PKI secret backend the resource belongs to.\n"
                    },
                    "pemBundle": {
                        "type": "string",
                        "description": "The key and certificate PEM bundle\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendConfigUrls:SecretBackendConfigUrls": {
            "description": "Allows setting the issuing certificate endpoints, CRL distribution points, and OCSP server endpoints that will be encoded into issued certificates.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst pki = new vault.pkiSecret.SecretBackend(\"pki\", {\n    defaultLeaseTtlSeconds: 3600,\n    maxLeaseTtlSeconds: 86400,\n    path: \"%s\",\n});\nconst configUrls = new vault.pkiSecret.SecretBackendConfigUrls(\"config_urls\", {\n    backend: pki.path,\n    issuingCertificates: [\"http://127.0.0.1:8200/v1/pki/ca\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\npki = vault.pki_secret.SecretBackend(\"pki\",\n    default_lease_ttl_seconds=3600,\n    max_lease_ttl_seconds=86400,\n    path=\"%s\")\nconfig_urls = vault.pki_secret.SecretBackendConfigUrls(\"configUrls\",\n    backend=pki.path,\n    issuing_certificates=[\"http://127.0.0.1:8200/v1/pki/ca\"])\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var pki = new Vault.PkiSecret.SecretBackend(\"pki\", new Vault.PkiSecret.SecretBackendArgs\n        {\n            DefaultLeaseTtlSeconds = 3600,\n            MaxLeaseTtlSeconds = 86400,\n            Path = \"%s\",\n        });\n        var configUrls = new Vault.PkiSecret.SecretBackendConfigUrls(\"configUrls\", new Vault.PkiSecret.SecretBackendConfigUrlsArgs\n        {\n            Backend = pki.Path,\n            IssuingCertificates = \n            {\n                \"http://127.0.0.1:8200/v1/pki/ca\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/pkiSecret\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tpki, err := pkiSecret.NewSecretBackend(ctx, \"pki\", \u0026pkiSecret.SecretBackendArgs{\n\t\t\tDefaultLeaseTtlSeconds: pulumi.Int(3600),\n\t\t\tMaxLeaseTtlSeconds:     pulumi.Int(86400),\n\t\t\tPath:                   pulumi.String(fmt.Sprintf(\"%v%v\", \"%\", \"s\")),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = pkiSecret.NewSecretBackendConfigUrls(ctx, \"configUrls\", \u0026pkiSecret.SecretBackendConfigUrlsArgs{\n\t\t\tBackend: pki.Path,\n\t\t\tIssuingCertificates: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://127.0.0.1:8200/v1/pki/ca\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "crlDistributionPoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the URL values for the CRL Distribution Points field.\n"
                },
                "issuingCertificates": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the URL values for the Issuing Certificate field.\n"
                },
                "ocspServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the URL values for the OCSP Servers field.\n"
                }
            },
            "required": [
                "backend"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "crlDistributionPoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the URL values for the CRL Distribution Points field.\n"
                },
                "issuingCertificates": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the URL values for the Issuing Certificate field.\n"
                },
                "ocspServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the URL values for the OCSP Servers field.\n"
                }
            },
            "requiredInputs": [
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendConfigUrls resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                    },
                    "crlDistributionPoints": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the URL values for the CRL Distribution Points field.\n"
                    },
                    "issuingCertificates": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the URL values for the Issuing Certificate field.\n"
                    },
                    "ocspServers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the URL values for the OCSP Servers field.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendCrlConfig:SecretBackendCrlConfig": {
            "description": "Allows setting the duration for which the generated CRL should be marked valid. If the CRL is disabled, it will return a signed but zero-length CRL for any request. If enabled, it will re-build the CRL.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst pki = new vault.Mount(\"pki\", {\n    defaultLeaseTtlSeconds: 3600,\n    maxLeaseTtlSeconds: 86400,\n    path: \"%s\",\n    type: \"pki\",\n});\nconst crlConfig = new vault.pkiSecret.SecretBackendCrlConfig(\"crl_config\", {\n    backend: pki.path,\n    disable: false,\n    expiry: \"72h\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\npki = vault.Mount(\"pki\",\n    default_lease_ttl_seconds=3600,\n    max_lease_ttl_seconds=86400,\n    path=\"%s\",\n    type=\"pki\")\ncrl_config = vault.pki_secret.SecretBackendCrlConfig(\"crlConfig\",\n    backend=pki.path,\n    disable=False,\n    expiry=\"72h\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var pki = new Vault.Mount(\"pki\", new Vault.MountArgs\n        {\n            DefaultLeaseTtlSeconds = 3600,\n            MaxLeaseTtlSeconds = 86400,\n            Path = \"%s\",\n            Type = \"pki\",\n        });\n        var crlConfig = new Vault.PkiSecret.SecretBackendCrlConfig(\"crlConfig\", new Vault.PkiSecret.SecretBackendCrlConfigArgs\n        {\n            Backend = pki.Path,\n            Disable = false,\n            Expiry = \"72h\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/pkiSecret\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tpki, err := vault.NewMount(ctx, \"pki\", \u0026vault.MountArgs{\n\t\t\tDefaultLeaseTtlSeconds: pulumi.Int(3600),\n\t\t\tMaxLeaseTtlSeconds:     pulumi.Int(86400),\n\t\t\tPath:                   pulumi.String(fmt.Sprintf(\"%v%v\", \"%\", \"s\")),\n\t\t\tType:                   pulumi.String(\"pki\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = pkiSecret.NewSecretBackendCrlConfig(ctx, \"crlConfig\", \u0026pkiSecret.SecretBackendCrlConfigArgs{\n\t\t\tBackend: pki.Path,\n\t\t\tDisable: pulumi.Bool(false),\n\t\t\tExpiry:  pulumi.String(\"72h\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "disable": {
                    "type": "boolean",
                    "description": "Disables or enables CRL building.\n"
                },
                "expiry": {
                    "type": "string",
                    "description": "Specifies the time until expiration.\n"
                }
            },
            "required": [
                "backend"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "disable": {
                    "type": "boolean",
                    "description": "Disables or enables CRL building.\n"
                },
                "expiry": {
                    "type": "string",
                    "description": "Specifies the time until expiration.\n"
                }
            },
            "requiredInputs": [
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendCrlConfig resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                    },
                    "disable": {
                        "type": "boolean",
                        "description": "Disables or enables CRL building.\n"
                    },
                    "expiry": {
                        "type": "string",
                        "description": "Specifies the time until expiration.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendIntermediateCertRequest:SecretBackendIntermediateCertRequest": {
            "properties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of intermediate to create\n"
                },
                "country": {
                    "type": "string",
                    "description": "The country\n"
                },
                "csr": {
                    "type": "string",
                    "description": "The CSR\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "keyBits": {
                    "type": "integer",
                    "description": "The number of bits to use\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "The desired key type\n"
                },
                "locality": {
                    "type": "string",
                    "description": "The locality\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "ou": {
                    "type": "string",
                    "description": "The organization unit\n"
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "The private key\n"
                },
                "privateKeyFormat": {
                    "type": "string",
                    "description": "The private key format\n"
                },
                "privateKeyType": {
                    "type": "string",
                    "description": "The private key type\n"
                },
                "province": {
                    "type": "string",
                    "description": "The province\n"
                },
                "streetAddress": {
                    "type": "string",
                    "description": "The street address\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of intermediate to create. Must be either \\\"exported\\\" or \\\"internal\\\"\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n"
                }
            },
            "required": [
                "backend",
                "commonName",
                "csr",
                "privateKey",
                "privateKeyType",
                "type"
            ],
            "inputProperties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of intermediate to create\n"
                },
                "country": {
                    "type": "string",
                    "description": "The country\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "keyBits": {
                    "type": "integer",
                    "description": "The number of bits to use\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "The desired key type\n"
                },
                "locality": {
                    "type": "string",
                    "description": "The locality\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "ou": {
                    "type": "string",
                    "description": "The organization unit\n"
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code\n"
                },
                "privateKeyFormat": {
                    "type": "string",
                    "description": "The private key format\n"
                },
                "province": {
                    "type": "string",
                    "description": "The province\n"
                },
                "streetAddress": {
                    "type": "string",
                    "description": "The street address\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of intermediate to create. Must be either \\\"exported\\\" or \\\"internal\\\"\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n"
                }
            },
            "requiredInputs": [
                "backend",
                "commonName",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendIntermediateCertRequest resources.\n",
                "properties": {
                    "altNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative names\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The PKI secret backend the resource belongs to.\n"
                    },
                    "commonName": {
                        "type": "string",
                        "description": "CN of intermediate to create\n"
                    },
                    "country": {
                        "type": "string",
                        "description": "The country\n"
                    },
                    "csr": {
                        "type": "string",
                        "description": "The CSR\n"
                    },
                    "excludeCnFromSans": {
                        "type": "boolean",
                        "description": "Flag to exclude CN from SANs\n"
                    },
                    "format": {
                        "type": "string",
                        "description": "The format of data\n"
                    },
                    "ipSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative IPs\n"
                    },
                    "keyBits": {
                        "type": "integer",
                        "description": "The number of bits to use\n"
                    },
                    "keyType": {
                        "type": "string",
                        "description": "The desired key type\n"
                    },
                    "locality": {
                        "type": "string",
                        "description": "The locality\n"
                    },
                    "organization": {
                        "type": "string",
                        "description": "The organization\n"
                    },
                    "otherSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of other SANs\n"
                    },
                    "ou": {
                        "type": "string",
                        "description": "The organization unit\n"
                    },
                    "postalCode": {
                        "type": "string",
                        "description": "The postal code\n"
                    },
                    "privateKey": {
                        "type": "string",
                        "description": "The private key\n"
                    },
                    "privateKeyFormat": {
                        "type": "string",
                        "description": "The private key format\n"
                    },
                    "privateKeyType": {
                        "type": "string",
                        "description": "The private key type\n"
                    },
                    "province": {
                        "type": "string",
                        "description": "The province\n"
                    },
                    "streetAddress": {
                        "type": "string",
                        "description": "The street address\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of intermediate to create. Must be either \\\"exported\\\" or \\\"internal\\\"\n"
                    },
                    "uriSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative URIs\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendIntermediateSetSigned:SecretBackendIntermediateSetSigned": {
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The certificate\n"
                }
            },
            "required": [
                "backend",
                "certificate"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The certificate\n"
                }
            },
            "requiredInputs": [
                "backend",
                "certificate"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendIntermediateSetSigned resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The PKI secret backend the resource belongs to.\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "The certificate\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendRole:SecretBackendRole": {
            "description": "Creates a role on an PKI Secret Backend for Vault.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst pki = new vault.pkiSecret.SecretBackend(\"pki\", {\n    defaultLeaseTtlSeconds: 3600,\n    maxLeaseTtlSeconds: 86400,\n    path: \"%s\",\n});\nconst role = new vault.pkiSecret.SecretBackendRole(\"role\", {\n    backend: pki.path,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\npki = vault.pki_secret.SecretBackend(\"pki\",\n    default_lease_ttl_seconds=3600,\n    max_lease_ttl_seconds=86400,\n    path=\"%s\")\nrole = vault.pki_secret.SecretBackendRole(\"role\", backend=pki.path)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var pki = new Vault.PkiSecret.SecretBackend(\"pki\", new Vault.PkiSecret.SecretBackendArgs\n        {\n            DefaultLeaseTtlSeconds = 3600,\n            MaxLeaseTtlSeconds = 86400,\n            Path = \"%s\",\n        });\n        var role = new Vault.PkiSecret.SecretBackendRole(\"role\", new Vault.PkiSecret.SecretBackendRoleArgs\n        {\n            Backend = pki.Path,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/pkiSecret\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tpki, err := pkiSecret.NewSecretBackend(ctx, \"pki\", \u0026pkiSecret.SecretBackendArgs{\n\t\t\tDefaultLeaseTtlSeconds: pulumi.Int(3600),\n\t\t\tMaxLeaseTtlSeconds:     pulumi.Int(86400),\n\t\t\tPath:                   pulumi.String(fmt.Sprintf(\"%v%v\", \"%\", \"s\")),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = pkiSecret.NewSecretBackendRole(ctx, \"role\", \u0026pkiSecret.SecretBackendRoleArgs{\n\t\t\tBackend: pki.Path,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "allowAnyName": {
                    "type": "boolean",
                    "description": "Flag to allow any name\n"
                },
                "allowBareDomains": {
                    "type": "boolean",
                    "description": "Flag to allow certificates matching the actual domain\n"
                },
                "allowGlobDomains": {
                    "type": "boolean",
                    "description": "Flag to allow names containing glob patterns.\n"
                },
                "allowIpSans": {
                    "type": "boolean",
                    "description": "Flag to allow IP SANs\n"
                },
                "allowLocalhost": {
                    "type": "boolean",
                    "description": "Flag to allow certificates for localhost\n"
                },
                "allowSubdomains": {
                    "type": "boolean",
                    "description": "Flag to allow certificates matching subdomains\n"
                },
                "allowedDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of allowed domains for certificates\n"
                },
                "allowedOtherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Defines allowed custom SANs\n"
                },
                "allowedUriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Defines allowed URI SANs\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "basicConstraintsValidForNonCa": {
                    "type": "boolean",
                    "description": "Flag to mark basic constraints valid when issuing non-CA certificates\n"
                },
                "clientFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for client use\n"
                },
                "codeSigningFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for code signing use\n"
                },
                "countries": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The country of generated certificates\n"
                },
                "emailProtectionFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for email protection use\n"
                },
                "enforceHostnames": {
                    "type": "boolean",
                    "description": "Flag to allow only valid host names\n"
                },
                "extKeyUsages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify the allowed extended key usage constraint on issued certificates\n"
                },
                "generateLease": {
                    "type": "boolean",
                    "description": "Flag to generate leases with certificates\n"
                },
                "keyBits": {
                    "type": "integer",
                    "description": "The number of bits of generated keys\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "The type of generated keys\n"
                },
                "keyUsages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify the allowed key usage constraint on issued certificates\n"
                },
                "localities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The locality of generated certificates\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "The maximum TTL\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this role within the backend. Must be unique within the backend.\n"
                },
                "noStore": {
                    "type": "boolean",
                    "description": "Flag to not store certificates in the storage backend\n"
                },
                "notBeforeDuration": {
                    "type": "string",
                    "description": "Specifies the duration by which to backdate the NotBefore property.\n"
                },
                "organizationUnit": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The organization unit of generated certificates\n"
                },
                "organizations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The organization of generated certificates\n"
                },
                "policyIdentifiers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify the list of allowed policies IODs\n"
                },
                "postalCodes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The postal code of generated certificates\n"
                },
                "provinces": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The province of generated certificates\n"
                },
                "requireCn": {
                    "type": "boolean",
                    "description": "Flag to force CN usage\n"
                },
                "serverFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for server use\n"
                },
                "streetAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The street address of generated certificates\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "The TTL\n"
                },
                "useCsrCommonName": {
                    "type": "boolean",
                    "description": "Flag to use the CN in the CSR\n"
                },
                "useCsrSans": {
                    "type": "boolean",
                    "description": "Flag to use the SANs in the CSR\n"
                }
            },
            "required": [
                "backend",
                "name",
                "notBeforeDuration"
            ],
            "inputProperties": {
                "allowAnyName": {
                    "type": "boolean",
                    "description": "Flag to allow any name\n"
                },
                "allowBareDomains": {
                    "type": "boolean",
                    "description": "Flag to allow certificates matching the actual domain\n"
                },
                "allowGlobDomains": {
                    "type": "boolean",
                    "description": "Flag to allow names containing glob patterns.\n"
                },
                "allowIpSans": {
                    "type": "boolean",
                    "description": "Flag to allow IP SANs\n"
                },
                "allowLocalhost": {
                    "type": "boolean",
                    "description": "Flag to allow certificates for localhost\n"
                },
                "allowSubdomains": {
                    "type": "boolean",
                    "description": "Flag to allow certificates matching subdomains\n"
                },
                "allowedDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of allowed domains for certificates\n"
                },
                "allowedOtherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Defines allowed custom SANs\n"
                },
                "allowedUriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Defines allowed URI SANs\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "basicConstraintsValidForNonCa": {
                    "type": "boolean",
                    "description": "Flag to mark basic constraints valid when issuing non-CA certificates\n"
                },
                "clientFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for client use\n"
                },
                "codeSigningFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for code signing use\n"
                },
                "countries": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The country of generated certificates\n"
                },
                "emailProtectionFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for email protection use\n"
                },
                "enforceHostnames": {
                    "type": "boolean",
                    "description": "Flag to allow only valid host names\n"
                },
                "extKeyUsages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify the allowed extended key usage constraint on issued certificates\n"
                },
                "generateLease": {
                    "type": "boolean",
                    "description": "Flag to generate leases with certificates\n"
                },
                "keyBits": {
                    "type": "integer",
                    "description": "The number of bits of generated keys\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "The type of generated keys\n"
                },
                "keyUsages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify the allowed key usage constraint on issued certificates\n"
                },
                "localities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The locality of generated certificates\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "The maximum TTL\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this role within the backend. Must be unique within the backend.\n"
                },
                "noStore": {
                    "type": "boolean",
                    "description": "Flag to not store certificates in the storage backend\n"
                },
                "notBeforeDuration": {
                    "type": "string",
                    "description": "Specifies the duration by which to backdate the NotBefore property.\n"
                },
                "organizationUnit": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The organization unit of generated certificates\n"
                },
                "organizations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The organization of generated certificates\n"
                },
                "policyIdentifiers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify the list of allowed policies IODs\n"
                },
                "postalCodes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The postal code of generated certificates\n"
                },
                "provinces": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The province of generated certificates\n"
                },
                "requireCn": {
                    "type": "boolean",
                    "description": "Flag to force CN usage\n"
                },
                "serverFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for server use\n"
                },
                "streetAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The street address of generated certificates\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "The TTL\n"
                },
                "useCsrCommonName": {
                    "type": "boolean",
                    "description": "Flag to use the CN in the CSR\n"
                },
                "useCsrSans": {
                    "type": "boolean",
                    "description": "Flag to use the SANs in the CSR\n"
                }
            },
            "requiredInputs": [
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRole resources.\n",
                "properties": {
                    "allowAnyName": {
                        "type": "boolean",
                        "description": "Flag to allow any name\n"
                    },
                    "allowBareDomains": {
                        "type": "boolean",
                        "description": "Flag to allow certificates matching the actual domain\n"
                    },
                    "allowGlobDomains": {
                        "type": "boolean",
                        "description": "Flag to allow names containing glob patterns.\n"
                    },
                    "allowIpSans": {
                        "type": "boolean",
                        "description": "Flag to allow IP SANs\n"
                    },
                    "allowLocalhost": {
                        "type": "boolean",
                        "description": "Flag to allow certificates for localhost\n"
                    },
                    "allowSubdomains": {
                        "type": "boolean",
                        "description": "Flag to allow certificates matching subdomains\n"
                    },
                    "allowedDomains": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of allowed domains for certificates\n"
                    },
                    "allowedOtherSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Defines allowed custom SANs\n"
                    },
                    "allowedUriSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Defines allowed URI SANs\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                    },
                    "basicConstraintsValidForNonCa": {
                        "type": "boolean",
                        "description": "Flag to mark basic constraints valid when issuing non-CA certificates\n"
                    },
                    "clientFlag": {
                        "type": "boolean",
                        "description": "Flag to specify certificates for client use\n"
                    },
                    "codeSigningFlag": {
                        "type": "boolean",
                        "description": "Flag to specify certificates for code signing use\n"
                    },
                    "countries": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The country of generated certificates\n"
                    },
                    "emailProtectionFlag": {
                        "type": "boolean",
                        "description": "Flag to specify certificates for email protection use\n"
                    },
                    "enforceHostnames": {
                        "type": "boolean",
                        "description": "Flag to allow only valid host names\n"
                    },
                    "extKeyUsages": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specify the allowed extended key usage constraint on issued certificates\n"
                    },
                    "generateLease": {
                        "type": "boolean",
                        "description": "Flag to generate leases with certificates\n"
                    },
                    "keyBits": {
                        "type": "integer",
                        "description": "The number of bits of generated keys\n"
                    },
                    "keyType": {
                        "type": "string",
                        "description": "The type of generated keys\n"
                    },
                    "keyUsages": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specify the allowed key usage constraint on issued certificates\n"
                    },
                    "localities": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The locality of generated certificates\n"
                    },
                    "maxTtl": {
                        "type": "string",
                        "description": "The maximum TTL\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name to identify this role within the backend. Must be unique within the backend.\n"
                    },
                    "noStore": {
                        "type": "boolean",
                        "description": "Flag to not store certificates in the storage backend\n"
                    },
                    "notBeforeDuration": {
                        "type": "string",
                        "description": "Specifies the duration by which to backdate the NotBefore property.\n"
                    },
                    "organizationUnit": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The organization unit of generated certificates\n"
                    },
                    "organizations": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The organization of generated certificates\n"
                    },
                    "policyIdentifiers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specify the list of allowed policies IODs\n"
                    },
                    "postalCodes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The postal code of generated certificates\n"
                    },
                    "provinces": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The province of generated certificates\n"
                    },
                    "requireCn": {
                        "type": "boolean",
                        "description": "Flag to force CN usage\n"
                    },
                    "serverFlag": {
                        "type": "boolean",
                        "description": "Flag to specify certificates for server use\n"
                    },
                    "streetAddresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The street address of generated certificates\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "The TTL\n"
                    },
                    "useCsrCommonName": {
                        "type": "boolean",
                        "description": "Flag to use the CN in the CSR\n"
                    },
                    "useCsrSans": {
                        "type": "boolean",
                        "description": "Flag to use the SANs in the CSR\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendRootCert:SecretBackendRootCert": {
            "properties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The certificate\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of intermediate to create\n"
                },
                "country": {
                    "type": "string",
                    "description": "The country\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "issuingCa": {
                    "type": "string",
                    "description": "The issuing CA\n"
                },
                "keyBits": {
                    "type": "integer",
                    "description": "The number of bits to use\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "The desired key type\n"
                },
                "locality": {
                    "type": "string",
                    "description": "The locality\n"
                },
                "maxPathLength": {
                    "type": "integer",
                    "description": "The maximum path length to encode in the generated certificate\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "ou": {
                    "type": "string",
                    "description": "The organization unit\n"
                },
                "permittedDnsDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of domains for which certificates are allowed to be issued\n"
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code\n"
                },
                "privateKeyFormat": {
                    "type": "string",
                    "description": "The private key format\n"
                },
                "province": {
                    "type": "string",
                    "description": "The province\n"
                },
                "serial": {
                    "type": "string",
                    "description": "The serial\n"
                },
                "streetAddress": {
                    "type": "string",
                    "description": "The street address\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of intermediate to create. Must be either \\\"exported\\\" or \\\"internal\\\"\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n"
                }
            },
            "required": [
                "backend",
                "certificate",
                "commonName",
                "issuingCa",
                "serial",
                "type"
            ],
            "inputProperties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of intermediate to create\n"
                },
                "country": {
                    "type": "string",
                    "description": "The country\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "keyBits": {
                    "type": "integer",
                    "description": "The number of bits to use\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "The desired key type\n"
                },
                "locality": {
                    "type": "string",
                    "description": "The locality\n"
                },
                "maxPathLength": {
                    "type": "integer",
                    "description": "The maximum path length to encode in the generated certificate\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "ou": {
                    "type": "string",
                    "description": "The organization unit\n"
                },
                "permittedDnsDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of domains for which certificates are allowed to be issued\n"
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code\n"
                },
                "privateKeyFormat": {
                    "type": "string",
                    "description": "The private key format\n"
                },
                "province": {
                    "type": "string",
                    "description": "The province\n"
                },
                "streetAddress": {
                    "type": "string",
                    "description": "The street address\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of intermediate to create. Must be either \\\"exported\\\" or \\\"internal\\\"\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n"
                }
            },
            "requiredInputs": [
                "backend",
                "commonName",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRootCert resources.\n",
                "properties": {
                    "altNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative names\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The PKI secret backend the resource belongs to.\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "The certificate\n"
                    },
                    "commonName": {
                        "type": "string",
                        "description": "CN of intermediate to create\n"
                    },
                    "country": {
                        "type": "string",
                        "description": "The country\n"
                    },
                    "excludeCnFromSans": {
                        "type": "boolean",
                        "description": "Flag to exclude CN from SANs\n"
                    },
                    "format": {
                        "type": "string",
                        "description": "The format of data\n"
                    },
                    "ipSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative IPs\n"
                    },
                    "issuingCa": {
                        "type": "string",
                        "description": "The issuing CA\n"
                    },
                    "keyBits": {
                        "type": "integer",
                        "description": "The number of bits to use\n"
                    },
                    "keyType": {
                        "type": "string",
                        "description": "The desired key type\n"
                    },
                    "locality": {
                        "type": "string",
                        "description": "The locality\n"
                    },
                    "maxPathLength": {
                        "type": "integer",
                        "description": "The maximum path length to encode in the generated certificate\n"
                    },
                    "organization": {
                        "type": "string",
                        "description": "The organization\n"
                    },
                    "otherSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of other SANs\n"
                    },
                    "ou": {
                        "type": "string",
                        "description": "The organization unit\n"
                    },
                    "permittedDnsDomains": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of domains for which certificates are allowed to be issued\n"
                    },
                    "postalCode": {
                        "type": "string",
                        "description": "The postal code\n"
                    },
                    "privateKeyFormat": {
                        "type": "string",
                        "description": "The private key format\n"
                    },
                    "province": {
                        "type": "string",
                        "description": "The province\n"
                    },
                    "serial": {
                        "type": "string",
                        "description": "The serial\n"
                    },
                    "streetAddress": {
                        "type": "string",
                        "description": "The street address\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Time to live\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of intermediate to create. Must be either \\\"exported\\\" or \\\"internal\\\"\n"
                    },
                    "uriSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative URIs\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendRootSignIntermediate:SecretBackendRootSignIntermediate": {
            "description": "Creates an PKI certificate.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst root = new vault.pkiSecret.SecretBackendRootSignIntermediate(\"root\", {\n    backend: vault_pki_secret_backend.root.path,\n    csr: vault_pki_secret_backend_intermediate_cert_request.intermediate.csr,\n    commonName: \"Intermediate CA\",\n    excludeCnFromSans: true,\n    ou: \"My OU\",\n    organization: \"My organization\",\n}, {\n    dependsOn: [\"vault_pki_secret_backend_intermediate_cert_request.intermediate\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nroot = vault.pki_secret.SecretBackendRootSignIntermediate(\"root\",\n    backend=vault_pki_secret_backend[\"root\"][\"path\"],\n    csr=vault_pki_secret_backend_intermediate_cert_request[\"intermediate\"][\"csr\"],\n    common_name=\"Intermediate CA\",\n    exclude_cn_from_sans=True,\n    ou=\"My OU\",\n    organization=\"My organization\",\n    opts=ResourceOptions(depends_on=[\"vault_pki_secret_backend_intermediate_cert_request.intermediate\"]))\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var root = new Vault.PkiSecret.SecretBackendRootSignIntermediate(\"root\", new Vault.PkiSecret.SecretBackendRootSignIntermediateArgs\n        {\n            Backend = vault_pki_secret_backend.Root.Path,\n            Csr = vault_pki_secret_backend_intermediate_cert_request.Intermediate.Csr,\n            CommonName = \"Intermediate CA\",\n            ExcludeCnFromSans = true,\n            Ou = \"My OU\",\n            Organization = \"My organization\",\n        }, new CustomResourceOptions\n        {\n            DependsOn = \n            {\n                \"vault_pki_secret_backend_intermediate_cert_request.intermediate\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/pkiSecret\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := pkiSecret.NewSecretBackendRootSignIntermediate(ctx, \"root\", \u0026pkiSecret.SecretBackendRootSignIntermediateArgs{\n\t\t\tBackend:           pulumi.String(vault_pki_secret_backend.Root.Path),\n\t\t\tCsr:               pulumi.String(vault_pki_secret_backend_intermediate_cert_request.Intermediate.Csr),\n\t\t\tCommonName:        pulumi.String(\"Intermediate CA\"),\n\t\t\tExcludeCnFromSans: pulumi.Bool(true),\n\t\t\tOu:                pulumi.String(\"My OU\"),\n\t\t\tOrganization:      pulumi.String(\"My organization\"),\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\t\"vault_pki_secret_backend_intermediate_cert_request.intermediate\",\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "caChain": {
                    "type": "string",
                    "description": "The CA chain\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The certificate\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of intermediate to create\n"
                },
                "country": {
                    "type": "string",
                    "description": "The country\n"
                },
                "csr": {
                    "type": "string",
                    "description": "The CSR\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "issuingCa": {
                    "type": "string",
                    "description": "The issuing CA\n"
                },
                "locality": {
                    "type": "string",
                    "description": "The locality\n"
                },
                "maxPathLength": {
                    "type": "integer",
                    "description": "The maximum path length to encode in the generated certificate\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "ou": {
                    "type": "string",
                    "description": "The organization unit\n"
                },
                "permittedDnsDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of domains for which certificates are allowed to be issued\n"
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code\n"
                },
                "province": {
                    "type": "string",
                    "description": "The province\n"
                },
                "serial": {
                    "type": "string",
                    "description": "The serial\n"
                },
                "streetAddress": {
                    "type": "string",
                    "description": "The street address\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n"
                },
                "useCsrValues": {
                    "type": "boolean",
                    "description": "Preserve CSR values\n"
                }
            },
            "required": [
                "backend",
                "caChain",
                "certificate",
                "commonName",
                "csr",
                "issuingCa",
                "serial"
            ],
            "inputProperties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of intermediate to create\n"
                },
                "country": {
                    "type": "string",
                    "description": "The country\n"
                },
                "csr": {
                    "type": "string",
                    "description": "The CSR\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "locality": {
                    "type": "string",
                    "description": "The locality\n"
                },
                "maxPathLength": {
                    "type": "integer",
                    "description": "The maximum path length to encode in the generated certificate\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "ou": {
                    "type": "string",
                    "description": "The organization unit\n"
                },
                "permittedDnsDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of domains for which certificates are allowed to be issued\n"
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code\n"
                },
                "province": {
                    "type": "string",
                    "description": "The province\n"
                },
                "streetAddress": {
                    "type": "string",
                    "description": "The street address\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n"
                },
                "useCsrValues": {
                    "type": "boolean",
                    "description": "Preserve CSR values\n"
                }
            },
            "requiredInputs": [
                "backend",
                "commonName",
                "csr"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRootSignIntermediate resources.\n",
                "properties": {
                    "altNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative names\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The PKI secret backend the resource belongs to.\n"
                    },
                    "caChain": {
                        "type": "string",
                        "description": "The CA chain\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "The certificate\n"
                    },
                    "commonName": {
                        "type": "string",
                        "description": "CN of intermediate to create\n"
                    },
                    "country": {
                        "type": "string",
                        "description": "The country\n"
                    },
                    "csr": {
                        "type": "string",
                        "description": "The CSR\n"
                    },
                    "excludeCnFromSans": {
                        "type": "boolean",
                        "description": "Flag to exclude CN from SANs\n"
                    },
                    "format": {
                        "type": "string",
                        "description": "The format of data\n"
                    },
                    "ipSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative IPs\n"
                    },
                    "issuingCa": {
                        "type": "string",
                        "description": "The issuing CA\n"
                    },
                    "locality": {
                        "type": "string",
                        "description": "The locality\n"
                    },
                    "maxPathLength": {
                        "type": "integer",
                        "description": "The maximum path length to encode in the generated certificate\n"
                    },
                    "organization": {
                        "type": "string",
                        "description": "The organization\n"
                    },
                    "otherSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of other SANs\n"
                    },
                    "ou": {
                        "type": "string",
                        "description": "The organization unit\n"
                    },
                    "permittedDnsDomains": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of domains for which certificates are allowed to be issued\n"
                    },
                    "postalCode": {
                        "type": "string",
                        "description": "The postal code\n"
                    },
                    "province": {
                        "type": "string",
                        "description": "The province\n"
                    },
                    "serial": {
                        "type": "string",
                        "description": "The serial\n"
                    },
                    "streetAddress": {
                        "type": "string",
                        "description": "The street address\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Time to live\n"
                    },
                    "uriSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative URIs\n"
                    },
                    "useCsrValues": {
                        "type": "boolean",
                        "description": "Preserve CSR values\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendSign:SecretBackendSign": {
            "properties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "autoRenew": {
                    "type": "boolean",
                    "description": "If set to `true`, certs will be renewed if the expiration is within `min_seconds_remaining`. Default `false`\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "caChains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The CA chain\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The certificate\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of certificate to create\n"
                },
                "csr": {
                    "type": "string",
                    "description": "The CSR\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "expiration": {
                    "type": "integer",
                    "description": "The expiration date of the certificate in unix epoch format\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "issuingCa": {
                    "type": "string",
                    "description": "The issuing CA\n"
                },
                "minSecondsRemaining": {
                    "type": "integer",
                    "description": "Generate a new certificate when the expiration is within this number of seconds, default is 604800 (7 days)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the role to create the certificate against\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "serial": {
                    "type": "string",
                    "description": "The serial\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alterative URIs\n"
                }
            },
            "required": [
                "backend",
                "caChains",
                "certificate",
                "commonName",
                "csr",
                "expiration",
                "issuingCa",
                "name",
                "serial"
            ],
            "inputProperties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "autoRenew": {
                    "type": "boolean",
                    "description": "If set to `true`, certs will be renewed if the expiration is within `min_seconds_remaining`. Default `false`\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of certificate to create\n"
                },
                "csr": {
                    "type": "string",
                    "description": "The CSR\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "minSecondsRemaining": {
                    "type": "integer",
                    "description": "Generate a new certificate when the expiration is within this number of seconds, default is 604800 (7 days)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the role to create the certificate against\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alterative URIs\n"
                }
            },
            "requiredInputs": [
                "backend",
                "commonName",
                "csr"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendSign resources.\n",
                "properties": {
                    "altNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative names\n"
                    },
                    "autoRenew": {
                        "type": "boolean",
                        "description": "If set to `true`, certs will be renewed if the expiration is within `min_seconds_remaining`. Default `false`\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The PKI secret backend the resource belongs to.\n"
                    },
                    "caChains": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The CA chain\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "The certificate\n"
                    },
                    "commonName": {
                        "type": "string",
                        "description": "CN of certificate to create\n"
                    },
                    "csr": {
                        "type": "string",
                        "description": "The CSR\n"
                    },
                    "excludeCnFromSans": {
                        "type": "boolean",
                        "description": "Flag to exclude CN from SANs\n"
                    },
                    "expiration": {
                        "type": "integer",
                        "description": "The expiration date of the certificate in unix epoch format\n"
                    },
                    "format": {
                        "type": "string",
                        "description": "The format of data\n"
                    },
                    "ipSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative IPs\n"
                    },
                    "issuingCa": {
                        "type": "string",
                        "description": "The issuing CA\n"
                    },
                    "minSecondsRemaining": {
                        "type": "integer",
                        "description": "Generate a new certificate when the expiration is within this number of seconds, default is 604800 (7 days)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the role to create the certificate against\n"
                    },
                    "otherSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of other SANs\n"
                    },
                    "serial": {
                        "type": "string",
                        "description": "The serial\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Time to live\n"
                    },
                    "uriSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alterative URIs\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:rabbitMq/secretBackend:SecretBackend": {
            "properties": {
                "connectionUri": {
                    "type": "string",
                    "description": "Specifies the RabbitMQ connection URI.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials\nissued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Specifies the RabbitMQ management administrator password.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `aws`.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Specifies the RabbitMQ management administrator username.\n"
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Specifies whether to verify connection URI, username, and password.\nDefaults to `true`.\n"
                }
            },
            "required": [
                "connectionUri",
                "defaultLeaseTtlSeconds",
                "maxLeaseTtlSeconds",
                "password",
                "username"
            ],
            "inputProperties": {
                "connectionUri": {
                    "type": "string",
                    "description": "Specifies the RabbitMQ connection URI.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials\nissued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Specifies the RabbitMQ management administrator password.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `aws`.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Specifies the RabbitMQ management administrator username.\n"
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Specifies whether to verify connection URI, username, and password.\nDefaults to `true`.\n"
                }
            },
            "requiredInputs": [
                "connectionUri",
                "password",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackend resources.\n",
                "properties": {
                    "connectionUri": {
                        "type": "string",
                        "description": "Specifies the RabbitMQ connection URI.\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The default TTL for credentials\nissued by this backend.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A human-friendly description for this backend.\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "Specifies the RabbitMQ management administrator password.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `aws`.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Specifies the RabbitMQ management administrator username.\n"
                    },
                    "verifyConnection": {
                        "type": "boolean",
                        "description": "Specifies whether to verify connection URI, username, and password.\nDefaults to `true`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:rabbitMq/secretBackendRole:SecretBackendRole": {
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path the RabbitMQ secret backend is mounted at,\nwith no leading or trailing `/`s.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n"
                },
                "tags": {
                    "type": "string",
                    "description": "Specifies a comma-separated RabbitMQ management tags.\n"
                },
                "vhosts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:rabbitMq/SecretBackendRoleVhost:SecretBackendRoleVhost"
                    },
                    "description": "Specifies a map of virtual hosts to permissions.\n"
                }
            },
            "required": [
                "backend",
                "name"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path the RabbitMQ secret backend is mounted at,\nwith no leading or trailing `/`s.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n"
                },
                "tags": {
                    "type": "string",
                    "description": "Specifies a comma-separated RabbitMQ management tags.\n"
                },
                "vhosts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:rabbitMq/SecretBackendRoleVhost:SecretBackendRoleVhost"
                    },
                    "description": "Specifies a map of virtual hosts to permissions.\n"
                }
            },
            "requiredInputs": [
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the RabbitMQ secret backend is mounted at,\nwith no leading or trailing `/`s.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n"
                    },
                    "tags": {
                        "type": "string",
                        "description": "Specifies a comma-separated RabbitMQ management tags.\n"
                    },
                    "vhosts": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:rabbitMq/SecretBackendRoleVhost:SecretBackendRoleVhost"
                        },
                        "description": "Specifies a map of virtual hosts to permissions.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:ssh/secretBackendCa:SecretBackendCa": {
            "description": "Provides a resource to manage CA information in an SSH secret backend\n[SSH secret backend within Vault](https://www.vaultproject.io/docs/secrets/ssh/index.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.Mount(\"example\", {\n    type: \"ssh\",\n});\nconst foo = new vault.ssh.SecretBackendCa(\"foo\", {\n    backend: example.path,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.Mount(\"example\", type=\"ssh\")\nfoo = vault.ssh.SecretBackendCa(\"foo\", backend=example.path)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.Mount(\"example\", new Vault.MountArgs\n        {\n            Type = \"ssh\",\n        });\n        var foo = new Vault.Ssh.SecretBackendCa(\"foo\", new Vault.Ssh.SecretBackendCaArgs\n        {\n            Backend = example.Path,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/ssh\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := vault.NewMount(ctx, \"example\", \u0026vault.MountArgs{\n\t\t\tType: pulumi.String(\"ssh\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ssh.NewSecretBackendCa(ctx, \"foo\", \u0026ssh.SecretBackendCaArgs{\n\t\t\tBackend: example.Path,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path where the SSH secret backend is mounted. Defaults to 'ssh'\n"
                },
                "generateSigningKey": {
                    "type": "boolean",
                    "description": "Whether Vault should generate the signing key pair internally. Defaults to true\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "The private key part the SSH CA key pair; required if generate_signing_key is false.\n"
                },
                "publicKey": {
                    "type": "string",
                    "description": "The public key part the SSH CA key pair; required if generate_signing_key is false.\n"
                }
            },
            "required": [
                "privateKey",
                "publicKey"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path where the SSH secret backend is mounted. Defaults to 'ssh'\n"
                },
                "generateSigningKey": {
                    "type": "boolean",
                    "description": "Whether Vault should generate the signing key pair internally. Defaults to true\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "The private key part the SSH CA key pair; required if generate_signing_key is false.\n"
                },
                "publicKey": {
                    "type": "string",
                    "description": "The public key part the SSH CA key pair; required if generate_signing_key is false.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendCa resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path where the SSH secret backend is mounted. Defaults to 'ssh'\n"
                    },
                    "generateSigningKey": {
                        "type": "boolean",
                        "description": "Whether Vault should generate the signing key pair internally. Defaults to true\n"
                    },
                    "privateKey": {
                        "type": "string",
                        "description": "The private key part the SSH CA key pair; required if generate_signing_key is false.\n"
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "The public key part the SSH CA key pair; required if generate_signing_key is false.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:ssh/secretBackendRole:SecretBackendRole": {
            "description": "Provides a resource to manage roles in an SSH secret backend\n[SSH secret backend within Vault](https://www.vaultproject.io/docs/secrets/ssh/index.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.Mount(\"example\", {\n    type: \"ssh\",\n});\nconst foo = new vault.ssh.SecretBackendRole(\"foo\", {\n    allowUserCertificates: true,\n    backend: example.path,\n    keyType: \"ca\",\n});\nconst bar = new vault.ssh.SecretBackendRole(\"bar\", {\n    allowedUsers: \"default,baz\",\n    backend: example.path,\n    cidrList: \"0.0.0.0/0\",\n    defaultUser: \"default\",\n    keyType: \"otp\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.Mount(\"example\", type=\"ssh\")\nfoo = vault.ssh.SecretBackendRole(\"foo\",\n    allow_user_certificates=True,\n    backend=example.path,\n    key_type=\"ca\")\nbar = vault.ssh.SecretBackendRole(\"bar\",\n    allowed_users=\"default,baz\",\n    backend=example.path,\n    cidr_list=\"0.0.0.0/0\",\n    default_user=\"default\",\n    key_type=\"otp\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.Mount(\"example\", new Vault.MountArgs\n        {\n            Type = \"ssh\",\n        });\n        var foo = new Vault.Ssh.SecretBackendRole(\"foo\", new Vault.Ssh.SecretBackendRoleArgs\n        {\n            AllowUserCertificates = true,\n            Backend = example.Path,\n            KeyType = \"ca\",\n        });\n        var bar = new Vault.Ssh.SecretBackendRole(\"bar\", new Vault.Ssh.SecretBackendRoleArgs\n        {\n            AllowedUsers = \"default,baz\",\n            Backend = example.Path,\n            CidrList = \"0.0.0.0/0\",\n            DefaultUser = \"default\",\n            KeyType = \"otp\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/ssh\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := vault.NewMount(ctx, \"example\", \u0026vault.MountArgs{\n\t\t\tType: pulumi.String(\"ssh\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ssh.NewSecretBackendRole(ctx, \"foo\", \u0026ssh.SecretBackendRoleArgs{\n\t\t\tAllowUserCertificates: pulumi.Bool(true),\n\t\t\tBackend:               example.Path,\n\t\t\tKeyType:               pulumi.String(\"ca\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ssh.NewSecretBackendRole(ctx, \"bar\", \u0026ssh.SecretBackendRoleArgs{\n\t\t\tAllowedUsers: pulumi.String(\"default,baz\"),\n\t\t\tBackend:      example.Path,\n\t\t\tCidrList:     pulumi.String(\"0.0.0.0/0\"),\n\t\t\tDefaultUser:  pulumi.String(\"default\"),\n\t\t\tKeyType:      pulumi.String(\"otp\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "allowBareDomains": {
                    "type": "boolean",
                    "description": "Specifies if host certificates that are requested are allowed to use the base domains listed in `allowed_domains`.\n"
                },
                "allowHostCertificates": {
                    "type": "boolean",
                    "description": "Specifies if certificates are allowed to be signed for use as a 'host'.\n"
                },
                "allowSubdomains": {
                    "type": "boolean",
                    "description": "Specifies if host certificates that are requested are allowed to be subdomains of those listed in `allowed_domains`.\n"
                },
                "allowUserCertificates": {
                    "type": "boolean",
                    "description": "Specifies if certificates are allowed to be signed for use as a 'user'.\n"
                },
                "allowUserKeyIds": {
                    "type": "boolean",
                    "description": "Specifies if users can override the key ID for a signed certificate with the `key_id` field.\n"
                },
                "allowedCriticalOptions": {
                    "type": "string",
                    "description": "Specifies a comma-separated list of critical options that certificates can have when signed.\n"
                },
                "allowedDomains": {
                    "type": "string",
                    "description": "The list of domains for which a client can request a host certificate.\n"
                },
                "allowedExtensions": {
                    "type": "string",
                    "description": "Specifies a comma-separated list of extensions that certificates can have when signed.\n"
                },
                "allowedUserKeyLengths": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies a map of ssh key types and their expected sizes which are allowed to be signed by the CA type.\n"
                },
                "allowedUsers": {
                    "type": "string",
                    "description": "Specifies a comma-separated list of usernames that are to be allowed, only if certain usernames are to be allowed.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path where the SSH secret backend is mounted.\n"
                },
                "cidrList": {
                    "type": "string",
                    "description": "The comma-separated string of CIDR blocks for which this role is applicable.\n"
                },
                "defaultCriticalOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies a map of critical options that certificates have when signed.\n"
                },
                "defaultExtensions": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies a map of extensions that certificates have when signed.\n"
                },
                "defaultUser": {
                    "type": "string",
                    "description": "Specifies the default username for which a credential will be generated.\n"
                },
                "keyIdFormat": {
                    "type": "string",
                    "description": "Specifies a custom format for the key id of a signed certificate.\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "Specifies the type of credentials generated by this role. This can be either `otp`, `dynamic` or `ca`.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Specifies the maximum Time To Live value.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the role to create.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Specifies the Time To Live value.\n"
                }
            },
            "required": [
                "backend",
                "keyType",
                "maxTtl",
                "name",
                "ttl"
            ],
            "inputProperties": {
                "allowBareDomains": {
                    "type": "boolean",
                    "description": "Specifies if host certificates that are requested are allowed to use the base domains listed in `allowed_domains`.\n"
                },
                "allowHostCertificates": {
                    "type": "boolean",
                    "description": "Specifies if certificates are allowed to be signed for use as a 'host'.\n"
                },
                "allowSubdomains": {
                    "type": "boolean",
                    "description": "Specifies if host certificates that are requested are allowed to be subdomains of those listed in `allowed_domains`.\n"
                },
                "allowUserCertificates": {
                    "type": "boolean",
                    "description": "Specifies if certificates are allowed to be signed for use as a 'user'.\n"
                },
                "allowUserKeyIds": {
                    "type": "boolean",
                    "description": "Specifies if users can override the key ID for a signed certificate with the `key_id` field.\n"
                },
                "allowedCriticalOptions": {
                    "type": "string",
                    "description": "Specifies a comma-separated list of critical options that certificates can have when signed.\n"
                },
                "allowedDomains": {
                    "type": "string",
                    "description": "The list of domains for which a client can request a host certificate.\n"
                },
                "allowedExtensions": {
                    "type": "string",
                    "description": "Specifies a comma-separated list of extensions that certificates can have when signed.\n"
                },
                "allowedUserKeyLengths": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies a map of ssh key types and their expected sizes which are allowed to be signed by the CA type.\n"
                },
                "allowedUsers": {
                    "type": "string",
                    "description": "Specifies a comma-separated list of usernames that are to be allowed, only if certain usernames are to be allowed.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path where the SSH secret backend is mounted.\n"
                },
                "cidrList": {
                    "type": "string",
                    "description": "The comma-separated string of CIDR blocks for which this role is applicable.\n"
                },
                "defaultCriticalOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies a map of critical options that certificates have when signed.\n"
                },
                "defaultExtensions": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies a map of extensions that certificates have when signed.\n"
                },
                "defaultUser": {
                    "type": "string",
                    "description": "Specifies the default username for which a credential will be generated.\n"
                },
                "keyIdFormat": {
                    "type": "string",
                    "description": "Specifies a custom format for the key id of a signed certificate.\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "Specifies the type of credentials generated by this role. This can be either `otp`, `dynamic` or `ca`.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Specifies the maximum Time To Live value.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the role to create.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Specifies the Time To Live value.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "keyType"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRole resources.\n",
                "properties": {
                    "allowBareDomains": {
                        "type": "boolean",
                        "description": "Specifies if host certificates that are requested are allowed to use the base domains listed in `allowed_domains`.\n"
                    },
                    "allowHostCertificates": {
                        "type": "boolean",
                        "description": "Specifies if certificates are allowed to be signed for use as a 'host'.\n"
                    },
                    "allowSubdomains": {
                        "type": "boolean",
                        "description": "Specifies if host certificates that are requested are allowed to be subdomains of those listed in `allowed_domains`.\n"
                    },
                    "allowUserCertificates": {
                        "type": "boolean",
                        "description": "Specifies if certificates are allowed to be signed for use as a 'user'.\n"
                    },
                    "allowUserKeyIds": {
                        "type": "boolean",
                        "description": "Specifies if users can override the key ID for a signed certificate with the `key_id` field.\n"
                    },
                    "allowedCriticalOptions": {
                        "type": "string",
                        "description": "Specifies a comma-separated list of critical options that certificates can have when signed.\n"
                    },
                    "allowedDomains": {
                        "type": "string",
                        "description": "The list of domains for which a client can request a host certificate.\n"
                    },
                    "allowedExtensions": {
                        "type": "string",
                        "description": "Specifies a comma-separated list of extensions that certificates can have when signed.\n"
                    },
                    "allowedUserKeyLengths": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Specifies a map of ssh key types and their expected sizes which are allowed to be signed by the CA type.\n"
                    },
                    "allowedUsers": {
                        "type": "string",
                        "description": "Specifies a comma-separated list of usernames that are to be allowed, only if certain usernames are to be allowed.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path where the SSH secret backend is mounted.\n"
                    },
                    "cidrList": {
                        "type": "string",
                        "description": "The comma-separated string of CIDR blocks for which this role is applicable.\n"
                    },
                    "defaultCriticalOptions": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Specifies a map of critical options that certificates have when signed.\n"
                    },
                    "defaultExtensions": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Specifies a map of extensions that certificates have when signed.\n"
                    },
                    "defaultUser": {
                        "type": "string",
                        "description": "Specifies the default username for which a credential will be generated.\n"
                    },
                    "keyIdFormat": {
                        "type": "string",
                        "description": "Specifies a custom format for the key id of a signed certificate.\n"
                    },
                    "keyType": {
                        "type": "string",
                        "description": "Specifies the type of credentials generated by this role. This can be either `otp`, `dynamic` or `ca`.\n"
                    },
                    "maxTtl": {
                        "type": "string",
                        "description": "Specifies the maximum Time To Live value.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the name of the role to create.\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Specifies the Time To Live value.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:tokenauth/authBackendRole:AuthBackendRole": {
            "description": "Manages Token auth backend role in a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/token.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.tokenauth.AuthBackendRole(\"example\", {\n    allowedPolicies: [\n        \"dev\",\n        \"test\",\n    ],\n    disallowedPolicies: [\"default\"],\n    explicitMaxTtl: \"115200\",\n    orphan: true,\n    pathSuffix: \"path-suffix\",\n    period: \"86400\",\n    renewable: true,\n    roleName: \"my-role\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.tokenauth.AuthBackendRole(\"example\",\n    allowed_policies=[\n        \"dev\",\n        \"test\",\n    ],\n    disallowed_policies=[\"default\"],\n    explicit_max_ttl=\"115200\",\n    orphan=True,\n    path_suffix=\"path-suffix\",\n    period=\"86400\",\n    renewable=True,\n    role_name=\"my-role\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.TokenAuth.AuthBackendRole(\"example\", new Vault.TokenAuth.AuthBackendRoleArgs\n        {\n            AllowedPolicies = \n            {\n                \"dev\",\n                \"test\",\n            },\n            DisallowedPolicies = \n            {\n                \"default\",\n            },\n            ExplicitMaxTtl = \"115200\",\n            Orphan = true,\n            PathSuffix = \"path-suffix\",\n            Period = \"86400\",\n            Renewable = true,\n            RoleName = \"my-role\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/tokenauth\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := tokenauth.NewAuthBackendRole(ctx, \"example\", \u0026tokenauth.AuthBackendRoleArgs{\n\t\t\tAllowedPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tDisallowedPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t},\n\t\t\tExplicitMaxTtl: pulumi.String(\"115200\"),\n\t\t\tOrphan:         pulumi.Bool(true),\n\t\t\tPathSuffix:     pulumi.String(\"path-suffix\"),\n\t\t\tPeriod:         pulumi.String(\"86400\"),\n\t\t\tRenewable:      pulumi.Bool(true),\n\t\t\tRoleName:       pulumi.String(\"my-role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "allowedPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of allowed policies for given role.\n"
                },
                "boundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, a list of\nCIDRs valid as the source address for login requests. This value is also encoded into any resulting token.\n",
                    "deprecationMessage": "use `token_bound_cidrs` instead if you are running Vault \u003e= 1.2"
                },
                "disallowedPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of disallowed policies for given role.\n"
                },
                "explicitMaxTtl": {
                    "type": "string",
                    "description": "If set, the\ntoken will have an explicit max TTL set upon it.\n",
                    "deprecationMessage": "use `token_explicit_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "orphan": {
                    "type": "boolean",
                    "description": "If true, tokens created against this policy will be orphan tokens.\n"
                },
                "pathSuffix": {
                    "type": "string",
                    "description": "Tokens created against this role will have the given suffix as part of their path in addition to the role name.\n"
                },
                "period": {
                    "type": "string",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "renewable": {
                    "type": "boolean",
                    "description": "Wether to disable the ability of the token to be renewed past its initial TTL.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "required": [
                "roleName"
            ],
            "inputProperties": {
                "allowedPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of allowed policies for given role.\n"
                },
                "boundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, a list of\nCIDRs valid as the source address for login requests. This value is also encoded into any resulting token.\n",
                    "deprecationMessage": "use `token_bound_cidrs` instead if you are running Vault \u003e= 1.2"
                },
                "disallowedPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of disallowed policies for given role.\n"
                },
                "explicitMaxTtl": {
                    "type": "string",
                    "description": "If set, the\ntoken will have an explicit max TTL set upon it.\n",
                    "deprecationMessage": "use `token_explicit_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "orphan": {
                    "type": "boolean",
                    "description": "If true, tokens created against this policy will be orphan tokens.\n"
                },
                "pathSuffix": {
                    "type": "string",
                    "description": "Tokens created against this role will have the given suffix as part of their path in addition to the role name.\n"
                },
                "period": {
                    "type": "string",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "renewable": {
                    "type": "boolean",
                    "description": "Wether to disable the ability of the token to be renewed past its initial TTL.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                }
            },
            "requiredInputs": [
                "roleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "allowedPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of allowed policies for given role.\n"
                    },
                    "boundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, a list of\nCIDRs valid as the source address for login requests. This value is also encoded into any resulting token.\n",
                        "deprecationMessage": "use `token_bound_cidrs` instead if you are running Vault \u003e= 1.2"
                    },
                    "disallowedPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of disallowed policies for given role.\n"
                    },
                    "explicitMaxTtl": {
                        "type": "string",
                        "description": "If set, the\ntoken will have an explicit max TTL set upon it.\n",
                        "deprecationMessage": "use `token_explicit_max_ttl` instead if you are running Vault \u003e= 1.2"
                    },
                    "orphan": {
                        "type": "boolean",
                        "description": "If true, tokens created against this policy will be orphan tokens.\n"
                    },
                    "pathSuffix": {
                        "type": "string",
                        "description": "Tokens created against this role will have the given suffix as part of their path in addition to the role name.\n"
                    },
                    "period": {
                        "type": "string",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n",
                        "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                    },
                    "renewable": {
                        "type": "boolean",
                        "description": "Wether to disable the ability of the token to be renewed past its initial TTL.\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Generated Token's Policies\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:transform/alphabet:Alphabet": {
            "properties": {
                "alphabet": {
                    "type": "string",
                    "description": "A string of characters that contains the alphabet set.\n",
                    "language": {
                        "csharp": {
                            "name": "AlphabetSet"
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of the alphabet.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The mount path for a back-end, for example, the path given in \"$ vault auth enable -path=my-aws aws\".\n"
                }
            },
            "required": [
                "name",
                "path"
            ],
            "inputProperties": {
                "alphabet": {
                    "type": "string",
                    "description": "A string of characters that contains the alphabet set.\n",
                    "language": {
                        "csharp": {
                            "name": "AlphabetSet"
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of the alphabet.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The mount path for a back-end, for example, the path given in \"$ vault auth enable -path=my-aws aws\".\n"
                }
            },
            "requiredInputs": [
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Alphabet resources.\n",
                "properties": {
                    "alphabet": {
                        "type": "string",
                        "description": "A string of characters that contains the alphabet set.\n",
                        "language": {
                            "csharp": {
                                "name": "AlphabetSet"
                            }
                        }
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the alphabet.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The mount path for a back-end, for example, the path given in \"$ vault auth enable -path=my-aws aws\".\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:transform/role:Role": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The mount path for a back-end, for example, the path given in \"$ vault auth enable -path=my-aws aws\".\n"
                },
                "transformations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A comma separated string or slice of transformations to use.\n"
                }
            },
            "required": [
                "name",
                "path"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The mount path for a back-end, for example, the path given in \"$ vault auth enable -path=my-aws aws\".\n"
                },
                "transformations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A comma separated string or slice of transformations to use.\n"
                }
            },
            "requiredInputs": [
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Role resources.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The mount path for a back-end, for example, the path given in \"$ vault auth enable -path=my-aws aws\".\n"
                    },
                    "transformations": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A comma separated string or slice of transformations to use.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:transform/template:Template": {
            "properties": {
                "alphabet": {
                    "type": "string",
                    "description": "The alphabet to use for this template. This is only used during FPE transformations.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the template.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The mount path for a back-end, for example, the path given in \"$ vault auth enable -path=my-aws aws\".\n"
                },
                "pattern": {
                    "type": "string",
                    "description": "The pattern used for matching. Currently, only regular expression pattern is supported.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The pattern type to use for match detection. Currently, only regex is supported.\n"
                }
            },
            "required": [
                "name",
                "path"
            ],
            "inputProperties": {
                "alphabet": {
                    "type": "string",
                    "description": "The alphabet to use for this template. This is only used during FPE transformations.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the template.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The mount path for a back-end, for example, the path given in \"$ vault auth enable -path=my-aws aws\".\n"
                },
                "pattern": {
                    "type": "string",
                    "description": "The pattern used for matching. Currently, only regular expression pattern is supported.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The pattern type to use for match detection. Currently, only regex is supported.\n"
                }
            },
            "requiredInputs": [
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Template resources.\n",
                "properties": {
                    "alphabet": {
                        "type": "string",
                        "description": "The alphabet to use for this template. This is only used during FPE transformations.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the template.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The mount path for a back-end, for example, the path given in \"$ vault auth enable -path=my-aws aws\".\n"
                    },
                    "pattern": {
                        "type": "string",
                        "description": "The pattern used for matching. Currently, only regular expression pattern is supported.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The pattern type to use for match detection. Currently, only regex is supported.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:transform/transformation:Transformation": {
            "properties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The set of roles allowed to perform this transformation.\n"
                },
                "maskingCharacter": {
                    "type": "string",
                    "description": "The character used to replace data when in masking mode\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the transformation.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The mount path for a back-end, for example, the path given in \"$ vault auth enable -path=my-aws aws\".\n"
                },
                "template": {
                    "type": "string",
                    "description": "The name of the template to use.\n"
                },
                "templates": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Templates configured for transformation.\n"
                },
                "tweakSource": {
                    "type": "string",
                    "description": "The source of where the tweak value comes from. Only valid when in FPE mode.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of transformation to perform.\n"
                }
            },
            "required": [
                "name",
                "path",
                "templates"
            ],
            "inputProperties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The set of roles allowed to perform this transformation.\n"
                },
                "maskingCharacter": {
                    "type": "string",
                    "description": "The character used to replace data when in masking mode\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the transformation.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The mount path for a back-end, for example, the path given in \"$ vault auth enable -path=my-aws aws\".\n"
                },
                "template": {
                    "type": "string",
                    "description": "The name of the template to use.\n"
                },
                "templates": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Templates configured for transformation.\n"
                },
                "tweakSource": {
                    "type": "string",
                    "description": "The source of where the tweak value comes from. Only valid when in FPE mode.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of transformation to perform.\n"
                }
            },
            "requiredInputs": [
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Transformation resources.\n",
                "properties": {
                    "allowedRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The set of roles allowed to perform this transformation.\n"
                    },
                    "maskingCharacter": {
                        "type": "string",
                        "description": "The character used to replace data when in masking mode\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the transformation.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The mount path for a back-end, for example, the path given in \"$ vault auth enable -path=my-aws aws\".\n"
                    },
                    "template": {
                        "type": "string",
                        "description": "The name of the template to use.\n"
                    },
                    "templates": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Templates configured for transformation.\n"
                    },
                    "tweakSource": {
                        "type": "string",
                        "description": "The source of where the tweak value comes from. Only valid when in FPE mode.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of transformation to perform.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:transit/secretBackendKey:SecretBackendKey": {
            "description": "Creates an Encryption Keyring on a Transit Secret Backend for Vault.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst transit = new vault.Mount(\"transit\", {\n    defaultLeaseTtlSeconds: 3600,\n    description: \"Example description\",\n    maxLeaseTtlSeconds: 86400,\n    path: \"transit\",\n    type: \"transit\",\n});\nconst key = new vault.transit.SecretBackendKey(\"key\", {\n    backend: transit.path,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntransit = vault.Mount(\"transit\",\n    default_lease_ttl_seconds=3600,\n    description=\"Example description\",\n    max_lease_ttl_seconds=86400,\n    path=\"transit\",\n    type=\"transit\")\nkey = vault.transit.SecretBackendKey(\"key\", backend=transit.path)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var transit = new Vault.Mount(\"transit\", new Vault.MountArgs\n        {\n            DefaultLeaseTtlSeconds = 3600,\n            Description = \"Example description\",\n            MaxLeaseTtlSeconds = 86400,\n            Path = \"transit\",\n            Type = \"transit\",\n        });\n        var key = new Vault.Transit.SecretBackendKey(\"key\", new Vault.Transit.SecretBackendKeyArgs\n        {\n            Backend = transit.Path,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/transit\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttransit, err := vault.NewMount(ctx, \"transit\", \u0026vault.MountArgs{\n\t\t\tDefaultLeaseTtlSeconds: pulumi.Int(3600),\n\t\t\tDescription:            pulumi.String(\"Example description\"),\n\t\t\tMaxLeaseTtlSeconds:     pulumi.Int(86400),\n\t\t\tPath:                   pulumi.String(\"transit\"),\n\t\t\tType:                   pulumi.String(\"transit\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = transit.NewSecretBackendKey(ctx, \"key\", \u0026transit.SecretBackendKeyArgs{\n\t\t\tBackend: transit.Path,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "allowPlaintextBackup": {
                    "type": "boolean",
                    "description": "Enables taking backup of entire keyring in the plaintext format. Once set, this cannot be disabled.\n* Refer to Vault API documentation on key backups for more information: [Backup Key](https://www.vaultproject.io/api-docs/secret/transit#backup-key)\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the transit secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "convergentEncryption": {
                    "type": "boolean",
                    "description": "Whether or not to support convergent encryption, where the same plaintext creates the same ciphertext. This requires `derived` to be set to `true`.\n"
                },
                "deletionAllowed": {
                    "type": "boolean",
                    "description": "Specifies if the key is allowed to be deleted.\n"
                },
                "derived": {
                    "type": "boolean",
                    "description": "Specifies if key derivation is to be used. If enabled, all encrypt/decrypt requests to this key must provide a context which is used for key derivation.\n"
                },
                "exportable": {
                    "type": "boolean",
                    "description": "Enables keys to be exportable. This allows for all valid private keys in the keyring to be exported. Once set, this cannot be disabled.\n"
                },
                "keys": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "description": "List of key versions in the keyring. This attribute is zero-indexed and will contain a map of values depending on the `type` of the encryption key.\n* for key types `aes256-gcm96` and `chacha20-poly1305`, each key version will be a map of a single value `id` which is just a hash of the key's metadata.\n* for key types `ed25519`, `ecdsa-p256`, `rsa-2048` and `rsa-4096`, each key version will be a map of the following:\n"
                },
                "latestVersion": {
                    "type": "integer",
                    "description": "Latest key version available. This value is 1-indexed, so if `latest_version` is `1`, then the key's information can be referenced from `keys` by selecting element `0`\n"
                },
                "minAvailableVersion": {
                    "type": "integer",
                    "description": "Minimum key version available for use. If keys have been archived by increasing `min_decryption_version`, this attribute will reflect that change.\n"
                },
                "minDecryptionVersion": {
                    "type": "integer",
                    "description": "Minimum key version to use for decryption.\n"
                },
                "minEncryptionVersion": {
                    "type": "integer",
                    "description": "Minimum key version to use for encryption\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this key within the backend. Must be unique within the backend.\n"
                },
                "supportsDecryption": {
                    "type": "boolean",
                    "description": "Whether or not the key supports decryption, based on key type.\n"
                },
                "supportsDerivation": {
                    "type": "boolean",
                    "description": "Whether or not the key supports derivation, based on key type.\n"
                },
                "supportsEncryption": {
                    "type": "boolean",
                    "description": "Whether or not the key supports encryption, based on key type.\n"
                },
                "supportsSigning": {
                    "type": "boolean",
                    "description": "Whether or not the key supports signing, based on key type.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Specifies the type of key to create. The currently-supported types are: `aes256-gcm96` (default), `chacha20-poly1305`, `ed25519`, `ecdsa-p256`, `rsa-2048` and `rsa-4096`. \n* Refer to the Vault documentation on transit key types for more information: [Key Types](https://www.vaultproject.io/docs/secrets/transit#key-types)\n"
                }
            },
            "required": [
                "backend",
                "keys",
                "latestVersion",
                "minAvailableVersion",
                "name",
                "supportsDecryption",
                "supportsDerivation",
                "supportsEncryption",
                "supportsSigning"
            ],
            "inputProperties": {
                "allowPlaintextBackup": {
                    "type": "boolean",
                    "description": "Enables taking backup of entire keyring in the plaintext format. Once set, this cannot be disabled.\n* Refer to Vault API documentation on key backups for more information: [Backup Key](https://www.vaultproject.io/api-docs/secret/transit#backup-key)\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the transit secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "convergentEncryption": {
                    "type": "boolean",
                    "description": "Whether or not to support convergent encryption, where the same plaintext creates the same ciphertext. This requires `derived` to be set to `true`.\n"
                },
                "deletionAllowed": {
                    "type": "boolean",
                    "description": "Specifies if the key is allowed to be deleted.\n"
                },
                "derived": {
                    "type": "boolean",
                    "description": "Specifies if key derivation is to be used. If enabled, all encrypt/decrypt requests to this key must provide a context which is used for key derivation.\n"
                },
                "exportable": {
                    "type": "boolean",
                    "description": "Enables keys to be exportable. This allows for all valid private keys in the keyring to be exported. Once set, this cannot be disabled.\n"
                },
                "minDecryptionVersion": {
                    "type": "integer",
                    "description": "Minimum key version to use for decryption.\n"
                },
                "minEncryptionVersion": {
                    "type": "integer",
                    "description": "Minimum key version to use for encryption\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this key within the backend. Must be unique within the backend.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Specifies the type of key to create. The currently-supported types are: `aes256-gcm96` (default), `chacha20-poly1305`, `ed25519`, `ecdsa-p256`, `rsa-2048` and `rsa-4096`. \n* Refer to the Vault documentation on transit key types for more information: [Key Types](https://www.vaultproject.io/docs/secrets/transit#key-types)\n"
                }
            },
            "requiredInputs": [
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendKey resources.\n",
                "properties": {
                    "allowPlaintextBackup": {
                        "type": "boolean",
                        "description": "Enables taking backup of entire keyring in the plaintext format. Once set, this cannot be disabled.\n* Refer to Vault API documentation on key backups for more information: [Backup Key](https://www.vaultproject.io/api-docs/secret/transit#backup-key)\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path the transit secret backend is mounted at, with no leading or trailing `/`s.\n"
                    },
                    "convergentEncryption": {
                        "type": "boolean",
                        "description": "Whether or not to support convergent encryption, where the same plaintext creates the same ciphertext. This requires `derived` to be set to `true`.\n"
                    },
                    "deletionAllowed": {
                        "type": "boolean",
                        "description": "Specifies if the key is allowed to be deleted.\n"
                    },
                    "derived": {
                        "type": "boolean",
                        "description": "Specifies if key derivation is to be used. If enabled, all encrypt/decrypt requests to this key must provide a context which is used for key derivation.\n"
                    },
                    "exportable": {
                        "type": "boolean",
                        "description": "Enables keys to be exportable. This allows for all valid private keys in the keyring to be exported. Once set, this cannot be disabled.\n"
                    },
                    "keys": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        },
                        "description": "List of key versions in the keyring. This attribute is zero-indexed and will contain a map of values depending on the `type` of the encryption key.\n* for key types `aes256-gcm96` and `chacha20-poly1305`, each key version will be a map of a single value `id` which is just a hash of the key's metadata.\n* for key types `ed25519`, `ecdsa-p256`, `rsa-2048` and `rsa-4096`, each key version will be a map of the following:\n"
                    },
                    "latestVersion": {
                        "type": "integer",
                        "description": "Latest key version available. This value is 1-indexed, so if `latest_version` is `1`, then the key's information can be referenced from `keys` by selecting element `0`\n"
                    },
                    "minAvailableVersion": {
                        "type": "integer",
                        "description": "Minimum key version available for use. If keys have been archived by increasing `min_decryption_version`, this attribute will reflect that change.\n"
                    },
                    "minDecryptionVersion": {
                        "type": "integer",
                        "description": "Minimum key version to use for decryption.\n"
                    },
                    "minEncryptionVersion": {
                        "type": "integer",
                        "description": "Minimum key version to use for encryption\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name to identify this key within the backend. Must be unique within the backend.\n"
                    },
                    "supportsDecryption": {
                        "type": "boolean",
                        "description": "Whether or not the key supports decryption, based on key type.\n"
                    },
                    "supportsDerivation": {
                        "type": "boolean",
                        "description": "Whether or not the key supports derivation, based on key type.\n"
                    },
                    "supportsEncryption": {
                        "type": "boolean",
                        "description": "Whether or not the key supports encryption, based on key type.\n"
                    },
                    "supportsSigning": {
                        "type": "boolean",
                        "description": "Whether or not the key supports signing, based on key type.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Specifies the type of key to create. The currently-supported types are: `aes256-gcm96` (default), `chacha20-poly1305`, `ed25519`, `ecdsa-p256`, `rsa-2048` and `rsa-4096`. \n* Refer to the Vault documentation on transit key types for more information: [Key Types](https://www.vaultproject.io/docs/secrets/transit#key-types)\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:transit/secretCacheConfig:SecretCacheConfig": {
            "description": "Configure the cache for the Transit Secret Backend in Vault.\n",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path the transit secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "The number of cache entries. 0 means unlimited.\n"
                }
            },
            "required": [
                "backend",
                "size"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path the transit secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "The number of cache entries. 0 means unlimited.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "size"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretCacheConfig resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the transit secret backend is mounted at, with no leading or trailing `/`s.\n"
                    },
                    "size": {
                        "type": "integer",
                        "description": "The number of cache entries. 0 means unlimited.\n"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "vault:appRole/getAuthBackendRoleId:getAuthBackendRoleId": {
            "description": "Reads the Role ID of an AppRole from a Vault server.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst role = pulumi.output(vault.appRole.getAuthBackendRoleId({\n    backend: \"my-approle-backend\",\n    roleName: \"my-role\",\n}, { async: true }));\n\nexport const role_id = role.roleId;\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nrole = vault.appRole.get_auth_backend_role_id(backend=\"my-approle-backend\",\n    role_name=\"my-role\")\npulumi.export(\"role-id\", role.role_id)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var role = Output.Create(Vault.AppRole.GetAuthBackendRoleId.InvokeAsync(new Vault.AppRole.GetAuthBackendRoleIdArgs\n        {\n            Backend = \"my-approle-backend\",\n            RoleName = \"my-role\",\n        }));\n        this.Role_id = role.Apply(role =\u003e role.RoleId);\n    }\n\n    [Output(\"role-id\")]\n    public Output\u003cstring\u003e Role_id { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/appRole\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\topt0 := \"my-approle-backend\"\n\t\trole, err := appRole.GetAuthBackendRoleId(ctx, \u0026appRole.GetAuthBackendRoleIdArgs{\n\t\t\tBackend:  \u0026opt0,\n\t\t\tRoleName: \"my-role\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"role-id\", role.RoleId)\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getAuthBackendRoleId.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The unique name for the AppRole backend the role to\nretrieve a RoleID for resides in. Defaults to \"approle\".\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role to retrieve the Role ID for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "roleName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAuthBackendRoleId.\n",
                "properties": {
                    "backend": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "roleId": {
                        "type": "string",
                        "description": "The RoleID of the role.\n"
                    },
                    "roleName": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "roleId",
                    "roleName",
                    "id"
                ]
            }
        },
        "vault:aws/getAccessCredentials:getAccessCredentials": {
            "inputs": {
                "description": "A collection of arguments for invoking getAccessCredentials.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path to the AWS secret backend to\nread credentials from, with no leading or trailing `/`s.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the AWS secret backend role to read\ncredentials from, with no leading or trailing `/`s.\n"
                    },
                    "roleArn": {
                        "type": "string",
                        "description": "The specific AWS ARN to use\nfrom the configured role. If the role does not have multiple ARNs, this does\nnot need to be specified.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of credentials to read. Defaults\nto `\"creds\"`, which just returns an AWS Access Key ID and Secret\nKey. Can also be set to `\"sts\"`, which will return a security token\nin addition to the keys.\n"
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "role"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAccessCredentials.\n",
                "properties": {
                    "accessKey": {
                        "type": "string",
                        "description": "The AWS Access Key ID returned by Vault.\n"
                    },
                    "backend": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "leaseDuration": {
                        "type": "integer",
                        "description": "The duration of the secret lease, in seconds relative\nto the time the data was requested. Once this time has passed any plan\ngenerated with this data may fail to apply.\n"
                    },
                    "leaseId": {
                        "type": "string",
                        "description": "The lease identifier assigned by Vault.\n"
                    },
                    "leaseRenewable": {
                        "type": "boolean"
                    },
                    "leaseStartTime": {
                        "type": "string"
                    },
                    "role": {
                        "type": "string"
                    },
                    "roleArn": {
                        "type": "string"
                    },
                    "secretKey": {
                        "type": "string",
                        "description": "The AWS Secret Key returned by Vault.\n"
                    },
                    "securityToken": {
                        "type": "string",
                        "description": "The STS token returned by Vault, if any.\n"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "accessKey",
                    "backend",
                    "leaseDuration",
                    "leaseId",
                    "leaseRenewable",
                    "leaseStartTime",
                    "role",
                    "secretKey",
                    "securityToken",
                    "id"
                ]
            }
        },
        "vault:azure/getAccessCredentials:getAccessCredentials": {
            "inputs": {
                "description": "A collection of arguments for invoking getAccessCredentials.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path to the Azure secret backend to\nread credentials from, with no leading or trailing `/`s.\n"
                    },
                    "maxCredValidationSeconds": {
                        "type": "integer",
                        "description": "If 'validate_creds' is true, \nthe number of seconds after which to give up validating credentials. Defaults\nto 1,200 (20 minutes).\n"
                    },
                    "numSecondsBetweenTests": {
                        "type": "integer",
                        "description": "If 'validate_creds' is true, \nthe number of seconds to wait between each test of generated credentials.\nDefaults to 7.\n"
                    },
                    "numSequentialSuccesses": {
                        "type": "integer",
                        "description": "If 'validate_creds' is true, \nthe number of sequential successes required to validate generated\ncredentials. Defaults to 8.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the Azure secret backend role to read\ncredentials from, with no leading or trailing `/`s.\n"
                    },
                    "validateCreds": {
                        "type": "boolean",
                        "description": "Whether generated credentials should be \nvalidated before being returned. Defaults to `false`, which returns\ncredentials without checking whether they have fully propagated throughout\nAzure Active Directory. Designating `true` activates testing.\n"
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "role"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAccessCredentials.\n",
                "properties": {
                    "backend": {
                        "type": "string"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client id for credentials to query the Azure APIs.\n"
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "The client secret for credentials to query the Azure APIs.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "leaseDuration": {
                        "type": "integer",
                        "description": "The duration of the secret lease, in seconds relative\nto the time the data was requested. Once this time has passed any plan\ngenerated with this data may fail to apply.\n"
                    },
                    "leaseId": {
                        "type": "string",
                        "description": "The lease identifier assigned by Vault.\n"
                    },
                    "leaseRenewable": {
                        "type": "boolean"
                    },
                    "leaseStartTime": {
                        "type": "string"
                    },
                    "maxCredValidationSeconds": {
                        "type": "integer"
                    },
                    "numSecondsBetweenTests": {
                        "type": "integer"
                    },
                    "numSequentialSuccesses": {
                        "type": "integer"
                    },
                    "role": {
                        "type": "string"
                    },
                    "validateCreds": {
                        "type": "boolean"
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "clientId",
                    "clientSecret",
                    "leaseDuration",
                    "leaseId",
                    "leaseRenewable",
                    "leaseStartTime",
                    "role",
                    "id"
                ]
            }
        },
        "vault:generic/getSecret:getSecret": {
            "inputs": {
                "description": "A collection of arguments for invoking getSecret.\n",
                "properties": {
                    "path": {
                        "type": "string",
                        "description": "The full logical path from which to request data.\nTo read data from the \"generic\" secret backend mounted in Vault by\ndefault, this should be prefixed with `secret/`. Reading from other backends\nwith this data source is possible; consult each backend's documentation\nto see which endpoints support the `GET` method.\n"
                    },
                    "version": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "path"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSecret.\n",
                "properties": {
                    "data": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A mapping whose keys are the top-level data keys returned from\nVault and whose values are the corresponding values. This map can only\nrepresent string data, so any non-string values returned from Vault are\nserialized as JSON.\n"
                    },
                    "dataJson": {
                        "type": "string",
                        "description": "A string containing the full data payload retrieved from\nVault, serialized in JSON format.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "leaseDuration": {
                        "type": "integer",
                        "description": "The duration of the secret lease, in seconds relative\nto the time the data was requested. Once this time has passed any plan\ngenerated with this data may fail to apply.\n"
                    },
                    "leaseId": {
                        "type": "string",
                        "description": "The lease identifier assigned by Vault, if any.\n"
                    },
                    "leaseRenewable": {
                        "type": "boolean"
                    },
                    "leaseStartTime": {
                        "type": "string"
                    },
                    "path": {
                        "type": "string"
                    },
                    "version": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "data",
                    "dataJson",
                    "leaseDuration",
                    "leaseId",
                    "leaseRenewable",
                    "leaseStartTime",
                    "path",
                    "id"
                ]
            }
        },
        "vault:identity/getEntity:getEntity": {
            "inputs": {
                "description": "A collection of arguments for invoking getEntity.\n",
                "properties": {
                    "aliasId": {
                        "type": "string",
                        "description": "ID of the alias.\n"
                    },
                    "aliasMountAccessor": {
                        "type": "string",
                        "description": "Accessor of the mount to which the alias belongs to.\nThis should be supplied in conjunction with `alias_name`.\n"
                    },
                    "aliasName": {
                        "type": "string",
                        "description": "Name of the alias. This should be supplied in conjunction with\n`alias_mount_accessor`.\n"
                    },
                    "entityId": {
                        "type": "string",
                        "description": "ID of the entity.\n"
                    },
                    "entityName": {
                        "type": "string",
                        "description": "Name of the entity.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getEntity.\n",
                "properties": {
                    "aliasId": {
                        "type": "string"
                    },
                    "aliasMountAccessor": {
                        "type": "string"
                    },
                    "aliasName": {
                        "type": "string"
                    },
                    "aliases": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:identity/getEntityAlias:getEntityAlias"
                        },
                        "description": "A list of entity alias. Structure is documented below.\n"
                    },
                    "creationTime": {
                        "type": "string",
                        "description": "Creation time of the Alias\n"
                    },
                    "dataJson": {
                        "type": "string",
                        "description": "A string containing the full data payload retrieved from\nVault, serialized in JSON format.\n"
                    },
                    "directGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Group IDs of which the entity is directly a member of\n"
                    },
                    "disabled": {
                        "type": "boolean",
                        "description": "Whether the entity is disabled\n"
                    },
                    "entityId": {
                        "type": "string"
                    },
                    "entityName": {
                        "type": "string"
                    },
                    "groupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of all Group IDs of which the entity is a member of\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "inheritedGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of all Group IDs of which the entity is a member of transitively\n"
                    },
                    "lastUpdateTime": {
                        "type": "string",
                        "description": "Last update time of the alias\n"
                    },
                    "mergedEntityIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Other entity IDs which is merged with this entity\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Arbitrary metadata\n"
                    },
                    "namespaceId": {
                        "type": "string",
                        "description": "Namespace of which the entity is part of\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies attached to the entity\n"
                    }
                },
                "type": "object",
                "required": [
                    "aliasId",
                    "aliasMountAccessor",
                    "aliasName",
                    "aliases",
                    "creationTime",
                    "dataJson",
                    "directGroupIds",
                    "disabled",
                    "entityId",
                    "entityName",
                    "groupIds",
                    "inheritedGroupIds",
                    "lastUpdateTime",
                    "mergedEntityIds",
                    "metadata",
                    "namespaceId",
                    "policies",
                    "id"
                ]
            }
        },
        "vault:identity/getGroup:getGroup": {
            "inputs": {
                "description": "A collection of arguments for invoking getGroup.\n",
                "properties": {
                    "aliasId": {
                        "type": "string",
                        "description": "ID of the alias.\n"
                    },
                    "aliasMountAccessor": {
                        "type": "string",
                        "description": "Accessor of the mount to which the alias belongs to.\nThis should be supplied in conjunction with `alias_name`.\n"
                    },
                    "aliasName": {
                        "type": "string",
                        "description": "Name of the alias. This should be supplied in conjunction with\n`alias_mount_accessor`.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "ID of the group.\n"
                    },
                    "groupName": {
                        "type": "string",
                        "description": "Name of the group.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getGroup.\n",
                "properties": {
                    "aliasCanonicalId": {
                        "type": "string",
                        "description": "Canonical ID of the Alias\n"
                    },
                    "aliasCreationTime": {
                        "type": "string",
                        "description": "Creation time of the Alias\n"
                    },
                    "aliasId": {
                        "type": "string"
                    },
                    "aliasLastUpdateTime": {
                        "type": "string",
                        "description": "Last update time of the alias\n"
                    },
                    "aliasMergedFromCanonicalIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of canonical IDs merged with this alias\n"
                    },
                    "aliasMetadata": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Arbitrary metadata\n"
                    },
                    "aliasMountAccessor": {
                        "type": "string"
                    },
                    "aliasMountPath": {
                        "type": "string",
                        "description": "Authentication mount path which this alias belongs to\n"
                    },
                    "aliasMountType": {
                        "type": "string",
                        "description": "Authentication mount type which this alias belongs to\n"
                    },
                    "aliasName": {
                        "type": "string"
                    },
                    "creationTime": {
                        "type": "string",
                        "description": "Creation timestamp of the group\n"
                    },
                    "dataJson": {
                        "type": "string",
                        "description": "A string containing the full data payload retrieved from\nVault, serialized in JSON format.\n"
                    },
                    "groupId": {
                        "type": "string"
                    },
                    "groupName": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "lastUpdateTime": {
                        "type": "string",
                        "description": "Last updated time of the group\n"
                    },
                    "memberEntityIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Entity IDs which are members of this group\n"
                    },
                    "memberGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Group IDs which are members of this group\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Arbitrary metadata\n"
                    },
                    "modifyIndex": {
                        "type": "integer",
                        "description": "Modify index of the group\n"
                    },
                    "namespaceId": {
                        "type": "string",
                        "description": "Namespace of which the group is part of\n"
                    },
                    "parentGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Group IDs which are parents of this group.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies attached to the group\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of group\n"
                    }
                },
                "type": "object",
                "required": [
                    "aliasCanonicalId",
                    "aliasCreationTime",
                    "aliasId",
                    "aliasLastUpdateTime",
                    "aliasMergedFromCanonicalIds",
                    "aliasMetadata",
                    "aliasMountAccessor",
                    "aliasMountPath",
                    "aliasMountType",
                    "aliasName",
                    "creationTime",
                    "dataJson",
                    "groupId",
                    "groupName",
                    "lastUpdateTime",
                    "memberEntityIds",
                    "memberGroupIds",
                    "metadata",
                    "modifyIndex",
                    "namespaceId",
                    "parentGroupIds",
                    "policies",
                    "type",
                    "id"
                ]
            }
        },
        "vault:index/getAuthBackend:getAuthBackend": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = pulumi.output(vault.getAuthBackend({\n    path: \"userpass\",\n}, { async: true }));\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.get_auth_backend(path=\"userpass\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = Output.Create(Vault.GetAuthBackend.InvokeAsync(new Vault.GetAuthBackendArgs\n        {\n            Path = \"userpass\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.LookupAuthBackend(ctx, \u0026vault.LookupAuthBackendArgs{\n\t\t\tPath: \"userpass\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getAuthBackend.\n",
                "properties": {
                    "path": {
                        "type": "string",
                        "description": "The auth backend mount point.\n"
                    }
                },
                "type": "object",
                "required": [
                    "path"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAuthBackend.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The accessor for this auth method\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The default lease duration in seconds.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description of the auth method.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "listingVisibility": {
                        "type": "string",
                        "description": "Speficies whether to show this mount in the UI-specific listing endpoint.\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Specifies if the auth method is local only.\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The maximum lease duration in seconds.\n"
                    },
                    "path": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string",
                        "description": "The name of the auth method type.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accessor",
                    "defaultLeaseTtlSeconds",
                    "description",
                    "listingVisibility",
                    "local",
                    "maxLeaseTtlSeconds",
                    "path",
                    "type",
                    "id"
                ]
            }
        },
        "vault:index/getPolicyDocument:getPolicyDocument": {
            "description": "This is a data source which can be used to construct a HCL representation of an Vault policy document, for use with resources which expect policy documents, such as the `vault.Policy` resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst examplePolicyDocument = pulumi.output(vault.getPolicyDocument({\n    rules: [{\n        capabilities: [\n            \"create\",\n            \"read\",\n            \"update\",\n            \"delete\",\n            \"list\",\n        ],\n        description: \"allow all on secrets\",\n        path: \"secret/*\",\n    }],\n}, { async: true }));\nconst examplePolicy = new vault.Policy(\"example\", {\n    policy: examplePolicyDocument.hcl,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample_policy_document = vault.get_policy_document(rules=[{\n    \"capabilities\": [\n        \"create\",\n        \"read\",\n        \"update\",\n        \"delete\",\n        \"list\",\n    ],\n    \"description\": \"allow all on secrets\",\n    \"path\": \"secret/*\",\n}])\nexample_policy = vault.Policy(\"examplePolicy\", policy=example_policy_document.hcl)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var examplePolicyDocument = Output.Create(Vault.GetPolicyDocument.InvokeAsync(new Vault.GetPolicyDocumentArgs\n        {\n            Rules = \n            {\n                new Vault.Inputs.GetPolicyDocumentRuleArgs\n                {\n                    Capabilities = \n                    {\n                        \"create\",\n                        \"read\",\n                        \"update\",\n                        \"delete\",\n                        \"list\",\n                    },\n                    Description = \"allow all on secrets\",\n                    Path = \"secret/*\",\n                },\n            },\n        }));\n        var examplePolicy = new Vault.Policy(\"examplePolicy\", new Vault.PolicyArgs\n        {\n            Policy = examplePolicyDocument.Apply(examplePolicyDocument =\u003e examplePolicyDocument.Hcl),\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texamplePolicyDocument, err := vault.GetPolicyDocument(ctx, \u0026vault.GetPolicyDocumentArgs{\n\t\t\tRules: []vault.GetPolicyDocumentRule{\n\t\t\t\tvault.GetPolicyDocumentRule{\n\t\t\t\t\tCapabilities: []string{\n\t\t\t\t\t\t\"create\",\n\t\t\t\t\t\t\"read\",\n\t\t\t\t\t\t\"update\",\n\t\t\t\t\t\t\"delete\",\n\t\t\t\t\t\t\"list\",\n\t\t\t\t\t},\n\t\t\t\t\tDescription: \"allow all on secrets\",\n\t\t\t\t\tPath:        \"secret/*\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vault.NewPolicy(ctx, \"examplePolicy\", \u0026vault.PolicyArgs{\n\t\t\tPolicy: pulumi.String(examplePolicyDocument.Hcl),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getPolicyDocument.\n",
                "properties": {
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:/getPolicyDocumentRule:getPolicyDocumentRule"
                        }
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getPolicyDocument.\n",
                "properties": {
                    "hcl": {
                        "type": "string",
                        "description": "The above arguments serialized as a standard Vault HCL policy document.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:/getPolicyDocumentRule:getPolicyDocumentRule"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "hcl",
                    "rules",
                    "id"
                ]
            }
        },
        "vault:kubernetes/getAuthBackendConfig:getAuthBackendConfig": {
            "description": "Reads the Role of an Kubernetes from a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/api-docs/auth/kubernetes#read-config) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst config = pulumi.output(vault.kubernetes.getAuthBackendConfig({\n    backend: \"my-kubernetes-backend\",\n}, { async: true }));\n\nexport const tokenReviewerJwt = config.tokenReviewerJwt;\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getAuthBackendConfig.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The unique name for the Kubernetes backend the config to\nretrieve Role attributes for resides in. Defaults to \"kubernetes\".\n"
                    },
                    "issuer": {
                        "type": "string",
                        "description": "Optional JWT issuer. If no issuer is specified, `kubernetes.io/serviceaccount` will be used as the default issuer.\n"
                    },
                    "kubernetesCaCert": {
                        "type": "string",
                        "description": "PEM encoded CA cert for use by the TLS client used to talk with the Kubernetes API.\n"
                    },
                    "kubernetesHost": {
                        "type": "string",
                        "description": "Host must be a host string, a host:port pair, or a URL to the base of the Kubernetes API server.\n"
                    },
                    "pemKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Optional list of PEM-formatted public keys or certificates used to verify the signatures of Kubernetes service account JWTs. If a certificate is given, its public key will be extracted. Not every installation of Kubernetes exposes these keys.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getAuthBackendConfig.\n",
                "properties": {
                    "backend": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "issuer": {
                        "type": "string",
                        "description": "Optional JWT issuer. If no issuer is specified, `kubernetes.io/serviceaccount` will be used as the default issuer.\n"
                    },
                    "kubernetesCaCert": {
                        "type": "string",
                        "description": "PEM encoded CA cert for use by the TLS client used to talk with the Kubernetes API.\n"
                    },
                    "kubernetesHost": {
                        "type": "string",
                        "description": "Host must be a host string, a host:port pair, or a URL to the base of the Kubernetes API server.\n"
                    },
                    "pemKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Optional list of PEM-formatted public keys or certificates used to verify the signatures of Kubernetes service account JWTs. If a certificate is given, its public key will be extracted. Not every installation of Kubernetes exposes these keys.\n"
                    }
                },
                "type": "object",
                "required": [
                    "issuer",
                    "kubernetesCaCert",
                    "kubernetesHost",
                    "pemKeys",
                    "id"
                ]
            }
        },
        "vault:kubernetes/getAuthBackendRole:getAuthBackendRole": {
            "description": "Reads the Role of an Kubernetes from a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/api-docs/auth/kubernetes#read-role) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst role = pulumi.output(vault.kubernetes.getAuthBackendRole({\n    backend: \"my-kubernetes-backend\",\n    roleName: \"my-role\",\n}, { async: true }));\n\nexport const policies = role.policies!;\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nrole = vault.kubernetes.get_auth_backend_role(backend=\"my-kubernetes-backend\",\n    role_name=\"my-role\")\npulumi.export(\"policies\", role.policies)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var role = Output.Create(Vault.Kubernetes.GetAuthBackendRole.InvokeAsync(new Vault.Kubernetes.GetAuthBackendRoleArgs\n        {\n            Backend = \"my-kubernetes-backend\",\n            RoleName = \"my-role\",\n        }));\n        this.Policies = role.Apply(role =\u003e role.Policies);\n    }\n\n    [Output(\"policies\")]\n    public Output\u003cstring\u003e Policies { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v2/go/vault/kubernetes\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\topt0 := \"my-kubernetes-backend\"\n\t\trole, err := kubernetes.LookupAuthBackendRole(ctx, \u0026kubernetes.LookupAuthBackendRoleArgs{\n\t\t\tBackend:  \u0026opt0,\n\t\t\tRoleName: \"my-role\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"policies\", role.Policies)\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getAuthBackendRole.\n",
                "properties": {
                    "audience": {
                        "type": "string",
                        "description": "(Optional) Audience claim to verify in the JWT.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The unique name for the Kubernetes backend the role to\nretrieve Role attributes for resides in. Defaults to \"kubernetes\".\n"
                    },
                    "boundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "deprecationMessage": "use `token_bound_cidrs` instead if you are running Vault \u003e= 1.2"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                    },
                    "numUses": {
                        "type": "integer",
                        "deprecationMessage": "use `token_num_uses` instead if you are running Vault \u003e= 1.2"
                    },
                    "period": {
                        "type": "integer",
                        "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role to retrieve the Role attributes for.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "(Optional) If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                    }
                },
                "type": "object",
                "required": [
                    "roleName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAuthBackendRole.\n",
                "properties": {
                    "audience": {
                        "type": "string",
                        "description": "(Optional) Audience claim to verify in the JWT.\n"
                    },
                    "backend": {
                        "type": "string"
                    },
                    "boundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "deprecationMessage": "use `token_bound_cidrs` instead if you are running Vault \u003e= 1.2"
                    },
                    "boundServiceAccountNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of service account names able to access this role. If set to \"*\" all names are allowed, both this and bound_service_account_namespaces can not be \"*\".\n"
                    },
                    "boundServiceAccountNamespaces": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of namespaces allowed to access this role. If set to \"*\" all namespaces are allowed, both this and bound_service_account_names can not be set to \"*\".\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                    },
                    "numUses": {
                        "type": "integer",
                        "deprecationMessage": "use `token_num_uses` instead if you are running Vault \u003e= 1.2"
                    },
                    "period": {
                        "type": "integer",
                        "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                    },
                    "roleName": {
                        "type": "string"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "If set, will encode an\n[explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)\nonto the token in number of seconds. This is a hard cap even if `token_ttl` and\n`token_max_ttl` would otherwise allow a renewal.\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The\n[period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),\nif any, in number of seconds to set on the token.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "(Optional) If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token that should be generated. Can be `service`,\n`batch`, or `default` to use the mount's tuned default (which unless changed will be\n`service` tokens). For token store roles, there are two additional possibilities:\n`default-service` and `default-batch` which specify the type to return unless the client\nrequests a different type at generation time.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                    }
                },
                "type": "object",
                "required": [
                    "boundServiceAccountNames",
                    "boundServiceAccountNamespaces",
                    "roleName",
                    "id"
                ]
            }
        },
        "vault:transform/getDecode:getDecode": {
            "inputs": {
                "description": "A collection of arguments for invoking getDecode.\n",
                "properties": {
                    "batchInputs": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        }
                    },
                    "batchResults": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        }
                    },
                    "decodedValue": {
                        "type": "string"
                    },
                    "path": {
                        "type": "string"
                    },
                    "roleName": {
                        "type": "string"
                    },
                    "transformation": {
                        "type": "string"
                    },
                    "tweak": {
                        "type": "string"
                    },
                    "value": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "path",
                    "roleName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDecode.\n",
                "properties": {
                    "batchInputs": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        }
                    },
                    "batchResults": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        }
                    },
                    "decodedValue": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "path": {
                        "type": "string"
                    },
                    "roleName": {
                        "type": "string"
                    },
                    "transformation": {
                        "type": "string"
                    },
                    "tweak": {
                        "type": "string"
                    },
                    "value": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "batchResults",
                    "decodedValue",
                    "path",
                    "roleName",
                    "id"
                ]
            }
        },
        "vault:transform/getEncode:getEncode": {
            "inputs": {
                "description": "A collection of arguments for invoking getEncode.\n",
                "properties": {
                    "batchInputs": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        }
                    },
                    "batchResults": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        }
                    },
                    "encodedValue": {
                        "type": "string"
                    },
                    "path": {
                        "type": "string"
                    },
                    "roleName": {
                        "type": "string"
                    },
                    "transformation": {
                        "type": "string"
                    },
                    "tweak": {
                        "type": "string"
                    },
                    "value": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "path",
                    "roleName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getEncode.\n",
                "properties": {
                    "batchInputs": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        }
                    },
                    "batchResults": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        }
                    },
                    "encodedValue": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "path": {
                        "type": "string"
                    },
                    "roleName": {
                        "type": "string"
                    },
                    "transformation": {
                        "type": "string"
                    },
                    "tweak": {
                        "type": "string"
                    },
                    "value": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "batchResults",
                    "encodedValue",
                    "path",
                    "roleName",
                    "id"
                ]
            }
        }
    },
    "language": {
        "csharp": {
            "namespaces": {
                "alicloud": "AliCloud",
                "appRole": "AppRole",
                "aws": "Aws",
                "azure": "Azure",
                "consul": "Consul",
                "database": "Database",
                "gcp": "Gcp",
                "generic": "Generic",
                "github": "GitHub",
                "identity": "Identity",
                "index": "index",
                "jwt": "Jwt",
                "kubernetes": "Kubernetes",
                "ldap": "Ldap",
                "okta": "Okta",
                "pkiSecret": "PkiSecret",
                "rabbitMq": "RabbitMQ",
                "ssh": "Ssh",
                "tokenauth": "TokenAuth",
                "transform": "Transform",
                "transit": "Transit",
                "vault": "Vault"
            },
            "packageReferences": {
                "Pulumi": "2.*",
                "System.Collections.Immutable": "1.6.0"
            }
        },
        "nodejs": {
            "dependencies": {
                "@pulumi/pulumi": "^2.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^8.0.25"
            },
            "disableUnionOutputTypes": true,
            "packageDescription": "A Pulumi package for creating and managing vault cloud resources.",
            "packageName": "",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/terraform-providers/terraform-provider-vault)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi/pulumi-vault` repo](https://github.com/pulumi/pulumi-vault/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-providers/terraform-provider-vault` repo](https://github.com/terraform-providers/terraform-provider-vault/issues).",
            "typescriptVersion": ""
        },
        "python": {
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/terraform-providers/terraform-provider-vault)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi/pulumi-vault` repo](https://github.com/pulumi/pulumi-vault/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-providers/terraform-provider-vault` repo](https://github.com/terraform-providers/terraform-provider-vault/issues).",
            "requires": {
                "pulumi": "\u003e=2.0.0,\u003c3.0.0"
            }
        }
    }
}