{
    "name": "vault",
    "description": "A Pulumi package for creating and managing vault cloud resources.",
    "keywords": [
        "pulumi",
        "vault"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`vault` Terraform Provider](https://github.com/terraform-providers/terraform-provider-vault).",
    "repository": "https://github.com/pulumi/pulumi-vault",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "config": {
        "variables": {
            "addAddressToEnv": {
                "type": "string",
                "description": "If true, adds the value of the `address` argument to the Terraform process environment.\n"
            },
            "address": {
                "type": "string",
                "description": "URL of the root of the target Vault server.\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_ADDR"
                    ]
                }
            },
            "authLogins": {
                "type": "array",
                "items": {
                    "$ref": "#/types/vault:config/authLogins:authLogins"
                },
                "description": "Login to vault with an existing auth method using auth/\u003cmount\u003e/login\n"
            },
            "caCertDir": {
                "type": "string",
                "description": "Path to directory containing CA certificate files to validate the server's certificate.\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_CAPATH"
                    ]
                }
            },
            "caCertFile": {
                "type": "string",
                "description": "Path to a CA certificate file to validate the server's certificate.\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_CACERT"
                    ]
                }
            },
            "clientAuths": {
                "type": "array",
                "items": {
                    "$ref": "#/types/vault:config/clientAuths:clientAuths"
                },
                "description": "Client authentication credentials.\n"
            },
            "headers": {
                "type": "array",
                "items": {
                    "$ref": "#/types/vault:config/headers:headers"
                },
                "description": "The headers to send with each Vault request.\n"
            },
            "maxLeaseTtlSeconds": {
                "type": "integer",
                "description": "Maximum TTL for secret leases requested by this provider\n",
                "default": 1200,
                "defaultInfo": {
                    "environment": [
                        "TERRAFORM_VAULT_MAX_TTL"
                    ]
                }
            },
            "maxRetries": {
                "type": "integer",
                "description": "Maximum number of retries when a 5xx error code is encountered.\n",
                "default": 2,
                "defaultInfo": {
                    "environment": [
                        "VAULT_MAX_RETRIES"
                    ]
                }
            },
            "namespace": {
                "type": "string",
                "description": "The namespace to use. Available only for Vault Enterprise\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_NAMESPACE"
                    ]
                }
            },
            "skipTlsVerify": {
                "type": "boolean",
                "description": "Set this to true only if the target Vault server is an insecure development instance.\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_SKIP_VERIFY"
                    ]
                }
            },
            "token": {
                "type": "string",
                "description": "Token to use to authenticate to Vault.\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_TOKEN"
                    ]
                }
            },
            "tokenName": {
                "type": "string",
                "description": "Token name to use for creating the Vault child token.\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_TOKEN_NAME"
                    ]
                }
            }
        },
        "defaults": [
            "address",
            "token"
        ]
    },
    "types": {
        "vault:azure/BackendRoleAzureGroup:BackendRoleAzureGroup": {
            "properties": {
                "groupName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "objectId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "groupName"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "groupName",
                        "objectId"
                    ]
                }
            }
        },
        "vault:azure/BackendRoleAzureRole:BackendRoleAzureRole": {
            "properties": {
                "roleId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "scope": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "roleName",
                "scope"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "roleId",
                        "roleName",
                        "scope"
                    ]
                }
            }
        },
        "vault:config/authLogins:authLogins": {
            "properties": {
                "namespace": {
                    "type": "string"
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "path": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "path"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vault:config/clientAuths:clientAuths": {
            "properties": {
                "certFile": {
                    "type": "string"
                },
                "keyFile": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "certFile",
                "keyFile"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vault:config/headers:headers": {
            "properties": {
                "name": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vault:database/SecretBackendConnectionCassandra:SecretBackendConnectionCassandra": {
            "properties": {
                "connectTimeout": {
                    "type": "integer",
                    "description": "The number of seconds to use as a connection\ntimeout.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The hosts to connect to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Whether to skip verification of the server\ncertificate when using TLS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "The password to authenticate with.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pemBundle": {
                    "type": "string",
                    "description": "Concatenated PEM blocks configuring the certificate\nchain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pemJson": {
                    "type": "string",
                    "description": "A JSON structure configuring the certificate chain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "port": {
                    "type": "integer",
                    "description": "The default port to connect to if no port is specified as\npart of the host.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "protocolVersion": {
                    "type": "integer",
                    "description": "The CQL protocol version to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tls": {
                    "type": "boolean",
                    "description": "Whether to use TLS when connecting to Cassandra.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The username to authenticate with.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionElasticsearch:SecretBackendConnectionElasticsearch": {
            "properties": {
                "password": {
                    "type": "string",
                    "description": "The password to authenticate with.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "url": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The username to authenticate with.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "password",
                "url",
                "username"
            ]
        },
        "vault:database/SecretBackendConnectionHana:SecretBackendConnectionHana": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information. See\nthe [Vault\ndocs](https://www.vaultproject.io/api/secret/databases/oracle.html#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionMongodb:SecretBackendConnectionMongodb": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information. See\nthe [Vault\ndocs](https://www.vaultproject.io/api/secret/databases/oracle.html#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionMongodbatlas:SecretBackendConnectionMongodbatlas": {
            "properties": {
                "privateKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "projectId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "publicKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "privateKey",
                "projectId",
                "publicKey"
            ]
        },
        "vault:database/SecretBackendConnectionMssql:SecretBackendConnectionMssql": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information. See\nthe [Vault\ndocs](https://www.vaultproject.io/api/secret/databases/oracle.html#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionMysql:SecretBackendConnectionMysql": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information. See\nthe [Vault\ndocs](https://www.vaultproject.io/api/secret/databases/oracle.html#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionMysqlAurora:SecretBackendConnectionMysqlAurora": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information. See\nthe [Vault\ndocs](https://www.vaultproject.io/api/secret/databases/oracle.html#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionMysqlLegacy:SecretBackendConnectionMysqlLegacy": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information. See\nthe [Vault\ndocs](https://www.vaultproject.io/api/secret/databases/oracle.html#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionMysqlRds:SecretBackendConnectionMysqlRds": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information. See\nthe [Vault\ndocs](https://www.vaultproject.io/api/secret/databases/oracle.html#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionOracle:SecretBackendConnectionOracle": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information. See\nthe [Vault\ndocs](https://www.vaultproject.io/api/secret/databases/oracle.html#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:database/SecretBackendConnectionPostgresql:SecretBackendConnectionPostgresql": {
            "properties": {
                "connectionUrl": {
                    "type": "string",
                    "description": "A URL containing connection information. See\nthe [Vault\ndocs](https://www.vaultproject.io/api/secret/databases/oracle.html#sample-payload)\nfor an example.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxConnectionLifetime": {
                    "type": "integer",
                    "description": "The maximum number of seconds to keep\na connection alive for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxIdleConnections": {
                    "type": "integer",
                    "description": "The maximum number of idle connections to\nmaintain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxOpenConnections": {
                    "type": "integer",
                    "description": "The maximum number of open connections to\nuse.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:gcp/SecretRolesetBinding:SecretRolesetBinding": {
            "properties": {
                "resource": {
                    "type": "string",
                    "description": "Resource or resource path for which IAM policy information will be bound. The resource path may be specified in a few different [formats](https://www.vaultproject.io/docs/secrets/gcp/index.html#roleset-bindings).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of [GCP IAM roles](https://cloud.google.com/iam/docs/understanding-roles) for the resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "resource",
                "roles"
            ]
        },
        "vault:github/AuthBackendTune:AuthBackendTune": {
            "properties": {
                "allowedResponseHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "auditNonHmacRequestKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will \nnot be HMAC'd by audit devices in the request data object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "auditNonHmacResponseKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will \nnot be HMAC'd by audit devices in the response data object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "defaultLeaseTtl": {
                    "type": "string",
                    "description": "Specifies the default time-to-live. \nIf set, this overrides the global default.\nMust be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "listingVisibility": {
                    "type": "string",
                    "description": "Specifies whether to show this mount in \nthe UI-specific listing endpoint. Valid values are \"unauth\" or \"hidden\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxLeaseTtl": {
                    "type": "string",
                    "description": "Specifies the maximum time-to-live. \nIf set, this overrides the global default.\nMust be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "passthroughRequestHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of headers to whitelist and \npass from the request to the backend.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tokenType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:identity/getEntityAlias:getEntityAlias": {
            "properties": {
                "canonicalId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "creationTime": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lastUpdateTime": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mergedFromCanonicalIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mountAccessor": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mountPath": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mountType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "canonicalId",
                "creationTime",
                "id",
                "lastUpdateTime",
                "mergedFromCanonicalIds",
                "metadata",
                "mountAccessor",
                "mountPath",
                "mountType",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vault:index/AuthBackendTune:AuthBackendTune": {
            "properties": {
                "allowedResponseHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "auditNonHmacRequestKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "auditNonHmacResponseKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "defaultLeaseTtl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "listingVisibility": {
                    "type": "string",
                    "description": "Speficies whether to show this mount in the UI-specific listing endpoint.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxLeaseTtl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "passthroughRequestHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tokenType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:index/ProviderAuthLogin:ProviderAuthLogin": {
            "properties": {
                "namespace": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "path"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": []
                }
            }
        },
        "vault:index/ProviderClientAuth:ProviderClientAuth": {
            "properties": {
                "certFile": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyFile": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "certFile",
                "keyFile"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": []
                }
            }
        },
        "vault:index/ProviderHeader:ProviderHeader": {
            "properties": {
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": []
                }
            }
        },
        "vault:index/getPolicyDocumentRule:getPolicyDocumentRule": {
            "properties": {
                "allowedParameters": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:index/getPolicyDocumentRuleAllowedParameter:getPolicyDocumentRuleAllowedParameter"
                    },
                    "description": "Whitelists a list of keys and values that are permitted on the given path. See Parameters below.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "capabilities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of capabilities that this rule apply to `path`. For example, [\"read\", \"write\"].\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "deniedParameters": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:index/getPolicyDocumentRuleDeniedParameter:getPolicyDocumentRuleDeniedParameter"
                    },
                    "description": "Blacklists a list of parameter and values. Any values specified here take precedence over `allowed_parameter`. See Parameters below.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "description": "Description of the rule. Will be added as a commend to rendered rule.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxWrappingTtl": {
                    "type": "string",
                    "description": "The maximum allowed TTL that clients can specify for a wrapped response.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minWrappingTtl": {
                    "type": "string",
                    "description": "The minimum allowed TTL that clients can specify for a wrapped response.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "description": "A path in Vault that this rule applies to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "requiredParameters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of parameters that must be specified.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "capabilities",
                "path"
            ]
        },
        "vault:index/getPolicyDocumentRuleAllowedParameter:getPolicyDocumentRuleAllowedParameter": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "name of permitted or denied parameter.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "list of values what are permitted or denied by policy rule.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "key",
                "values"
            ]
        },
        "vault:index/getPolicyDocumentRuleDeniedParameter:getPolicyDocumentRuleDeniedParameter": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "name of permitted or denied parameter.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "list of values what are permitted or denied by policy rule.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "key",
                "values"
            ]
        },
        "vault:jwt/AuthBackendTune:AuthBackendTune": {
            "properties": {
                "allowedResponseHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "auditNonHmacRequestKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will \nnot be HMAC'd by audit devices in the request data object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "auditNonHmacResponseKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of keys that will \nnot be HMAC'd by audit devices in the response data object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "defaultLeaseTtl": {
                    "type": "string",
                    "description": "Specifies the default time-to-live. \nIf set, this overrides the global default.\nMust be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "listingVisibility": {
                    "type": "string",
                    "description": "Specifies whether to show this mount in \nthe UI-specific listing endpoint. Valid values are \"unauth\" or \"hidden\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxLeaseTtl": {
                    "type": "string",
                    "description": "Specifies the maximum time-to-live. \nIf set, this overrides the global default.\nMust be a valid [duration string](https://golang.org/pkg/time/#ParseDuration)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "passthroughRequestHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of headers to whitelist and \npass from the request to the backend.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tokenType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vault:okta/AuthBackendGroup:AuthBackendGroup": {
            "properties": {
                "groupName": {
                    "type": "string",
                    "description": "Name of the group within the Okta\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Vault policies to associate with this user\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "groupName",
                "policies"
            ]
        },
        "vault:okta/AuthBackendUser:AuthBackendUser": {
            "properties": {
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Okta groups to associate with this user\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Vault policies to associate with this user\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "Name of the user within Okta\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "groups",
                "username"
            ]
        },
        "vault:rabbitMq/SecretBackendRoleVhost:SecretBackendRoleVhost": {
            "properties": {
                "configure": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "read": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "write": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "configure",
                "host",
                "read",
                "write"
            ]
        }
    },
    "provider": {
        "description": "The provider type for the vault package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "inputProperties": {
            "addAddressToEnv": {
                "type": "string",
                "description": "If true, adds the value of the `address` argument to the Terraform process environment.\n"
            },
            "address": {
                "type": "string",
                "description": "URL of the root of the target Vault server.\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_ADDR"
                    ]
                }
            },
            "authLogins": {
                "type": "array",
                "items": {
                    "$ref": "#/types/vault:index/ProviderAuthLogin:ProviderAuthLogin"
                },
                "description": "Login to vault with an existing auth method using auth/\u003cmount\u003e/login\n"
            },
            "caCertDir": {
                "type": "string",
                "description": "Path to directory containing CA certificate files to validate the server's certificate.\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_CAPATH"
                    ]
                }
            },
            "caCertFile": {
                "type": "string",
                "description": "Path to a CA certificate file to validate the server's certificate.\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_CACERT"
                    ]
                }
            },
            "clientAuths": {
                "type": "array",
                "items": {
                    "$ref": "#/types/vault:index/ProviderClientAuth:ProviderClientAuth"
                },
                "description": "Client authentication credentials.\n"
            },
            "headers": {
                "type": "array",
                "items": {
                    "$ref": "#/types/vault:index/ProviderHeader:ProviderHeader"
                },
                "description": "The headers to send with each Vault request.\n"
            },
            "maxLeaseTtlSeconds": {
                "type": "integer",
                "description": "Maximum TTL for secret leases requested by this provider\n",
                "default": 1200,
                "defaultInfo": {
                    "environment": [
                        "TERRAFORM_VAULT_MAX_TTL"
                    ]
                }
            },
            "maxRetries": {
                "type": "integer",
                "description": "Maximum number of retries when a 5xx error code is encountered.\n",
                "default": 2,
                "defaultInfo": {
                    "environment": [
                        "VAULT_MAX_RETRIES"
                    ]
                }
            },
            "namespace": {
                "type": "string",
                "description": "The namespace to use. Available only for Vault Enterprise\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_NAMESPACE"
                    ]
                }
            },
            "skipTlsVerify": {
                "type": "boolean",
                "description": "Set this to true only if the target Vault server is an insecure development instance.\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_SKIP_VERIFY"
                    ]
                }
            },
            "token": {
                "type": "string",
                "description": "Token to use to authenticate to Vault.\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_TOKEN"
                    ]
                }
            },
            "tokenName": {
                "type": "string",
                "description": "Token name to use for creating the Vault child token.\n",
                "defaultInfo": {
                    "environment": [
                        "VAULT_TOKEN_NAME"
                    ]
                }
            }
        }
    },
    "resources": {
        "vault:ad/secretBackend:SecretBackend": {
            "properties": {
                "anonymousGroupSearch": {
                    "type": "boolean",
                    "description": "Use anonymous binds when performing LDAP group searches (if true the initial credentials will still be used for the\ninitial connection test).\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The mount path for a backend, for example, the path given in \"$ vault auth enable -path=my-ad ad\".\n"
                },
                "binddn": {
                    "type": "string",
                    "description": "Distinguished name of object to bind when performing user and group search.\n"
                },
                "bindpass": {
                    "type": "string",
                    "description": "LDAP password for searching for the user DN.\n"
                },
                "caseSensitiveNames": {
                    "type": "boolean",
                    "description": "If true, case sensitivity will be used when comparing usernames and groups for matching policies.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "CA certificate to use when verifying LDAP server certificate, must be x509 PEM encoded.\n"
                },
                "clientTlsCert": {
                    "type": "string",
                    "description": "Client certificate to provide to the LDAP server, must be x509 PEM encoded.\n"
                },
                "clientTlsKey": {
                    "type": "string",
                    "description": "Client certificate key to provide to the LDAP server, must be x509 PEM encoded.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Default lease duration for secrets in seconds\n"
                },
                "denyNullBind": {
                    "type": "boolean",
                    "description": "Denies an unauthenticated LDAP bind request if the user's password is empty; defaults to true\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the backend.\n"
                },
                "discoverdn": {
                    "type": "boolean",
                    "description": "Use anonymous bind to discover the bind DN of a user.\n"
                },
                "formatter": {
                    "type": "string",
                    "description": "Text to insert the password into, ex. \"customPrefix{{PASSWORD}}customSuffix\".\n",
                    "deprecationMessage": "Formatter is deprecated and password_policy should be used with Vault \u003e= 1.5."
                },
                "groupattr": {
                    "type": "string",
                    "description": "LDAP attribute to follow on objects returned by \u003cgroupfilter\u003e in order to enumerate user group membership. Examples:\n\"cn\" or \"memberOf\", etc. Default: cn\n"
                },
                "groupdn": {
                    "type": "string",
                    "description": "LDAP search base to use for group membership search (eg: ou=Groups,dc=example,dc=org)\n"
                },
                "groupfilter": {
                    "type": "string",
                    "description": "Go template for querying group membership of user. The template can access the following context variables: UserDN,\nUsername Example: (\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}})) Default:\n(|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}}))\n"
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Skip LDAP server SSL Certificate verification - insecure and not recommended for production use.\n"
                },
                "lastRotationTolerance": {
                    "type": "integer",
                    "description": "The number of seconds after a Vault rotation where, if Active Directory shows a later rotation, it should be considered\nout-of-band.\n"
                },
                "length": {
                    "type": "integer",
                    "description": "The desired length of passwords that Vault generates.\n",
                    "deprecationMessage": "Length is deprecated and password_policy should be used with Vault \u003e= 1.5."
                },
                "local": {
                    "type": "boolean",
                    "description": "Mark the secrets engine as local-only. Local engines are not replicated or removed by replication.Tolerance duration to\nuse when checking the last rotation time.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Maximum possible lease duration for secrets in seconds.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "In seconds, the maximum password time-to-live.\n"
                },
                "passwordPolicy": {
                    "type": "string",
                    "description": "Name of the password policy to use to generate passwords.\n"
                },
                "requestTimeout": {
                    "type": "integer",
                    "description": "Timeout, in seconds, for the connection when making requests against the server before returning back an error.\n"
                },
                "starttls": {
                    "type": "boolean",
                    "description": "Issue a StartTLS command after establishing unencrypted connection.\n"
                },
                "tlsMaxVersion": {
                    "type": "string",
                    "description": "Maximum TLS version to use. Accepted values are 'tls10', 'tls11', 'tls12' or 'tls13'. Defaults to 'tls12'\n"
                },
                "tlsMinVersion": {
                    "type": "string",
                    "description": "Minimum TLS version to use. Accepted values are 'tls10', 'tls11', 'tls12' or 'tls13'. Defaults to 'tls12'\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "In seconds, the default password time-to-live.\n"
                },
                "upndomain": {
                    "type": "string",
                    "description": "Enables userPrincipalDomain login with [username]@UPNDomain.\n"
                },
                "url": {
                    "type": "string",
                    "description": "LDAP URL to connect to (default: ldap://127.0.0.1). Multiple URLs can be specified by concatenating them with commas;\nthey will be tried in-order.\n"
                },
                "usePre111GroupCnBehavior": {
                    "type": "boolean",
                    "description": "In Vault 1.1.1 a fix for handling group CN values of different cases unfortunately introduced a regression that could\ncause previously defined groups to not be found due to a change in the resulting name. If set true, the pre-1.1.1\nbehavior for matching group CNs will be used. This is only needed in some upgrade scenarios for backwards compatibility.\nIt is enabled by default if the config is upgraded but disabled by default on new configurations.\n"
                },
                "useTokenGroups": {
                    "type": "boolean",
                    "description": "If true, use the Active Directory tokenGroups constructed attribute of the user to find the group memberships. This will\nfind all security groups including nested ones.\n"
                },
                "userattr": {
                    "type": "string",
                    "description": "Attribute used for users (default: cn)\n"
                },
                "userdn": {
                    "type": "string",
                    "description": "LDAP domain to use for users (eg: ou=People,dc=example,dc=org)\n"
                }
            },
            "required": [
                "binddn",
                "bindpass",
                "defaultLeaseTtlSeconds",
                "formatter",
                "lastRotationTolerance",
                "length",
                "maxLeaseTtlSeconds",
                "maxTtl",
                "starttls",
                "tlsMaxVersion",
                "tlsMinVersion",
                "ttl",
                "upndomain",
                "usePre111GroupCnBehavior"
            ],
            "inputProperties": {
                "anonymousGroupSearch": {
                    "type": "boolean",
                    "description": "Use anonymous binds when performing LDAP group searches (if true the initial credentials will still be used for the\ninitial connection test).\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The mount path for a backend, for example, the path given in \"$ vault auth enable -path=my-ad ad\".\n"
                },
                "binddn": {
                    "type": "string",
                    "description": "Distinguished name of object to bind when performing user and group search.\n"
                },
                "bindpass": {
                    "type": "string",
                    "description": "LDAP password for searching for the user DN.\n"
                },
                "caseSensitiveNames": {
                    "type": "boolean",
                    "description": "If true, case sensitivity will be used when comparing usernames and groups for matching policies.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "CA certificate to use when verifying LDAP server certificate, must be x509 PEM encoded.\n"
                },
                "clientTlsCert": {
                    "type": "string",
                    "description": "Client certificate to provide to the LDAP server, must be x509 PEM encoded.\n"
                },
                "clientTlsKey": {
                    "type": "string",
                    "description": "Client certificate key to provide to the LDAP server, must be x509 PEM encoded.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Default lease duration for secrets in seconds\n"
                },
                "denyNullBind": {
                    "type": "boolean",
                    "description": "Denies an unauthenticated LDAP bind request if the user's password is empty; defaults to true\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the backend.\n"
                },
                "discoverdn": {
                    "type": "boolean",
                    "description": "Use anonymous bind to discover the bind DN of a user.\n"
                },
                "formatter": {
                    "type": "string",
                    "description": "Text to insert the password into, ex. \"customPrefix{{PASSWORD}}customSuffix\".\n",
                    "deprecationMessage": "Formatter is deprecated and password_policy should be used with Vault \u003e= 1.5."
                },
                "groupattr": {
                    "type": "string",
                    "description": "LDAP attribute to follow on objects returned by \u003cgroupfilter\u003e in order to enumerate user group membership. Examples:\n\"cn\" or \"memberOf\", etc. Default: cn\n"
                },
                "groupdn": {
                    "type": "string",
                    "description": "LDAP search base to use for group membership search (eg: ou=Groups,dc=example,dc=org)\n"
                },
                "groupfilter": {
                    "type": "string",
                    "description": "Go template for querying group membership of user. The template can access the following context variables: UserDN,\nUsername Example: (\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}})) Default:\n(|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}}))\n"
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Skip LDAP server SSL Certificate verification - insecure and not recommended for production use.\n"
                },
                "lastRotationTolerance": {
                    "type": "integer",
                    "description": "The number of seconds after a Vault rotation where, if Active Directory shows a later rotation, it should be considered\nout-of-band.\n"
                },
                "length": {
                    "type": "integer",
                    "description": "The desired length of passwords that Vault generates.\n",
                    "deprecationMessage": "Length is deprecated and password_policy should be used with Vault \u003e= 1.5."
                },
                "local": {
                    "type": "boolean",
                    "description": "Mark the secrets engine as local-only. Local engines are not replicated or removed by replication.Tolerance duration to\nuse when checking the last rotation time.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Maximum possible lease duration for secrets in seconds.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "In seconds, the maximum password time-to-live.\n"
                },
                "passwordPolicy": {
                    "type": "string",
                    "description": "Name of the password policy to use to generate passwords.\n"
                },
                "requestTimeout": {
                    "type": "integer",
                    "description": "Timeout, in seconds, for the connection when making requests against the server before returning back an error.\n"
                },
                "starttls": {
                    "type": "boolean",
                    "description": "Issue a StartTLS command after establishing unencrypted connection.\n"
                },
                "tlsMaxVersion": {
                    "type": "string",
                    "description": "Maximum TLS version to use. Accepted values are 'tls10', 'tls11', 'tls12' or 'tls13'. Defaults to 'tls12'\n"
                },
                "tlsMinVersion": {
                    "type": "string",
                    "description": "Minimum TLS version to use. Accepted values are 'tls10', 'tls11', 'tls12' or 'tls13'. Defaults to 'tls12'\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "In seconds, the default password time-to-live.\n"
                },
                "upndomain": {
                    "type": "string",
                    "description": "Enables userPrincipalDomain login with [username]@UPNDomain.\n"
                },
                "url": {
                    "type": "string",
                    "description": "LDAP URL to connect to (default: ldap://127.0.0.1). Multiple URLs can be specified by concatenating them with commas;\nthey will be tried in-order.\n"
                },
                "usePre111GroupCnBehavior": {
                    "type": "boolean",
                    "description": "In Vault 1.1.1 a fix for handling group CN values of different cases unfortunately introduced a regression that could\ncause previously defined groups to not be found due to a change in the resulting name. If set true, the pre-1.1.1\nbehavior for matching group CNs will be used. This is only needed in some upgrade scenarios for backwards compatibility.\nIt is enabled by default if the config is upgraded but disabled by default on new configurations.\n"
                },
                "useTokenGroups": {
                    "type": "boolean",
                    "description": "If true, use the Active Directory tokenGroups constructed attribute of the user to find the group memberships. This will\nfind all security groups including nested ones.\n"
                },
                "userattr": {
                    "type": "string",
                    "description": "Attribute used for users (default: cn)\n"
                },
                "userdn": {
                    "type": "string",
                    "description": "LDAP domain to use for users (eg: ou=People,dc=example,dc=org)\n"
                }
            },
            "requiredInputs": [
                "binddn",
                "bindpass"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackend resources.\n",
                "properties": {
                    "anonymousGroupSearch": {
                        "type": "boolean",
                        "description": "Use anonymous binds when performing LDAP group searches (if true the initial credentials will still be used for the\ninitial connection test).\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The mount path for a backend, for example, the path given in \"$ vault auth enable -path=my-ad ad\".\n"
                    },
                    "binddn": {
                        "type": "string",
                        "description": "Distinguished name of object to bind when performing user and group search.\n"
                    },
                    "bindpass": {
                        "type": "string",
                        "description": "LDAP password for searching for the user DN.\n"
                    },
                    "caseSensitiveNames": {
                        "type": "boolean",
                        "description": "If true, case sensitivity will be used when comparing usernames and groups for matching policies.\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "CA certificate to use when verifying LDAP server certificate, must be x509 PEM encoded.\n"
                    },
                    "clientTlsCert": {
                        "type": "string",
                        "description": "Client certificate to provide to the LDAP server, must be x509 PEM encoded.\n"
                    },
                    "clientTlsKey": {
                        "type": "string",
                        "description": "Client certificate key to provide to the LDAP server, must be x509 PEM encoded.\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "Default lease duration for secrets in seconds\n"
                    },
                    "denyNullBind": {
                        "type": "boolean",
                        "description": "Denies an unauthenticated LDAP bind request if the user's password is empty; defaults to true\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Human-friendly description of the mount for the backend.\n"
                    },
                    "discoverdn": {
                        "type": "boolean",
                        "description": "Use anonymous bind to discover the bind DN of a user.\n"
                    },
                    "formatter": {
                        "type": "string",
                        "description": "Text to insert the password into, ex. \"customPrefix{{PASSWORD}}customSuffix\".\n",
                        "deprecationMessage": "Formatter is deprecated and password_policy should be used with Vault \u003e= 1.5."
                    },
                    "groupattr": {
                        "type": "string",
                        "description": "LDAP attribute to follow on objects returned by \u003cgroupfilter\u003e in order to enumerate user group membership. Examples:\n\"cn\" or \"memberOf\", etc. Default: cn\n"
                    },
                    "groupdn": {
                        "type": "string",
                        "description": "LDAP search base to use for group membership search (eg: ou=Groups,dc=example,dc=org)\n"
                    },
                    "groupfilter": {
                        "type": "string",
                        "description": "Go template for querying group membership of user. The template can access the following context variables: UserDN,\nUsername Example: (\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}})) Default:\n(|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}}))\n"
                    },
                    "insecureTls": {
                        "type": "boolean",
                        "description": "Skip LDAP server SSL Certificate verification - insecure and not recommended for production use.\n"
                    },
                    "lastRotationTolerance": {
                        "type": "integer",
                        "description": "The number of seconds after a Vault rotation where, if Active Directory shows a later rotation, it should be considered\nout-of-band.\n"
                    },
                    "length": {
                        "type": "integer",
                        "description": "The desired length of passwords that Vault generates.\n",
                        "deprecationMessage": "Length is deprecated and password_policy should be used with Vault \u003e= 1.5."
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Mark the secrets engine as local-only. Local engines are not replicated or removed by replication.Tolerance duration to\nuse when checking the last rotation time.\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "Maximum possible lease duration for secrets in seconds.\n"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "In seconds, the maximum password time-to-live.\n"
                    },
                    "passwordPolicy": {
                        "type": "string",
                        "description": "Name of the password policy to use to generate passwords.\n"
                    },
                    "requestTimeout": {
                        "type": "integer",
                        "description": "Timeout, in seconds, for the connection when making requests against the server before returning back an error.\n"
                    },
                    "starttls": {
                        "type": "boolean",
                        "description": "Issue a StartTLS command after establishing unencrypted connection.\n"
                    },
                    "tlsMaxVersion": {
                        "type": "string",
                        "description": "Maximum TLS version to use. Accepted values are 'tls10', 'tls11', 'tls12' or 'tls13'. Defaults to 'tls12'\n"
                    },
                    "tlsMinVersion": {
                        "type": "string",
                        "description": "Minimum TLS version to use. Accepted values are 'tls10', 'tls11', 'tls12' or 'tls13'. Defaults to 'tls12'\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "In seconds, the default password time-to-live.\n"
                    },
                    "upndomain": {
                        "type": "string",
                        "description": "Enables userPrincipalDomain login with [username]@UPNDomain.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "LDAP URL to connect to (default: ldap://127.0.0.1). Multiple URLs can be specified by concatenating them with commas;\nthey will be tried in-order.\n"
                    },
                    "usePre111GroupCnBehavior": {
                        "type": "boolean",
                        "description": "In Vault 1.1.1 a fix for handling group CN values of different cases unfortunately introduced a regression that could\ncause previously defined groups to not be found due to a change in the resulting name. If set true, the pre-1.1.1\nbehavior for matching group CNs will be used. This is only needed in some upgrade scenarios for backwards compatibility.\nIt is enabled by default if the config is upgraded but disabled by default on new configurations.\n"
                    },
                    "useTokenGroups": {
                        "type": "boolean",
                        "description": "If true, use the Active Directory tokenGroups constructed attribute of the user to find the group memberships. This will\nfind all security groups including nested ones.\n"
                    },
                    "userattr": {
                        "type": "string",
                        "description": "Attribute used for users (default: cn)\n"
                    },
                    "userdn": {
                        "type": "string",
                        "description": "LDAP domain to use for users (eg: ou=People,dc=example,dc=org)\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:ad/secretLibrary:SecretLibrary": {
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The mount path for the AD backend.\n"
                },
                "disableCheckInEnforcement": {
                    "type": "boolean",
                    "description": "Disable enforcing that service accounts must be checked in by the entity or client token that checked them out.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum amount of time, in seconds, a check-out last with renewal before Vault automatically checks it back in.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the set of service accounts.\n"
                },
                "serviceAccountNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The names of all the service accounts that can be checked out from this set. These service accounts must already exist\nin Active Directory.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The amount of time, in seconds, a single check-out lasts before Vault automatically checks it back in.\n"
                }
            },
            "required": [
                "backend",
                "maxTtl",
                "name",
                "serviceAccountNames",
                "ttl"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The mount path for the AD backend.\n"
                },
                "disableCheckInEnforcement": {
                    "type": "boolean",
                    "description": "Disable enforcing that service accounts must be checked in by the entity or client token that checked them out.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum amount of time, in seconds, a check-out last with renewal before Vault automatically checks it back in.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the set of service accounts.\n"
                },
                "serviceAccountNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The names of all the service accounts that can be checked out from this set. These service accounts must already exist\nin Active Directory.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The amount of time, in seconds, a single check-out lasts before Vault automatically checks it back in.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "serviceAccountNames"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretLibrary resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The mount path for the AD backend.\n"
                    },
                    "disableCheckInEnforcement": {
                        "type": "boolean",
                        "description": "Disable enforcing that service accounts must be checked in by the entity or client token that checked them out.\n"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "The maximum amount of time, in seconds, a check-out last with renewal before Vault automatically checks it back in.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the set of service accounts.\n"
                    },
                    "serviceAccountNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The names of all the service accounts that can be checked out from this set. These service accounts must already exist\nin Active Directory.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "The amount of time, in seconds, a single check-out lasts before Vault automatically checks it back in.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:ad/secretRole:SecretRole": {
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The mount path for the AD backend.\n"
                },
                "lastVaultRotation": {
                    "type": "string",
                    "description": "Last time Vault rotated this service account's password.\n"
                },
                "passwordLastSet": {
                    "type": "string",
                    "description": "Last time Vault set this service account's password.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the role.\n"
                },
                "serviceAccountName": {
                    "type": "string",
                    "description": "The username/logon name for the service account with which this role will be associated.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "In seconds, the default password time-to-live.\n"
                }
            },
            "required": [
                "backend",
                "lastVaultRotation",
                "passwordLastSet",
                "role",
                "serviceAccountName"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The mount path for the AD backend.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the role.\n"
                },
                "serviceAccountName": {
                    "type": "string",
                    "description": "The username/logon name for the service account with which this role will be associated.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "In seconds, the default password time-to-live.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "role",
                "serviceAccountName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The mount path for the AD backend.\n"
                    },
                    "lastVaultRotation": {
                        "type": "string",
                        "description": "Last time Vault rotated this service account's password.\n"
                    },
                    "passwordLastSet": {
                        "type": "string",
                        "description": "Last time Vault set this service account's password.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "Name of the role.\n"
                    },
                    "serviceAccountName": {
                        "type": "string",
                        "description": "The username/logon name for the service account with which this role will be associated.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "In seconds, the default password time-to-live.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:alicloud/authBackendRole:AuthBackendRole": {
            "properties": {
                "arn": {
                    "type": "string",
                    "description": "The role's arn.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Auth backend.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the role. Must correspond with the name of the role reflected in the arn.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n"
                }
            },
            "required": [
                "arn",
                "role"
            ],
            "inputProperties": {
                "arn": {
                    "type": "string",
                    "description": "The role's arn.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Auth backend.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the role. Must correspond with the name of the role reflected in the arn.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n"
                }
            },
            "requiredInputs": [
                "arn",
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "arn": {
                        "type": "string",
                        "description": "The role's arn.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "Auth backend.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "Name of the role. Must correspond with the name of the role reflected in the arn.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime of the generated token\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "Generated Token's Period\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Generated Token's Policies\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The initial ttl of the token to generate in seconds\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token to generate, service or batch\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:appRole/authBackendLogin:AuthBackendLogin": {
            "description": "Logs into Vault using the AppRole auth backend. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/approle.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst approle = new vault.AuthBackend(\"approle\", {\n    type: \"approle\",\n});\nconst example = new vault.appRole.AuthBackendRole(\"example\", {\n    backend: approle.path,\n    policies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    roleName: \"test-role\",\n});\nconst id = new vault.appRole.AuthBackendRoleSecretID(\"id\", {\n    backend: approle.path,\n    roleName: example.roleName,\n});\nconst login = new vault.appRole.AuthBackendLogin(\"login\", {\n    backend: approle.path,\n    roleId: example.roleId,\n    secretId: id.secretId,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\napprole = vault.AuthBackend(\"approle\", type=\"approle\")\nexample = vault.app_role.AuthBackendRole(\"example\",\n    backend=approle.path,\n    policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    role_name=\"test-role\")\nid = vault.app_role.AuthBackendRoleSecretID(\"id\",\n    backend=approle.path,\n    role_name=example.role_name)\nlogin = vault.app_role.AuthBackendLogin(\"login\",\n    backend=approle.path,\n    role_id=example.role_id,\n    secret_id=id.secret_id)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var approle = new Vault.AuthBackend(\"approle\", new Vault.AuthBackendArgs\n        {\n            Type = \"approle\",\n        });\n        var example = new Vault.AppRole.AuthBackendRole(\"example\", new Vault.AppRole.AuthBackendRoleArgs\n        {\n            Backend = approle.Path,\n            Policies = \n            {\n                \"default\",\n                \"dev\",\n                \"prod\",\n            },\n            RoleName = \"test-role\",\n        });\n        var id = new Vault.AppRole.AuthBackendRoleSecretID(\"id\", new Vault.AppRole.AuthBackendRoleSecretIDArgs\n        {\n            Backend = approle.Path,\n            RoleName = example.RoleName,\n        });\n        var login = new Vault.AppRole.AuthBackendLogin(\"login\", new Vault.AppRole.AuthBackendLoginArgs\n        {\n            Backend = approle.Path,\n            RoleId = example.RoleId,\n            SecretId = id.SecretId,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/appRole\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tapprole, err := vault.NewAuthBackend(ctx, \"approle\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"approle\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texample, err := appRole.NewAuthBackendRole(ctx, \"example\", \u0026appRole.AuthBackendRoleArgs{\n\t\t\tBackend: approle.Path,\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t\tRoleName: pulumi.String(\"test-role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tid, err := appRole.NewAuthBackendRoleSecretID(ctx, \"id\", \u0026appRole.AuthBackendRoleSecretIDArgs{\n\t\t\tBackend:  approle.Path,\n\t\t\tRoleName: example.RoleName,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = appRole.NewAuthBackendLogin(ctx, \"login\", \u0026appRole.AuthBackendLoginArgs{\n\t\t\tBackend:  approle.Path,\n\t\t\tRoleId:   example.RoleId,\n\t\t\tSecretId: id.SecretId,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The accessor for the token.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique path of the Vault backend to log in with.\n"
                },
                "clientToken": {
                    "type": "string",
                    "description": "The Vault token created.\n"
                },
                "leaseDuration": {
                    "type": "integer",
                    "description": "How long the token is valid for, in seconds.\n"
                },
                "leaseStarted": {
                    "type": "string",
                    "description": "The date and time the lease started, in RFC 3339 format.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The metadata associated with the token.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of policies applied to the token.\n"
                },
                "renewable": {
                    "type": "boolean",
                    "description": "Whether the token is renewable or not.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "The ID of the role to log in with.\n"
                },
                "secretId": {
                    "type": "string",
                    "description": "The secret ID of the role to log in with. Required\nunless `bind_secret_id` is set to false on the role.\n"
                }
            },
            "required": [
                "accessor",
                "clientToken",
                "leaseDuration",
                "leaseStarted",
                "metadata",
                "policies",
                "renewable",
                "roleId"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The unique path of the Vault backend to log in with.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "The ID of the role to log in with.\n"
                },
                "secretId": {
                    "type": "string",
                    "description": "The secret ID of the role to log in with. Required\nunless `bind_secret_id` is set to false on the role.\n"
                }
            },
            "requiredInputs": [
                "roleId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendLogin resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The accessor for the token.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The unique path of the Vault backend to log in with.\n"
                    },
                    "clientToken": {
                        "type": "string",
                        "description": "The Vault token created.\n"
                    },
                    "leaseDuration": {
                        "type": "integer",
                        "description": "How long the token is valid for, in seconds.\n"
                    },
                    "leaseStarted": {
                        "type": "string",
                        "description": "The date and time the lease started, in RFC 3339 format.\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "The metadata associated with the token.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of policies applied to the token.\n"
                    },
                    "renewable": {
                        "type": "boolean",
                        "description": "Whether the token is renewable or not.\n"
                    },
                    "roleId": {
                        "type": "string",
                        "description": "The ID of the role to log in with.\n"
                    },
                    "secretId": {
                        "type": "string",
                        "description": "The secret ID of the role to log in with. Required\nunless `bind_secret_id` is set to false on the role.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:appRole/authBackendRole:AuthBackendRole": {
            "description": "Manages an AppRole auth backend role in a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/approle.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst approle = new vault.AuthBackend(\"approle\", {\n    type: \"approle\",\n});\nconst example = new vault.appRole.AuthBackendRole(\"example\", {\n    backend: approle.path,\n    policies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    roleName: \"test-role\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\napprole = vault.AuthBackend(\"approle\", type=\"approle\")\nexample = vault.app_role.AuthBackendRole(\"example\",\n    backend=approle.path,\n    policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    role_name=\"test-role\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var approle = new Vault.AuthBackend(\"approle\", new Vault.AuthBackendArgs\n        {\n            Type = \"approle\",\n        });\n        var example = new Vault.AppRole.AuthBackendRole(\"example\", new Vault.AppRole.AuthBackendRoleArgs\n        {\n            Backend = approle.Path,\n            Policies = \n            {\n                \"default\",\n                \"dev\",\n                \"prod\",\n            },\n            RoleName = \"test-role\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/appRole\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tapprole, err := vault.NewAuthBackend(ctx, \"approle\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"approle\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = appRole.NewAuthBackendRole(ctx, \"example\", \u0026appRole.AuthBackendRoleArgs{\n\t\t\tBackend: approle.Path,\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t\tRoleName: pulumi.String(\"test-role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAppRole authentication backend roles can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:appRole/authBackendRole:AuthBackendRole example auth/approle/role/test-role\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of the auth backend to configure.\nDefaults to `approle`.\n"
                },
                "bindSecretId": {
                    "type": "boolean",
                    "description": "Whether or not to require `secret_id` to be\npresented when logging in using this AppRole. Defaults to `true`.\n"
                },
                "boundCidrLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, specifies blocks of IP addresses which\ncan perform the login operation.\n",
                    "deprecationMessage": "use `secret_id_bound_cidrs` instead"
                },
                "period": {
                    "type": "integer",
                    "description": "If set, indicates that the token generated using this\nrole should never expire. The token should be renewed within the duration\nspecified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. The maximum allowed lifetime of token issued using this\nrole. Specified as a number of seconds.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings specifying the policies to be set\non tokens issued using this role.\n",
                    "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                },
                "roleId": {
                    "type": "string",
                    "description": "The RoleID of this role. If not specified, one will be\nauto-generated.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "secretIdBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks that can log in using the AppRole.\n"
                },
                "secretIdNumUses": {
                    "type": "integer",
                    "description": "The number of times any particular SecretID\ncan be used to fetch a token from this AppRole, after which the SecretID will\nexpire. A value of zero will allow unlimited uses.\n"
                },
                "secretIdTtl": {
                    "type": "integer",
                    "description": "The number of seconds after which any SecretID\nexpires.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum allowed lifetime of tokens issued\nusing this role, provided as a number of seconds.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The number of times issued tokens can be used.\nA value of 0 means unlimited uses.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The TTL period of tokens issued using this role,\nprovided as a number of seconds.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n"
                }
            },
            "required": [
                "roleId",
                "roleName"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of the auth backend to configure.\nDefaults to `approle`.\n"
                },
                "bindSecretId": {
                    "type": "boolean",
                    "description": "Whether or not to require `secret_id` to be\npresented when logging in using this AppRole. Defaults to `true`.\n"
                },
                "boundCidrLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, specifies blocks of IP addresses which\ncan perform the login operation.\n",
                    "deprecationMessage": "use `secret_id_bound_cidrs` instead"
                },
                "period": {
                    "type": "integer",
                    "description": "If set, indicates that the token generated using this\nrole should never expire. The token should be renewed within the duration\nspecified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. The maximum allowed lifetime of token issued using this\nrole. Specified as a number of seconds.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings specifying the policies to be set\non tokens issued using this role.\n",
                    "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                },
                "roleId": {
                    "type": "string",
                    "description": "The RoleID of this role. If not specified, one will be\nauto-generated.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "secretIdBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDR blocks that can log in using the AppRole.\n"
                },
                "secretIdNumUses": {
                    "type": "integer",
                    "description": "The number of times any particular SecretID\ncan be used to fetch a token from this AppRole, after which the SecretID will\nexpire. A value of zero will allow unlimited uses.\n"
                },
                "secretIdTtl": {
                    "type": "integer",
                    "description": "The number of seconds after which any SecretID\nexpires.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum allowed lifetime of tokens issued\nusing this role, provided as a number of seconds.\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The number of times issued tokens can be used.\nA value of 0 means unlimited uses.\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The TTL period of tokens issued using this role,\nprovided as a number of seconds.\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n"
                }
            },
            "requiredInputs": [
                "roleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The unique name of the auth backend to configure.\nDefaults to `approle`.\n"
                    },
                    "bindSecretId": {
                        "type": "boolean",
                        "description": "Whether or not to require `secret_id` to be\npresented when logging in using this AppRole. Defaults to `true`.\n"
                    },
                    "boundCidrLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, specifies blocks of IP addresses which\ncan perform the login operation.\n",
                        "deprecationMessage": "use `secret_id_bound_cidrs` instead"
                    },
                    "period": {
                        "type": "integer",
                        "description": "If set, indicates that the token generated using this\nrole should never expire. The token should be renewed within the duration\nspecified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. The maximum allowed lifetime of token issued using this\nrole. Specified as a number of seconds.\n",
                        "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of strings specifying the policies to be set\non tokens issued using this role.\n",
                        "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                    },
                    "roleId": {
                        "type": "string",
                        "description": "The RoleID of this role. If not specified, one will be\nauto-generated.\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "secretIdBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDR blocks that can log in using the AppRole.\n"
                    },
                    "secretIdNumUses": {
                        "type": "integer",
                        "description": "The number of times any particular SecretID\ncan be used to fetch a token from this AppRole, after which the SecretID will\nexpire. A value of zero will allow unlimited uses.\n"
                    },
                    "secretIdTtl": {
                        "type": "integer",
                        "description": "The number of seconds after which any SecretID\nexpires.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum allowed lifetime of tokens issued\nusing this role, provided as a number of seconds.\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The number of times issued tokens can be used.\nA value of 0 means unlimited uses.\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "Generated Token's Period\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Generated Token's Policies\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The TTL period of tokens issued using this role,\nprovided as a number of seconds.\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token to generate, service or batch\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:appRole/authBackendRoleSecretID:AuthBackendRoleSecretID": {
            "description": "Manages an AppRole auth backend SecretID in a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/approle.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst approle = new vault.AuthBackend(\"approle\", {\n    type: \"approle\",\n});\nconst example = new vault.appRole.AuthBackendRole(\"example\", {\n    backend: approle.path,\n    policies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    roleName: \"test-role\",\n});\nconst id = new vault.appRole.AuthBackendRoleSecretID(\"id\", {\n    backend: approle.path,\n    metadata: `{\n  \"hello\": \"world\"\n}\n`,\n    roleName: example.roleName,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\napprole = vault.AuthBackend(\"approle\", type=\"approle\")\nexample = vault.app_role.AuthBackendRole(\"example\",\n    backend=approle.path,\n    policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    role_name=\"test-role\")\nid = vault.app_role.AuthBackendRoleSecretID(\"id\",\n    backend=approle.path,\n    metadata=\"\"\"{\n  \"hello\": \"world\"\n}\n\n\"\"\",\n    role_name=example.role_name)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var approle = new Vault.AuthBackend(\"approle\", new Vault.AuthBackendArgs\n        {\n            Type = \"approle\",\n        });\n        var example = new Vault.AppRole.AuthBackendRole(\"example\", new Vault.AppRole.AuthBackendRoleArgs\n        {\n            Backend = approle.Path,\n            Policies = \n            {\n                \"default\",\n                \"dev\",\n                \"prod\",\n            },\n            RoleName = \"test-role\",\n        });\n        var id = new Vault.AppRole.AuthBackendRoleSecretID(\"id\", new Vault.AppRole.AuthBackendRoleSecretIDArgs\n        {\n            Backend = approle.Path,\n            Metadata = @\"{\n  \"\"hello\"\": \"\"world\"\"\n}\n\n\",\n            RoleName = example.RoleName,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/appRole\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tapprole, err := vault.NewAuthBackend(ctx, \"approle\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"approle\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texample, err := appRole.NewAuthBackendRole(ctx, \"example\", \u0026appRole.AuthBackendRoleArgs{\n\t\t\tBackend: approle.Path,\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t\tRoleName: pulumi.String(\"test-role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = appRole.NewAuthBackendRoleSecretID(ctx, \"id\", \u0026appRole.AuthBackendRoleSecretIDArgs{\n\t\t\tBackend:  approle.Path,\n\t\t\tMetadata: pulumi.String(fmt.Sprintf(\"%v%v%v%v\", \"{\\n\", \"  \\\"hello\\\": \\\"world\\\"\\n\", \"}\\n\", \"\\n\")),\n\t\t\tRoleName: example.RoleName,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The unique ID for this SecretID that can be safely logged.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Unique name of the auth backend to configure.\n"
                },
                "cidrLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, specifies blocks of IP addresses which can\nperform the login operation using this SecretID.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "A JSON-encoded string containing metadata in\nkey-value pairs to be set on tokens issued with this SecretID.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role to create the SecretID for.\n"
                },
                "secretId": {
                    "type": "string",
                    "description": "The SecretID to be created. If set, uses \"Push\"\nmode.  Defaults to Vault auto-generating SecretIDs.\n"
                },
                "wrappingAccessor": {
                    "type": "string",
                    "description": "The wrapped SecretID accessor.\n"
                },
                "wrappingToken": {
                    "type": "string",
                    "description": "The wrapped SecretID token.\n"
                },
                "wrappingTtl": {
                    "type": "string",
                    "description": "The TTL duration of the wrapped SecretID.\n"
                }
            },
            "required": [
                "accessor",
                "roleName",
                "secretId",
                "wrappingAccessor",
                "wrappingToken"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Unique name of the auth backend to configure.\n"
                },
                "cidrLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, specifies blocks of IP addresses which can\nperform the login operation using this SecretID.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "A JSON-encoded string containing metadata in\nkey-value pairs to be set on tokens issued with this SecretID.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role to create the SecretID for.\n"
                },
                "secretId": {
                    "type": "string",
                    "description": "The SecretID to be created. If set, uses \"Push\"\nmode.  Defaults to Vault auto-generating SecretIDs.\n"
                },
                "wrappingTtl": {
                    "type": "string",
                    "description": "The TTL duration of the wrapped SecretID.\n"
                }
            },
            "requiredInputs": [
                "roleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRoleSecretID resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The unique ID for this SecretID that can be safely logged.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "Unique name of the auth backend to configure.\n"
                    },
                    "cidrLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, specifies blocks of IP addresses which can\nperform the login operation using this SecretID.\n"
                    },
                    "metadata": {
                        "type": "string",
                        "description": "A JSON-encoded string containing metadata in\nkey-value pairs to be set on tokens issued with this SecretID.\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role to create the SecretID for.\n"
                    },
                    "secretId": {
                        "type": "string",
                        "description": "The SecretID to be created. If set, uses \"Push\"\nmode.  Defaults to Vault auto-generating SecretIDs.\n"
                    },
                    "wrappingAccessor": {
                        "type": "string",
                        "description": "The wrapped SecretID accessor.\n"
                    },
                    "wrappingToken": {
                        "type": "string",
                        "description": "The wrapped SecretID token.\n"
                    },
                    "wrappingTtl": {
                        "type": "string",
                        "description": "The TTL duration of the wrapped SecretID.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendCert:AuthBackendCert": {
            "description": "\n\n\n## Import\n\nAWS auth backend certificates can be imported using `auth/`, the `backend` path, `/config/certificate/`, and the `cert_name` e.g.\n\n```sh\n $ pulumi import vault:aws/authBackendCert:AuthBackendCert example auth/aws/config/certificate/my-cert\n```\n\n ",
            "properties": {
                "awsPublicCert": {
                    "type": "string",
                    "description": "The  Base64 encoded AWS Public key required to\nverify PKCS7 signature of the EC2 instance metadata. You can find this key in\nthe [AWS\ndocumentation](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-identity-documents.html).\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                },
                "certName": {
                    "type": "string",
                    "description": "The name of the certificate.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Either \"pkcs7\" or \"identity\", indicating the type of\ndocument which can be verified using the given certificate. Defaults to\n\"pkcs7\".\n"
                }
            },
            "required": [
                "awsPublicCert",
                "certName"
            ],
            "inputProperties": {
                "awsPublicCert": {
                    "type": "string",
                    "description": "The  Base64 encoded AWS Public key required to\nverify PKCS7 signature of the EC2 instance metadata. You can find this key in\nthe [AWS\ndocumentation](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-identity-documents.html).\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                },
                "certName": {
                    "type": "string",
                    "description": "The name of the certificate.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Either \"pkcs7\" or \"identity\", indicating the type of\ndocument which can be verified using the given certificate. Defaults to\n\"pkcs7\".\n"
                }
            },
            "requiredInputs": [
                "awsPublicCert",
                "certName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendCert resources.\n",
                "properties": {
                    "awsPublicCert": {
                        "type": "string",
                        "description": "The  Base64 encoded AWS Public key required to\nverify PKCS7 signature of the EC2 instance metadata. You can find this key in\nthe [AWS\ndocumentation](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-identity-documents.html).\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                    },
                    "certName": {
                        "type": "string",
                        "description": "The name of the certificate.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Either \"pkcs7\" or \"identity\", indicating the type of\ndocument which can be verified using the given certificate. Defaults to\n\"pkcs7\".\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendClient:AuthBackendClient": {
            "description": "\n\n\n## Import\n\nAWS auth backend clients can be imported using `auth/`, the `backend` path, and `/config/client` e.g.\n\n```sh\n $ pulumi import vault:aws/authBackendClient:AuthBackendClient example auth/aws/config/client\n```\n\n ",
            "properties": {
                "accessKey": {
                    "type": "string",
                    "description": "The AWS access key that Vault should use for the\nauth backend.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                },
                "ec2Endpoint": {
                    "type": "string",
                    "description": "Override the URL Vault uses when making EC2 API\ncalls.\n"
                },
                "iamEndpoint": {
                    "type": "string",
                    "description": "Override the URL Vault uses when making IAM API\ncalls.\n"
                },
                "iamServerIdHeaderValue": {
                    "type": "string",
                    "description": "The value to require in the\n`X-Vault-AWS-IAM-Server-ID` header as part of `GetCallerIdentity` requests\nthat are used in the IAM auth method.\n"
                },
                "secretKey": {
                    "type": "string",
                    "description": "The AWS secret key that Vault should use for the\nauth backend.\n"
                },
                "stsEndpoint": {
                    "type": "string",
                    "description": "Override the URL Vault uses when making STS API\ncalls.\n"
                },
                "stsRegion": {
                    "type": "string",
                    "description": "Region to override the default region for making AWS STS API calls.\n"
                }
            },
            "inputProperties": {
                "accessKey": {
                    "type": "string",
                    "description": "The AWS access key that Vault should use for the\nauth backend.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                },
                "ec2Endpoint": {
                    "type": "string",
                    "description": "Override the URL Vault uses when making EC2 API\ncalls.\n"
                },
                "iamEndpoint": {
                    "type": "string",
                    "description": "Override the URL Vault uses when making IAM API\ncalls.\n"
                },
                "iamServerIdHeaderValue": {
                    "type": "string",
                    "description": "The value to require in the\n`X-Vault-AWS-IAM-Server-ID` header as part of `GetCallerIdentity` requests\nthat are used in the IAM auth method.\n"
                },
                "secretKey": {
                    "type": "string",
                    "description": "The AWS secret key that Vault should use for the\nauth backend.\n"
                },
                "stsEndpoint": {
                    "type": "string",
                    "description": "Override the URL Vault uses when making STS API\ncalls.\n"
                },
                "stsRegion": {
                    "type": "string",
                    "description": "Region to override the default region for making AWS STS API calls.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendClient resources.\n",
                "properties": {
                    "accessKey": {
                        "type": "string",
                        "description": "The AWS access key that Vault should use for the\nauth backend.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                    },
                    "ec2Endpoint": {
                        "type": "string",
                        "description": "Override the URL Vault uses when making EC2 API\ncalls.\n"
                    },
                    "iamEndpoint": {
                        "type": "string",
                        "description": "Override the URL Vault uses when making IAM API\ncalls.\n"
                    },
                    "iamServerIdHeaderValue": {
                        "type": "string",
                        "description": "The value to require in the\n`X-Vault-AWS-IAM-Server-ID` header as part of `GetCallerIdentity` requests\nthat are used in the IAM auth method.\n"
                    },
                    "secretKey": {
                        "type": "string",
                        "description": "The AWS secret key that Vault should use for the\nauth backend.\n"
                    },
                    "stsEndpoint": {
                        "type": "string",
                        "description": "Override the URL Vault uses when making STS API\ncalls.\n"
                    },
                    "stsRegion": {
                        "type": "string",
                        "description": "Region to override the default region for making AWS STS API calls.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendIdentityWhitelist:AuthBackendIdentityWhitelist": {
            "description": "Configures the periodic tidying operation of the whitelisted identity entries.\n\nFor more information, see the\n[Vault docs](https://www.vaultproject.io/api/auth/aws/index.html#configure-identity-whitelist-tidy-operation).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst exampleAuthBackend = new vault.AuthBackend(\"example\", {\n    type: \"aws\",\n});\nconst exampleAuthBackendIdentityWhitelist = new vault.aws.AuthBackendIdentityWhitelist(\"example\", {\n    backend: exampleAuthBackend.path,\n    safetyBuffer: 3600,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample_auth_backend = vault.AuthBackend(\"exampleAuthBackend\", type=\"aws\")\nexample_auth_backend_identity_whitelist = vault.aws.AuthBackendIdentityWhitelist(\"exampleAuthBackendIdentityWhitelist\",\n    backend=example_auth_backend.path,\n    safety_buffer=3600)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleAuthBackend = new Vault.AuthBackend(\"exampleAuthBackend\", new Vault.AuthBackendArgs\n        {\n            Type = \"aws\",\n        });\n        var exampleAuthBackendIdentityWhitelist = new Vault.Aws.AuthBackendIdentityWhitelist(\"exampleAuthBackendIdentityWhitelist\", new Vault.Aws.AuthBackendIdentityWhitelistArgs\n        {\n            Backend = exampleAuthBackend.Path,\n            SafetyBuffer = 3600,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/aws\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleAuthBackend, err := vault.NewAuthBackend(ctx, \"exampleAuthBackend\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"aws\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = aws.NewAuthBackendIdentityWhitelist(ctx, \"exampleAuthBackendIdentityWhitelist\", \u0026aws.AuthBackendIdentityWhitelistArgs{\n\t\t\tBackend:      exampleAuthBackend.Path,\n\t\t\tSafetyBuffer: pulumi.Int(3600),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAWS auth backend identity whitelists can be imported using `auth/`, the `backend` path, and `/config/tidy/identity-whitelist` e.g.\n\n```sh\n $ pulumi import vault:aws/authBackendIdentityWhitelist:AuthBackendIdentityWhitelist example auth/aws/config/tidy/identity-whitelist\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path of the AWS backend being configured.\n"
                },
                "disablePeriodicTidy": {
                    "type": "boolean",
                    "description": "If set to true, disables the periodic\ntidying of the identity-whitelist entries.\n"
                },
                "safetyBuffer": {
                    "type": "integer",
                    "description": "The amount of extra time, in minutes, that must\nhave passed beyond the roletag expiration, before it is removed from the\nbackend storage.\n"
                }
            },
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path of the AWS backend being configured.\n"
                },
                "disablePeriodicTidy": {
                    "type": "boolean",
                    "description": "If set to true, disables the periodic\ntidying of the identity-whitelist entries.\n"
                },
                "safetyBuffer": {
                    "type": "integer",
                    "description": "The amount of extra time, in minutes, that must\nhave passed beyond the roletag expiration, before it is removed from the\nbackend storage.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendIdentityWhitelist resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path of the AWS backend being configured.\n"
                    },
                    "disablePeriodicTidy": {
                        "type": "boolean",
                        "description": "If set to true, disables the periodic\ntidying of the identity-whitelist entries.\n"
                    },
                    "safetyBuffer": {
                        "type": "integer",
                        "description": "The amount of extra time, in minutes, that must\nhave passed beyond the roletag expiration, before it is removed from the\nbackend storage.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendLogin:AuthBackendLogin": {
            "description": "Logs into a Vault server using an AWS auth backend. Login can be\naccomplished using a signed identity request from IAM or using ec2\ninstance metadata. For more information, see the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/aws.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst aws = new vault.AuthBackend(\"aws\", {\n    type: \"aws\",\n});\nconst exampleAuthBackendClient = new vault.aws.AuthBackendClient(\"example\", {\n    accessKey: \"123456789012\",\n    backend: aws.path,\n    secretKey: \"AWSSECRETKEYGOESHERE\",\n});\nconst exampleAuthBackendRole = new vault.aws.AuthBackendRole(\"example\", {\n    authType: \"ec2\",\n    backend: aws.path,\n    boundAccountId: \"123456789012\",\n    boundAmiId: \"ami-8c1be5f6\",\n    boundIamInstanceProfileArn: \"arn:aws:iam::123456789012:instance-profile/MyProfile\",\n    boundSubnetId: \"vpc-133128f1\",\n    boundVpcId: \"vpc-b61106d4\",\n    maxTtl: 120,\n    policies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    role: \"test-role\",\n    ttl: 60,\n}, { dependsOn: [exampleAuthBackendClient] });\nconst exampleAuthBackendLogin = new vault.aws.AuthBackendLogin(\"example\", {\n    backend: vault_auth_backend_example.path,\n    identity: \"BASE64ENCODEDIDENTITYDOCUMENT\",\n    role: exampleAuthBackendRole.role,\n    signature: \"BASE64ENCODEDSHA256IDENTITYDOCUMENTSIGNATURE\",\n});\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The token's accessor.\n"
                },
                "authType": {
                    "type": "string",
                    "description": "The authentication type used to generate this token.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique name of the AWS auth backend. Defaults to\n'aws'.\n"
                },
                "clientToken": {
                    "type": "string",
                    "description": "The token returned by Vault.\n"
                },
                "iamHttpRequestMethod": {
                    "type": "string",
                    "description": "The HTTP method used in the signed IAM\nrequest.\n"
                },
                "iamRequestBody": {
                    "type": "string",
                    "description": "The base64-encoded body of the signed\nrequest.\n"
                },
                "iamRequestHeaders": {
                    "type": "string",
                    "description": "The base64-encoded, JSON serialized\nrepresentation of the GetCallerIdentity HTTP request headers.\n"
                },
                "iamRequestUrl": {
                    "type": "string",
                    "description": "The base64-encoded HTTP URL used in the signed\nrequest.\n"
                },
                "identity": {
                    "type": "string",
                    "description": "The base64-encoded EC2 instance identity document to\nauthenticate with. Can be retrieved from the EC2 metadata server.\n"
                },
                "leaseDuration": {
                    "type": "integer",
                    "description": "The duration in seconds the token will be valid, relative\nto the time in `lease_start_time`.\n"
                },
                "leaseStartTime": {
                    "type": "string",
                    "description": "Time at which the lease was read, using the clock of the system where Terraform was running\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of information returned by the Vault server about the\nauthentication used to generate this token.\n"
                },
                "nonce": {
                    "type": "string",
                    "description": "The unique nonce to be used for login requests. Can be\nset to a user-specified value, or will contain the server-generated value\nonce a token is issued. EC2 instances can only acquire a single token until\nthe whitelist is tidied again unless they keep track of this nonce.\n"
                },
                "pkcs7": {
                    "type": "string",
                    "description": "The PKCS#7 signature of the identity document to\nauthenticate with, with all newline characters removed. Can be retrieved from\nthe EC2 metadata server.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The Vault policies assigned to this token.\n"
                },
                "renewable": {
                    "type": "boolean",
                    "description": "Set to true if the token can be extended through renewal.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the AWS auth backend role to create tokens\nagainst.\n"
                },
                "signature": {
                    "type": "string",
                    "description": "The base64-encoded SHA256 RSA signature of the\ninstance identity document to authenticate with, with all newline characters\nremoved. Can be retrieved from the EC2 metadata server.\n"
                }
            },
            "required": [
                "accessor",
                "authType",
                "clientToken",
                "leaseDuration",
                "leaseStartTime",
                "metadata",
                "nonce",
                "policies",
                "renewable",
                "role"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of the AWS auth backend. Defaults to\n'aws'.\n"
                },
                "iamHttpRequestMethod": {
                    "type": "string",
                    "description": "The HTTP method used in the signed IAM\nrequest.\n"
                },
                "iamRequestBody": {
                    "type": "string",
                    "description": "The base64-encoded body of the signed\nrequest.\n"
                },
                "iamRequestHeaders": {
                    "type": "string",
                    "description": "The base64-encoded, JSON serialized\nrepresentation of the GetCallerIdentity HTTP request headers.\n"
                },
                "iamRequestUrl": {
                    "type": "string",
                    "description": "The base64-encoded HTTP URL used in the signed\nrequest.\n"
                },
                "identity": {
                    "type": "string",
                    "description": "The base64-encoded EC2 instance identity document to\nauthenticate with. Can be retrieved from the EC2 metadata server.\n"
                },
                "nonce": {
                    "type": "string",
                    "description": "The unique nonce to be used for login requests. Can be\nset to a user-specified value, or will contain the server-generated value\nonce a token is issued. EC2 instances can only acquire a single token until\nthe whitelist is tidied again unless they keep track of this nonce.\n"
                },
                "pkcs7": {
                    "type": "string",
                    "description": "The PKCS#7 signature of the identity document to\nauthenticate with, with all newline characters removed. Can be retrieved from\nthe EC2 metadata server.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the AWS auth backend role to create tokens\nagainst.\n"
                },
                "signature": {
                    "type": "string",
                    "description": "The base64-encoded SHA256 RSA signature of the\ninstance identity document to authenticate with, with all newline characters\nremoved. Can be retrieved from the EC2 metadata server.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendLogin resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The token's accessor.\n"
                    },
                    "authType": {
                        "type": "string",
                        "description": "The authentication type used to generate this token.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The unique name of the AWS auth backend. Defaults to\n'aws'.\n"
                    },
                    "clientToken": {
                        "type": "string",
                        "description": "The token returned by Vault.\n"
                    },
                    "iamHttpRequestMethod": {
                        "type": "string",
                        "description": "The HTTP method used in the signed IAM\nrequest.\n"
                    },
                    "iamRequestBody": {
                        "type": "string",
                        "description": "The base64-encoded body of the signed\nrequest.\n"
                    },
                    "iamRequestHeaders": {
                        "type": "string",
                        "description": "The base64-encoded, JSON serialized\nrepresentation of the GetCallerIdentity HTTP request headers.\n"
                    },
                    "iamRequestUrl": {
                        "type": "string",
                        "description": "The base64-encoded HTTP URL used in the signed\nrequest.\n"
                    },
                    "identity": {
                        "type": "string",
                        "description": "The base64-encoded EC2 instance identity document to\nauthenticate with. Can be retrieved from the EC2 metadata server.\n"
                    },
                    "leaseDuration": {
                        "type": "integer",
                        "description": "The duration in seconds the token will be valid, relative\nto the time in `lease_start_time`.\n"
                    },
                    "leaseStartTime": {
                        "type": "string",
                        "description": "Time at which the lease was read, using the clock of the system where Terraform was running\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A map of information returned by the Vault server about the\nauthentication used to generate this token.\n"
                    },
                    "nonce": {
                        "type": "string",
                        "description": "The unique nonce to be used for login requests. Can be\nset to a user-specified value, or will contain the server-generated value\nonce a token is issued. EC2 instances can only acquire a single token until\nthe whitelist is tidied again unless they keep track of this nonce.\n"
                    },
                    "pkcs7": {
                        "type": "string",
                        "description": "The PKCS#7 signature of the identity document to\nauthenticate with, with all newline characters removed. Can be retrieved from\nthe EC2 metadata server.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The Vault policies assigned to this token.\n"
                    },
                    "renewable": {
                        "type": "boolean",
                        "description": "Set to true if the token can be extended through renewal.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the AWS auth backend role to create tokens\nagainst.\n"
                    },
                    "signature": {
                        "type": "string",
                        "description": "The base64-encoded SHA256 RSA signature of the\ninstance identity document to authenticate with, with all newline characters\nremoved. Can be retrieved from the EC2 metadata server.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendRole:AuthBackendRole": {
            "description": "Manages an AWS auth backend role in a Vault server. Roles constrain the\ninstances or principals that can perform the login operation against the\nbackend. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/aws.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst aws = new vault.AuthBackend(\"aws\", {\n    type: \"aws\",\n});\nconst example = new vault.aws.AuthBackendRole(\"example\", {\n    authType: \"iam\",\n    backend: aws.path,\n    boundAccountIds: [\"123456789012\"],\n    boundAmiIds: [\"ami-8c1be5f6\"],\n    boundIamInstanceProfileArns: [\"arn:aws:iam::123456789012:instance-profile/MyProfile\"],\n    boundIamRoleArns: [\"arn:aws:iam::123456789012:role/MyRole\"],\n    boundSubnetIds: [\"vpc-133128f1\"],\n    boundVpcIds: [\"vpc-b61106d4\"],\n    inferredAwsRegion: \"us-east-1\",\n    inferredEntityType: \"ec2_instance\",\n    maxTtl: 120,\n    policies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    role: \"test-role\",\n    ttl: 60,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\naws = vault.AuthBackend(\"aws\", type=\"aws\")\nexample = vault.aws.AuthBackendRole(\"example\",\n    auth_type=\"iam\",\n    backend=aws.path,\n    bound_account_ids=[\"123456789012\"],\n    bound_ami_ids=[\"ami-8c1be5f6\"],\n    bound_iam_instance_profile_arns=[\"arn:aws:iam::123456789012:instance-profile/MyProfile\"],\n    bound_iam_role_arns=[\"arn:aws:iam::123456789012:role/MyRole\"],\n    bound_subnet_ids=[\"vpc-133128f1\"],\n    bound_vpc_ids=[\"vpc-b61106d4\"],\n    inferred_aws_region=\"us-east-1\",\n    inferred_entity_type=\"ec2_instance\",\n    max_ttl=120,\n    policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    role=\"test-role\",\n    ttl=60)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var aws = new Vault.AuthBackend(\"aws\", new Vault.AuthBackendArgs\n        {\n            Type = \"aws\",\n        });\n        var example = new Vault.Aws.AuthBackendRole(\"example\", new Vault.Aws.AuthBackendRoleArgs\n        {\n            AuthType = \"iam\",\n            Backend = aws.Path,\n            BoundAccountIds = \n            {\n                \"123456789012\",\n            },\n            BoundAmiIds = \n            {\n                \"ami-8c1be5f6\",\n            },\n            BoundIamInstanceProfileArns = \n            {\n                \"arn:aws:iam::123456789012:instance-profile/MyProfile\",\n            },\n            BoundIamRoleArns = \n            {\n                \"arn:aws:iam::123456789012:role/MyRole\",\n            },\n            BoundSubnetIds = \n            {\n                \"vpc-133128f1\",\n            },\n            BoundVpcIds = \n            {\n                \"vpc-b61106d4\",\n            },\n            InferredAwsRegion = \"us-east-1\",\n            InferredEntityType = \"ec2_instance\",\n            MaxTtl = 120,\n            Policies = \n            {\n                \"default\",\n                \"dev\",\n                \"prod\",\n            },\n            Role = \"test-role\",\n            Ttl = 60,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/aws\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\taws, err := vault.NewAuthBackend(ctx, \"aws\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"aws\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = aws.NewAuthBackendRole(ctx, \"example\", \u0026aws.AuthBackendRoleArgs{\n\t\t\tAuthType: pulumi.String(\"iam\"),\n\t\t\tBackend:  aws.Path,\n\t\t\tBoundAccountIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"123456789012\"),\n\t\t\t},\n\t\t\tBoundAmiIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"ami-8c1be5f6\"),\n\t\t\t},\n\t\t\tBoundIamInstanceProfileArns: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"arn:aws:iam::123456789012:instance-profile/MyProfile\"),\n\t\t\t},\n\t\t\tBoundIamRoleArns: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"arn:aws:iam::123456789012:role/MyRole\"),\n\t\t\t},\n\t\t\tBoundSubnetIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vpc-133128f1\"),\n\t\t\t},\n\t\t\tBoundVpcIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vpc-b61106d4\"),\n\t\t\t},\n\t\t\tInferredAwsRegion:  pulumi.String(\"us-east-1\"),\n\t\t\tInferredEntityType: pulumi.String(\"ec2_instance\"),\n\t\t\tMaxTtl:             pulumi.Int(120),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t\tRole: pulumi.String(\"test-role\"),\n\t\t\tTtl:  pulumi.Int(60),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAWS auth backend roles can be imported using `auth/`, the `backend` path, `/role/`, and the `role` name e.g.\n\n```sh\n $ pulumi import vault:aws/authBackendRole:AuthBackendRole example auth/aws/role/test-role\n```\n\n ",
            "properties": {
                "allowInstanceMigration": {
                    "type": "boolean",
                    "description": "If set to `true`, allows migration of\nthe underlying instance where the client resides.\n"
                },
                "authType": {
                    "type": "string",
                    "description": "The auth type permitted for this role. Valid choices\nare `ec2` and `iam`. Defaults to `iam`.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Unique name of the auth backend to configure.\n"
                },
                "boundAccountIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they should be using the\naccount ID specified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundAmiIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they should be using the AMI ID\nspecified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundEc2InstanceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Only EC2 instances that match this instance ID will be permitted to log in.\n"
                },
                "boundIamInstanceProfileArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on\nthe EC2 instances that can perform the login operation that they must be\nassociated with an IAM instance profile ARN which has a prefix that matches\nthe value specified by this field. The value is prefix-matched as though it\nwere a glob ending in `*`. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundIamPrincipalArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines the IAM principal that\nmust be authenticated when `auth_type` is set to `iam`. Wildcards are\nsupported at the end of the ARN.\n"
                },
                "boundIamRoleArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they must match the IAM\nrole ARN specified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that the region in their identity\ndocument must match the one specified by this field. `auth_type` must be set\nto `ec2` or `inferred_entity_type` must be set to `ec2_instance` to use this\nconstraint.\n"
                },
                "boundSubnetIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they be associated with\nthe subnet ID that matches the value specified by this field. `auth_type`\nmust be set to `ec2` or `inferred_entity_type` must be set to `ec2_instance`\nto use this constraint.\n"
                },
                "boundVpcIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they be associated with the VPC ID\nthat matches the value specified by this field. `auth_type` must be set to\n`ec2` or `inferred_entity_type` must be set to `ec2_instance` to use this\nconstraint.\n"
                },
                "disallowReauthentication": {
                    "type": "boolean",
                    "description": "IF set to `true`, only allows a\nsingle token to be granted per instance ID. This can only be set when\n`auth_type` is set to `ec2`.\n"
                },
                "inferredAwsRegion": {
                    "type": "string",
                    "description": "When `inferred_entity_type` is set, this\nis the region to search for the inferred entities. Required if\n`inferred_entity_type` is set. This only applies when `auth_type` is set to\n`iam`.\n"
                },
                "inferredEntityType": {
                    "type": "string",
                    "description": "If set, instructs Vault to turn on\ninferencing. The only valid value is `ec2_instance`, which instructs Vault to\ninfer that the role comes from an EC2 instance in an IAM instance profile.\nThis only applies when `auth_type` is set to `iam`.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum allowed lifetime of tokens issued using\nthis role, provided as a number of seconds.\n",
                    "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "period": {
                    "type": "integer",
                    "description": "If set, indicates that the token generated using this\nrole should never expire. The token should be renewed within the duration\nspecified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. The maximum allowed lifetime of token issued using this\nrole. Specified as a number of seconds.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings specifying the policies to be set\non tokens issued using this role.\n",
                    "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                },
                "resolveAwsUniqueIds": {
                    "type": "boolean",
                    "description": "If set to `true`, the\n`bound_iam_principal_arns` are resolved to [AWS Unique\nIDs](http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-unique-ids)\nfor the bound principal ARN. This field is ignored when a\n`bound_iam_principal_arn` ends in a wildcard. Resolving to unique IDs more\nclosely mimics the behavior of AWS services in that if an IAM user or role is\ndeleted and a new one is recreated with the same name, those new users or\nroles won't get access to roles in Vault that were permissioned to the prior\nprincipals of the same name. Defaults to `true`.\nOnce set to `true`, this cannot be changed to `false` without recreating the role.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "roleTag": {
                    "type": "string",
                    "description": "If set, enable role tags for this role. The value set\nfor this field should be the key of the tag on the EC2 instance. `auth_type`\nmust be set to `ec2` or `inferred_entity_type` must be set to `ec2_instance`\nto use this constraint.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The TTL period of tokens issued using this role, provided\nas a number of seconds.\n",
                    "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                }
            },
            "required": [
                "role"
            ],
            "inputProperties": {
                "allowInstanceMigration": {
                    "type": "boolean",
                    "description": "If set to `true`, allows migration of\nthe underlying instance where the client resides.\n"
                },
                "authType": {
                    "type": "string",
                    "description": "The auth type permitted for this role. Valid choices\nare `ec2` and `iam`. Defaults to `iam`.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Unique name of the auth backend to configure.\n"
                },
                "boundAccountIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they should be using the\naccount ID specified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundAmiIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they should be using the AMI ID\nspecified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundEc2InstanceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Only EC2 instances that match this instance ID will be permitted to log in.\n"
                },
                "boundIamInstanceProfileArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on\nthe EC2 instances that can perform the login operation that they must be\nassociated with an IAM instance profile ARN which has a prefix that matches\nthe value specified by this field. The value is prefix-matched as though it\nwere a glob ending in `*`. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundIamPrincipalArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines the IAM principal that\nmust be authenticated when `auth_type` is set to `iam`. Wildcards are\nsupported at the end of the ARN.\n"
                },
                "boundIamRoleArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they must match the IAM\nrole ARN specified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                },
                "boundRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that the region in their identity\ndocument must match the one specified by this field. `auth_type` must be set\nto `ec2` or `inferred_entity_type` must be set to `ec2_instance` to use this\nconstraint.\n"
                },
                "boundSubnetIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they be associated with\nthe subnet ID that matches the value specified by this field. `auth_type`\nmust be set to `ec2` or `inferred_entity_type` must be set to `ec2_instance`\nto use this constraint.\n"
                },
                "boundVpcIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they be associated with the VPC ID\nthat matches the value specified by this field. `auth_type` must be set to\n`ec2` or `inferred_entity_type` must be set to `ec2_instance` to use this\nconstraint.\n"
                },
                "disallowReauthentication": {
                    "type": "boolean",
                    "description": "IF set to `true`, only allows a\nsingle token to be granted per instance ID. This can only be set when\n`auth_type` is set to `ec2`.\n"
                },
                "inferredAwsRegion": {
                    "type": "string",
                    "description": "When `inferred_entity_type` is set, this\nis the region to search for the inferred entities. Required if\n`inferred_entity_type` is set. This only applies when `auth_type` is set to\n`iam`.\n"
                },
                "inferredEntityType": {
                    "type": "string",
                    "description": "If set, instructs Vault to turn on\ninferencing. The only valid value is `ec2_instance`, which instructs Vault to\ninfer that the role comes from an EC2 instance in an IAM instance profile.\nThis only applies when `auth_type` is set to `iam`.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum allowed lifetime of tokens issued using\nthis role, provided as a number of seconds.\n",
                    "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "period": {
                    "type": "integer",
                    "description": "If set, indicates that the token generated using this\nrole should never expire. The token should be renewed within the duration\nspecified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. The maximum allowed lifetime of token issued using this\nrole. Specified as a number of seconds.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings specifying the policies to be set\non tokens issued using this role.\n",
                    "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                },
                "resolveAwsUniqueIds": {
                    "type": "boolean",
                    "description": "If set to `true`, the\n`bound_iam_principal_arns` are resolved to [AWS Unique\nIDs](http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-unique-ids)\nfor the bound principal ARN. This field is ignored when a\n`bound_iam_principal_arn` ends in a wildcard. Resolving to unique IDs more\nclosely mimics the behavior of AWS services in that if an IAM user or role is\ndeleted and a new one is recreated with the same name, those new users or\nroles won't get access to roles in Vault that were permissioned to the prior\nprincipals of the same name. Defaults to `true`.\nOnce set to `true`, this cannot be changed to `false` without recreating the role.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "roleTag": {
                    "type": "string",
                    "description": "If set, enable role tags for this role. The value set\nfor this field should be the key of the tag on the EC2 instance. `auth_type`\nmust be set to `ec2` or `inferred_entity_type` must be set to `ec2_instance`\nto use this constraint.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The TTL period of tokens issued using this role, provided\nas a number of seconds.\n",
                    "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                }
            },
            "requiredInputs": [
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "allowInstanceMigration": {
                        "type": "boolean",
                        "description": "If set to `true`, allows migration of\nthe underlying instance where the client resides.\n"
                    },
                    "authType": {
                        "type": "string",
                        "description": "The auth type permitted for this role. Valid choices\nare `ec2` and `iam`. Defaults to `iam`.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "Unique name of the auth backend to configure.\n"
                    },
                    "boundAccountIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they should be using the\naccount ID specified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                    },
                    "boundAmiIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they should be using the AMI ID\nspecified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                    },
                    "boundEc2InstanceIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Only EC2 instances that match this instance ID will be permitted to log in.\n"
                    },
                    "boundIamInstanceProfileArns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on\nthe EC2 instances that can perform the login operation that they must be\nassociated with an IAM instance profile ARN which has a prefix that matches\nthe value specified by this field. The value is prefix-matched as though it\nwere a glob ending in `*`. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                    },
                    "boundIamPrincipalArns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines the IAM principal that\nmust be authenticated when `auth_type` is set to `iam`. Wildcards are\nsupported at the end of the ARN.\n"
                    },
                    "boundIamRoleArns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they must match the IAM\nrole ARN specified by this field. `auth_type` must be set to `ec2` or\n`inferred_entity_type` must be set to `ec2_instance` to use this constraint.\n"
                    },
                    "boundRegions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that the region in their identity\ndocument must match the one specified by this field. `auth_type` must be set\nto `ec2` or `inferred_entity_type` must be set to `ec2_instance` to use this\nconstraint.\n"
                    },
                    "boundSubnetIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they be associated with\nthe subnet ID that matches the value specified by this field. `auth_type`\nmust be set to `ec2` or `inferred_entity_type` must be set to `ec2_instance`\nto use this constraint.\n"
                    },
                    "boundVpcIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they be associated with the VPC ID\nthat matches the value specified by this field. `auth_type` must be set to\n`ec2` or `inferred_entity_type` must be set to `ec2_instance` to use this\nconstraint.\n"
                    },
                    "disallowReauthentication": {
                        "type": "boolean",
                        "description": "IF set to `true`, only allows a\nsingle token to be granted per instance ID. This can only be set when\n`auth_type` is set to `ec2`.\n"
                    },
                    "inferredAwsRegion": {
                        "type": "string",
                        "description": "When `inferred_entity_type` is set, this\nis the region to search for the inferred entities. Required if\n`inferred_entity_type` is set. This only applies when `auth_type` is set to\n`iam`.\n"
                    },
                    "inferredEntityType": {
                        "type": "string",
                        "description": "If set, instructs Vault to turn on\ninferencing. The only valid value is `ec2_instance`, which instructs Vault to\ninfer that the role comes from an EC2 instance in an IAM instance profile.\nThis only applies when `auth_type` is set to `iam`.\n"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "The maximum allowed lifetime of tokens issued using\nthis role, provided as a number of seconds.\n",
                        "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                    },
                    "period": {
                        "type": "integer",
                        "description": "If set, indicates that the token generated using this\nrole should never expire. The token should be renewed within the duration\nspecified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. The maximum allowed lifetime of token issued using this\nrole. Specified as a number of seconds.\n",
                        "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of strings specifying the policies to be set\non tokens issued using this role.\n",
                        "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                    },
                    "resolveAwsUniqueIds": {
                        "type": "boolean",
                        "description": "If set to `true`, the\n`bound_iam_principal_arns` are resolved to [AWS Unique\nIDs](http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-unique-ids)\nfor the bound principal ARN. This field is ignored when a\n`bound_iam_principal_arn` ends in a wildcard. Resolving to unique IDs more\nclosely mimics the behavior of AWS services in that if an IAM user or role is\ndeleted and a new one is recreated with the same name, those new users or\nroles won't get access to roles in Vault that were permissioned to the prior\nprincipals of the same name. Defaults to `true`.\nOnce set to `true`, this cannot be changed to `false` without recreating the role.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "roleTag": {
                        "type": "string",
                        "description": "If set, enable role tags for this role. The value set\nfor this field should be the key of the tag on the EC2 instance. `auth_type`\nmust be set to `ec2` or `inferred_entity_type` must be set to `ec2_instance`\nto use this constraint.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime of the generated token\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "Generated Token's Period\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Generated Token's Policies\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The initial ttl of the token to generate in seconds\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token to generate, service or batch\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "The TTL period of tokens issued using this role, provided\nas a number of seconds.\n",
                        "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendRoleTag:AuthBackendRoleTag": {
            "description": "Reads role tag information from an AWS auth backend in Vault. \n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst aws = new vault.AuthBackend(\"aws\", {\n    path: \"%s\",\n    type: \"aws\",\n});\nconst role = new vault.aws.AuthBackendRole(\"role\", {\n    authType: \"ec2\",\n    backend: aws.path,\n    boundAccountId: \"123456789012\",\n    policies: [\n        \"dev\",\n        \"prod\",\n        \"qa\",\n        \"test\",\n    ],\n    role: \"%s\",\n    roleTag: \"VaultRoleTag\",\n});\nconst test = new vault.aws.AuthBackendRoleTag(\"test\", {\n    backend: aws.path,\n    instanceId: \"i-1234567\",\n    maxTtl: \"1h\",\n    policies: [\n        \"prod\",\n        \"dev\",\n        \"test\",\n    ],\n    role: role.role,\n});\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "allowInstanceMigration": {
                    "type": "boolean",
                    "description": "If set, allows migration of the underlying instances where the client resides. Use with caution.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path to the AWS auth backend to\nread role tags from, with no leading or trailing `/`s. Defaults to \"aws\".\n"
                },
                "disallowReauthentication": {
                    "type": "boolean",
                    "description": "If set, only allows a single token to be granted per instance ID.\n"
                },
                "instanceId": {
                    "type": "string",
                    "description": "Instance ID for which this tag is intended for. If set, the created tag can only be used by the instance with the given ID.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "The maximum TTL of the tokens issued using this role.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The policies to be associated with the tag. Must be a subset of the policies associated with the role.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the AWS auth backend role to read\nrole tags from, with no leading or trailing `/`s.\n"
                },
                "tagKey": {
                    "type": "string",
                    "description": "The key of the role tag.\n"
                },
                "tagValue": {
                    "type": "string",
                    "description": "The value to set the role key.\n"
                }
            },
            "required": [
                "role",
                "tagKey",
                "tagValue"
            ],
            "inputProperties": {
                "allowInstanceMigration": {
                    "type": "boolean",
                    "description": "If set, allows migration of the underlying instances where the client resides. Use with caution.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path to the AWS auth backend to\nread role tags from, with no leading or trailing `/`s. Defaults to \"aws\".\n"
                },
                "disallowReauthentication": {
                    "type": "boolean",
                    "description": "If set, only allows a single token to be granted per instance ID.\n"
                },
                "instanceId": {
                    "type": "string",
                    "description": "Instance ID for which this tag is intended for. If set, the created tag can only be used by the instance with the given ID.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "The maximum TTL of the tokens issued using this role.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The policies to be associated with the tag. Must be a subset of the policies associated with the role.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the AWS auth backend role to read\nrole tags from, with no leading or trailing `/`s.\n"
                }
            },
            "requiredInputs": [
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRoleTag resources.\n",
                "properties": {
                    "allowInstanceMigration": {
                        "type": "boolean",
                        "description": "If set, allows migration of the underlying instances where the client resides. Use with caution.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path to the AWS auth backend to\nread role tags from, with no leading or trailing `/`s. Defaults to \"aws\".\n"
                    },
                    "disallowReauthentication": {
                        "type": "boolean",
                        "description": "If set, only allows a single token to be granted per instance ID.\n"
                    },
                    "instanceId": {
                        "type": "string",
                        "description": "Instance ID for which this tag is intended for. If set, the created tag can only be used by the instance with the given ID.\n"
                    },
                    "maxTtl": {
                        "type": "string",
                        "description": "The maximum TTL of the tokens issued using this role.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The policies to be associated with the tag. Must be a subset of the policies associated with the role.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the AWS auth backend role to read\nrole tags from, with no leading or trailing `/`s.\n"
                    },
                    "tagKey": {
                        "type": "string",
                        "description": "The key of the role tag.\n"
                    },
                    "tagValue": {
                        "type": "string",
                        "description": "The value to set the role key.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendRoletagBlacklist:AuthBackendRoletagBlacklist": {
            "description": "Configures the periodic tidying operation of the blacklisted role tag entries.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst exampleAuthBackend = new vault.AuthBackend(\"example\", {\n    type: \"aws\",\n});\nconst exampleAuthBackendRoletagBlacklist = new vault.aws.AuthBackendRoletagBlacklist(\"example\", {\n    backend: exampleAuthBackend.path,\n    safetyBuffer: 360,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample_auth_backend = vault.AuthBackend(\"exampleAuthBackend\", type=\"aws\")\nexample_auth_backend_roletag_blacklist = vault.aws.AuthBackendRoletagBlacklist(\"exampleAuthBackendRoletagBlacklist\",\n    backend=example_auth_backend.path,\n    safety_buffer=360)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleAuthBackend = new Vault.AuthBackend(\"exampleAuthBackend\", new Vault.AuthBackendArgs\n        {\n            Type = \"aws\",\n        });\n        var exampleAuthBackendRoletagBlacklist = new Vault.Aws.AuthBackendRoletagBlacklist(\"exampleAuthBackendRoletagBlacklist\", new Vault.Aws.AuthBackendRoletagBlacklistArgs\n        {\n            Backend = exampleAuthBackend.Path,\n            SafetyBuffer = 360,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/aws\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleAuthBackend, err := vault.NewAuthBackend(ctx, \"exampleAuthBackend\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"aws\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = aws.NewAuthBackendRoletagBlacklist(ctx, \"exampleAuthBackendRoletagBlacklist\", \u0026aws.AuthBackendRoletagBlacklistArgs{\n\t\t\tBackend:      exampleAuthBackend.Path,\n\t\t\tSafetyBuffer: pulumi.Int(360),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.\n"
                },
                "disablePeriodicTidy": {
                    "type": "boolean",
                    "description": "If set to true, disables the periodic\ntidying of the roletag blacklist entries. Defaults to false.\n"
                },
                "safetyBuffer": {
                    "type": "integer",
                    "description": "The amount of extra time that must have passed\nbeyond the roletag expiration, before it is removed from the backend storage.\nDefaults to 259,200 seconds, or 72 hours.\n"
                }
            },
            "required": [
                "backend"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.\n"
                },
                "disablePeriodicTidy": {
                    "type": "boolean",
                    "description": "If set to true, disables the periodic\ntidying of the roletag blacklist entries. Defaults to false.\n"
                },
                "safetyBuffer": {
                    "type": "integer",
                    "description": "The amount of extra time that must have passed\nbeyond the roletag expiration, before it is removed from the backend storage.\nDefaults to 259,200 seconds, or 72 hours.\n"
                }
            },
            "requiredInputs": [
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRoletagBlacklist resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the AWS auth backend being configured was\nmounted at.\n"
                    },
                    "disablePeriodicTidy": {
                        "type": "boolean",
                        "description": "If set to true, disables the periodic\ntidying of the roletag blacklist entries. Defaults to false.\n"
                    },
                    "safetyBuffer": {
                        "type": "integer",
                        "description": "The amount of extra time that must have passed\nbeyond the roletag expiration, before it is removed from the backend storage.\nDefaults to 259,200 seconds, or 72 hours.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/authBackendStsRole:AuthBackendStsRole": {
            "description": "\n\n\n## Import\n\nAWS auth backend STS roles can be imported using `auth/`, the `backend` path, `/config/sts/`, and the `account_id` e.g.\n\n```sh\n $ pulumi import vault:aws/authBackendStsRole:AuthBackendStsRole example auth/aws/config/sts/1234567890\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The AWS account ID to configure the STS role for.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                },
                "stsRole": {
                    "type": "string",
                    "description": "The STS role to assume when verifying requests made\nby EC2 instances in the account specified by `account_id`.\n"
                }
            },
            "required": [
                "accountId",
                "stsRole"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The AWS account ID to configure the STS role for.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                },
                "stsRole": {
                    "type": "string",
                    "description": "The STS role to assume when verifying requests made\nby EC2 instances in the account specified by `account_id`.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "stsRole"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendStsRole resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The AWS account ID to configure the STS role for.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path the AWS auth backend being configured was\nmounted at.  Defaults to `aws`.\n"
                    },
                    "stsRole": {
                        "type": "string",
                        "description": "The STS role to assume when verifying requests made\nby EC2 instances in the account specified by `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/secretBackend:SecretBackend": {
            "description": "\n\n\n## Import\n\nAWS secret backends can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:aws/secretBackend:SecretBackend aws aws\n```\n\n ",
            "properties": {
                "accessKey": {
                    "type": "string",
                    "description": "The AWS Access Key ID this backend should use to\nissue new credentials.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials\nissued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `aws`.\n"
                },
                "region": {
                    "type": "string",
                    "description": "The AWS region for API calls. Defaults to `us-east-1`.\n"
                },
                "secretKey": {
                    "type": "string",
                    "description": "The AWS Secret Key this backend should use to\nissue new credentials.\n"
                }
            },
            "required": [
                "defaultLeaseTtlSeconds",
                "maxLeaseTtlSeconds",
                "region"
            ],
            "inputProperties": {
                "accessKey": {
                    "type": "string",
                    "description": "The AWS Access Key ID this backend should use to\nissue new credentials.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials\nissued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `aws`.\n"
                },
                "region": {
                    "type": "string",
                    "description": "The AWS region for API calls. Defaults to `us-east-1`.\n"
                },
                "secretKey": {
                    "type": "string",
                    "description": "The AWS Secret Key this backend should use to\nissue new credentials.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackend resources.\n",
                "properties": {
                    "accessKey": {
                        "type": "string",
                        "description": "The AWS Access Key ID this backend should use to\nissue new credentials.\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The default TTL for credentials\nissued by this backend.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A human-friendly description for this backend.\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `aws`.\n"
                    },
                    "region": {
                        "type": "string",
                        "description": "The AWS region for API calls. Defaults to `us-east-1`.\n"
                    },
                    "secretKey": {
                        "type": "string",
                        "description": "The AWS Secret Key this backend should use to\nissue new credentials.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:aws/secretBackendRole:SecretBackendRole": {
            "description": "\n\n\n## Import\n\nAWS secret backend roles can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:aws/secretBackendRole:SecretBackendRole role aws/roles/deploy\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path the AWS secret backend is mounted at,\nwith no leading or trailing `/`s.\n"
                },
                "credentialType": {
                    "type": "string",
                    "description": "Specifies the type of credential to be used when \nretrieving credentials from the role. Must be one of `iam_user`, `assumed_role`, or\n`federation_token`.\n"
                },
                "defaultStsTtl": {
                    "type": "integer",
                    "description": "The default TTL in seconds for STS credentials. When a TTL is not specified when STS credentials are requested, and a\ndefault TTL is specified on the role, then this default TTL will be used. Valid only when credential_type is one of\nassumed_role or federation_token.\n"
                },
                "iamGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of IAM group names. IAM users generated against this vault role will be added to these IAM Groups. For a\ncredential type of assumed_role or federation_token, the policies sent to the corresponding AWS call (sts:AssumeRole or\nsts:GetFederation) will be the policies from each group in iam_groups combined with the policy_document and policy_arns\nparameters.\n"
                },
                "maxStsTtl": {
                    "type": "integer",
                    "description": "The max allowed TTL in seconds for STS credentials (credentials TTL are capped to max_sts_ttl). Valid only when\ncredential_type is one of assumed_role or federation_token.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n"
                },
                "policyArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ARN for a pre-existing policy to associate\nwith this role. Either `policy_document` or `policy_arns` must be specified.\n"
                },
                "policyDocument": {
                    "type": "string",
                    "description": "The JSON-formatted policy to associate with this\nrole. Either `policy_document` or `policy_arns` must be specified.\n"
                },
                "roleArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the ARNs of the AWS roles this Vault role\nis allowed to assume. Required when `credential_type` is `assumed_role` and\nprohibited otherwise.\n"
                }
            },
            "required": [
                "backend",
                "credentialType",
                "defaultStsTtl",
                "maxStsTtl",
                "name"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path the AWS secret backend is mounted at,\nwith no leading or trailing `/`s.\n"
                },
                "credentialType": {
                    "type": "string",
                    "description": "Specifies the type of credential to be used when \nretrieving credentials from the role. Must be one of `iam_user`, `assumed_role`, or\n`federation_token`.\n"
                },
                "defaultStsTtl": {
                    "type": "integer",
                    "description": "The default TTL in seconds for STS credentials. When a TTL is not specified when STS credentials are requested, and a\ndefault TTL is specified on the role, then this default TTL will be used. Valid only when credential_type is one of\nassumed_role or federation_token.\n"
                },
                "iamGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of IAM group names. IAM users generated against this vault role will be added to these IAM Groups. For a\ncredential type of assumed_role or federation_token, the policies sent to the corresponding AWS call (sts:AssumeRole or\nsts:GetFederation) will be the policies from each group in iam_groups combined with the policy_document and policy_arns\nparameters.\n"
                },
                "maxStsTtl": {
                    "type": "integer",
                    "description": "The max allowed TTL in seconds for STS credentials (credentials TTL are capped to max_sts_ttl). Valid only when\ncredential_type is one of assumed_role or federation_token.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n"
                },
                "policyArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ARN for a pre-existing policy to associate\nwith this role. Either `policy_document` or `policy_arns` must be specified.\n"
                },
                "policyDocument": {
                    "type": "string",
                    "description": "The JSON-formatted policy to associate with this\nrole. Either `policy_document` or `policy_arns` must be specified.\n"
                },
                "roleArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the ARNs of the AWS roles this Vault role\nis allowed to assume. Required when `credential_type` is `assumed_role` and\nprohibited otherwise.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "credentialType"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the AWS secret backend is mounted at,\nwith no leading or trailing `/`s.\n"
                    },
                    "credentialType": {
                        "type": "string",
                        "description": "Specifies the type of credential to be used when \nretrieving credentials from the role. Must be one of `iam_user`, `assumed_role`, or\n`federation_token`.\n"
                    },
                    "defaultStsTtl": {
                        "type": "integer",
                        "description": "The default TTL in seconds for STS credentials. When a TTL is not specified when STS credentials are requested, and a\ndefault TTL is specified on the role, then this default TTL will be used. Valid only when credential_type is one of\nassumed_role or federation_token.\n"
                    },
                    "iamGroups": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of IAM group names. IAM users generated against this vault role will be added to these IAM Groups. For a\ncredential type of assumed_role or federation_token, the policies sent to the corresponding AWS call (sts:AssumeRole or\nsts:GetFederation) will be the policies from each group in iam_groups combined with the policy_document and policy_arns\nparameters.\n"
                    },
                    "maxStsTtl": {
                        "type": "integer",
                        "description": "The max allowed TTL in seconds for STS credentials (credentials TTL are capped to max_sts_ttl). Valid only when\ncredential_type is one of assumed_role or federation_token.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n"
                    },
                    "policyArns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The ARN for a pre-existing policy to associate\nwith this role. Either `policy_document` or `policy_arns` must be specified.\n"
                    },
                    "policyDocument": {
                        "type": "string",
                        "description": "The JSON-formatted policy to associate with this\nrole. Either `policy_document` or `policy_arns` must be specified.\n"
                    },
                    "roleArns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the ARNs of the AWS roles this Vault role\nis allowed to assume. Required when `credential_type` is `assumed_role` and\nprohibited otherwise.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:azure/authBackendConfig:AuthBackendConfig": {
            "description": "\n\n\n## Import\n\nAzure auth backends can be imported using `auth/`, the `backend` path, and `/config` e.g.\n\n```sh\n $ pulumi import vault:azure/authBackendConfig:AuthBackendConfig example auth/azure/config\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path the Azure auth backend being configured was\nmounted at.  Defaults to `azure`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client id for credentials to query the Azure APIs.\nCurrently read permissions to query compute resources are required.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client secret for credentials to query the\nAzure APIs.\n"
                },
                "environment": {
                    "type": "string",
                    "description": "The Azure cloud environment. Valid values:\nAzurePublicCloud, AzureUSGovernmentCloud, AzureChinaCloud,\nAzureGermanCloud.  Defaults to `AzurePublicCloud`.\n"
                },
                "resource": {
                    "type": "string",
                    "description": "The configured URL for the application registered in\nAzure Active Directory.\n"
                },
                "tenantId": {
                    "type": "string",
                    "description": "The tenant id for the Azure Active Directory\norganization.\n"
                }
            },
            "required": [
                "resource",
                "tenantId"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path the Azure auth backend being configured was\nmounted at.  Defaults to `azure`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client id for credentials to query the Azure APIs.\nCurrently read permissions to query compute resources are required.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client secret for credentials to query the\nAzure APIs.\n"
                },
                "environment": {
                    "type": "string",
                    "description": "The Azure cloud environment. Valid values:\nAzurePublicCloud, AzureUSGovernmentCloud, AzureChinaCloud,\nAzureGermanCloud.  Defaults to `AzurePublicCloud`.\n"
                },
                "resource": {
                    "type": "string",
                    "description": "The configured URL for the application registered in\nAzure Active Directory.\n"
                },
                "tenantId": {
                    "type": "string",
                    "description": "The tenant id for the Azure Active Directory\norganization.\n"
                }
            },
            "requiredInputs": [
                "resource",
                "tenantId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendConfig resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the Azure auth backend being configured was\nmounted at.  Defaults to `azure`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client id for credentials to query the Azure APIs.\nCurrently read permissions to query compute resources are required.\n"
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "The client secret for credentials to query the\nAzure APIs.\n"
                    },
                    "environment": {
                        "type": "string",
                        "description": "The Azure cloud environment. Valid values:\nAzurePublicCloud, AzureUSGovernmentCloud, AzureChinaCloud,\nAzureGermanCloud.  Defaults to `AzurePublicCloud`.\n"
                    },
                    "resource": {
                        "type": "string",
                        "description": "The configured URL for the application registered in\nAzure Active Directory.\n"
                    },
                    "tenantId": {
                        "type": "string",
                        "description": "The tenant id for the Azure Active Directory\norganization.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:azure/authBackendRole:AuthBackendRole": {
            "description": "Manages an Azure auth backend role in a Vault server. Roles constrain the\ninstances or principals that can perform the login operation against the\nbackend. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/azure.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst azure = new vault.AuthBackend(\"azure\", {\n    type: \"azure\",\n});\nconst example = new vault.azure.AuthBackendRole(\"example\", {\n    backend: azure.path,\n    boundResourceGroups: [\"123456789012\"],\n    boundSubscriptionIds: [\"11111111-2222-3333-4444-555555555555\"],\n    maxTtl: 120,\n    policies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    role: \"test-role\",\n    ttl: 60,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nazure = vault.AuthBackend(\"azure\", type=\"azure\")\nexample = vault.azure.AuthBackendRole(\"example\",\n    backend=azure.path,\n    bound_resource_groups=[\"123456789012\"],\n    bound_subscription_ids=[\"11111111-2222-3333-4444-555555555555\"],\n    max_ttl=120,\n    policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    role=\"test-role\",\n    ttl=60)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var azure = new Vault.AuthBackend(\"azure\", new Vault.AuthBackendArgs\n        {\n            Type = \"azure\",\n        });\n        var example = new Vault.Azure.AuthBackendRole(\"example\", new Vault.Azure.AuthBackendRoleArgs\n        {\n            Backend = azure.Path,\n            BoundResourceGroups = \n            {\n                \"123456789012\",\n            },\n            BoundSubscriptionIds = \n            {\n                \"11111111-2222-3333-4444-555555555555\",\n            },\n            MaxTtl = 120,\n            Policies = \n            {\n                \"default\",\n                \"dev\",\n                \"prod\",\n            },\n            Role = \"test-role\",\n            Ttl = 60,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/azure\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tazure, err := vault.NewAuthBackend(ctx, \"azure\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"azure\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = azure.NewAuthBackendRole(ctx, \"example\", \u0026azure.AuthBackendRoleArgs{\n\t\t\tBackend: azure.Path,\n\t\t\tBoundResourceGroups: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"123456789012\"),\n\t\t\t},\n\t\t\tBoundSubscriptionIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"11111111-2222-3333-4444-555555555555\"),\n\t\t\t},\n\t\t\tMaxTtl: pulumi.Int(120),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t\tRole: pulumi.String(\"test-role\"),\n\t\t\tTtl:  pulumi.Int(60),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAzure auth backend roles can be imported using `auth/`, the `backend` path, `/role/`, and the `role` name e.g.\n\n```sh\n $ pulumi import vault:azure/authBackendRole:AuthBackendRole example auth/azure/role/test-role\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Unique name of the auth backend to configure.\n"
                },
                "boundGroupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the groups\nthat can perform the login operation that they should be using the group\nID specified by this field.\n"
                },
                "boundLocations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the virtual machines\nthat can perform the login operation that the location in their identity\ndocument must match the one specified by this field.\n"
                },
                "boundResourceGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the virtual\nmachiness that can perform the login operation that they be associated with\nthe resource group that matches the value specified by this field.\n"
                },
                "boundScaleSets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the virtual\nmachines that can perform the login operation that they must match the scale set\nspecified by this field.\n"
                },
                "boundServicePrincipalIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the\nservice principals that can perform the login operation that they should be posess\nthe ids specified by this field.\n"
                },
                "boundSubscriptionIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the subscriptions\nthat can perform the login operation to ones which  matches the value specified by this\nfield.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum allowed lifetime of tokens issued using\nthis role, provided as a number of seconds.\n",
                    "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "period": {
                    "type": "integer",
                    "description": "If set, indicates that the token generated using this\nrole should never expire. The token should be renewed within the duration\nspecified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. The maximum allowed lifetime of token issued using this\nrole. Specified as a number of seconds.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings specifying the policies to be set\non tokens issued using this role.\n",
                    "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The TTL period of tokens issued using this role, provided\nas a number of seconds.\n",
                    "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                }
            },
            "required": [
                "role"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Unique name of the auth backend to configure.\n"
                },
                "boundGroupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the groups\nthat can perform the login operation that they should be using the group\nID specified by this field.\n"
                },
                "boundLocations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the virtual machines\nthat can perform the login operation that the location in their identity\ndocument must match the one specified by this field.\n"
                },
                "boundResourceGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the virtual\nmachiness that can perform the login operation that they be associated with\nthe resource group that matches the value specified by this field.\n"
                },
                "boundScaleSets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the virtual\nmachines that can perform the login operation that they must match the scale set\nspecified by this field.\n"
                },
                "boundServicePrincipalIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the\nservice principals that can perform the login operation that they should be posess\nthe ids specified by this field.\n"
                },
                "boundSubscriptionIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, defines a constraint on the subscriptions\nthat can perform the login operation to ones which  matches the value specified by this\nfield.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum allowed lifetime of tokens issued using\nthis role, provided as a number of seconds.\n",
                    "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "period": {
                    "type": "integer",
                    "description": "If set, indicates that the token generated using this\nrole should never expire. The token should be renewed within the duration\nspecified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. The maximum allowed lifetime of token issued using this\nrole. Specified as a number of seconds.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of strings specifying the policies to be set\non tokens issued using this role.\n",
                    "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The TTL period of tokens issued using this role, provided\nas a number of seconds.\n",
                    "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                }
            },
            "requiredInputs": [
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Unique name of the auth backend to configure.\n"
                    },
                    "boundGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the groups\nthat can perform the login operation that they should be using the group\nID specified by this field.\n"
                    },
                    "boundLocations": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the virtual machines\nthat can perform the login operation that the location in their identity\ndocument must match the one specified by this field.\n"
                    },
                    "boundResourceGroups": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the virtual\nmachiness that can perform the login operation that they be associated with\nthe resource group that matches the value specified by this field.\n"
                    },
                    "boundScaleSets": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the virtual\nmachines that can perform the login operation that they must match the scale set\nspecified by this field.\n"
                    },
                    "boundServicePrincipalIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the\nservice principals that can perform the login operation that they should be posess\nthe ids specified by this field.\n"
                    },
                    "boundSubscriptionIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, defines a constraint on the subscriptions\nthat can perform the login operation to ones which  matches the value specified by this\nfield.\n"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "The maximum allowed lifetime of tokens issued using\nthis role, provided as a number of seconds.\n",
                        "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                    },
                    "period": {
                        "type": "integer",
                        "description": "If set, indicates that the token generated using this\nrole should never expire. The token should be renewed within the duration\nspecified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. The maximum allowed lifetime of token issued using this\nrole. Specified as a number of seconds.\n",
                        "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of strings specifying the policies to be set\non tokens issued using this role.\n",
                        "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime of the generated token\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "Generated Token's Period\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Generated Token's Policies\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The initial ttl of the token to generate in seconds\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token to generate, service or batch\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "The TTL period of tokens issued using this role, provided\nas a number of seconds.\n",
                        "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                    }
                },
                "type": "object"
            }
        },
        "vault:azure/backend:Backend": {
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The client id for credentials to query the Azure APIs. Currently read permissions to query compute resources are\nrequired.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client secret for credentials to query the Azure APIs\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the backend.\n"
                },
                "environment": {
                    "type": "string",
                    "description": "The Azure cloud environment. Valid values: AzurePublicCloud, AzureUSGovernmentCloud, AzureChinaCloud, AzureGermanCloud.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to mount the backend at.\n"
                },
                "subscriptionId": {
                    "type": "string",
                    "description": "The subscription id for the Azure Active Directory.\n"
                },
                "tenantId": {
                    "type": "string",
                    "description": "The tenant id for the Azure Active Directory organization.\n"
                }
            },
            "required": [
                "subscriptionId",
                "tenantId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The client id for credentials to query the Azure APIs. Currently read permissions to query compute resources are\nrequired.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client secret for credentials to query the Azure APIs\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the backend.\n"
                },
                "environment": {
                    "type": "string",
                    "description": "The Azure cloud environment. Valid values: AzurePublicCloud, AzureUSGovernmentCloud, AzureChinaCloud, AzureGermanCloud.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to mount the backend at.\n"
                },
                "subscriptionId": {
                    "type": "string",
                    "description": "The subscription id for the Azure Active Directory.\n"
                },
                "tenantId": {
                    "type": "string",
                    "description": "The tenant id for the Azure Active Directory organization.\n"
                }
            },
            "requiredInputs": [
                "subscriptionId",
                "tenantId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Backend resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The client id for credentials to query the Azure APIs. Currently read permissions to query compute resources are\nrequired.\n"
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "The client secret for credentials to query the Azure APIs\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Human-friendly description of the mount for the backend.\n"
                    },
                    "environment": {
                        "type": "string",
                        "description": "The Azure cloud environment. Valid values: AzurePublicCloud, AzureUSGovernmentCloud, AzureChinaCloud, AzureGermanCloud.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Path to mount the backend at.\n"
                    },
                    "subscriptionId": {
                        "type": "string",
                        "description": "The subscription id for the Azure Active Directory.\n"
                    },
                    "tenantId": {
                        "type": "string",
                        "description": "The tenant id for the Azure Active Directory organization.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:azure/backendRole:BackendRole": {
            "properties": {
                "applicationObjectId": {
                    "type": "string",
                    "description": "Application Object ID for an existing service principal that will be used instead of creating dynamic service\nprincipals.\n"
                },
                "azureGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:azure/BackendRoleAzureGroup:BackendRoleAzureGroup"
                    }
                },
                "azureRoles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:azure/BackendRoleAzureRole:BackendRoleAzureRole"
                    }
                },
                "backend": {
                    "type": "string",
                    "description": "Unique name of the auth backend to configure.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the backend.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the backend.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the role to create\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the backend.\n"
                }
            },
            "required": [
                "role"
            ],
            "inputProperties": {
                "applicationObjectId": {
                    "type": "string",
                    "description": "Application Object ID for an existing service principal that will be used instead of creating dynamic service\nprincipals.\n"
                },
                "azureGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:azure/BackendRoleAzureGroup:BackendRoleAzureGroup"
                    }
                },
                "azureRoles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:azure/BackendRoleAzureRole:BackendRoleAzureRole"
                    }
                },
                "backend": {
                    "type": "string",
                    "description": "Unique name of the auth backend to configure.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the backend.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the backend.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the role to create\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Human-friendly description of the mount for the backend.\n"
                }
            },
            "requiredInputs": [
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering BackendRole resources.\n",
                "properties": {
                    "applicationObjectId": {
                        "type": "string",
                        "description": "Application Object ID for an existing service principal that will be used instead of creating dynamic service\nprincipals.\n"
                    },
                    "azureGroups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:azure/BackendRoleAzureGroup:BackendRoleAzureGroup"
                        }
                    },
                    "azureRoles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:azure/BackendRoleAzureRole:BackendRoleAzureRole"
                        }
                    },
                    "backend": {
                        "type": "string",
                        "description": "Unique name of the auth backend to configure.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Human-friendly description of the mount for the backend.\n"
                    },
                    "maxTtl": {
                        "type": "string",
                        "description": "Human-friendly description of the mount for the backend.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "Name of the role to create\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Human-friendly description of the mount for the backend.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:consul/secretBackend:SecretBackend": {
            "description": "\n\n\n## Import\n\nConsul secret backends can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:consul/secretBackend:SecretBackend example consul\n```\n\n ",
            "properties": {
                "address": {
                    "type": "string",
                    "description": "Specifies the address of the Consul instance, provided as \"host:port\" like \"127.0.0.1:8500\".\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials issued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique location this backend should be mounted at. Must not begin or end with a `/`. Defaults to `consul`.\n"
                },
                "scheme": {
                    "type": "string",
                    "description": "Specifies the URL scheme to use. Defaults to `http`.\n"
                },
                "token": {
                    "type": "string",
                    "description": "The Consul management token this backend should use to issue new tokens.\n"
                }
            },
            "required": [
                "address",
                "token"
            ],
            "inputProperties": {
                "address": {
                    "type": "string",
                    "description": "Specifies the address of the Consul instance, provided as \"host:port\" like \"127.0.0.1:8500\".\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials issued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique location this backend should be mounted at. Must not begin or end with a `/`. Defaults to `consul`.\n"
                },
                "scheme": {
                    "type": "string",
                    "description": "Specifies the URL scheme to use. Defaults to `http`.\n"
                },
                "token": {
                    "type": "string",
                    "description": "The Consul management token this backend should use to issue new tokens.\n"
                }
            },
            "requiredInputs": [
                "address",
                "token"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackend resources.\n",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "Specifies the address of the Consul instance, provided as \"host:port\" like \"127.0.0.1:8500\".\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The default TTL for credentials issued by this backend.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A human-friendly description for this backend.\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The unique location this backend should be mounted at. Must not begin or end with a `/`. Defaults to `consul`.\n"
                    },
                    "scheme": {
                        "type": "string",
                        "description": "Specifies the URL scheme to use. Defaults to `http`.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "The Consul management token this backend should use to issue new tokens.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:consul/secretBackendRole:SecretBackendRole": {
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path of the Consul Secret Backend the role belongs to.\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Indicates that the token should not be replicated globally and instead be local to the current datacenter.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "Maximum TTL for leases associated with this role, in seconds.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of an existing role against which to create this Consul credential\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path of the Consul Secret Backend the role belongs to.\n",
                    "deprecationMessage": "use `backend` instead"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Consul policies to associate with this role\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "Specifies the type of token to create when using this role. Valid values are \"client\" or \"management\".\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "Specifies the TTL for this role.\n"
                }
            },
            "required": [
                "name",
                "policies"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path of the Consul Secret Backend the role belongs to.\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Indicates that the token should not be replicated globally and instead be local to the current datacenter.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "Maximum TTL for leases associated with this role, in seconds.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of an existing role against which to create this Consul credential\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path of the Consul Secret Backend the role belongs to.\n",
                    "deprecationMessage": "use `backend` instead"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Consul policies to associate with this role\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "Specifies the type of token to create when using this role. Valid values are \"client\" or \"management\".\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "Specifies the TTL for this role.\n"
                }
            },
            "requiredInputs": [
                "policies"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path of the Consul Secret Backend the role belongs to.\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Indicates that the token should not be replicated globally and instead be local to the current datacenter.\n"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "Maximum TTL for leases associated with this role, in seconds.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of an existing role against which to create this Consul credential\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path of the Consul Secret Backend the role belongs to.\n",
                        "deprecationMessage": "use `backend` instead"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Consul policies to associate with this role\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "Specifies the type of token to create when using this role. Valid values are \"client\" or \"management\".\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "Specifies the TTL for this role.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:database/secretBackendConnection:SecretBackendConnection": {
            "description": "\n\n\n## Import\n\nDatabase secret backend connections can be imported using the `backend`, `/config/`, and the `name` e.g.\n\n```sh\n $ pulumi import vault:database/secretBackendConnection:SecretBackendConnection example postgres/config/postgres\n```\n\n ",
            "properties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of roles that are allowed to use this\nconnection.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique name of the Vault mount to configure.\n"
                },
                "cassandra": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionCassandra:SecretBackendConnectionCassandra",
                    "description": "A nested block containing configuration options for Cassandra connections.\n"
                },
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n"
                },
                "elasticsearch": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionElasticsearch:SecretBackendConnectionElasticsearch",
                    "description": "Connection parameters for the elasticsearch-database-plugin.\n"
                },
                "hana": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionHana:SecretBackendConnectionHana",
                    "description": "A nested block containing configuration options for SAP HanaDB connections.\n"
                },
                "mongodb": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMongodb:SecretBackendConnectionMongodb",
                    "description": "A nested block containing configuration options for MongoDB connections.\n"
                },
                "mongodbatlas": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMongodbatlas:SecretBackendConnectionMongodbatlas",
                    "description": "Connection parameters for the mongodbatlas-database-plugin plugin.\n"
                },
                "mssql": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMssql:SecretBackendConnectionMssql",
                    "description": "A nested block containing configuration options for MSSQL connections.\n"
                },
                "mysql": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysql:SecretBackendConnectionMysql",
                    "description": "A nested block containing configuration options for MySQL connections.\n"
                },
                "mysqlAurora": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysqlAurora:SecretBackendConnectionMysqlAurora",
                    "description": "A nested block containing configuration options for Aurora MySQL connections.\n"
                },
                "mysqlLegacy": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysqlLegacy:SecretBackendConnectionMysqlLegacy",
                    "description": "A nested block containing configuration options for legacy MySQL connections.\n"
                },
                "mysqlRds": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysqlRds:SecretBackendConnectionMysqlRds",
                    "description": "A nested block containing configuration options for RDS MySQL connections.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to give the database connection.\n"
                },
                "oracle": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionOracle:SecretBackendConnectionOracle",
                    "description": "A nested block containing configuration options for Oracle connections.\n"
                },
                "postgresql": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionPostgresql:SecretBackendConnectionPostgresql",
                    "description": "A nested block containing configuration options for PostgreSQL connections.\n"
                },
                "rootRotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of database statements to be executed to rotate the root user's credentials.\n"
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Whether the connection should be verified on\ninitial configuration or not.\n"
                }
            },
            "required": [
                "backend",
                "name"
            ],
            "inputProperties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of roles that are allowed to use this\nconnection.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique name of the Vault mount to configure.\n"
                },
                "cassandra": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionCassandra:SecretBackendConnectionCassandra",
                    "description": "A nested block containing configuration options for Cassandra connections.\n"
                },
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n"
                },
                "elasticsearch": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionElasticsearch:SecretBackendConnectionElasticsearch",
                    "description": "Connection parameters for the elasticsearch-database-plugin.\n"
                },
                "hana": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionHana:SecretBackendConnectionHana",
                    "description": "A nested block containing configuration options for SAP HanaDB connections.\n"
                },
                "mongodb": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMongodb:SecretBackendConnectionMongodb",
                    "description": "A nested block containing configuration options for MongoDB connections.\n"
                },
                "mongodbatlas": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMongodbatlas:SecretBackendConnectionMongodbatlas",
                    "description": "Connection parameters for the mongodbatlas-database-plugin plugin.\n"
                },
                "mssql": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMssql:SecretBackendConnectionMssql",
                    "description": "A nested block containing configuration options for MSSQL connections.\n"
                },
                "mysql": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysql:SecretBackendConnectionMysql",
                    "description": "A nested block containing configuration options for MySQL connections.\n"
                },
                "mysqlAurora": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysqlAurora:SecretBackendConnectionMysqlAurora",
                    "description": "A nested block containing configuration options for Aurora MySQL connections.\n"
                },
                "mysqlLegacy": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysqlLegacy:SecretBackendConnectionMysqlLegacy",
                    "description": "A nested block containing configuration options for legacy MySQL connections.\n"
                },
                "mysqlRds": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionMysqlRds:SecretBackendConnectionMysqlRds",
                    "description": "A nested block containing configuration options for RDS MySQL connections.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to give the database connection.\n"
                },
                "oracle": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionOracle:SecretBackendConnectionOracle",
                    "description": "A nested block containing configuration options for Oracle connections.\n"
                },
                "postgresql": {
                    "$ref": "#/types/vault:database/SecretBackendConnectionPostgresql:SecretBackendConnectionPostgresql",
                    "description": "A nested block containing configuration options for PostgreSQL connections.\n"
                },
                "rootRotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of database statements to be executed to rotate the root user's credentials.\n"
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Whether the connection should be verified on\ninitial configuration or not.\n"
                }
            },
            "requiredInputs": [
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendConnection resources.\n",
                "properties": {
                    "allowedRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of roles that are allowed to use this\nconnection.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The unique name of the Vault mount to configure.\n"
                    },
                    "cassandra": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionCassandra:SecretBackendConnectionCassandra",
                        "description": "A nested block containing configuration options for Cassandra connections.\n"
                    },
                    "data": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A map of sensitive data to pass to the endpoint. Useful for templated connection strings.\n"
                    },
                    "elasticsearch": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionElasticsearch:SecretBackendConnectionElasticsearch",
                        "description": "Connection parameters for the elasticsearch-database-plugin.\n"
                    },
                    "hana": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionHana:SecretBackendConnectionHana",
                        "description": "A nested block containing configuration options for SAP HanaDB connections.\n"
                    },
                    "mongodb": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionMongodb:SecretBackendConnectionMongodb",
                        "description": "A nested block containing configuration options for MongoDB connections.\n"
                    },
                    "mongodbatlas": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionMongodbatlas:SecretBackendConnectionMongodbatlas",
                        "description": "Connection parameters for the mongodbatlas-database-plugin plugin.\n"
                    },
                    "mssql": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionMssql:SecretBackendConnectionMssql",
                        "description": "A nested block containing configuration options for MSSQL connections.\n"
                    },
                    "mysql": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionMysql:SecretBackendConnectionMysql",
                        "description": "A nested block containing configuration options for MySQL connections.\n"
                    },
                    "mysqlAurora": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionMysqlAurora:SecretBackendConnectionMysqlAurora",
                        "description": "A nested block containing configuration options for Aurora MySQL connections.\n"
                    },
                    "mysqlLegacy": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionMysqlLegacy:SecretBackendConnectionMysqlLegacy",
                        "description": "A nested block containing configuration options for legacy MySQL connections.\n"
                    },
                    "mysqlRds": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionMysqlRds:SecretBackendConnectionMysqlRds",
                        "description": "A nested block containing configuration options for RDS MySQL connections.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name to give the database connection.\n"
                    },
                    "oracle": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionOracle:SecretBackendConnectionOracle",
                        "description": "A nested block containing configuration options for Oracle connections.\n"
                    },
                    "postgresql": {
                        "$ref": "#/types/vault:database/SecretBackendConnectionPostgresql:SecretBackendConnectionPostgresql",
                        "description": "A nested block containing configuration options for PostgreSQL connections.\n"
                    },
                    "rootRotationStatements": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of database statements to be executed to rotate the root user's credentials.\n"
                    },
                    "verifyConnection": {
                        "type": "boolean",
                        "description": "Whether the connection should be verified on\ninitial configuration or not.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:database/secretBackendRole:SecretBackendRole": {
            "description": "\n\n\n## Import\n\nDatabase secret backend roles can be imported using the `backend`, `/roles/`, and the `name` e.g.\n\n```sh\n $ pulumi import vault:database/secretBackendRole:SecretBackendRole example postgres/roles/my-role\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of the Vault mount to configure.\n"
                },
                "creationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\ncreating a user.\n"
                },
                "dbName": {
                    "type": "string",
                    "description": "The unique name of the database connection to use for\nthe role.\n"
                },
                "defaultTtl": {
                    "type": "integer",
                    "description": "The default number of seconds for leases for this\nrole.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum number of seconds for leases for this\nrole.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to give the role.\n"
                },
                "renewStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\nrenewing a user.\n"
                },
                "revocationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\nrevoking a user.\n"
                },
                "rollbackStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\nrolling back creation due to an error.\n"
                }
            },
            "required": [
                "backend",
                "creationStatements",
                "dbName",
                "name"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The unique name of the Vault mount to configure.\n"
                },
                "creationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\ncreating a user.\n"
                },
                "dbName": {
                    "type": "string",
                    "description": "The unique name of the database connection to use for\nthe role.\n"
                },
                "defaultTtl": {
                    "type": "integer",
                    "description": "The default number of seconds for leases for this\nrole.\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum number of seconds for leases for this\nrole.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to give the role.\n"
                },
                "renewStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\nrenewing a user.\n"
                },
                "revocationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\nrevoking a user.\n"
                },
                "rollbackStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The database statements to execute when\nrolling back creation due to an error.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "creationStatements",
                "dbName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The unique name of the Vault mount to configure.\n"
                    },
                    "creationStatements": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The database statements to execute when\ncreating a user.\n"
                    },
                    "dbName": {
                        "type": "string",
                        "description": "The unique name of the database connection to use for\nthe role.\n"
                    },
                    "defaultTtl": {
                        "type": "integer",
                        "description": "The default number of seconds for leases for this\nrole.\n"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "The maximum number of seconds for leases for this\nrole.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name to give the role.\n"
                    },
                    "renewStatements": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The database statements to execute when\nrenewing a user.\n"
                    },
                    "revocationStatements": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The database statements to execute when\nrevoking a user.\n"
                    },
                    "rollbackStatements": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The database statements to execute when\nrolling back creation due to an error.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:database/secretBackendStaticRole:SecretBackendStaticRole": {
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path of the Database Secret Backend the role belongs to.\n"
                },
                "dbName": {
                    "type": "string",
                    "description": "Database connection to use for this role.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Unique name for the static role.\n"
                },
                "rotationPeriod": {
                    "type": "integer",
                    "description": "The amount of time Vault should wait before rotating the password, in seconds.\n"
                },
                "rotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Database statements to execute to rotate the password for the configured database user.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The database username that this role corresponds to.\n"
                }
            },
            "required": [
                "backend",
                "dbName",
                "name",
                "rotationPeriod",
                "username"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path of the Database Secret Backend the role belongs to.\n"
                },
                "dbName": {
                    "type": "string",
                    "description": "Database connection to use for this role.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Unique name for the static role.\n"
                },
                "rotationPeriod": {
                    "type": "integer",
                    "description": "The amount of time Vault should wait before rotating the password, in seconds.\n"
                },
                "rotationStatements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Database statements to execute to rotate the password for the configured database user.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The database username that this role corresponds to.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "dbName",
                "rotationPeriod",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendStaticRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path of the Database Secret Backend the role belongs to.\n"
                    },
                    "dbName": {
                        "type": "string",
                        "description": "Database connection to use for this role.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Unique name for the static role.\n"
                    },
                    "rotationPeriod": {
                        "type": "integer",
                        "description": "The amount of time Vault should wait before rotating the password, in seconds.\n"
                    },
                    "rotationStatements": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Database statements to execute to rotate the password for the configured database user.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "The database username that this role corresponds to.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:gcp/authBackend:AuthBackend": {
            "description": "Provides a resource to configure the [GCP auth backend within Vault](https://www.vaultproject.io/docs/auth/gcp.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as fs from \"fs\";\nimport * as vault from \"@pulumi/vault\";\n\nconst gcp = new vault.gcp.AuthBackend(\"gcp\", {\n    credentials: fs.readFileSync(\"vault-gcp-credentials.json\", \"utf-8\"),\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ngcp = vault.gcp.AuthBackend(\"gcp\", credentials=(lambda path: open(path).read())(\"vault-gcp-credentials.json\"))\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var gcp = new Vault.Gcp.AuthBackend(\"gcp\", new Vault.Gcp.AuthBackendArgs\n        {\n            Credentials = File.ReadAllText(\"vault-gcp-credentials.json\"),\n        });\n    }\n\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "clientEmail": {
                    "type": "string",
                    "description": "The clients email assosiated with the credentials\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The Client ID of the credentials\n"
                },
                "credentials": {
                    "type": "string",
                    "description": "A JSON string containing the contents of a GCP credentials file.\n"
                },
                "description": {
                    "type": "string"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the auth method is local only\n"
                },
                "path": {
                    "type": "string"
                },
                "privateKeyId": {
                    "type": "string",
                    "description": "The ID of the private key from the credentials\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The GCP Project ID\n"
                }
            },
            "required": [
                "clientEmail",
                "clientId",
                "privateKeyId",
                "projectId"
            ],
            "inputProperties": {
                "clientEmail": {
                    "type": "string",
                    "description": "The clients email assosiated with the credentials\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The Client ID of the credentials\n"
                },
                "credentials": {
                    "type": "string",
                    "description": "A JSON string containing the contents of a GCP credentials file.\n"
                },
                "description": {
                    "type": "string"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the auth method is local only\n"
                },
                "path": {
                    "type": "string"
                },
                "privateKeyId": {
                    "type": "string",
                    "description": "The ID of the private key from the credentials\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The GCP Project ID\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackend resources.\n",
                "properties": {
                    "clientEmail": {
                        "type": "string",
                        "description": "The clients email assosiated with the credentials\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The Client ID of the credentials\n"
                    },
                    "credentials": {
                        "type": "string",
                        "description": "A JSON string containing the contents of a GCP credentials file.\n"
                    },
                    "description": {
                        "type": "string"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Specifies if the auth method is local only\n"
                    },
                    "path": {
                        "type": "string"
                    },
                    "privateKeyId": {
                        "type": "string",
                        "description": "The ID of the private key from the credentials\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The GCP Project ID\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:gcp/authBackendRole:AuthBackendRole": {
            "description": "Provides a resource to create a role in an [GCP auth backend within Vault](https://www.vaultproject.io/docs/auth/gcp.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst gcpAuthBackend = new vault.AuthBackend(\"gcp\", {\n    path: \"gcp\",\n    type: \"gcp\",\n});\nconst gcpAuthBackendRole = new vault.gcp.AuthBackendRole(\"gcp\", {\n    backend: vault_auth_backend_cert.path,\n    boundServiceAccounts: [\"database-server@foo-bar-baz.iam.gserviceaccount.com\"],\n    policies: [\"database-server\"],\n    projectId: \"foo-bar-baz\",\n});\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "addGroupAliases": {
                    "type": "boolean"
                },
                "allowGceInference": {
                    "type": "boolean",
                    "description": "A flag to determine if this role should allow GCE instances to authenticate by inferring service accounts from the GCE identity metadata token.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Path to the mounted GCP auth backend\n"
                },
                "boundInstanceGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The instance groups that an authorized instance must belong to in order to be authenticated. If specified, either `bound_zones` or `bound_regions` must be set too.\n"
                },
                "boundLabels": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A comma-separated list of GCP labels formatted as `\"key:value\"` strings that must be set on authorized GCE instances. Because GCP labels are not currently ACL'd, we recommend that this be used in conjunction with other restrictions.\n"
                },
                "boundProjects": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "GCP Projects that the role exists within\n"
                },
                "boundRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of regions that a GCE instance must belong to in order to be authenticated. If bound_instance_groups is provided, it is assumed to be a regional group and the group must belong to this region. If bound_zones are provided, this attribute is ignored.\n"
                },
                "boundServiceAccounts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "GCP Service Accounts allowed to issue tokens under this role. (Note: **Required** if role is `iam`)\n"
                },
                "boundZones": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of zones that a GCE instance must belong to in order to be authenticated. If bound_instance_groups is provided, it is assumed to be a zonal group and the group must belong to this zone.\n"
                },
                "maxJwtExp": {
                    "type": "string",
                    "description": "The number of seconds past the time of authentication that the login param JWT must expire within. For example, if a user attempts to login with a token that expires within an hour and this is set to 15 minutes, Vault will return an error prompting the user to create a new signed JWT with a shorter `exp`. The GCE metadata tokens currently do not allow the `exp` claim to be customized.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Maximum TTL of tokens issued by the backend\n",
                    "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "period": {
                    "type": "string",
                    "description": "Duration in seconds for token.  If set, the issued token is a periodic token.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Policies to grant on the issued token\n",
                    "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the GCP role\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Default TTL of tokens issued by the backend\n",
                    "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "type": {
                    "type": "string",
                    "description": "Type of GCP authentication role (either `gce` or `iam`)\n"
                }
            },
            "required": [
                "addGroupAliases",
                "allowGceInference",
                "boundInstanceGroups",
                "boundLabels",
                "boundRegions",
                "boundServiceAccounts",
                "boundZones",
                "maxJwtExp",
                "maxTtl",
                "period",
                "policies",
                "role",
                "ttl",
                "type"
            ],
            "inputProperties": {
                "addGroupAliases": {
                    "type": "boolean"
                },
                "allowGceInference": {
                    "type": "boolean",
                    "description": "A flag to determine if this role should allow GCE instances to authenticate by inferring service accounts from the GCE identity metadata token.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Path to the mounted GCP auth backend\n"
                },
                "boundInstanceGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The instance groups that an authorized instance must belong to in order to be authenticated. If specified, either `bound_zones` or `bound_regions` must be set too.\n"
                },
                "boundLabels": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A comma-separated list of GCP labels formatted as `\"key:value\"` strings that must be set on authorized GCE instances. Because GCP labels are not currently ACL'd, we recommend that this be used in conjunction with other restrictions.\n"
                },
                "boundProjects": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "GCP Projects that the role exists within\n"
                },
                "boundRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of regions that a GCE instance must belong to in order to be authenticated. If bound_instance_groups is provided, it is assumed to be a regional group and the group must belong to this region. If bound_zones are provided, this attribute is ignored.\n"
                },
                "boundServiceAccounts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "GCP Service Accounts allowed to issue tokens under this role. (Note: **Required** if role is `iam`)\n"
                },
                "boundZones": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of zones that a GCE instance must belong to in order to be authenticated. If bound_instance_groups is provided, it is assumed to be a zonal group and the group must belong to this zone.\n"
                },
                "maxJwtExp": {
                    "type": "string",
                    "description": "The number of seconds past the time of authentication that the login param JWT must expire within. For example, if a user attempts to login with a token that expires within an hour and this is set to 15 minutes, Vault will return an error prompting the user to create a new signed JWT with a shorter `exp`. The GCE metadata tokens currently do not allow the `exp` claim to be customized.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Maximum TTL of tokens issued by the backend\n",
                    "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "period": {
                    "type": "string",
                    "description": "Duration in seconds for token.  If set, the issued token is a periodic token.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Policies to grant on the issued token\n",
                    "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                },
                "role": {
                    "type": "string",
                    "description": "Name of the GCP role\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Default TTL of tokens issued by the backend\n",
                    "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "type": {
                    "type": "string",
                    "description": "Type of GCP authentication role (either `gce` or `iam`)\n"
                }
            },
            "requiredInputs": [
                "role",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "addGroupAliases": {
                        "type": "boolean"
                    },
                    "allowGceInference": {
                        "type": "boolean",
                        "description": "A flag to determine if this role should allow GCE instances to authenticate by inferring service accounts from the GCE identity metadata token.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "Path to the mounted GCP auth backend\n"
                    },
                    "boundInstanceGroups": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The instance groups that an authorized instance must belong to in order to be authenticated. If specified, either `bound_zones` or `bound_regions` must be set too.\n"
                    },
                    "boundLabels": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A comma-separated list of GCP labels formatted as `\"key:value\"` strings that must be set on authorized GCE instances. Because GCP labels are not currently ACL'd, we recommend that this be used in conjunction with other restrictions.\n"
                    },
                    "boundProjects": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "GCP Projects that the role exists within\n"
                    },
                    "boundRegions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of regions that a GCE instance must belong to in order to be authenticated. If bound_instance_groups is provided, it is assumed to be a regional group and the group must belong to this region. If bound_zones are provided, this attribute is ignored.\n"
                    },
                    "boundServiceAccounts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "GCP Service Accounts allowed to issue tokens under this role. (Note: **Required** if role is `iam`)\n"
                    },
                    "boundZones": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of zones that a GCE instance must belong to in order to be authenticated. If bound_instance_groups is provided, it is assumed to be a zonal group and the group must belong to this zone.\n"
                    },
                    "maxJwtExp": {
                        "type": "string",
                        "description": "The number of seconds past the time of authentication that the login param JWT must expire within. For example, if a user attempts to login with a token that expires within an hour and this is set to 15 minutes, Vault will return an error prompting the user to create a new signed JWT with a shorter `exp`. The GCE metadata tokens currently do not allow the `exp` claim to be customized.\n"
                    },
                    "maxTtl": {
                        "type": "string",
                        "description": "Maximum TTL of tokens issued by the backend\n",
                        "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                    },
                    "period": {
                        "type": "string",
                        "description": "Duration in seconds for token.  If set, the issued token is a periodic token.\n",
                        "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Policies to grant on the issued token\n",
                        "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                    },
                    "role": {
                        "type": "string",
                        "description": "Name of the GCP role\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime of the generated token\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "Generated Token's Period\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Generated Token's Policies\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The initial ttl of the token to generate in seconds\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token to generate, service or batch\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Default TTL of tokens issued by the backend\n",
                        "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of GCP authentication role (either `gce` or `iam`)\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:gcp/secretBackend:SecretBackend": {
            "properties": {
                "credentials": {
                    "type": "string",
                    "description": "The GCP service account credentails in JSON format.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials\nissued by this backend. Defaults to '0'.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Local mount flag that can be explicitly set to true to enforce local mount in HA environment\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend. Defaults to '0'.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `gcp`.\n"
                }
            },
            "inputProperties": {
                "credentials": {
                    "type": "string",
                    "description": "The GCP service account credentails in JSON format.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials\nissued by this backend. Defaults to '0'.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Local mount flag that can be explicitly set to true to enforce local mount in HA environment\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend. Defaults to '0'.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `gcp`.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackend resources.\n",
                "properties": {
                    "credentials": {
                        "type": "string",
                        "description": "The GCP service account credentails in JSON format.\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The default TTL for credentials\nissued by this backend. Defaults to '0'.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A human-friendly description for this backend.\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Local mount flag that can be explicitly set to true to enforce local mount in HA environment\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The maximum TTL that can be requested\nfor credentials issued by this backend. Defaults to '0'.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `gcp`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:gcp/secretRoleset:SecretRoleset": {
            "description": "Creates a Roleset in the [GCP Secrets Engine](https://www.vaultproject.io/docs/secrets/gcp/index.html) for Vault.\n\nEach Roleset is [tied](https://www.vaultproject.io/docs/secrets/gcp/index.html#service-accounts-are-tied-to-rolesets) to a Service Account, and can have one or more [bindings](https://www.vaultproject.io/docs/secrets/gcp/index.html#roleset-bindings) associated with it.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as fs from \"fs\";\nimport * as vault from \"@pulumi/vault\";\n\nconst project = \"my-awesome-project\";\nconst gcp = new vault.gcp.SecretBackend(\"gcp\", {\n    credentials: fs.readFileSync(\"credentials.json\", \"utf-8\"),\n});\nconst agent = new vault.gcp.SecretRoleset(\"agent\", {\n    backend: gcp.path,\n    bindings: [{\n        resource: `//cloudresourcemanager.googleapis.com/projects/${project}`,\n        roles: [\"roles/viewer\"],\n    }],\n    project: project,\n    roleset: \"project_viewer\",\n    secretType: \"access_token\",\n    tokenScopes: [\"https://www.googleapis.com/auth/cloud-platform\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nproject = \"my-awesome-project\"\ngcp = vault.gcp.SecretBackend(\"gcp\", credentials=(lambda path: open(path).read())(\"credentials.json\"))\nagent = vault.gcp.SecretRoleset(\"agent\",\n    backend=gcp.path,\n    bindings=[vault.gcp.SecretRolesetBindingArgs(\n        resource=f\"//cloudresourcemanager.googleapis.com/projects/{project}\",\n        roles=[\"roles/viewer\"],\n    )],\n    project=project,\n    roleset=\"project_viewer\",\n    secret_type=\"access_token\",\n    token_scopes=[\"https://www.googleapis.com/auth/cloud-platform\"])\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var project = \"my-awesome-project\";\n        var gcp = new Vault.Gcp.SecretBackend(\"gcp\", new Vault.Gcp.SecretBackendArgs\n        {\n            Credentials = File.ReadAllText(\"credentials.json\"),\n        });\n        var agent = new Vault.Gcp.SecretRoleset(\"agent\", new Vault.Gcp.SecretRolesetArgs\n        {\n            Backend = gcp.Path,\n            Bindings = \n            {\n                new Vault.Gcp.Inputs.SecretRolesetBindingArgs\n                {\n                    Resource = $\"//cloudresourcemanager.googleapis.com/projects/{project}\",\n                    Roles = \n                    {\n                        \"roles/viewer\",\n                    },\n                },\n            },\n            Project = project,\n            Roleset = \"project_viewer\",\n            SecretType = \"access_token\",\n            TokenScopes = \n            {\n                \"https://www.googleapis.com/auth/cloud-platform\",\n            },\n        });\n    }\n\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the GCP Secrets Engine is mounted\n"
                },
                "bindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:gcp/SecretRolesetBinding:SecretRolesetBinding"
                    },
                    "description": "Bindings to create for this roleset. This can be specified multiple times for multiple bindings. Structure is documented below.\n"
                },
                "project": {
                    "type": "string",
                    "description": "Name of the GCP project that this roleset's service account will belong to.\n"
                },
                "roleset": {
                    "type": "string",
                    "description": "Name of the Roleset to create\n"
                },
                "secretType": {
                    "type": "string",
                    "description": "Type of secret generated for this role set. Accepted values: `access_token`, `service_account_key`. Defaults to `access_token`.\n"
                },
                "serviceAccountEmail": {
                    "type": "string",
                    "description": "Email of the service account created by Vault for this Roleset\n"
                },
                "tokenScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of OAuth scopes to assign to `access_token` secrets generated under this role set (`access_token` role sets only).\n"
                }
            },
            "required": [
                "backend",
                "bindings",
                "project",
                "roleset",
                "secretType",
                "serviceAccountEmail"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the GCP Secrets Engine is mounted\n"
                },
                "bindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:gcp/SecretRolesetBinding:SecretRolesetBinding"
                    },
                    "description": "Bindings to create for this roleset. This can be specified multiple times for multiple bindings. Structure is documented below.\n"
                },
                "project": {
                    "type": "string",
                    "description": "Name of the GCP project that this roleset's service account will belong to.\n"
                },
                "roleset": {
                    "type": "string",
                    "description": "Name of the Roleset to create\n"
                },
                "secretType": {
                    "type": "string",
                    "description": "Type of secret generated for this role set. Accepted values: `access_token`, `service_account_key`. Defaults to `access_token`.\n"
                },
                "tokenScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of OAuth scopes to assign to `access_token` secrets generated under this role set (`access_token` role sets only).\n"
                }
            },
            "requiredInputs": [
                "backend",
                "bindings",
                "project",
                "roleset"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretRoleset resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Path where the GCP Secrets Engine is mounted\n"
                    },
                    "bindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:gcp/SecretRolesetBinding:SecretRolesetBinding"
                        },
                        "description": "Bindings to create for this roleset. This can be specified multiple times for multiple bindings. Structure is documented below.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "Name of the GCP project that this roleset's service account will belong to.\n"
                    },
                    "roleset": {
                        "type": "string",
                        "description": "Name of the Roleset to create\n"
                    },
                    "secretType": {
                        "type": "string",
                        "description": "Type of secret generated for this role set. Accepted values: `access_token`, `service_account_key`. Defaults to `access_token`.\n"
                    },
                    "serviceAccountEmail": {
                        "type": "string",
                        "description": "Email of the service account created by Vault for this Roleset\n"
                    },
                    "tokenScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of OAuth scopes to assign to `access_token` secrets generated under this role set (`access_token` role sets only).\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:generic/endpoint:Endpoint": {
            "description": "\n\n\n## Import\n\nImport is not supported for this resource. ",
            "properties": {
                "dataJson": {
                    "type": "string",
                    "description": "String containing a JSON-encoded object that will be\nwritten to the given path as the secret data.\n"
                },
                "disableDelete": {
                    "type": "boolean",
                    "description": "Don't attempt to delete the path from Vault if true\n"
                },
                "disableRead": {
                    "type": "boolean",
                    "description": "True/false. Set this to true if your vault\nauthentication is not able to read the data or if the endpoint does\nnot support the `GET` method. Setting this to `true` will break drift\ndetection. You should set this to `true` for endpoints that are\nwrite-only. Defaults to false.\n"
                },
                "ignoreAbsentFields": {
                    "type": "boolean",
                    "description": "When reading, disregard fields not present in data_json\n"
                },
                "path": {
                    "type": "string",
                    "description": "The full logical path at which to write the given\ndata. Consult each backend's documentation to see which endpoints\nsupport the `PUT` methods and to determine whether they also support\n`DELETE` and `GET`.\n"
                },
                "writeData": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of strings returned by write operation\n"
                },
                "writeDataJson": {
                    "type": "string",
                    "description": "JSON data returned by write operation\n"
                },
                "writeFields": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Top-level fields returned by write to persist in state\n"
                }
            },
            "required": [
                "dataJson",
                "path",
                "writeData",
                "writeDataJson"
            ],
            "inputProperties": {
                "dataJson": {
                    "type": "string",
                    "description": "String containing a JSON-encoded object that will be\nwritten to the given path as the secret data.\n"
                },
                "disableDelete": {
                    "type": "boolean",
                    "description": "Don't attempt to delete the path from Vault if true\n"
                },
                "disableRead": {
                    "type": "boolean",
                    "description": "True/false. Set this to true if your vault\nauthentication is not able to read the data or if the endpoint does\nnot support the `GET` method. Setting this to `true` will break drift\ndetection. You should set this to `true` for endpoints that are\nwrite-only. Defaults to false.\n"
                },
                "ignoreAbsentFields": {
                    "type": "boolean",
                    "description": "When reading, disregard fields not present in data_json\n"
                },
                "path": {
                    "type": "string",
                    "description": "The full logical path at which to write the given\ndata. Consult each backend's documentation to see which endpoints\nsupport the `PUT` methods and to determine whether they also support\n`DELETE` and `GET`.\n"
                },
                "writeFields": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Top-level fields returned by write to persist in state\n"
                }
            },
            "requiredInputs": [
                "dataJson",
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Endpoint resources.\n",
                "properties": {
                    "dataJson": {
                        "type": "string",
                        "description": "String containing a JSON-encoded object that will be\nwritten to the given path as the secret data.\n"
                    },
                    "disableDelete": {
                        "type": "boolean",
                        "description": "Don't attempt to delete the path from Vault if true\n"
                    },
                    "disableRead": {
                        "type": "boolean",
                        "description": "True/false. Set this to true if your vault\nauthentication is not able to read the data or if the endpoint does\nnot support the `GET` method. Setting this to `true` will break drift\ndetection. You should set this to `true` for endpoints that are\nwrite-only. Defaults to false.\n"
                    },
                    "ignoreAbsentFields": {
                        "type": "boolean",
                        "description": "When reading, disregard fields not present in data_json\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The full logical path at which to write the given\ndata. Consult each backend's documentation to see which endpoints\nsupport the `PUT` methods and to determine whether they also support\n`DELETE` and `GET`.\n"
                    },
                    "writeData": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of strings returned by write operation\n"
                    },
                    "writeDataJson": {
                        "type": "string",
                        "description": "JSON data returned by write operation\n"
                    },
                    "writeFields": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Top-level fields returned by write to persist in state\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:generic/secret:Secret": {
            "description": "\n\n\n## Import\n\nGeneric secrets can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:generic/secret:Secret example secret/foo\n```\n\n ",
            "properties": {
                "data": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A mapping whose keys are the top-level data keys returned from\nVault and whose values are the corresponding values. This map can only\nrepresent string data, so any non-string values returned from Vault are\nserialized as JSON.\n"
                },
                "dataJson": {
                    "type": "string",
                    "description": "String containing a JSON-encoded object that will be\nwritten as the secret data at the given path.\n"
                },
                "disableRead": {
                    "type": "boolean",
                    "description": "True/false. Set this to true if your vault\nauthentication is not able to read the data. Setting this to `true` will\nbreak drift detection. Defaults to false.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The full logical path at which to write the given data.\nTo write data into the \"generic\" secret backend mounted in Vault by default,\nthis should be prefixed with `secret/`. Writing to other backends with this\nresource is possible; consult each backend's documentation to see which\nendpoints support the `PUT` and `DELETE` methods.\n"
                }
            },
            "required": [
                "data",
                "dataJson",
                "path"
            ],
            "inputProperties": {
                "dataJson": {
                    "type": "string",
                    "description": "String containing a JSON-encoded object that will be\nwritten as the secret data at the given path.\n"
                },
                "disableRead": {
                    "type": "boolean",
                    "description": "True/false. Set this to true if your vault\nauthentication is not able to read the data. Setting this to `true` will\nbreak drift detection. Defaults to false.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The full logical path at which to write the given data.\nTo write data into the \"generic\" secret backend mounted in Vault by default,\nthis should be prefixed with `secret/`. Writing to other backends with this\nresource is possible; consult each backend's documentation to see which\nendpoints support the `PUT` and `DELETE` methods.\n"
                }
            },
            "requiredInputs": [
                "dataJson",
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Secret resources.\n",
                "properties": {
                    "data": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A mapping whose keys are the top-level data keys returned from\nVault and whose values are the corresponding values. This map can only\nrepresent string data, so any non-string values returned from Vault are\nserialized as JSON.\n"
                    },
                    "dataJson": {
                        "type": "string",
                        "description": "String containing a JSON-encoded object that will be\nwritten as the secret data at the given path.\n"
                    },
                    "disableRead": {
                        "type": "boolean",
                        "description": "True/false. Set this to true if your vault\nauthentication is not able to read the data. Setting this to `true` will\nbreak drift detection. Defaults to false.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The full logical path at which to write the given data.\nTo write data into the \"generic\" secret backend mounted in Vault by default,\nthis should be prefixed with `secret/`. Writing to other backends with this\nresource is possible; consult each backend's documentation to see which\nendpoints support the `PUT` and `DELETE` methods.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:github/authBackend:AuthBackend": {
            "description": "Manages a Github Auth mount in a Vault server. See the [Vault \ndocumentation](https://www.vaultproject.io/docs/auth/github.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.github.AuthBackend(\"example\", {\n    organization: \"myorg\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.github.AuthBackend(\"example\", organization=\"myorg\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.GitHub.AuthBackend(\"example\", new Vault.GitHub.AuthBackendArgs\n        {\n            Organization = \"myorg\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/github\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := github.NewAuthBackend(ctx, \"example\", \u0026github.AuthBackendArgs{\n\t\t\tOrganization: pulumi.String(\"myorg\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGithub authentication mounts can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:github/authBackend:AuthBackend example github\n```\n\n ",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The mount accessor related to the auth mount. It is useful for integration with [Identity Secrets Engine](https://www.vaultproject.io/docs/secrets/identity/index.html).\n"
                },
                "baseUrl": {
                    "type": "string",
                    "description": "The API endpoint to use. Useful if you \nare running GitHub Enterprise or an API-compatible authentication server.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Specifies the description of the mount. \nThis overrides the current stored value, if any.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Maximum duration after which authentication will be expired.\nThis must be a valid [duration string](https://golang.org/pkg/time/#ParseDuration).\n",
                    "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization configured users must be part of.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path where the auth backend is mounted. Defaults to `auth/github` \nif not specified.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Duration after which authentication will be expired. \nThis must be a valid [duration string](https://golang.org/pkg/time/#ParseDuration).\n",
                    "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "tune": {
                    "$ref": "#/types/vault:github/AuthBackendTune:AuthBackendTune"
                }
            },
            "required": [
                "accessor",
                "organization",
                "tune"
            ],
            "inputProperties": {
                "baseUrl": {
                    "type": "string",
                    "description": "The API endpoint to use. Useful if you \nare running GitHub Enterprise or an API-compatible authentication server.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Specifies the description of the mount. \nThis overrides the current stored value, if any.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Maximum duration after which authentication will be expired.\nThis must be a valid [duration string](https://golang.org/pkg/time/#ParseDuration).\n",
                    "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization configured users must be part of.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path where the auth backend is mounted. Defaults to `auth/github` \nif not specified.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Duration after which authentication will be expired. \nThis must be a valid [duration string](https://golang.org/pkg/time/#ParseDuration).\n",
                    "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "tune": {
                    "$ref": "#/types/vault:github/AuthBackendTune:AuthBackendTune"
                }
            },
            "requiredInputs": [
                "organization"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackend resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The mount accessor related to the auth mount. It is useful for integration with [Identity Secrets Engine](https://www.vaultproject.io/docs/secrets/identity/index.html).\n"
                    },
                    "baseUrl": {
                        "type": "string",
                        "description": "The API endpoint to use. Useful if you \nare running GitHub Enterprise or an API-compatible authentication server.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Specifies the description of the mount. \nThis overrides the current stored value, if any.\n"
                    },
                    "maxTtl": {
                        "type": "string",
                        "description": "Maximum duration after which authentication will be expired.\nThis must be a valid [duration string](https://golang.org/pkg/time/#ParseDuration).\n",
                        "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                    },
                    "organization": {
                        "type": "string",
                        "description": "The organization configured users must be part of.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Path where the auth backend is mounted. Defaults to `auth/github` \nif not specified.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime of the generated token\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "Generated Token's Period\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Generated Token's Policies\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The initial ttl of the token to generate in seconds\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token to generate, service or batch\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Duration after which authentication will be expired. \nThis must be a valid [duration string](https://golang.org/pkg/time/#ParseDuration).\n",
                        "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                    },
                    "tune": {
                        "$ref": "#/types/vault:github/AuthBackendTune:AuthBackendTune"
                    }
                },
                "type": "object"
            }
        },
        "vault:github/team:Team": {
            "description": "Manages policy mappings for Github Teams authenticated via Github. See the [Vault \ndocumentation](https://www.vaultproject.io/docs/auth/github.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.github.AuthBackend(\"example\", {\n    organization: \"myorg\",\n});\nconst tfDevs = new vault.github.Team(\"tf_devs\", {\n    backend: example.id,\n    policies: [\n        \"developer\",\n        \"read-only\",\n    ],\n    team: \"terraform-developers\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.github.AuthBackend(\"example\", organization=\"myorg\")\ntf_devs = vault.github.Team(\"tfDevs\",\n    backend=example.id,\n    policies=[\n        \"developer\",\n        \"read-only\",\n    ],\n    team=\"terraform-developers\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.GitHub.AuthBackend(\"example\", new Vault.GitHub.AuthBackendArgs\n        {\n            Organization = \"myorg\",\n        });\n        var tfDevs = new Vault.GitHub.Team(\"tfDevs\", new Vault.GitHub.TeamArgs\n        {\n            Backend = example.Id,\n            Policies = \n            {\n                \"developer\",\n                \"read-only\",\n            },\n            Team = \"terraform-developers\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/github\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := github.NewAuthBackend(ctx, \"example\", \u0026github.AuthBackendArgs{\n\t\t\tOrganization: pulumi.String(\"myorg\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = github.NewTeam(ctx, \"tfDevs\", \u0026github.TeamArgs{\n\t\t\tBackend: example.ID(),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"developer\"),\n\t\t\t\tpulumi.String(\"read-only\"),\n\t\t\t},\n\t\t\tTeam: pulumi.String(\"terraform-developers\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGithub team mappings can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:github/team:Team tf_devs auth/github/map/teams/terraform-developers\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the github auth backend is mounted. Defaults to `github` \nif not specified.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of policies to be assigned to this team.\n"
                },
                "team": {
                    "type": "string",
                    "description": "GitHub team name in \"slugified\" format.\n",
                    "language": {
                        "csharp": {
                            "name": "TeamCity"
                        }
                    }
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                }
            },
            "required": [
                "team"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the github auth backend is mounted. Defaults to `github` \nif not specified.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of policies to be assigned to this team.\n"
                },
                "team": {
                    "type": "string",
                    "description": "GitHub team name in \"slugified\" format.\n",
                    "language": {
                        "csharp": {
                            "name": "TeamCity"
                        }
                    }
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                }
            },
            "requiredInputs": [
                "team"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Team resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Path where the github auth backend is mounted. Defaults to `github` \nif not specified.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of policies to be assigned to this team.\n"
                    },
                    "team": {
                        "type": "string",
                        "description": "GitHub team name in \"slugified\" format.\n",
                        "language": {
                            "csharp": {
                                "name": "TeamCity"
                            }
                        }
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "Generated Token's Explicit Maximum TTL in seconds\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime of the generated token\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If true, the 'default' policy will not automatically be added to generated tokens\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The maximum number of times a token may be used, a value of zero means unlimited\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "Generated Token's Period\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Generated Token's Policies\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The initial ttl of the token to generate in seconds\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token to generate, service or batch\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    }
                },
                "type": "object"
            }
        },
        "vault:github/user:User": {
            "description": "Manages policy mappings for Github Users authenticated via Github. See the [Vault \ndocumentation](https://www.vaultproject.io/docs/auth/github.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.github.AuthBackend(\"example\", {\n    organization: \"myorg\",\n});\nconst tfUser = new vault.github.User(\"tf_user\", {\n    backend: example.id,\n    policies: [\n        \"developer\",\n        \"read-only\",\n    ],\n    user: \"john.doe\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.github.AuthBackend(\"example\", organization=\"myorg\")\ntf_user = vault.github.User(\"tfUser\",\n    backend=example.id,\n    policies=[\n        \"developer\",\n        \"read-only\",\n    ],\n    user=\"john.doe\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.GitHub.AuthBackend(\"example\", new Vault.GitHub.AuthBackendArgs\n        {\n            Organization = \"myorg\",\n        });\n        var tfUser = new Vault.GitHub.User(\"tfUser\", new Vault.GitHub.UserArgs\n        {\n            Backend = example.Id,\n            Policies = \n            {\n                \"developer\",\n                \"read-only\",\n            },\n            User = \"john.doe\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/github\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := github.NewAuthBackend(ctx, \"example\", \u0026github.AuthBackendArgs{\n\t\t\tOrganization: pulumi.String(\"myorg\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = github.NewUser(ctx, \"tfUser\", \u0026github.UserArgs{\n\t\t\tBackend: example.ID(),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"developer\"),\n\t\t\t\tpulumi.String(\"read-only\"),\n\t\t\t},\n\t\t\tUser: pulumi.String(\"john.doe\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGithub user mappings can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:github/user:User tf_user auth/github/map/users/john.doe\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the github auth backend is mounted. Defaults to `github` \nif not specified.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of policies to be assigned to this user.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "user": {
                    "type": "string",
                    "description": "GitHub user name.\n",
                    "language": {
                        "csharp": {
                            "name": "UserName"
                        }
                    }
                }
            },
            "required": [
                "user"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Path where the github auth backend is mounted. Defaults to `github` \nif not specified.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of policies to be assigned to this user.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n",
                    "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                },
                "user": {
                    "type": "string",
                    "description": "GitHub user name.\n",
                    "language": {
                        "csharp": {
                            "name": "UserName"
                        }
                    }
                }
            },
            "requiredInputs": [
                "user"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering User resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Path where the github auth backend is mounted. Defaults to `github` \nif not specified.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of policies to be assigned to this user.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "Generated Token's Explicit Maximum TTL in seconds\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime of the generated token\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If true, the 'default' policy will not automatically be added to generated tokens\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The maximum number of times a token may be used, a value of zero means unlimited\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "Generated Token's Period\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Generated Token's Policies\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The initial ttl of the token to generate in seconds\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token to generate, service or batch\n",
                        "deprecationMessage": "This parameter should be moved to the Github Auth backend config block. It does nothing in a user/team block."
                    },
                    "user": {
                        "type": "string",
                        "description": "GitHub user name.\n",
                        "language": {
                            "csharp": {
                                "name": "UserName"
                            }
                        }
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/entity:Entity": {
            "properties": {
                "disabled": {
                    "type": "boolean",
                    "description": "True/false Is this entity currently disabled. Defaults to `false`\n"
                },
                "externalPolicies": {
                    "type": "boolean",
                    "description": "Manage policies externally through `vault_identity_entity_policies`.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A Map of additional metadata to associate with the user.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the identity entity to create.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of policies to apply to the entity.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "disabled": {
                    "type": "boolean",
                    "description": "True/false Is this entity currently disabled. Defaults to `false`\n"
                },
                "externalPolicies": {
                    "type": "boolean",
                    "description": "Manage policies externally through `vault_identity_entity_policies`.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A Map of additional metadata to associate with the user.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the identity entity to create.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of policies to apply to the entity.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Entity resources.\n",
                "properties": {
                    "disabled": {
                        "type": "boolean",
                        "description": "True/false Is this entity currently disabled. Defaults to `false`\n"
                    },
                    "externalPolicies": {
                        "type": "boolean",
                        "description": "Manage policies externally through `vault_identity_entity_policies`.\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A Map of additional metadata to associate with the user.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the identity entity to create.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of policies to apply to the entity.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/entityAlias:EntityAlias": {
            "properties": {
                "canonicalId": {
                    "type": "string",
                    "description": "Entity ID to which this alias belongs to.\n"
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "Accessor of the mount to which the alias should belong to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the alias. Name should be the identifier of the client in the authentication source. For example, if the alias belongs to userpass backend, the name should be a valid username within userpass backend. If alias belongs to GitHub, it should be the GitHub username.\n"
                }
            },
            "required": [
                "canonicalId",
                "mountAccessor",
                "name"
            ],
            "inputProperties": {
                "canonicalId": {
                    "type": "string",
                    "description": "Entity ID to which this alias belongs to.\n"
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "Accessor of the mount to which the alias should belong to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the alias. Name should be the identifier of the client in the authentication source. For example, if the alias belongs to userpass backend, the name should be a valid username within userpass backend. If alias belongs to GitHub, it should be the GitHub username.\n"
                }
            },
            "requiredInputs": [
                "canonicalId",
                "mountAccessor"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EntityAlias resources.\n",
                "properties": {
                    "canonicalId": {
                        "type": "string",
                        "description": "Entity ID to which this alias belongs to.\n"
                    },
                    "mountAccessor": {
                        "type": "string",
                        "description": "Accessor of the mount to which the alias should belong to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the alias. Name should be the identifier of the client in the authentication source. For example, if the alias belongs to userpass backend, the name should be a valid username within userpass backend. If alias belongs to GitHub, it should be the GitHub username.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/entityPolicies:EntityPolicies": {
            "properties": {
                "entityId": {
                    "type": "string",
                    "description": "ID of the entity.\n"
                },
                "entityName": {
                    "type": "string",
                    "description": "Name of the entity.\n"
                },
                "exclusive": {
                    "type": "boolean",
                    "description": "Should the resource manage policies exclusively\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Policies to be tied to the entity.\n"
                }
            },
            "required": [
                "entityId",
                "entityName",
                "policies"
            ],
            "inputProperties": {
                "entityId": {
                    "type": "string",
                    "description": "ID of the entity.\n"
                },
                "exclusive": {
                    "type": "boolean",
                    "description": "Should the resource manage policies exclusively\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Policies to be tied to the entity.\n"
                }
            },
            "requiredInputs": [
                "entityId",
                "policies"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EntityPolicies resources.\n",
                "properties": {
                    "entityId": {
                        "type": "string",
                        "description": "ID of the entity.\n"
                    },
                    "entityName": {
                        "type": "string",
                        "description": "Name of the entity.\n"
                    },
                    "exclusive": {
                        "type": "boolean",
                        "description": "Should the resource manage policies exclusively\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Policies to be tied to the entity.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/group:Group": {
            "description": "Creates an Identity Group for Vault. The [Identity secrets engine](https://www.vaultproject.io/docs/secrets/identity/index.html) is the identity management solution for Vault.\n\nA group can contain multiple entities as its members. A group can also have subgroups. Policies set on the group is granted to all members of the group. During request time, when the token's entity ID is being evaluated for the policies that it has access to; along with the policies on the entity itself, policies that are inherited due to group memberships are also granted.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Internal Group\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst internal = new vault.identity.Group(\"internal\", {\n    metadata: {\n        version: \"2\",\n    },\n    policies: [\n        \"dev\",\n        \"test\",\n    ],\n    type: \"internal\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ninternal = vault.identity.Group(\"internal\",\n    metadata={\n        \"version\": \"2\",\n    },\n    policies=[\n        \"dev\",\n        \"test\",\n    ],\n    type=\"internal\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var @internal = new Vault.Identity.Group(\"internal\", new Vault.Identity.GroupArgs\n        {\n            Metadata = \n            {\n                { \"version\", \"2\" },\n            },\n            Policies = \n            {\n                \"dev\",\n                \"test\",\n            },\n            Type = \"internal\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := identity.NewGroup(ctx, \"internal\", \u0026identity.GroupArgs{\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"version\": pulumi.String(\"2\"),\n\t\t\t},\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"internal\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% example %}}\n### External Group\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst group = new vault.identity.Group(\"group\", {\n    metadata: {\n        version: \"1\",\n    },\n    policies: [\"test\"],\n    type: \"external\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ngroup = vault.identity.Group(\"group\",\n    metadata={\n        \"version\": \"1\",\n    },\n    policies=[\"test\"],\n    type=\"external\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var @group = new Vault.Identity.Group(\"group\", new Vault.Identity.GroupArgs\n        {\n            Metadata = \n            {\n                { \"version\", \"1\" },\n            },\n            Policies = \n            {\n                \"test\",\n            },\n            Type = \"external\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := identity.NewGroup(ctx, \"group\", \u0026identity.GroupArgs{\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"version\": pulumi.String(\"1\"),\n\t\t\t},\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"external\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "externalMemberEntityIds": {
                    "type": "boolean",
                    "description": "Manage member entities externally through `vault_identity_group_policies_member_entity_ids`\n"
                },
                "externalPolicies": {
                    "type": "boolean",
                    "description": "Manage policies externally through `vault_identity_group_policies`, allows using group ID in assigned policies.\n"
                },
                "memberEntityIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of Entity IDs to be assigned as group members. Not allowed on `external` groups.\n"
                },
                "memberGroupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of Group IDs to be assigned as group members.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A Map of additional metadata to associate with the group.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the identity group to create.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of policies to apply to the group.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the group, internal or external. Defaults to `internal`.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "externalMemberEntityIds": {
                    "type": "boolean",
                    "description": "Manage member entities externally through `vault_identity_group_policies_member_entity_ids`\n"
                },
                "externalPolicies": {
                    "type": "boolean",
                    "description": "Manage policies externally through `vault_identity_group_policies`, allows using group ID in assigned policies.\n"
                },
                "memberEntityIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of Entity IDs to be assigned as group members. Not allowed on `external` groups.\n"
                },
                "memberGroupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of Group IDs to be assigned as group members.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A Map of additional metadata to associate with the group.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the identity group to create.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of policies to apply to the group.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the group, internal or external. Defaults to `internal`.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Group resources.\n",
                "properties": {
                    "externalMemberEntityIds": {
                        "type": "boolean",
                        "description": "Manage member entities externally through `vault_identity_group_policies_member_entity_ids`\n"
                    },
                    "externalPolicies": {
                        "type": "boolean",
                        "description": "Manage policies externally through `vault_identity_group_policies`, allows using group ID in assigned policies.\n"
                    },
                    "memberEntityIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of Entity IDs to be assigned as group members. Not allowed on `external` groups.\n"
                    },
                    "memberGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of Group IDs to be assigned as group members.\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A Map of additional metadata to associate with the group.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the identity group to create.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of policies to apply to the group.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of the group, internal or external. Defaults to `internal`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/groupAlias:GroupAlias": {
            "description": "Creates an Identity Group Alias for Vault. The [Identity secrets engine](https://www.vaultproject.io/docs/secrets/identity/index.html) is the identity management solution for Vault.\n\nGroup aliases allows entity membership in external groups to be managed semi-automatically. External group serves as a mapping to a group that is outside of the identity store. External groups can have one (and only one) alias. This alias should map to a notion of group that is outside of the identity store. For example, groups in LDAP, and teams in GitHub. A username in LDAP, belonging to a group in LDAP, can get its entity ID added as a member of a group in Vault automatically during logins and token renewals. This works only if the group in Vault is an external group and has an alias that maps to the group in LDAP. If the user is removed from the group in LDAP, that change gets reflected in Vault only upon the subsequent login or renewal operation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst group = new vault.identity.Group(\"group\", {\n    policies: [\"test\"],\n    type: \"external\",\n});\nconst github = new vault.AuthBackend(\"github\", {\n    path: \"github\",\n    type: \"github\",\n});\nconst group_alias = new vault.identity.GroupAlias(\"group-alias\", {\n    canonicalId: group.id,\n    mountAccessor: github.accessor,\n    name: \"Github_Team_Slug\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ngroup = vault.identity.Group(\"group\",\n    policies=[\"test\"],\n    type=\"external\")\ngithub = vault.AuthBackend(\"github\",\n    path=\"github\",\n    type=\"github\")\ngroup_alias = vault.identity.GroupAlias(\"group-alias\",\n    canonical_id=group.id,\n    mount_accessor=github.accessor,\n    name=\"Github_Team_Slug\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var @group = new Vault.Identity.Group(\"group\", new Vault.Identity.GroupArgs\n        {\n            Policies = \n            {\n                \"test\",\n            },\n            Type = \"external\",\n        });\n        var github = new Vault.AuthBackend(\"github\", new Vault.AuthBackendArgs\n        {\n            Path = \"github\",\n            Type = \"github\",\n        });\n        var group_alias = new Vault.Identity.GroupAlias(\"group-alias\", new Vault.Identity.GroupAliasArgs\n        {\n            CanonicalId = @group.Id,\n            MountAccessor = github.Accessor,\n            Name = \"Github_Team_Slug\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/identity\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tgroup, err := identity.NewGroup(ctx, \"group\", \u0026identity.GroupArgs{\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"external\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgithub, err := vault.NewAuthBackend(ctx, \"github\", \u0026vault.AuthBackendArgs{\n\t\t\tPath: pulumi.String(\"github\"),\n\t\t\tType: pulumi.String(\"github\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = identity.NewGroupAlias(ctx, \"group_alias\", \u0026identity.GroupAliasArgs{\n\t\t\tCanonicalId:   group.ID(),\n\t\t\tMountAccessor: github.Accessor,\n\t\t\tName:          pulumi.String(\"Github_Team_Slug\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "canonicalId": {
                    "type": "string",
                    "description": "ID of the group to which this is an alias.\n"
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "Mount accessor of the authentication backend to which this alias belongs to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the group alias to create.\n"
                }
            },
            "required": [
                "canonicalId",
                "mountAccessor",
                "name"
            ],
            "inputProperties": {
                "canonicalId": {
                    "type": "string",
                    "description": "ID of the group to which this is an alias.\n"
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "Mount accessor of the authentication backend to which this alias belongs to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the group alias to create.\n"
                }
            },
            "requiredInputs": [
                "canonicalId",
                "mountAccessor",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupAlias resources.\n",
                "properties": {
                    "canonicalId": {
                        "type": "string",
                        "description": "ID of the group to which this is an alias.\n"
                    },
                    "mountAccessor": {
                        "type": "string",
                        "description": "Mount accessor of the authentication backend to which this alias belongs to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the group alias to create.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/groupMemberEntityIds:GroupMemberEntityIds": {
            "properties": {
                "exclusive": {
                    "type": "boolean",
                    "description": "Should the resource manage member entity ids exclusively? Beware of race conditions when disabling exclusive management\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "ID of the group.\n"
                },
                "groupName": {
                    "type": "string",
                    "description": "Name of the group.\n"
                },
                "memberEntityIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Entity IDs to be assigned as group members.\n"
                }
            },
            "required": [
                "groupId",
                "groupName"
            ],
            "inputProperties": {
                "exclusive": {
                    "type": "boolean",
                    "description": "Should the resource manage member entity ids exclusively? Beware of race conditions when disabling exclusive management\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "ID of the group.\n"
                },
                "memberEntityIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Entity IDs to be assigned as group members.\n"
                }
            },
            "requiredInputs": [
                "groupId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupMemberEntityIds resources.\n",
                "properties": {
                    "exclusive": {
                        "type": "boolean",
                        "description": "Should the resource manage member entity ids exclusively? Beware of race conditions when disabling exclusive management\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "ID of the group.\n"
                    },
                    "groupName": {
                        "type": "string",
                        "description": "Name of the group.\n"
                    },
                    "memberEntityIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Entity IDs to be assigned as group members.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/groupPolicies:GroupPolicies": {
            "description": "\n\n\n## Import\n\nDatabase secret backend roles can be imported using the `backend`, `/roles/`, and the `name` e.g.\n\n```sh\n $ pulumi import vault:identity/groupPolicies:GroupPolicies example postgres/roles/my-role\n```\n\n ",
            "properties": {
                "exclusive": {
                    "type": "boolean",
                    "description": "Should the resource manage policies exclusively? Beware of race conditions when disabling exclusive management\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "ID of the group.\n"
                },
                "groupName": {
                    "type": "string",
                    "description": "Name of the group.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Policies to be tied to the group.\n"
                }
            },
            "required": [
                "groupId",
                "groupName",
                "policies"
            ],
            "inputProperties": {
                "exclusive": {
                    "type": "boolean",
                    "description": "Should the resource manage policies exclusively? Beware of race conditions when disabling exclusive management\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "ID of the group.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Policies to be tied to the group.\n"
                }
            },
            "requiredInputs": [
                "groupId",
                "policies"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupPolicies resources.\n",
                "properties": {
                    "exclusive": {
                        "type": "boolean",
                        "description": "Should the resource manage policies exclusively? Beware of race conditions when disabling exclusive management\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "ID of the group.\n"
                    },
                    "groupName": {
                        "type": "string",
                        "description": "Name of the group.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Policies to be tied to the group.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/oidc:Oidc": {
            "properties": {
                "issuer": {
                    "type": "string",
                    "description": "Issuer URL to be used in the iss claim of the token. If not set, Vault's api_addr will be used. The issuer is a case\nsensitive URL using the https scheme that contains scheme, host, and optionally, port number and path components, but no\nquery or fragment components.\n"
                }
            },
            "required": [
                "issuer"
            ],
            "inputProperties": {
                "issuer": {
                    "type": "string",
                    "description": "Issuer URL to be used in the iss claim of the token. If not set, Vault's api_addr will be used. The issuer is a case\nsensitive URL using the https scheme that contains scheme, host, and optionally, port number and path components, but no\nquery or fragment components.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Oidc resources.\n",
                "properties": {
                    "issuer": {
                        "type": "string",
                        "description": "Issuer URL to be used in the iss claim of the token. If not set, Vault's api_addr will be used. The issuer is a case\nsensitive URL using the https scheme that contains scheme, host, and optionally, port number and path components, but no\nquery or fragment components.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/oidcKey:OidcKey": {
            "properties": {
                "algorithm": {
                    "type": "string",
                    "description": "Signing algorithm to use. Signing algorithm to use. Allowed values are: RS256 (default), RS384, RS512, ES256, ES384,\nES512, EdDSA.\n"
                },
                "allowedClientIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Array of role client ids allowed to use this key for signing. If empty, no roles are allowed. If \"*\", all roles are\nallowed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the key.\n"
                },
                "rotationPeriod": {
                    "type": "integer",
                    "description": "How often to generate a new signing key in number of seconds\n"
                },
                "verificationTtl": {
                    "type": "integer",
                    "description": "Controls how long the public portion of a signing key will be available for verification after being rotated in seconds.\n"
                }
            },
            "required": [
                "allowedClientIds",
                "name"
            ],
            "inputProperties": {
                "algorithm": {
                    "type": "string",
                    "description": "Signing algorithm to use. Signing algorithm to use. Allowed values are: RS256 (default), RS384, RS512, ES256, ES384,\nES512, EdDSA.\n"
                },
                "allowedClientIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Array of role client ids allowed to use this key for signing. If empty, no roles are allowed. If \"*\", all roles are\nallowed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the key.\n"
                },
                "rotationPeriod": {
                    "type": "integer",
                    "description": "How often to generate a new signing key in number of seconds\n"
                },
                "verificationTtl": {
                    "type": "integer",
                    "description": "Controls how long the public portion of a signing key will be available for verification after being rotated in seconds.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OidcKey resources.\n",
                "properties": {
                    "algorithm": {
                        "type": "string",
                        "description": "Signing algorithm to use. Signing algorithm to use. Allowed values are: RS256 (default), RS384, RS512, ES256, ES384,\nES512, EdDSA.\n"
                    },
                    "allowedClientIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Array of role client ids allowed to use this key for signing. If empty, no roles are allowed. If \"*\", all roles are\nallowed.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the key.\n"
                    },
                    "rotationPeriod": {
                        "type": "integer",
                        "description": "How often to generate a new signing key in number of seconds\n"
                    },
                    "verificationTtl": {
                        "type": "integer",
                        "description": "Controls how long the public portion of a signing key will be available for verification after being rotated in seconds.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/oidcKeyAllowedClientID:OidcKeyAllowedClientID": {
            "properties": {
                "allowedClientId": {
                    "type": "string",
                    "description": "Role Client ID allowed to use the key for signing.\n"
                },
                "keyName": {
                    "type": "string",
                    "description": "Name of the key.\n"
                }
            },
            "required": [
                "allowedClientId",
                "keyName"
            ],
            "inputProperties": {
                "allowedClientId": {
                    "type": "string",
                    "description": "Role Client ID allowed to use the key for signing.\n"
                },
                "keyName": {
                    "type": "string",
                    "description": "Name of the key.\n"
                }
            },
            "requiredInputs": [
                "allowedClientId",
                "keyName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OidcKeyAllowedClientID resources.\n",
                "properties": {
                    "allowedClientId": {
                        "type": "string",
                        "description": "Role Client ID allowed to use the key for signing.\n"
                    },
                    "keyName": {
                        "type": "string",
                        "description": "Name of the key.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:identity/oidcRole:OidcRole": {
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The value that will be included in the `aud` field of all the OIDC identity tokens issued by this role\n"
                },
                "key": {
                    "type": "string",
                    "description": "A configured named key, the key must already exist.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the role.\n"
                },
                "template": {
                    "type": "string",
                    "description": "The template string to use for generating tokens. This may be in string-ified JSON or base64 format.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "TTL of the tokens generated against the role in number of seconds.\n"
                }
            },
            "required": [
                "clientId",
                "key",
                "name"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The value that will be included in the `aud` field of all the OIDC identity tokens issued by this role\n"
                },
                "key": {
                    "type": "string",
                    "description": "A configured named key, the key must already exist.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the role.\n"
                },
                "template": {
                    "type": "string",
                    "description": "The template string to use for generating tokens. This may be in string-ified JSON or base64 format.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "TTL of the tokens generated against the role in number of seconds.\n"
                }
            },
            "requiredInputs": [
                "key"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OidcRole resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The value that will be included in the `aud` field of all the OIDC identity tokens issued by this role\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "A configured named key, the key must already exist.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the role.\n"
                    },
                    "template": {
                        "type": "string",
                        "description": "The template string to use for generating tokens. This may be in string-ified JSON or base64 format.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "TTL of the tokens generated against the role in number of seconds.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/audit:Audit": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n### File Audit Device)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst test = new vault.Audit(\"test\", {\n    options: {\n        file_path: \"C:/temp/audit.txt\",\n    },\n    type: \"file\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntest = vault.Audit(\"test\",\n    options={\n        \"file_path\": \"C:/temp/audit.txt\",\n    },\n    type=\"file\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var test = new Vault.Audit(\"test\", new Vault.AuditArgs\n        {\n            Options = \n            {\n                { \"file_path\", \"C:/temp/audit.txt\" },\n            },\n            Type = \"file\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewAudit(ctx, \"test\", \u0026vault.AuditArgs{\n\t\t\tOptions: pulumi.StringMap{\n\t\t\t\t\"file_path\": pulumi.String(\"C:/temp/audit.txt\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"file\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Socket Audit Device)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst test = new vault.Audit(\"test\", {\n    options: {\n        address: \"127.0.0.1:8000\",\n        description: \"application x socket\",\n        socket_type: \"tcp\",\n    },\n    path: \"app_socket\",\n    type: \"socket\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ntest = vault.Audit(\"test\",\n    options={\n        \"address\": \"127.0.0.1:8000\",\n        \"description\": \"application x socket\",\n        \"socket_type\": \"tcp\",\n    },\n    path=\"app_socket\",\n    type=\"socket\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var test = new Vault.Audit(\"test\", new Vault.AuditArgs\n        {\n            Options = \n            {\n                { \"address\", \"127.0.0.1:8000\" },\n                { \"description\", \"application x socket\" },\n                { \"socket_type\", \"tcp\" },\n            },\n            Path = \"app_socket\",\n            Type = \"socket\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewAudit(ctx, \"test\", \u0026vault.AuditArgs{\n\t\t\tOptions: pulumi.StringMap{\n\t\t\t\t\"address\":     pulumi.String(\"127.0.0.1:8000\"),\n\t\t\t\t\"description\": pulumi.String(\"application x socket\"),\n\t\t\t\t\"socket_type\": pulumi.String(\"tcp\"),\n\t\t\t},\n\t\t\tPath: pulumi.String(\"app_socket\"),\n\t\t\tType: pulumi.String(\"socket\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAudit devices can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:index/audit:Audit test syslog\n```\n\n ",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the audit device.\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the audit device is a local only. Local audit devices are not replicated nor (if a secondary) removed by\nreplication.\n"
                },
                "options": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Configuration options to pass to the audit device itself.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path to mount the audit device. This defaults to the type.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the audit device, such as 'file'.\n"
                }
            },
            "required": [
                "options",
                "path",
                "type"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the audit device.\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the audit device is a local only. Local audit devices are not replicated nor (if a secondary) removed by\nreplication.\n"
                },
                "options": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Configuration options to pass to the audit device itself.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path to mount the audit device. This defaults to the type.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the audit device, such as 'file'.\n"
                }
            },
            "requiredInputs": [
                "options",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Audit resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Human-friendly description of the audit device.\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Specifies if the audit device is a local only. Local audit devices are not replicated nor (if a secondary) removed by\nreplication.\n"
                    },
                    "options": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Configuration options to pass to the audit device itself.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path to mount the audit device. This defaults to the type.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of the audit device, such as 'file'.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/authBackend:AuthBackend": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.AuthBackend(\"example\", {\n    type: \"github\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.AuthBackend(\"example\", type=\"github\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.AuthBackend(\"example\", new Vault.AuthBackendArgs\n        {\n            Type = \"github\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewAuthBackend(ctx, \"example\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"github\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAuth methods can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:index/authBackend:AuthBackend example github\n```\n\n ",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The accessor for this auth method\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default lease duration in seconds.\n",
                    "deprecationMessage": "Use the tune configuration block to avoid forcing creation of new resource on an update"
                },
                "description": {
                    "type": "string",
                    "description": "A description of the auth method\n"
                },
                "listingVisibility": {
                    "type": "string",
                    "description": "Speficies whether to show this mount in the UI-specific listing endpoint.\n",
                    "deprecationMessage": "Use the tune configuration block to avoid forcing creation of new resource on an update"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the auth method is local only.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum lease duration in seconds.\n",
                    "deprecationMessage": "Use the tune configuration block to avoid forcing creation of new resource on an update"
                },
                "path": {
                    "type": "string",
                    "description": "The path to mount the auth method — this defaults to the name of the type\n"
                },
                "tune": {
                    "$ref": "#/types/vault:index/AuthBackendTune:AuthBackendTune"
                },
                "type": {
                    "type": "string",
                    "description": "The name of the auth method type\n"
                }
            },
            "required": [
                "accessor",
                "defaultLeaseTtlSeconds",
                "listingVisibility",
                "maxLeaseTtlSeconds",
                "path",
                "tune",
                "type"
            ],
            "inputProperties": {
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default lease duration in seconds.\n",
                    "deprecationMessage": "Use the tune configuration block to avoid forcing creation of new resource on an update"
                },
                "description": {
                    "type": "string",
                    "description": "A description of the auth method\n"
                },
                "listingVisibility": {
                    "type": "string",
                    "description": "Speficies whether to show this mount in the UI-specific listing endpoint.\n",
                    "deprecationMessage": "Use the tune configuration block to avoid forcing creation of new resource on an update"
                },
                "local": {
                    "type": "boolean",
                    "description": "Specifies if the auth method is local only.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum lease duration in seconds.\n",
                    "deprecationMessage": "Use the tune configuration block to avoid forcing creation of new resource on an update"
                },
                "path": {
                    "type": "string",
                    "description": "The path to mount the auth method — this defaults to the name of the type\n"
                },
                "tune": {
                    "$ref": "#/types/vault:index/AuthBackendTune:AuthBackendTune"
                },
                "type": {
                    "type": "string",
                    "description": "The name of the auth method type\n"
                }
            },
            "requiredInputs": [
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackend resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The accessor for this auth method\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The default lease duration in seconds.\n",
                        "deprecationMessage": "Use the tune configuration block to avoid forcing creation of new resource on an update"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description of the auth method\n"
                    },
                    "listingVisibility": {
                        "type": "string",
                        "description": "Speficies whether to show this mount in the UI-specific listing endpoint.\n",
                        "deprecationMessage": "Use the tune configuration block to avoid forcing creation of new resource on an update"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Specifies if the auth method is local only.\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The maximum lease duration in seconds.\n",
                        "deprecationMessage": "Use the tune configuration block to avoid forcing creation of new resource on an update"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path to mount the auth method — this defaults to the name of the type\n"
                    },
                    "tune": {
                        "$ref": "#/types/vault:index/AuthBackendTune:AuthBackendTune"
                    },
                    "type": {
                        "type": "string",
                        "description": "The name of the auth method type\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/certAuthBackendRole:CertAuthBackendRole": {
            "description": "Provides a resource to create a role in an [Cert auth backend within Vault](https://www.vaultproject.io/docs/auth/cert.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as fs from \"fs\";\nimport * as vault from \"@pulumi/vault\";\n\nconst certAuthBackend = new vault.AuthBackend(\"cert\", {\n    path: \"cert\",\n    type: \"cert\",\n});\nconst certCertAuthBackendRole = new vault.CertAuthBackendRole(\"cert\", {\n    allowedNames: [\n        \"foo.example.org\",\n        \"baz.example.org\",\n    ],\n    backend: certAuthBackend.path,\n    certificate: fs.readFileSync(\"/path/to/certs/ca-cert.pem\", \"utf-8\"),\n    maxTtl: \"600\",\n    policies: [\"foo\"],\n    ttl: \"300\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\ncert_auth_backend = vault.AuthBackend(\"certAuthBackend\",\n    path=\"cert\",\n    type=\"cert\")\ncert_cert_auth_backend_role = vault.CertAuthBackendRole(\"certCertAuthBackendRole\",\n    allowed_names=[\n        \"foo.example.org\",\n        \"baz.example.org\",\n    ],\n    backend=cert_auth_backend.path,\n    certificate=(lambda path: open(path).read())(\"/path/to/certs/ca-cert.pem\"),\n    max_ttl=\"600\",\n    policies=[\"foo\"],\n    ttl=\"300\")\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var certAuthBackend = new Vault.AuthBackend(\"certAuthBackend\", new Vault.AuthBackendArgs\n        {\n            Path = \"cert\",\n            Type = \"cert\",\n        });\n        var certCertAuthBackendRole = new Vault.CertAuthBackendRole(\"certCertAuthBackendRole\", new Vault.CertAuthBackendRoleArgs\n        {\n            AllowedNames = \n            {\n                \"foo.example.org\",\n                \"baz.example.org\",\n            },\n            Backend = certAuthBackend.Path,\n            Certificate = File.ReadAllText(\"/path/to/certs/ca-cert.pem\"),\n            MaxTtl = \"600\",\n            Policies = \n            {\n                \"foo\",\n            },\n            Ttl = \"300\",\n        });\n    }\n\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "allowedCommonNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed the common names for authenticated client certificates\n"
                },
                "allowedDnsSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed alternative dns names for authenticated client certificates\n"
                },
                "allowedEmailSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed emails for authenticated client certificates\n"
                },
                "allowedNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed subject names for authenticated client certificates\n"
                },
                "allowedOrganizationUnits": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed organization units for authenticated client certificates\n"
                },
                "allowedUriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed URIs for authenticated client certificates\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Path to the mounted Cert auth backend\n"
                },
                "boundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Restriction usage of the certificates to client IPs falling within the range of the specified CIDRs\n",
                    "deprecationMessage": "use `token_bound_cidrs` instead if you are running Vault \u003e= 1.2"
                },
                "certificate": {
                    "type": "string",
                    "description": "CA certificate used to validate client certificates\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "The name to display on tokens issued under this role.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Maximum TTL of tokens issued by the backend\n",
                    "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the role\n"
                },
                "period": {
                    "type": "string",
                    "description": "Duration in seconds for token.  If set, the issued token is a periodic token.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Policies to grant on the issued token\n",
                    "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                },
                "requiredExtensions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "TLS extensions required on client certificates\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Default TTL of tokens issued by the backend\n",
                    "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                }
            },
            "required": [
                "allowedCommonNames",
                "allowedDnsSans",
                "allowedEmailSans",
                "allowedNames",
                "allowedOrganizationUnits",
                "allowedUriSans",
                "boundCidrs",
                "certificate",
                "displayName",
                "maxTtl",
                "name",
                "period",
                "policies",
                "requiredExtensions",
                "ttl"
            ],
            "inputProperties": {
                "allowedCommonNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed the common names for authenticated client certificates\n"
                },
                "allowedDnsSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed alternative dns names for authenticated client certificates\n"
                },
                "allowedEmailSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed emails for authenticated client certificates\n"
                },
                "allowedNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed subject names for authenticated client certificates\n"
                },
                "allowedOrganizationUnits": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed organization units for authenticated client certificates\n"
                },
                "allowedUriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Allowed URIs for authenticated client certificates\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Path to the mounted Cert auth backend\n"
                },
                "boundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Restriction usage of the certificates to client IPs falling within the range of the specified CIDRs\n",
                    "deprecationMessage": "use `token_bound_cidrs` instead if you are running Vault \u003e= 1.2"
                },
                "certificate": {
                    "type": "string",
                    "description": "CA certificate used to validate client certificates\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "The name to display on tokens issued under this role.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Maximum TTL of tokens issued by the backend\n",
                    "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the role\n"
                },
                "period": {
                    "type": "string",
                    "description": "Duration in seconds for token.  If set, the issued token is a periodic token.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Policies to grant on the issued token\n",
                    "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                },
                "requiredExtensions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "TLS extensions required on client certificates\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Default TTL of tokens issued by the backend\n",
                    "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                }
            },
            "requiredInputs": [
                "certificate"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CertAuthBackendRole resources.\n",
                "properties": {
                    "allowedCommonNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Allowed the common names for authenticated client certificates\n"
                    },
                    "allowedDnsSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Allowed alternative dns names for authenticated client certificates\n"
                    },
                    "allowedEmailSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Allowed emails for authenticated client certificates\n"
                    },
                    "allowedNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Allowed subject names for authenticated client certificates\n"
                    },
                    "allowedOrganizationUnits": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Allowed organization units for authenticated client certificates\n"
                    },
                    "allowedUriSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Allowed URIs for authenticated client certificates\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "Path to the mounted Cert auth backend\n"
                    },
                    "boundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Restriction usage of the certificates to client IPs falling within the range of the specified CIDRs\n",
                        "deprecationMessage": "use `token_bound_cidrs` instead if you are running Vault \u003e= 1.2"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "CA certificate used to validate client certificates\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "The name to display on tokens issued under this role.\n"
                    },
                    "maxTtl": {
                        "type": "string",
                        "description": "Maximum TTL of tokens issued by the backend\n",
                        "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the role\n"
                    },
                    "period": {
                        "type": "string",
                        "description": "Duration in seconds for token.  If set, the issued token is a periodic token.\n",
                        "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Policies to grant on the issued token\n",
                        "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                    },
                    "requiredExtensions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "TLS extensions required on client certificates\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime of the generated token\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "Generated Token's Period\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Generated Token's Policies\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The initial ttl of the token to generate in seconds\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token to generate, service or batch\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Default TTL of tokens issued by the backend\n",
                        "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/egpPolicy:EgpPolicy": {
            "description": "Provides a resource to manage Endpoint Governing Policy (EGP) via [Sentinel](https://www.vaultproject.io/docs/enterprise/sentinel/index.html).\n\n**Note** this feature is available only with Vault Enterprise.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst allow_all = new vault.EgpPolicy(\"allow-all\", {\n    enforcementLevel: \"soft-mandatory\",\n    paths: [\"*\"],\n    policy: `main = rule {\n  true\n}\n`,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nallow_all = vault.EgpPolicy(\"allow-all\",\n    enforcement_level=\"soft-mandatory\",\n    paths=[\"*\"],\n    policy=\"\"\"main = rule {\n  true\n}\n\n\"\"\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var allow_all = new Vault.EgpPolicy(\"allow-all\", new Vault.EgpPolicyArgs\n        {\n            EnforcementLevel = \"soft-mandatory\",\n            Paths = \n            {\n                \"*\",\n            },\n            Policy = @\"main = rule {\n  true\n}\n\n\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewEgpPolicy(ctx, \"allow_all\", \u0026vault.EgpPolicyArgs{\n\t\t\tEnforcementLevel: pulumi.String(\"soft-mandatory\"),\n\t\t\tPaths: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"*\"),\n\t\t\t},\n\t\t\tPolicy: pulumi.String(fmt.Sprintf(\"%v%v%v%v\", \"main = rule {\\n\", \"  true\\n\", \"}\\n\", \"\\n\")),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "enforcementLevel": {
                    "type": "string",
                    "description": "Enforcement level of Sentinel policy. Can be either `advisory` or `soft-mandatory` or `hard-mandatory`\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the policy\n"
                },
                "paths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of paths to which the policy will be applied to\n"
                },
                "policy": {
                    "type": "string",
                    "description": "String containing a Sentinel policy\n"
                }
            },
            "required": [
                "enforcementLevel",
                "name",
                "paths",
                "policy"
            ],
            "inputProperties": {
                "enforcementLevel": {
                    "type": "string",
                    "description": "Enforcement level of Sentinel policy. Can be either `advisory` or `soft-mandatory` or `hard-mandatory`\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the policy\n"
                },
                "paths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of paths to which the policy will be applied to\n"
                },
                "policy": {
                    "type": "string",
                    "description": "String containing a Sentinel policy\n"
                }
            },
            "requiredInputs": [
                "enforcementLevel",
                "paths",
                "policy"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EgpPolicy resources.\n",
                "properties": {
                    "enforcementLevel": {
                        "type": "string",
                        "description": "Enforcement level of Sentinel policy. Can be either `advisory` or `soft-mandatory` or `hard-mandatory`\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the policy\n"
                    },
                    "paths": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of paths to which the policy will be applied to\n"
                    },
                    "policy": {
                        "type": "string",
                        "description": "String containing a Sentinel policy\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/mfaDuo:MfaDuo": {
            "properties": {
                "apiHostname": {
                    "type": "string",
                    "description": "API hostname for Duo.\n"
                },
                "integrationKey": {
                    "type": "string",
                    "description": "Integration key for Duo.\n"
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "The mount to tie this method to for use in automatic mappings. The mapping will use the Name field of Aliases associated\nwith this mount as the username in the mapping.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the MFA method.\n"
                },
                "pushInfo": {
                    "type": "string",
                    "description": "Push information for Duo.\n"
                },
                "secretKey": {
                    "type": "string",
                    "description": "Secret key for Duo.\n"
                },
                "usernameFormat": {
                    "type": "string",
                    "description": "A format string for mapping Identity names to MFA method names. Values to substitute should be placed in `{{}}`.\n"
                }
            },
            "required": [
                "apiHostname",
                "integrationKey",
                "mountAccessor",
                "name",
                "secretKey"
            ],
            "inputProperties": {
                "apiHostname": {
                    "type": "string",
                    "description": "API hostname for Duo.\n"
                },
                "integrationKey": {
                    "type": "string",
                    "description": "Integration key for Duo.\n"
                },
                "mountAccessor": {
                    "type": "string",
                    "description": "The mount to tie this method to for use in automatic mappings. The mapping will use the Name field of Aliases associated\nwith this mount as the username in the mapping.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the MFA method.\n"
                },
                "pushInfo": {
                    "type": "string",
                    "description": "Push information for Duo.\n"
                },
                "secretKey": {
                    "type": "string",
                    "description": "Secret key for Duo.\n"
                },
                "usernameFormat": {
                    "type": "string",
                    "description": "A format string for mapping Identity names to MFA method names. Values to substitute should be placed in `{{}}`.\n"
                }
            },
            "requiredInputs": [
                "apiHostname",
                "integrationKey",
                "mountAccessor",
                "secretKey"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MfaDuo resources.\n",
                "properties": {
                    "apiHostname": {
                        "type": "string",
                        "description": "API hostname for Duo.\n"
                    },
                    "integrationKey": {
                        "type": "string",
                        "description": "Integration key for Duo.\n"
                    },
                    "mountAccessor": {
                        "type": "string",
                        "description": "The mount to tie this method to for use in automatic mappings. The mapping will use the Name field of Aliases associated\nwith this mount as the username in the mapping.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the MFA method.\n"
                    },
                    "pushInfo": {
                        "type": "string",
                        "description": "Push information for Duo.\n"
                    },
                    "secretKey": {
                        "type": "string",
                        "description": "Secret key for Duo.\n"
                    },
                    "usernameFormat": {
                        "type": "string",
                        "description": "A format string for mapping Identity names to MFA method names. Values to substitute should be placed in `{{}}`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/mount:Mount": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.Mount(\"example\", {\n    description: \"This is an example mount\",\n    path: \"dummy\",\n    type: \"generic\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.Mount(\"example\",\n    description=\"This is an example mount\",\n    path=\"dummy\",\n    type=\"generic\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.Mount(\"example\", new Vault.MountArgs\n        {\n            Description = \"This is an example mount\",\n            Path = \"dummy\",\n            Type = \"generic\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewMount(ctx, \"example\", \u0026vault.MountArgs{\n\t\t\tDescription: pulumi.String(\"This is an example mount\"),\n\t\t\tPath:        pulumi.String(\"dummy\"),\n\t\t\tType:        pulumi.String(\"generic\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nMounts can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:index/mount:Mount example dummy\n```\n\n ",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The accessor for this mount.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Default lease duration for tokens and secrets in seconds\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount\n"
                },
                "externalEntropyAccess": {
                    "type": "boolean",
                    "description": "Enable the secrets engine to access Vault's external entropy source\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Local mount flag that can be explicitly set to true to enforce local mount in HA environment\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Maximum possible lease duration for tokens and secrets in seconds\n"
                },
                "options": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies mount type specific options that are passed to the backend\n"
                },
                "path": {
                    "type": "string",
                    "description": "Where the secret backend will be mounted\n"
                },
                "sealWrap": {
                    "type": "boolean",
                    "description": "Enable seal wrapping for the mount, causing values stored by the mount to be wrapped by the seal's encryption capability\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the backend, such as \"aws\"\n"
                }
            },
            "required": [
                "accessor",
                "defaultLeaseTtlSeconds",
                "maxLeaseTtlSeconds",
                "path",
                "sealWrap",
                "type"
            ],
            "inputProperties": {
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Default lease duration for tokens and secrets in seconds\n"
                },
                "description": {
                    "type": "string",
                    "description": "Human-friendly description of the mount\n"
                },
                "externalEntropyAccess": {
                    "type": "boolean",
                    "description": "Enable the secrets engine to access Vault's external entropy source\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "Local mount flag that can be explicitly set to true to enforce local mount in HA environment\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "Maximum possible lease duration for tokens and secrets in seconds\n"
                },
                "options": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies mount type specific options that are passed to the backend\n"
                },
                "path": {
                    "type": "string",
                    "description": "Where the secret backend will be mounted\n"
                },
                "sealWrap": {
                    "type": "boolean",
                    "description": "Enable seal wrapping for the mount, causing values stored by the mount to be wrapped by the seal's encryption capability\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the backend, such as \"aws\"\n"
                }
            },
            "requiredInputs": [
                "path",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Mount resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The accessor for this mount.\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "Default lease duration for tokens and secrets in seconds\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Human-friendly description of the mount\n"
                    },
                    "externalEntropyAccess": {
                        "type": "boolean",
                        "description": "Enable the secrets engine to access Vault's external entropy source\n"
                    },
                    "local": {
                        "type": "boolean",
                        "description": "Local mount flag that can be explicitly set to true to enforce local mount in HA environment\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "Maximum possible lease duration for tokens and secrets in seconds\n"
                    },
                    "options": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Specifies mount type specific options that are passed to the backend\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Where the secret backend will be mounted\n"
                    },
                    "sealWrap": {
                        "type": "boolean",
                        "description": "Enable seal wrapping for the mount, causing values stored by the mount to be wrapped by the seal's encryption capability\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of the backend, such as \"aws\"\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/namespace:Namespace": {
            "description": "Provides a resource to manage [Namespaces](https://www.vaultproject.io/docs/enterprise/namespaces/index.html).\n\n**Note** this feature is available only with Vault Enterprise.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst ns1 = new vault.Namespace(\"ns1\", {\n    path: \"ns1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nns1 = vault.Namespace(\"ns1\", path=\"ns1\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var ns1 = new Vault.Namespace(\"ns1\", new Vault.NamespaceArgs\n        {\n            Path = \"ns1\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewNamespace(ctx, \"ns1\", \u0026vault.NamespaceArgs{\n\t\t\tPath: pulumi.String(\"ns1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "namespaceId": {
                    "type": "string",
                    "description": "ID of the namepsace.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path of the namespace. Must not have a trailing `/`\n"
                }
            },
            "required": [
                "namespaceId",
                "path"
            ],
            "inputProperties": {
                "path": {
                    "type": "string",
                    "description": "The path of the namespace. Must not have a trailing `/`\n"
                }
            },
            "requiredInputs": [
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Namespace resources.\n",
                "properties": {
                    "namespaceId": {
                        "type": "string",
                        "description": "ID of the namepsace.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path of the namespace. Must not have a trailing `/`\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/policy:Policy": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.Policy(\"example\", {\n    policy: `path \"secret/my_app\" {\n  policy = \"write\"\n}\n`,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.Policy(\"example\", policy=\"\"\"path \"secret/my_app\" {\n  policy = \"write\"\n}\n\n\"\"\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.Policy(\"example\", new Vault.PolicyArgs\n        {\n            Policy = @\"path \"\"secret/my_app\"\" {\n  policy = \"\"write\"\"\n}\n\n\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewPolicy(ctx, \"example\", \u0026vault.PolicyArgs{\n\t\t\tPolicy: pulumi.String(fmt.Sprintf(\"%v%v%v%v\", \"path \\\"secret/my_app\\\" {\\n\", \"  policy = \\\"write\\\"\\n\", \"}\\n\", \"\\n\")),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nPolicies can be imported using the `name`, e.g.\n\n```sh\n $ pulumi import vault:index/policy:Policy example dev-team\n```\n\n ",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the policy\n"
                },
                "policy": {
                    "type": "string",
                    "description": "String containing a Vault policy\n",
                    "language": {
                        "csharp": {
                            "name": "PolicyContents"
                        }
                    }
                }
            },
            "required": [
                "name",
                "policy"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "The name of the policy\n"
                },
                "policy": {
                    "type": "string",
                    "description": "String containing a Vault policy\n",
                    "language": {
                        "csharp": {
                            "name": "PolicyContents"
                        }
                    }
                }
            },
            "requiredInputs": [
                "policy"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Policy resources.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the policy\n"
                    },
                    "policy": {
                        "type": "string",
                        "description": "String containing a Vault policy\n",
                        "language": {
                            "csharp": {
                                "name": "PolicyContents"
                            }
                        }
                    }
                },
                "type": "object"
            }
        },
        "vault:index/quotaRateLimit:QuotaRateLimit": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the quota.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path of the mount or namespace to apply the quota. A blank path configures a global rate limit quota.\n"
                },
                "rate": {
                    "type": "number",
                    "description": "The maximum number of requests at any given second to be allowed by the quota rule. The rate must be positive.\n"
                }
            },
            "required": [
                "name",
                "rate"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "The name of the quota.\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path of the mount or namespace to apply the quota. A blank path configures a global rate limit quota.\n"
                },
                "rate": {
                    "type": "number",
                    "description": "The maximum number of requests at any given second to be allowed by the quota rule. The rate must be positive.\n"
                }
            },
            "requiredInputs": [
                "rate"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering QuotaRateLimit resources.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the quota.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Path of the mount or namespace to apply the quota. A blank path configures a global rate limit quota.\n"
                    },
                    "rate": {
                        "type": "number",
                        "description": "The maximum number of requests at any given second to be allowed by the quota rule. The rate must be positive.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/rgpPolicy:RgpPolicy": {
            "description": "Provides a resource to manage Role Governing Policy (RGP) via [Sentinel](https://www.vaultproject.io/docs/enterprise/sentinel/index.html).\n\n**Note** this feature is available only with Vault Enterprise.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst allow_all = new vault.RgpPolicy(\"allow-all\", {\n    enforcementLevel: \"soft-mandatory\",\n    policy: `main = rule {\n  true\n}\n`,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nallow_all = vault.RgpPolicy(\"allow-all\",\n    enforcement_level=\"soft-mandatory\",\n    policy=\"\"\"main = rule {\n  true\n}\n\n\"\"\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var allow_all = new Vault.RgpPolicy(\"allow-all\", new Vault.RgpPolicyArgs\n        {\n            EnforcementLevel = \"soft-mandatory\",\n            Policy = @\"main = rule {\n  true\n}\n\n\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewRgpPolicy(ctx, \"allow_all\", \u0026vault.RgpPolicyArgs{\n\t\t\tEnforcementLevel: pulumi.String(\"soft-mandatory\"),\n\t\t\tPolicy:           pulumi.String(fmt.Sprintf(\"%v%v%v%v\", \"main = rule {\\n\", \"  true\\n\", \"}\\n\", \"\\n\")),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "enforcementLevel": {
                    "type": "string",
                    "description": "Enforcement level of Sentinel policy. Can be either `advisory` or `soft-mandatory` or `hard-mandatory`\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the policy\n"
                },
                "policy": {
                    "type": "string",
                    "description": "String containing a Sentinel policy\n"
                }
            },
            "required": [
                "enforcementLevel",
                "name",
                "policy"
            ],
            "inputProperties": {
                "enforcementLevel": {
                    "type": "string",
                    "description": "Enforcement level of Sentinel policy. Can be either `advisory` or `soft-mandatory` or `hard-mandatory`\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the policy\n"
                },
                "policy": {
                    "type": "string",
                    "description": "String containing a Sentinel policy\n"
                }
            },
            "requiredInputs": [
                "enforcementLevel",
                "policy"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RgpPolicy resources.\n",
                "properties": {
                    "enforcementLevel": {
                        "type": "string",
                        "description": "Enforcement level of Sentinel policy. Can be either `advisory` or `soft-mandatory` or `hard-mandatory`\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the policy\n"
                    },
                    "policy": {
                        "type": "string",
                        "description": "String containing a Sentinel policy\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:index/token:Token": {
            "description": "Provides a resource to generate a vault token with its options. The token renewing is supported through optional\narguments.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.Token(\"example\", {\n    policies: [\n        \"policy1\",\n        \"policy2\",\n    ],\n    renewIncrement: 86400,\n    renewMinLease: 43200,\n    renewable: true,\n    roleName: \"app\",\n    ttl: \"24h\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.Token(\"example\",\n    policies=[\n        \"policy1\",\n        \"policy2\",\n    ],\n    renew_increment=86400,\n    renew_min_lease=43200,\n    renewable=True,\n    role_name=\"app\",\n    ttl=\"24h\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.Token(\"example\", new Vault.TokenArgs\n        {\n            Policies = \n            {\n                \"policy1\",\n                \"policy2\",\n            },\n            RenewIncrement = 86400,\n            RenewMinLease = 43200,\n            Renewable = true,\n            RoleName = \"app\",\n            Ttl = \"24h\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.NewToken(ctx, \"example\", \u0026vault.TokenArgs{\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"policy1\"),\n\t\t\t\tpulumi.String(\"policy2\"),\n\t\t\t},\n\t\t\tRenewIncrement: pulumi.Int(86400),\n\t\t\tRenewMinLease:  pulumi.Int(43200),\n\t\t\tRenewable:      pulumi.Bool(true),\n\t\t\tRoleName:       pulumi.String(\"app\"),\n\t\t\tTtl:            pulumi.String(\"24h\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nTokens can be imported using its `id` as accessor id, e.g.\n\n```sh\n $ pulumi import vault:index/token:Token example \u003caccessor_id\u003e\n```\n\n ",
            "properties": {
                "clientToken": {
                    "type": "string",
                    "description": "String containing the client token if stored in present file\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "String containing the token display name\n"
                },
                "encryptedClientToken": {
                    "type": "string",
                    "description": "The client token encrypted using the provided PGP key.\n"
                },
                "explicitMaxTtl": {
                    "type": "string",
                    "description": "The explicit max TTL of this token\n"
                },
                "leaseDuration": {
                    "type": "integer",
                    "description": "String containing the token lease duration if present in state file\n"
                },
                "leaseStarted": {
                    "type": "string",
                    "description": "String containing the token lease started time if present in state file\n"
                },
                "noDefaultPolicy": {
                    "type": "boolean",
                    "description": "Flag to not attach the default policy to this token\n"
                },
                "noParent": {
                    "type": "boolean",
                    "description": "Flag to create a token without parent\n"
                },
                "numUses": {
                    "type": "integer",
                    "description": "The number of allowed uses of this token\n"
                },
                "period": {
                    "type": "string",
                    "description": "The period of this token\n"
                },
                "pgpKey": {
                    "type": "string",
                    "description": "The PGP key (base64 encoded) to encrypt the token.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to attach to this token\n"
                },
                "renewIncrement": {
                    "type": "integer",
                    "description": "The renew increment\n"
                },
                "renewMinLease": {
                    "type": "integer",
                    "description": "The minimal lease to renew this token\n"
                },
                "renewable": {
                    "type": "boolean",
                    "description": "Flag to allow to renew this token\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The token role name\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "The TTL period of this token\n"
                },
                "wrappedToken": {
                    "type": "string",
                    "description": "The client wrapped token.\n"
                },
                "wrappingAccessor": {
                    "type": "string",
                    "description": "The client wrapping accessor.\n"
                },
                "wrappingTtl": {
                    "type": "string",
                    "description": "The TTL period of the wrapped token.\n"
                }
            },
            "required": [
                "clientToken",
                "encryptedClientToken",
                "leaseDuration",
                "leaseStarted",
                "noParent",
                "numUses",
                "renewable",
                "wrappedToken",
                "wrappingAccessor"
            ],
            "inputProperties": {
                "displayName": {
                    "type": "string",
                    "description": "String containing the token display name\n"
                },
                "explicitMaxTtl": {
                    "type": "string",
                    "description": "The explicit max TTL of this token\n"
                },
                "noDefaultPolicy": {
                    "type": "boolean",
                    "description": "Flag to not attach the default policy to this token\n"
                },
                "noParent": {
                    "type": "boolean",
                    "description": "Flag to create a token without parent\n"
                },
                "numUses": {
                    "type": "integer",
                    "description": "The number of allowed uses of this token\n"
                },
                "period": {
                    "type": "string",
                    "description": "The period of this token\n"
                },
                "pgpKey": {
                    "type": "string",
                    "description": "The PGP key (base64 encoded) to encrypt the token.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of policies to attach to this token\n"
                },
                "renewIncrement": {
                    "type": "integer",
                    "description": "The renew increment\n"
                },
                "renewMinLease": {
                    "type": "integer",
                    "description": "The minimal lease to renew this token\n"
                },
                "renewable": {
                    "type": "boolean",
                    "description": "Flag to allow to renew this token\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The token role name\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "The TTL period of this token\n"
                },
                "wrappingTtl": {
                    "type": "string",
                    "description": "The TTL period of the wrapped token.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Token resources.\n",
                "properties": {
                    "clientToken": {
                        "type": "string",
                        "description": "String containing the client token if stored in present file\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "String containing the token display name\n"
                    },
                    "encryptedClientToken": {
                        "type": "string",
                        "description": "The client token encrypted using the provided PGP key.\n"
                    },
                    "explicitMaxTtl": {
                        "type": "string",
                        "description": "The explicit max TTL of this token\n"
                    },
                    "leaseDuration": {
                        "type": "integer",
                        "description": "String containing the token lease duration if present in state file\n"
                    },
                    "leaseStarted": {
                        "type": "string",
                        "description": "String containing the token lease started time if present in state file\n"
                    },
                    "noDefaultPolicy": {
                        "type": "boolean",
                        "description": "Flag to not attach the default policy to this token\n"
                    },
                    "noParent": {
                        "type": "boolean",
                        "description": "Flag to create a token without parent\n"
                    },
                    "numUses": {
                        "type": "integer",
                        "description": "The number of allowed uses of this token\n"
                    },
                    "period": {
                        "type": "string",
                        "description": "The period of this token\n"
                    },
                    "pgpKey": {
                        "type": "string",
                        "description": "The PGP key (base64 encoded) to encrypt the token.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of policies to attach to this token\n"
                    },
                    "renewIncrement": {
                        "type": "integer",
                        "description": "The renew increment\n"
                    },
                    "renewMinLease": {
                        "type": "integer",
                        "description": "The minimal lease to renew this token\n"
                    },
                    "renewable": {
                        "type": "boolean",
                        "description": "Flag to allow to renew this token\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The token role name\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "The TTL period of this token\n"
                    },
                    "wrappedToken": {
                        "type": "string",
                        "description": "The client wrapped token.\n"
                    },
                    "wrappingAccessor": {
                        "type": "string",
                        "description": "The client wrapping accessor.\n"
                    },
                    "wrappingTtl": {
                        "type": "string",
                        "description": "The TTL period of the wrapped token.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:jwt/authBackend:AuthBackend": {
            "description": "Provides a resource for managing an\n[JWT auth backend within Vault](https://www.vaultproject.io/docs/auth/jwt.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nManage JWT auth backend:\n \n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.jwt.AuthBackend(\"example\", {\n    boundIssuer: \"https://myco.auth0.com/\",\n    description: \"Demonstration of the Terraform JWT auth backend\",\n    oidcDiscoveryUrl: \"https://myco.auth0.com/\",\n    path: \"jwt\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.jwt.AuthBackend(\"example\",\n    bound_issuer=\"https://myco.auth0.com/\",\n    description=\"Demonstration of the Terraform JWT auth backend\",\n    oidc_discovery_url=\"https://myco.auth0.com/\",\n    path=\"jwt\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.Jwt.AuthBackend(\"example\", new Vault.Jwt.AuthBackendArgs\n        {\n            BoundIssuer = \"https://myco.auth0.com/\",\n            Description = \"Demonstration of the Terraform JWT auth backend\",\n            OidcDiscoveryUrl = \"https://myco.auth0.com/\",\n            Path = \"jwt\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/jwt\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := jwt.NewAuthBackend(ctx, \"example\", \u0026jwt.AuthBackendArgs{\n\t\t\tBoundIssuer:      pulumi.String(\"https://myco.auth0.com/\"),\n\t\t\tDescription:      pulumi.String(\"Demonstration of the Terraform JWT auth backend\"),\n\t\t\tOidcDiscoveryUrl: pulumi.String(\"https://myco.auth0.com/\"),\n\t\t\tPath:             pulumi.String(\"jwt\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\nManage OIDC auth backend:\n \n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.jwt.AuthBackend(\"example\", {\n    boundIssuer: \"https://myco.auth0.com/\",\n    description: \"Demonstration of the Terraform JWT auth backend\",\n    oidcClientId: \"1234567890\",\n    oidcClientSecret: \"secret123456\",\n    oidcDiscoveryUrl: \"https://myco.auth0.com/\",\n    path: \"oidc\",\n    tune: {\n        listingVisibility: \"unauth\",\n    },\n    type: \"oidc\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.jwt.AuthBackend(\"example\",\n    bound_issuer=\"https://myco.auth0.com/\",\n    description=\"Demonstration of the Terraform JWT auth backend\",\n    oidc_client_id=\"1234567890\",\n    oidc_client_secret=\"secret123456\",\n    oidc_discovery_url=\"https://myco.auth0.com/\",\n    path=\"oidc\",\n    tune=vault.jwt.AuthBackendTuneArgs(\n        listing_visibility=\"unauth\",\n    ),\n    type=\"oidc\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.Jwt.AuthBackend(\"example\", new Vault.Jwt.AuthBackendArgs\n        {\n            BoundIssuer = \"https://myco.auth0.com/\",\n            Description = \"Demonstration of the Terraform JWT auth backend\",\n            OidcClientId = \"1234567890\",\n            OidcClientSecret = \"secret123456\",\n            OidcDiscoveryUrl = \"https://myco.auth0.com/\",\n            Path = \"oidc\",\n            Tune = new Vault.Jwt.Inputs.AuthBackendTuneArgs\n            {\n                ListingVisibility = \"unauth\",\n            },\n            Type = \"oidc\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/jwt\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := jwt.NewAuthBackend(ctx, \"example\", \u0026jwt.AuthBackendArgs{\n\t\t\tBoundIssuer:      pulumi.String(\"https://myco.auth0.com/\"),\n\t\t\tDescription:      pulumi.String(\"Demonstration of the Terraform JWT auth backend\"),\n\t\t\tOidcClientId:     pulumi.String(\"1234567890\"),\n\t\t\tOidcClientSecret: pulumi.String(\"secret123456\"),\n\t\t\tOidcDiscoveryUrl: pulumi.String(\"https://myco.auth0.com/\"),\n\t\t\tPath:             pulumi.String(\"oidc\"),\n\t\t\tTune: \u0026jwt.AuthBackendTuneArgs{\n\t\t\t\tListingVisibility: pulumi.String(\"unauth\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"oidc\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The accessor of the JWT auth backend\n"
                },
                "boundIssuer": {
                    "type": "string",
                    "description": "The value against which to match the iss claim in a JWT\n"
                },
                "defaultRole": {
                    "type": "string",
                    "description": "The default role to use if none is provided during login\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the auth backend\n"
                },
                "jwksCaPem": {
                    "type": "string",
                    "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the JWKS URL. If not set,\nsystem certificates are used.\n"
                },
                "jwksUrl": {
                    "type": "string",
                    "description": "JWKS URL to use to authenticate signatures. Cannot be used with 'oidc_discovery_url' or 'jwt_validation_pubkeys'.\n"
                },
                "jwtSupportedAlgs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of supported signing algorithms. Vault 1.1.0 defaults to [RS256] but future or past versions of Vault may differ\n"
                },
                "jwtValidationPubkeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of PEM-encoded public keys to use to authenticate signatures locally. Cannot be used in combination with `oidc_discovery_url`\n"
                },
                "oidcClientId": {
                    "type": "string",
                    "description": "Client ID used for OIDC backends\n"
                },
                "oidcClientSecret": {
                    "type": "string",
                    "description": "Client Secret used for OIDC backends\n"
                },
                "oidcDiscoveryCaPem": {
                    "type": "string",
                    "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the OIDC Discovery URL. If not set, system certificates are used\n"
                },
                "oidcDiscoveryUrl": {
                    "type": "string",
                    "description": "The OIDC Discovery URL, without any .well-known component (base path). Cannot be used in combination with `jwt_validation_pubkeys`\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to mount the JWT/OIDC auth backend\n"
                },
                "tune": {
                    "$ref": "#/types/vault:jwt/AuthBackendTune:AuthBackendTune"
                },
                "type": {
                    "type": "string",
                    "description": "Type of auth backend. Should be one of `jwt` or `oidc`. Default - `jwt`\n"
                }
            },
            "required": [
                "accessor",
                "tune"
            ],
            "inputProperties": {
                "boundIssuer": {
                    "type": "string",
                    "description": "The value against which to match the iss claim in a JWT\n"
                },
                "defaultRole": {
                    "type": "string",
                    "description": "The default role to use if none is provided during login\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the auth backend\n"
                },
                "jwksCaPem": {
                    "type": "string",
                    "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the JWKS URL. If not set,\nsystem certificates are used.\n"
                },
                "jwksUrl": {
                    "type": "string",
                    "description": "JWKS URL to use to authenticate signatures. Cannot be used with 'oidc_discovery_url' or 'jwt_validation_pubkeys'.\n"
                },
                "jwtSupportedAlgs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of supported signing algorithms. Vault 1.1.0 defaults to [RS256] but future or past versions of Vault may differ\n"
                },
                "jwtValidationPubkeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of PEM-encoded public keys to use to authenticate signatures locally. Cannot be used in combination with `oidc_discovery_url`\n"
                },
                "oidcClientId": {
                    "type": "string",
                    "description": "Client ID used for OIDC backends\n"
                },
                "oidcClientSecret": {
                    "type": "string",
                    "description": "Client Secret used for OIDC backends\n"
                },
                "oidcDiscoveryCaPem": {
                    "type": "string",
                    "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the OIDC Discovery URL. If not set, system certificates are used\n"
                },
                "oidcDiscoveryUrl": {
                    "type": "string",
                    "description": "The OIDC Discovery URL, without any .well-known component (base path). Cannot be used in combination with `jwt_validation_pubkeys`\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to mount the JWT/OIDC auth backend\n"
                },
                "tune": {
                    "$ref": "#/types/vault:jwt/AuthBackendTune:AuthBackendTune"
                },
                "type": {
                    "type": "string",
                    "description": "Type of auth backend. Should be one of `jwt` or `oidc`. Default - `jwt`\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackend resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The accessor of the JWT auth backend\n"
                    },
                    "boundIssuer": {
                        "type": "string",
                        "description": "The value against which to match the iss claim in a JWT\n"
                    },
                    "defaultRole": {
                        "type": "string",
                        "description": "The default role to use if none is provided during login\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the auth backend\n"
                    },
                    "jwksCaPem": {
                        "type": "string",
                        "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the JWKS URL. If not set,\nsystem certificates are used.\n"
                    },
                    "jwksUrl": {
                        "type": "string",
                        "description": "JWKS URL to use to authenticate signatures. Cannot be used with 'oidc_discovery_url' or 'jwt_validation_pubkeys'.\n"
                    },
                    "jwtSupportedAlgs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of supported signing algorithms. Vault 1.1.0 defaults to [RS256] but future or past versions of Vault may differ\n"
                    },
                    "jwtValidationPubkeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of PEM-encoded public keys to use to authenticate signatures locally. Cannot be used in combination with `oidc_discovery_url`\n"
                    },
                    "oidcClientId": {
                        "type": "string",
                        "description": "Client ID used for OIDC backends\n"
                    },
                    "oidcClientSecret": {
                        "type": "string",
                        "description": "Client Secret used for OIDC backends\n"
                    },
                    "oidcDiscoveryCaPem": {
                        "type": "string",
                        "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the OIDC Discovery URL. If not set, system certificates are used\n"
                    },
                    "oidcDiscoveryUrl": {
                        "type": "string",
                        "description": "The OIDC Discovery URL, without any .well-known component (base path). Cannot be used in combination with `jwt_validation_pubkeys`\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Path to mount the JWT/OIDC auth backend\n"
                    },
                    "tune": {
                        "$ref": "#/types/vault:jwt/AuthBackendTune:AuthBackendTune"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of auth backend. Should be one of `jwt` or `oidc`. Default - `jwt`\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:jwt/authBackendRole:AuthBackendRole": {
            "description": "Manages an JWT/OIDC auth backend role in a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/jwt.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nRole for JWT backend:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst jwt = new vault.jwt.AuthBackend(\"jwt\", {\n    path: \"jwt\",\n});\nconst example = new vault.jwt.AuthBackendRole(\"example\", {\n    backend: jwt.path,\n    boundAudiences: [\"https://myco.test\"],\n    policies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    roleName: \"test-role\",\n    roleType: \"jwt\",\n    userClaim: \"https://vault/user\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\njwt = vault.jwt.AuthBackend(\"jwt\", path=\"jwt\")\nexample = vault.jwt.AuthBackendRole(\"example\",\n    backend=jwt.path,\n    bound_audiences=[\"https://myco.test\"],\n    policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    role_name=\"test-role\",\n    role_type=\"jwt\",\n    user_claim=\"https://vault/user\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var jwt = new Vault.Jwt.AuthBackend(\"jwt\", new Vault.Jwt.AuthBackendArgs\n        {\n            Path = \"jwt\",\n        });\n        var example = new Vault.Jwt.AuthBackendRole(\"example\", new Vault.Jwt.AuthBackendRoleArgs\n        {\n            Backend = jwt.Path,\n            BoundAudiences = \n            {\n                \"https://myco.test\",\n            },\n            Policies = \n            {\n                \"default\",\n                \"dev\",\n                \"prod\",\n            },\n            RoleName = \"test-role\",\n            RoleType = \"jwt\",\n            UserClaim = \"https://vault/user\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/jwt\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tjwt, err := jwt.NewAuthBackend(ctx, \"jwt\", \u0026jwt.AuthBackendArgs{\n\t\t\tPath: pulumi.String(\"jwt\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = jwt.NewAuthBackendRole(ctx, \"example\", \u0026jwt.AuthBackendRoleArgs{\n\t\t\tBackend: jwt.Path,\n\t\t\tBoundAudiences: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"https://myco.test\"),\n\t\t\t},\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t\tRoleName:  pulumi.String(\"test-role\"),\n\t\t\tRoleType:  pulumi.String(\"jwt\"),\n\t\t\tUserClaim: pulumi.String(\"https://vault/user\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\nRole for OIDC backend:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst oidc = new vault.jwt.AuthBackend(\"oidc\", {\n    defaultRole: \"test-role\",\n    path: \"oidc\",\n});\nconst example = new vault.jwt.AuthBackendRole(\"example\", {\n    allowedRedirectUris: [\"http://localhost:8200/ui/vault/auth/oidc/oidc/callback\"],\n    backend: oidc.path,\n    boundAudiences: [\"https://myco.test\"],\n    policies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    roleName: \"test-role\",\n    roleType: \"oidc\",\n    userClaim: \"https://vault/user\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\noidc = vault.jwt.AuthBackend(\"oidc\",\n    default_role=\"test-role\",\n    path=\"oidc\")\nexample = vault.jwt.AuthBackendRole(\"example\",\n    allowed_redirect_uris=[\"http://localhost:8200/ui/vault/auth/oidc/oidc/callback\"],\n    backend=oidc.path,\n    bound_audiences=[\"https://myco.test\"],\n    policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    role_name=\"test-role\",\n    role_type=\"oidc\",\n    user_claim=\"https://vault/user\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var oidc = new Vault.Jwt.AuthBackend(\"oidc\", new Vault.Jwt.AuthBackendArgs\n        {\n            DefaultRole = \"test-role\",\n            Path = \"oidc\",\n        });\n        var example = new Vault.Jwt.AuthBackendRole(\"example\", new Vault.Jwt.AuthBackendRoleArgs\n        {\n            AllowedRedirectUris = \n            {\n                \"http://localhost:8200/ui/vault/auth/oidc/oidc/callback\",\n            },\n            Backend = oidc.Path,\n            BoundAudiences = \n            {\n                \"https://myco.test\",\n            },\n            Policies = \n            {\n                \"default\",\n                \"dev\",\n                \"prod\",\n            },\n            RoleName = \"test-role\",\n            RoleType = \"oidc\",\n            UserClaim = \"https://vault/user\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/jwt\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\toidc, err := jwt.NewAuthBackend(ctx, \"oidc\", \u0026jwt.AuthBackendArgs{\n\t\t\tDefaultRole: pulumi.String(\"test-role\"),\n\t\t\tPath:        pulumi.String(\"oidc\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = jwt.NewAuthBackendRole(ctx, \"example\", \u0026jwt.AuthBackendRoleArgs{\n\t\t\tAllowedRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8200/ui/vault/auth/oidc/oidc/callback\"),\n\t\t\t},\n\t\t\tBackend: oidc.Path,\n\t\t\tBoundAudiences: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"https://myco.test\"),\n\t\t\t},\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t\tRoleName:  pulumi.String(\"test-role\"),\n\t\t\tRoleType:  pulumi.String(\"oidc\"),\n\t\t\tUserClaim: pulumi.String(\"https://vault/user\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nJWT authentication backend roles can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:jwt/authBackendRole:AuthBackendRole example auth/jwt/role/test-role\n```\n\n ",
            "properties": {
                "allowedRedirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of allowed values for redirect_uri during OIDC logins.\nRequired for OIDC roles\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique name of the auth backend to configure.\nDefaults to `jwt`.\n"
                },
                "boundAudiences": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of `aud` claims to match\nagainst. Any match is sufficient.\n"
                },
                "boundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, a list of CIDRs valid as the source\naddress for login requests. This value is also encoded into any resulting\ntoken.\n",
                    "deprecationMessage": "use `token_bound_cidrs` instead if you are running Vault \u003e= 1.2"
                },
                "boundClaims": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "If set, a map of claims/values to match against. \nThe expected value may be a single string or a list of strings.\n"
                },
                "boundClaimsType": {
                    "type": "string",
                    "description": "How to interpret values in the claims/values map: can be either \"string\" (exact match) or \"glob\" (wildcard match).\n"
                },
                "boundSubject": {
                    "type": "string",
                    "description": "If set, requires that the `sub` claim matches\nthis value.\n"
                },
                "claimMappings": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "If set, a map of claims (keys) to be copied \nto specified metadata fields (values).\n"
                },
                "clockSkewLeeway": {
                    "type": "integer",
                    "description": "The amount of leeway to add to all claims to account for clock skew, in seconds. Defaults to 60 seconds if set to 0 and\ncan be disabled if set to -1. Only applicable with 'jwt' roles.\n"
                },
                "expirationLeeway": {
                    "type": "integer",
                    "description": "The amount of leeway to add to expiration (exp) claims to account for clock skew, in seconds. Defaults to 60 seconds if\nset to 0 and can be disabled if set to -1. Only applicable with 'jwt' roles.\n"
                },
                "groupsClaim": {
                    "type": "string",
                    "description": "The claim to use to uniquely identify\nthe set of groups to which the user belongs; this will be used as the names\nfor the Identity group aliases created due to a successful login. The claim\nvalue must be a list of strings.\n"
                },
                "groupsClaimDelimiterPattern": {
                    "type": "string",
                    "description": "(Optional; Deprecated. This field has been\nremoved since Vault 1.1. If the groups claim is not at the top level, it can\nnow be specified as a [JSONPointer](https://tools.ietf.org/html/rfc6901).)\nA pattern of delimiters\nused to allow the groups_claim to live outside of the top-level JWT structure.\nFor instance, a groups_claim of meta/user.name/groups with this field\nset to // will expect nested structures named meta, user.name, and groups.\nIf this field was set to /./ the groups information would expect to be\nvia nested structures of meta, user, name, and groups.\n",
                    "deprecationMessage": "`groups_claim_delimiter_pattern` has been removed since Vault 1.1. If the groups claim is not at the top level, it can now be specified as a JSONPointer."
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum allowed lifetime of tokens issued using\nthis role, in seconds.\n",
                    "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "notBeforeLeeway": {
                    "type": "integer",
                    "description": "The amount of leeway to add to not before (nbf) claims to account for clock skew, in seconds. Defaults to 150 seconds if\nset to 0 and can be disabled if set to -1. Only applicable with 'jwt' roles.\n"
                },
                "numUses": {
                    "type": "integer",
                    "description": "If set, puts a use-count limitation on the issued\ntoken.\n",
                    "deprecationMessage": "use `token_num_uses` instead if you are running Vault \u003e= 1.2"
                },
                "oidcScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, a list of OIDC scopes to be used with an OIDC role. \nThe standard scope \"openid\" is automatically included and need not be specified.\n"
                },
                "period": {
                    "type": "integer",
                    "description": "If set, indicates that the token generated\nusing this role should never expire, but instead always use the value set\nhere as the TTL for every renewal.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Policies to be set on tokens issued using this role.\n",
                    "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "roleType": {
                    "type": "string",
                    "description": "Type of role, either \"oidc\" (default) or \"jwt\".\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The initial/renewal TTL of tokens issued using this role,\nin seconds.\n",
                    "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "userClaim": {
                    "type": "string",
                    "description": "The claim to use to uniquely identify\nthe user; this will be used as the name for the Identity entity alias created\ndue to a successful login.\n"
                },
                "verboseOidcLogging": {
                    "type": "boolean",
                    "description": "Log received OIDC tokens and claims when debug-level logging is active. Not recommended in production since sensitive\ninformation may be present in OIDC responses.\n"
                }
            },
            "required": [
                "boundClaimsType",
                "roleName",
                "roleType",
                "userClaim"
            ],
            "inputProperties": {
                "allowedRedirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of allowed values for redirect_uri during OIDC logins.\nRequired for OIDC roles\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The unique name of the auth backend to configure.\nDefaults to `jwt`.\n"
                },
                "boundAudiences": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of `aud` claims to match\nagainst. Any match is sufficient.\n"
                },
                "boundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, a list of CIDRs valid as the source\naddress for login requests. This value is also encoded into any resulting\ntoken.\n",
                    "deprecationMessage": "use `token_bound_cidrs` instead if you are running Vault \u003e= 1.2"
                },
                "boundClaims": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "If set, a map of claims/values to match against. \nThe expected value may be a single string or a list of strings.\n"
                },
                "boundClaimsType": {
                    "type": "string",
                    "description": "How to interpret values in the claims/values map: can be either \"string\" (exact match) or \"glob\" (wildcard match).\n"
                },
                "boundSubject": {
                    "type": "string",
                    "description": "If set, requires that the `sub` claim matches\nthis value.\n"
                },
                "claimMappings": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "If set, a map of claims (keys) to be copied \nto specified metadata fields (values).\n"
                },
                "clockSkewLeeway": {
                    "type": "integer",
                    "description": "The amount of leeway to add to all claims to account for clock skew, in seconds. Defaults to 60 seconds if set to 0 and\ncan be disabled if set to -1. Only applicable with 'jwt' roles.\n"
                },
                "expirationLeeway": {
                    "type": "integer",
                    "description": "The amount of leeway to add to expiration (exp) claims to account for clock skew, in seconds. Defaults to 60 seconds if\nset to 0 and can be disabled if set to -1. Only applicable with 'jwt' roles.\n"
                },
                "groupsClaim": {
                    "type": "string",
                    "description": "The claim to use to uniquely identify\nthe set of groups to which the user belongs; this will be used as the names\nfor the Identity group aliases created due to a successful login. The claim\nvalue must be a list of strings.\n"
                },
                "groupsClaimDelimiterPattern": {
                    "type": "string",
                    "description": "(Optional; Deprecated. This field has been\nremoved since Vault 1.1. If the groups claim is not at the top level, it can\nnow be specified as a [JSONPointer](https://tools.ietf.org/html/rfc6901).)\nA pattern of delimiters\nused to allow the groups_claim to live outside of the top-level JWT structure.\nFor instance, a groups_claim of meta/user.name/groups with this field\nset to // will expect nested structures named meta, user.name, and groups.\nIf this field was set to /./ the groups information would expect to be\nvia nested structures of meta, user, name, and groups.\n",
                    "deprecationMessage": "`groups_claim_delimiter_pattern` has been removed since Vault 1.1. If the groups claim is not at the top level, it can now be specified as a JSONPointer."
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum allowed lifetime of tokens issued using\nthis role, in seconds.\n",
                    "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "notBeforeLeeway": {
                    "type": "integer",
                    "description": "The amount of leeway to add to not before (nbf) claims to account for clock skew, in seconds. Defaults to 150 seconds if\nset to 0 and can be disabled if set to -1. Only applicable with 'jwt' roles.\n"
                },
                "numUses": {
                    "type": "integer",
                    "description": "If set, puts a use-count limitation on the issued\ntoken.\n",
                    "deprecationMessage": "use `token_num_uses` instead if you are running Vault \u003e= 1.2"
                },
                "oidcScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, a list of OIDC scopes to be used with an OIDC role. \nThe standard scope \"openid\" is automatically included and need not be specified.\n"
                },
                "period": {
                    "type": "integer",
                    "description": "If set, indicates that the token generated\nusing this role should never expire, but instead always use the value set\nhere as the TTL for every renewal.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Policies to be set on tokens issued using this role.\n",
                    "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "roleType": {
                    "type": "string",
                    "description": "Type of role, either \"oidc\" (default) or \"jwt\".\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The initial/renewal TTL of tokens issued using this role,\nin seconds.\n",
                    "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "userClaim": {
                    "type": "string",
                    "description": "The claim to use to uniquely identify\nthe user; this will be used as the name for the Identity entity alias created\ndue to a successful login.\n"
                },
                "verboseOidcLogging": {
                    "type": "boolean",
                    "description": "Log received OIDC tokens and claims when debug-level logging is active. Not recommended in production since sensitive\ninformation may be present in OIDC responses.\n"
                }
            },
            "requiredInputs": [
                "roleName",
                "userClaim"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "allowedRedirectUris": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of allowed values for redirect_uri during OIDC logins.\nRequired for OIDC roles\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The unique name of the auth backend to configure.\nDefaults to `jwt`.\n"
                    },
                    "boundAudiences": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of `aud` claims to match\nagainst. Any match is sufficient.\n"
                    },
                    "boundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, a list of CIDRs valid as the source\naddress for login requests. This value is also encoded into any resulting\ntoken.\n",
                        "deprecationMessage": "use `token_bound_cidrs` instead if you are running Vault \u003e= 1.2"
                    },
                    "boundClaims": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "If set, a map of claims/values to match against. \nThe expected value may be a single string or a list of strings.\n"
                    },
                    "boundClaimsType": {
                        "type": "string",
                        "description": "How to interpret values in the claims/values map: can be either \"string\" (exact match) or \"glob\" (wildcard match).\n"
                    },
                    "boundSubject": {
                        "type": "string",
                        "description": "If set, requires that the `sub` claim matches\nthis value.\n"
                    },
                    "claimMappings": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "If set, a map of claims (keys) to be copied \nto specified metadata fields (values).\n"
                    },
                    "clockSkewLeeway": {
                        "type": "integer",
                        "description": "The amount of leeway to add to all claims to account for clock skew, in seconds. Defaults to 60 seconds if set to 0 and\ncan be disabled if set to -1. Only applicable with 'jwt' roles.\n"
                    },
                    "expirationLeeway": {
                        "type": "integer",
                        "description": "The amount of leeway to add to expiration (exp) claims to account for clock skew, in seconds. Defaults to 60 seconds if\nset to 0 and can be disabled if set to -1. Only applicable with 'jwt' roles.\n"
                    },
                    "groupsClaim": {
                        "type": "string",
                        "description": "The claim to use to uniquely identify\nthe set of groups to which the user belongs; this will be used as the names\nfor the Identity group aliases created due to a successful login. The claim\nvalue must be a list of strings.\n"
                    },
                    "groupsClaimDelimiterPattern": {
                        "type": "string",
                        "description": "(Optional; Deprecated. This field has been\nremoved since Vault 1.1. If the groups claim is not at the top level, it can\nnow be specified as a [JSONPointer](https://tools.ietf.org/html/rfc6901).)\nA pattern of delimiters\nused to allow the groups_claim to live outside of the top-level JWT structure.\nFor instance, a groups_claim of meta/user.name/groups with this field\nset to // will expect nested structures named meta, user.name, and groups.\nIf this field was set to /./ the groups information would expect to be\nvia nested structures of meta, user, name, and groups.\n",
                        "deprecationMessage": "`groups_claim_delimiter_pattern` has been removed since Vault 1.1. If the groups claim is not at the top level, it can now be specified as a JSONPointer."
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "The maximum allowed lifetime of tokens issued using\nthis role, in seconds.\n",
                        "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                    },
                    "notBeforeLeeway": {
                        "type": "integer",
                        "description": "The amount of leeway to add to not before (nbf) claims to account for clock skew, in seconds. Defaults to 150 seconds if\nset to 0 and can be disabled if set to -1. Only applicable with 'jwt' roles.\n"
                    },
                    "numUses": {
                        "type": "integer",
                        "description": "If set, puts a use-count limitation on the issued\ntoken.\n",
                        "deprecationMessage": "use `token_num_uses` instead if you are running Vault \u003e= 1.2"
                    },
                    "oidcScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, a list of OIDC scopes to be used with an OIDC role. \nThe standard scope \"openid\" is automatically included and need not be specified.\n"
                    },
                    "period": {
                        "type": "integer",
                        "description": "If set, indicates that the token generated\nusing this role should never expire, but instead always use the value set\nhere as the TTL for every renewal.\n",
                        "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Policies to be set on tokens issued using this role.\n",
                        "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "roleType": {
                        "type": "string",
                        "description": "Type of role, either \"oidc\" (default) or \"jwt\".\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime of the generated token\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "Generated Token's Period\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Generated Token's Policies\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The initial ttl of the token to generate in seconds\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token to generate, service or batch\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "The initial/renewal TTL of tokens issued using this role,\nin seconds.\n",
                        "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                    },
                    "userClaim": {
                        "type": "string",
                        "description": "The claim to use to uniquely identify\nthe user; this will be used as the name for the Identity entity alias created\ndue to a successful login.\n"
                    },
                    "verboseOidcLogging": {
                        "type": "boolean",
                        "description": "Log received OIDC tokens and claims when debug-level logging is active. Not recommended in production since sensitive\ninformation may be present in OIDC responses.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:kubernetes/authBackendConfig:AuthBackendConfig": {
            "description": "Manages an Kubernetes auth backend config in a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/kubernetes.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst kubernetes = new vault.AuthBackend(\"kubernetes\", {\n    type: \"kubernetes\",\n});\nconst example = new vault.kubernetes.AuthBackendConfig(\"example\", {\n    backend: kubernetes.path,\n    kubernetesCaCert: `-----BEGIN CERTIFICATE-----\nexample\n-----END CERTIFICATE-----`,\n    kubernetesHost: \"http://example.com:443\",\n    tokenReviewerJwt: \"ZXhhbXBsZQo=\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nkubernetes = vault.AuthBackend(\"kubernetes\", type=\"kubernetes\")\nexample = vault.kubernetes.AuthBackendConfig(\"example\",\n    backend=kubernetes.path,\n    kubernetes_ca_cert=\"\"\"-----BEGIN CERTIFICATE-----\nexample\n-----END CERTIFICATE-----\n\"\"\",\n    kubernetes_host=\"http://example.com:443\",\n    token_reviewer_jwt=\"ZXhhbXBsZQo=\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var kubernetes = new Vault.AuthBackend(\"kubernetes\", new Vault.AuthBackendArgs\n        {\n            Type = \"kubernetes\",\n        });\n        var example = new Vault.Kubernetes.AuthBackendConfig(\"example\", new Vault.Kubernetes.AuthBackendConfigArgs\n        {\n            Backend = kubernetes.Path,\n            KubernetesCaCert = @\"-----BEGIN CERTIFICATE-----\nexample\n-----END CERTIFICATE-----\n\",\n            KubernetesHost = \"http://example.com:443\",\n            TokenReviewerJwt = \"ZXhhbXBsZQo=\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/kubernetes\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tkubernetes, err := vault.NewAuthBackend(ctx, \"kubernetes\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"kubernetes\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = kubernetes.NewAuthBackendConfig(ctx, \"example\", \u0026kubernetes.AuthBackendConfigArgs{\n\t\t\tBackend:          kubernetes.Path,\n\t\t\tKubernetesCaCert: pulumi.String(fmt.Sprintf(\"%v%v%v\", \"-----BEGIN CERTIFICATE-----\\n\", \"example\\n\", \"-----END CERTIFICATE-----\\n\")),\n\t\t\tKubernetesHost:   pulumi.String(\"http://example.com:443\"),\n\t\t\tTokenReviewerJwt: pulumi.String(\"ZXhhbXBsZQo=\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Unique name of the kubernetes backend to configure.\n"
                },
                "disableIssValidation": {
                    "type": "boolean",
                    "description": "Optional disable JWT issuer validation. Allows to skip ISS validation.\n"
                },
                "disableLocalCaJwt": {
                    "type": "boolean",
                    "description": "Optional disable defaulting to the local CA cert and service account JWT when running in a Kubernetes pod.\n"
                },
                "issuer": {
                    "type": "string",
                    "description": "Optional JWT issuer. If no issuer is specified, kubernetes.io/serviceaccount will be used as the default issuer.\n"
                },
                "kubernetesCaCert": {
                    "type": "string",
                    "description": "PEM encoded CA cert for use by the TLS client used to talk with the Kubernetes API.\n"
                },
                "kubernetesHost": {
                    "type": "string",
                    "description": "Host must be a host string, a host:port pair, or a URL to the base of the Kubernetes API server.\n"
                },
                "pemKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of PEM-formatted public keys or certificates used to verify the signatures of Kubernetes service account JWTs. If a certificate is given, its public key will be extracted. Not every installation of Kubernetes exposes these keys.\n"
                },
                "tokenReviewerJwt": {
                    "type": "string",
                    "description": "A service account JWT used to access the TokenReview API to validate other JWTs during login. If not set the JWT used for login will be used to access the API.\n"
                }
            },
            "required": [
                "disableIssValidation",
                "disableLocalCaJwt",
                "kubernetesHost"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Unique name of the kubernetes backend to configure.\n"
                },
                "disableIssValidation": {
                    "type": "boolean",
                    "description": "Optional disable JWT issuer validation. Allows to skip ISS validation.\n"
                },
                "disableLocalCaJwt": {
                    "type": "boolean",
                    "description": "Optional disable defaulting to the local CA cert and service account JWT when running in a Kubernetes pod.\n"
                },
                "issuer": {
                    "type": "string",
                    "description": "Optional JWT issuer. If no issuer is specified, kubernetes.io/serviceaccount will be used as the default issuer.\n"
                },
                "kubernetesCaCert": {
                    "type": "string",
                    "description": "PEM encoded CA cert for use by the TLS client used to talk with the Kubernetes API.\n"
                },
                "kubernetesHost": {
                    "type": "string",
                    "description": "Host must be a host string, a host:port pair, or a URL to the base of the Kubernetes API server.\n"
                },
                "pemKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of PEM-formatted public keys or certificates used to verify the signatures of Kubernetes service account JWTs. If a certificate is given, its public key will be extracted. Not every installation of Kubernetes exposes these keys.\n"
                },
                "tokenReviewerJwt": {
                    "type": "string",
                    "description": "A service account JWT used to access the TokenReview API to validate other JWTs during login. If not set the JWT used for login will be used to access the API.\n"
                }
            },
            "requiredInputs": [
                "kubernetesHost"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendConfig resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Unique name of the kubernetes backend to configure.\n"
                    },
                    "disableIssValidation": {
                        "type": "boolean",
                        "description": "Optional disable JWT issuer validation. Allows to skip ISS validation.\n"
                    },
                    "disableLocalCaJwt": {
                        "type": "boolean",
                        "description": "Optional disable defaulting to the local CA cert and service account JWT when running in a Kubernetes pod.\n"
                    },
                    "issuer": {
                        "type": "string",
                        "description": "Optional JWT issuer. If no issuer is specified, kubernetes.io/serviceaccount will be used as the default issuer.\n"
                    },
                    "kubernetesCaCert": {
                        "type": "string",
                        "description": "PEM encoded CA cert for use by the TLS client used to talk with the Kubernetes API.\n"
                    },
                    "kubernetesHost": {
                        "type": "string",
                        "description": "Host must be a host string, a host:port pair, or a URL to the base of the Kubernetes API server.\n"
                    },
                    "pemKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of PEM-formatted public keys or certificates used to verify the signatures of Kubernetes service account JWTs. If a certificate is given, its public key will be extracted. Not every installation of Kubernetes exposes these keys.\n"
                    },
                    "tokenReviewerJwt": {
                        "type": "string",
                        "description": "A service account JWT used to access the TokenReview API to validate other JWTs during login. If not set the JWT used for login will be used to access the API.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:kubernetes/authBackendRole:AuthBackendRole": {
            "description": "Manages an Kubernetes auth backend role in a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/kubernetes.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst kubernetes = new vault.AuthBackend(\"kubernetes\", {\n    type: \"kubernetes\",\n});\nconst example = new vault.kubernetes.AuthBackendRole(\"example\", {\n    backend: kubernetes.path,\n    boundServiceAccountNames: [\"example\"],\n    boundServiceAccountNamespaces: [\"example\"],\n    policies: [\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    roleName: \"example-role\",\n    ttl: 3600,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nkubernetes = vault.AuthBackend(\"kubernetes\", type=\"kubernetes\")\nexample = vault.kubernetes.AuthBackendRole(\"example\",\n    backend=kubernetes.path,\n    bound_service_account_names=[\"example\"],\n    bound_service_account_namespaces=[\"example\"],\n    policies=[\n        \"default\",\n        \"dev\",\n        \"prod\",\n    ],\n    role_name=\"example-role\",\n    ttl=3600)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var kubernetes = new Vault.AuthBackend(\"kubernetes\", new Vault.AuthBackendArgs\n        {\n            Type = \"kubernetes\",\n        });\n        var example = new Vault.Kubernetes.AuthBackendRole(\"example\", new Vault.Kubernetes.AuthBackendRoleArgs\n        {\n            Backend = kubernetes.Path,\n            BoundServiceAccountNames = \n            {\n                \"example\",\n            },\n            BoundServiceAccountNamespaces = \n            {\n                \"example\",\n            },\n            Policies = \n            {\n                \"default\",\n                \"dev\",\n                \"prod\",\n            },\n            RoleName = \"example-role\",\n            Ttl = 3600,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/kubernetes\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tkubernetes, err := vault.NewAuthBackend(ctx, \"kubernetes\", \u0026vault.AuthBackendArgs{\n\t\t\tType: pulumi.String(\"kubernetes\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = kubernetes.NewAuthBackendRole(ctx, \"example\", \u0026kubernetes.AuthBackendRoleArgs{\n\t\t\tBackend: kubernetes.Path,\n\t\t\tBoundServiceAccountNames: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"example\"),\n\t\t\t},\n\t\t\tBoundServiceAccountNamespaces: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"example\"),\n\t\t\t},\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t},\n\t\t\tRoleName: pulumi.String(\"example-role\"),\n\t\t\tTtl:      pulumi.Int(3600),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "audience": {
                    "type": "string",
                    "description": "Optional Audience claim to verify in the JWT.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Unique name of the kubernetes backend to configure.\n"
                },
                "boundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDRs valid as the source address for login requests. This value is also encoded into any resulting token.\n",
                    "deprecationMessage": "use `token_bound_cidrs` instead if you are running Vault \u003e= 1.2"
                },
                "boundServiceAccountNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of service account names able to access this role. If set to `[\"*\"]` all names are allowed, both this and bound_service_account_namespaces can not be \"*\".\n"
                },
                "boundServiceAccountNamespaces": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of namespaces allowed to access this role. If set to `[\"*\"]` all namespaces are allowed, both this and bound_service_account_names can not be set to \"*\".\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum allowed lifetime of tokens issued in seconds using this role.\n",
                    "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "numUses": {
                    "type": "integer",
                    "description": "Number of times issued tokens can be used. Setting this to 0 or leaving it unset means unlimited uses.\n",
                    "deprecationMessage": "use `token_num_uses` instead if you are running Vault \u003e= 1.2"
                },
                "period": {
                    "type": "integer",
                    "description": "If set, indicates that the token generated using this role should never expire. The token should be renewed within the duration specified by this value. At each renewal, the token's TTL will be set to the value of this parameter.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Policies to be set on tokens issued using this role.\n",
                    "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                },
                "roleName": {
                    "type": "string",
                    "description": "Name of the role.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The TTL period of tokens issued using this role in seconds.\n",
                    "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                }
            },
            "required": [
                "boundServiceAccountNames",
                "boundServiceAccountNamespaces",
                "roleName"
            ],
            "inputProperties": {
                "audience": {
                    "type": "string",
                    "description": "Optional Audience claim to verify in the JWT.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "Unique name of the kubernetes backend to configure.\n"
                },
                "boundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of CIDRs valid as the source address for login requests. This value is also encoded into any resulting token.\n",
                    "deprecationMessage": "use `token_bound_cidrs` instead if you are running Vault \u003e= 1.2"
                },
                "boundServiceAccountNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of service account names able to access this role. If set to `[\"*\"]` all names are allowed, both this and bound_service_account_namespaces can not be \"*\".\n"
                },
                "boundServiceAccountNamespaces": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of namespaces allowed to access this role. If set to `[\"*\"]` all namespaces are allowed, both this and bound_service_account_names can not be set to \"*\".\n"
                },
                "maxTtl": {
                    "type": "integer",
                    "description": "The maximum allowed lifetime of tokens issued in seconds using this role.\n",
                    "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "numUses": {
                    "type": "integer",
                    "description": "Number of times issued tokens can be used. Setting this to 0 or leaving it unset means unlimited uses.\n",
                    "deprecationMessage": "use `token_num_uses` instead if you are running Vault \u003e= 1.2"
                },
                "period": {
                    "type": "integer",
                    "description": "If set, indicates that the token generated using this role should never expire. The token should be renewed within the duration specified by this value. At each renewal, the token's TTL will be set to the value of this parameter.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Policies to be set on tokens issued using this role.\n",
                    "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                },
                "roleName": {
                    "type": "string",
                    "description": "Name of the role.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The TTL period of tokens issued using this role in seconds.\n",
                    "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                }
            },
            "requiredInputs": [
                "boundServiceAccountNames",
                "boundServiceAccountNamespaces",
                "roleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "audience": {
                        "type": "string",
                        "description": "Optional Audience claim to verify in the JWT.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "Unique name of the kubernetes backend to configure.\n"
                    },
                    "boundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of CIDRs valid as the source address for login requests. This value is also encoded into any resulting token.\n",
                        "deprecationMessage": "use `token_bound_cidrs` instead if you are running Vault \u003e= 1.2"
                    },
                    "boundServiceAccountNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of service account names able to access this role. If set to `[\"*\"]` all names are allowed, both this and bound_service_account_namespaces can not be \"*\".\n"
                    },
                    "boundServiceAccountNamespaces": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of namespaces allowed to access this role. If set to `[\"*\"]` all namespaces are allowed, both this and bound_service_account_names can not be set to \"*\".\n"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "The maximum allowed lifetime of tokens issued in seconds using this role.\n",
                        "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                    },
                    "numUses": {
                        "type": "integer",
                        "description": "Number of times issued tokens can be used. Setting this to 0 or leaving it unset means unlimited uses.\n",
                        "deprecationMessage": "use `token_num_uses` instead if you are running Vault \u003e= 1.2"
                    },
                    "period": {
                        "type": "integer",
                        "description": "If set, indicates that the token generated using this role should never expire. The token should be renewed within the duration specified by this value. At each renewal, the token's TTL will be set to the value of this parameter.\n",
                        "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Policies to be set on tokens issued using this role.\n",
                        "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "Name of the role.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime of the generated token\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "Generated Token's Period\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Generated Token's Policies\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The initial ttl of the token to generate in seconds\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token to generate, service or batch\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "The TTL period of tokens issued using this role in seconds.\n",
                        "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                    }
                },
                "type": "object"
            }
        },
        "vault:ldap/authBackend:AuthBackend": {
            "description": "Provides a resource for managing an [LDAP auth backend within Vault](https://www.vaultproject.io/docs/auth/ldap.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst ldap = new vault.ldap.AuthBackend(\"ldap\", {\n    discoverdn: false,\n    groupdn: \"OU=Groups,DC=example,DC=org\",\n    groupfilter: \"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n    path: \"ldap\",\n    upndomain: \"EXAMPLE.ORG\",\n    url: \"ldaps://dc-01.example.org\",\n    userattr: \"sAMAccountName\",\n    userdn: \"OU=Users,OU=Accounts,DC=example,DC=org\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nldap = vault.ldap.AuthBackend(\"ldap\",\n    discoverdn=False,\n    groupdn=\"OU=Groups,DC=example,DC=org\",\n    groupfilter=\"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n    path=\"ldap\",\n    upndomain=\"EXAMPLE.ORG\",\n    url=\"ldaps://dc-01.example.org\",\n    userattr=\"sAMAccountName\",\n    userdn=\"OU=Users,OU=Accounts,DC=example,DC=org\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var ldap = new Vault.Ldap.AuthBackend(\"ldap\", new Vault.Ldap.AuthBackendArgs\n        {\n            Discoverdn = false,\n            Groupdn = \"OU=Groups,DC=example,DC=org\",\n            Groupfilter = \"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n            Path = \"ldap\",\n            Upndomain = \"EXAMPLE.ORG\",\n            Url = \"ldaps://dc-01.example.org\",\n            Userattr = \"sAMAccountName\",\n            Userdn = \"OU=Users,OU=Accounts,DC=example,DC=org\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := ldap.NewAuthBackend(ctx, \"ldap\", \u0026ldap.AuthBackendArgs{\n\t\t\tDiscoverdn:  pulumi.Bool(false),\n\t\t\tGroupdn:     pulumi.String(\"OU=Groups,DC=example,DC=org\"),\n\t\t\tGroupfilter: pulumi.String(\"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\"),\n\t\t\tPath:        pulumi.String(\"ldap\"),\n\t\t\tUpndomain:   pulumi.String(\"EXAMPLE.ORG\"),\n\t\t\tUrl:         pulumi.String(\"ldaps://dc-01.example.org\"),\n\t\t\tUserattr:    pulumi.String(\"sAMAccountName\"),\n\t\t\tUserdn:      pulumi.String(\"OU=Users,OU=Accounts,DC=example,DC=org\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nLDAP authentication backends can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:ldap/authBackend:AuthBackend ldap ldap\n```\n\n ",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The accessor for this auth mount.\n"
                },
                "binddn": {
                    "type": "string",
                    "description": "DN of object to bind when performing user search\n"
                },
                "bindpass": {
                    "type": "string",
                    "description": "Password to use with `binddn` when performing user search\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "Trusted CA to validate TLS certificate\n"
                },
                "denyNullBind": {
                    "type": "boolean"
                },
                "description": {
                    "type": "string",
                    "description": "Description for the LDAP auth backend mount\n"
                },
                "discoverdn": {
                    "type": "boolean"
                },
                "groupattr": {
                    "type": "string",
                    "description": "LDAP attribute to follow on objects returned by groupfilter\n"
                },
                "groupdn": {
                    "type": "string",
                    "description": "Base DN under which to perform group search\n"
                },
                "groupfilter": {
                    "type": "string",
                    "description": "Go template used to construct group membership query\n"
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Control whether or TLS certificates must be validated\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to mount the LDAP auth backend under\n"
                },
                "starttls": {
                    "type": "boolean",
                    "description": "Control use of TLS when conecting to LDAP\n"
                },
                "tlsMaxVersion": {
                    "type": "string",
                    "description": "Maximum acceptable version of TLS\n"
                },
                "tlsMinVersion": {
                    "type": "string",
                    "description": "Minimum acceptable version of TLS\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n"
                },
                "upndomain": {
                    "type": "string",
                    "description": "The userPrincipalDomain used to construct UPN string\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL of the LDAP server\n"
                },
                "useTokenGroups": {
                    "type": "boolean",
                    "description": "Use the Active Directory tokenGroups constructed attribute of the user to find the group memberships\n"
                },
                "userattr": {
                    "type": "string",
                    "description": "Attribute on user object matching username passed in\n"
                },
                "userdn": {
                    "type": "string",
                    "description": "Base DN under which to perform user search\n"
                }
            },
            "required": [
                "accessor",
                "binddn",
                "bindpass",
                "certificate",
                "denyNullBind",
                "description",
                "discoverdn",
                "groupattr",
                "groupdn",
                "groupfilter",
                "insecureTls",
                "starttls",
                "tlsMaxVersion",
                "tlsMinVersion",
                "upndomain",
                "url",
                "useTokenGroups",
                "userattr",
                "userdn"
            ],
            "inputProperties": {
                "binddn": {
                    "type": "string",
                    "description": "DN of object to bind when performing user search\n"
                },
                "bindpass": {
                    "type": "string",
                    "description": "Password to use with `binddn` when performing user search\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "Trusted CA to validate TLS certificate\n"
                },
                "denyNullBind": {
                    "type": "boolean"
                },
                "description": {
                    "type": "string",
                    "description": "Description for the LDAP auth backend mount\n"
                },
                "discoverdn": {
                    "type": "boolean"
                },
                "groupattr": {
                    "type": "string",
                    "description": "LDAP attribute to follow on objects returned by groupfilter\n"
                },
                "groupdn": {
                    "type": "string",
                    "description": "Base DN under which to perform group search\n"
                },
                "groupfilter": {
                    "type": "string",
                    "description": "Go template used to construct group membership query\n"
                },
                "insecureTls": {
                    "type": "boolean",
                    "description": "Control whether or TLS certificates must be validated\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to mount the LDAP auth backend under\n"
                },
                "starttls": {
                    "type": "boolean",
                    "description": "Control use of TLS when conecting to LDAP\n"
                },
                "tlsMaxVersion": {
                    "type": "string",
                    "description": "Maximum acceptable version of TLS\n"
                },
                "tlsMinVersion": {
                    "type": "string",
                    "description": "Minimum acceptable version of TLS\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch\n"
                },
                "upndomain": {
                    "type": "string",
                    "description": "The userPrincipalDomain used to construct UPN string\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL of the LDAP server\n"
                },
                "useTokenGroups": {
                    "type": "boolean",
                    "description": "Use the Active Directory tokenGroups constructed attribute of the user to find the group memberships\n"
                },
                "userattr": {
                    "type": "string",
                    "description": "Attribute on user object matching username passed in\n"
                },
                "userdn": {
                    "type": "string",
                    "description": "Base DN under which to perform user search\n"
                }
            },
            "requiredInputs": [
                "url"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackend resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The accessor for this auth mount.\n"
                    },
                    "binddn": {
                        "type": "string",
                        "description": "DN of object to bind when performing user search\n"
                    },
                    "bindpass": {
                        "type": "string",
                        "description": "Password to use with `binddn` when performing user search\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "Trusted CA to validate TLS certificate\n"
                    },
                    "denyNullBind": {
                        "type": "boolean"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description for the LDAP auth backend mount\n"
                    },
                    "discoverdn": {
                        "type": "boolean"
                    },
                    "groupattr": {
                        "type": "string",
                        "description": "LDAP attribute to follow on objects returned by groupfilter\n"
                    },
                    "groupdn": {
                        "type": "string",
                        "description": "Base DN under which to perform group search\n"
                    },
                    "groupfilter": {
                        "type": "string",
                        "description": "Go template used to construct group membership query\n"
                    },
                    "insecureTls": {
                        "type": "boolean",
                        "description": "Control whether or TLS certificates must be validated\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Path to mount the LDAP auth backend under\n"
                    },
                    "starttls": {
                        "type": "boolean",
                        "description": "Control use of TLS when conecting to LDAP\n"
                    },
                    "tlsMaxVersion": {
                        "type": "string",
                        "description": "Maximum acceptable version of TLS\n"
                    },
                    "tlsMinVersion": {
                        "type": "string",
                        "description": "Minimum acceptable version of TLS\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime of the generated token\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "Generated Token's Period\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Generated Token's Policies\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The initial ttl of the token to generate in seconds\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "The type of token to generate, service or batch\n"
                    },
                    "upndomain": {
                        "type": "string",
                        "description": "The userPrincipalDomain used to construct UPN string\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "The URL of the LDAP server\n"
                    },
                    "useTokenGroups": {
                        "type": "boolean",
                        "description": "Use the Active Directory tokenGroups constructed attribute of the user to find the group memberships\n"
                    },
                    "userattr": {
                        "type": "string",
                        "description": "Attribute on user object matching username passed in\n"
                    },
                    "userdn": {
                        "type": "string",
                        "description": "Base DN under which to perform user search\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:ldap/authBackendGroup:AuthBackendGroup": {
            "description": "Provides a resource to create a group in an [LDAP auth backend within Vault](https://www.vaultproject.io/docs/auth/ldap.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst ldap = new vault.ldap.AuthBackend(\"ldap\", {\n    discoverdn: false,\n    groupdn: \"OU=Groups,DC=example,DC=org\",\n    groupfilter: \"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n    path: \"ldap\",\n    upndomain: \"EXAMPLE.ORG\",\n    url: \"ldaps://dc-01.example.org\",\n    userattr: \"sAMAccountName\",\n    userdn: \"OU=Users,OU=Accounts,DC=example,DC=org\",\n});\nconst group = new vault.ldap.AuthBackendGroup(\"group\", {\n    backend: ldap.path,\n    groupname: \"dba\",\n    policies: [\"dba\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nldap = vault.ldap.AuthBackend(\"ldap\",\n    discoverdn=False,\n    groupdn=\"OU=Groups,DC=example,DC=org\",\n    groupfilter=\"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n    path=\"ldap\",\n    upndomain=\"EXAMPLE.ORG\",\n    url=\"ldaps://dc-01.example.org\",\n    userattr=\"sAMAccountName\",\n    userdn=\"OU=Users,OU=Accounts,DC=example,DC=org\")\ngroup = vault.ldap.AuthBackendGroup(\"group\",\n    backend=ldap.path,\n    groupname=\"dba\",\n    policies=[\"dba\"])\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var ldap = new Vault.Ldap.AuthBackend(\"ldap\", new Vault.Ldap.AuthBackendArgs\n        {\n            Discoverdn = false,\n            Groupdn = \"OU=Groups,DC=example,DC=org\",\n            Groupfilter = \"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n            Path = \"ldap\",\n            Upndomain = \"EXAMPLE.ORG\",\n            Url = \"ldaps://dc-01.example.org\",\n            Userattr = \"sAMAccountName\",\n            Userdn = \"OU=Users,OU=Accounts,DC=example,DC=org\",\n        });\n        var @group = new Vault.Ldap.AuthBackendGroup(\"group\", new Vault.Ldap.AuthBackendGroupArgs\n        {\n            Backend = ldap.Path,\n            Groupname = \"dba\",\n            Policies = \n            {\n                \"dba\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tldap, err := ldap.NewAuthBackend(ctx, \"ldap\", \u0026ldap.AuthBackendArgs{\n\t\t\tDiscoverdn:  pulumi.Bool(false),\n\t\t\tGroupdn:     pulumi.String(\"OU=Groups,DC=example,DC=org\"),\n\t\t\tGroupfilter: pulumi.String(\"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\"),\n\t\t\tPath:        pulumi.String(\"ldap\"),\n\t\t\tUpndomain:   pulumi.String(\"EXAMPLE.ORG\"),\n\t\t\tUrl:         pulumi.String(\"ldaps://dc-01.example.org\"),\n\t\t\tUserattr:    pulumi.String(\"sAMAccountName\"),\n\t\t\tUserdn:      pulumi.String(\"OU=Users,OU=Accounts,DC=example,DC=org\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewAuthBackendGroup(ctx, \"group\", \u0026ldap.AuthBackendGroupArgs{\n\t\t\tBackend:   ldap.Path,\n\t\t\tGroupname: pulumi.String(\"dba\"),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dba\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nLDAP authentication backend groups can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:ldap/authBackendGroup:AuthBackendGroup foo auth/ldap/groups/foo\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Path to the authentication backend\n"
                },
                "groupname": {
                    "type": "string",
                    "description": "The LDAP groupname\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Policies which should be granted to members of the group\n"
                }
            },
            "required": [
                "groupname",
                "policies"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Path to the authentication backend\n"
                },
                "groupname": {
                    "type": "string",
                    "description": "The LDAP groupname\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Policies which should be granted to members of the group\n"
                }
            },
            "requiredInputs": [
                "groupname"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendGroup resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Path to the authentication backend\n"
                    },
                    "groupname": {
                        "type": "string",
                        "description": "The LDAP groupname\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Policies which should be granted to members of the group\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:ldap/authBackendUser:AuthBackendUser": {
            "description": "Provides a resource to create a user in an [LDAP auth backend within Vault](https://www.vaultproject.io/docs/auth/ldap.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst ldap = new vault.ldap.AuthBackend(\"ldap\", {\n    discoverdn: false,\n    groupdn: \"OU=Groups,DC=example,DC=org\",\n    groupfilter: \"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n    path: \"ldap\",\n    upndomain: \"EXAMPLE.ORG\",\n    url: \"ldaps://dc-01.example.org\",\n    userattr: \"sAMAccountName\",\n    userdn: \"OU=Users,OU=Accounts,DC=example,DC=org\",\n});\nconst user = new vault.ldap.AuthBackendUser(\"user\", {\n    backend: ldap.path,\n    policies: [\n        \"dba\",\n        \"sysops\",\n    ],\n    username: \"test-user\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nldap = vault.ldap.AuthBackend(\"ldap\",\n    discoverdn=False,\n    groupdn=\"OU=Groups,DC=example,DC=org\",\n    groupfilter=\"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n    path=\"ldap\",\n    upndomain=\"EXAMPLE.ORG\",\n    url=\"ldaps://dc-01.example.org\",\n    userattr=\"sAMAccountName\",\n    userdn=\"OU=Users,OU=Accounts,DC=example,DC=org\")\nuser = vault.ldap.AuthBackendUser(\"user\",\n    backend=ldap.path,\n    policies=[\n        \"dba\",\n        \"sysops\",\n    ],\n    username=\"test-user\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var ldap = new Vault.Ldap.AuthBackend(\"ldap\", new Vault.Ldap.AuthBackendArgs\n        {\n            Discoverdn = false,\n            Groupdn = \"OU=Groups,DC=example,DC=org\",\n            Groupfilter = \"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\",\n            Path = \"ldap\",\n            Upndomain = \"EXAMPLE.ORG\",\n            Url = \"ldaps://dc-01.example.org\",\n            Userattr = \"sAMAccountName\",\n            Userdn = \"OU=Users,OU=Accounts,DC=example,DC=org\",\n        });\n        var user = new Vault.Ldap.AuthBackendUser(\"user\", new Vault.Ldap.AuthBackendUserArgs\n        {\n            Backend = ldap.Path,\n            Policies = \n            {\n                \"dba\",\n                \"sysops\",\n            },\n            Username = \"test-user\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tldap, err := ldap.NewAuthBackend(ctx, \"ldap\", \u0026ldap.AuthBackendArgs{\n\t\t\tDiscoverdn:  pulumi.Bool(false),\n\t\t\tGroupdn:     pulumi.String(\"OU=Groups,DC=example,DC=org\"),\n\t\t\tGroupfilter: pulumi.String(\"(\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))\"),\n\t\t\tPath:        pulumi.String(\"ldap\"),\n\t\t\tUpndomain:   pulumi.String(\"EXAMPLE.ORG\"),\n\t\t\tUrl:         pulumi.String(\"ldaps://dc-01.example.org\"),\n\t\t\tUserattr:    pulumi.String(\"sAMAccountName\"),\n\t\t\tUserdn:      pulumi.String(\"OU=Users,OU=Accounts,DC=example,DC=org\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewAuthBackendUser(ctx, \"user\", \u0026ldap.AuthBackendUserArgs{\n\t\t\tBackend: ldap.Path,\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dba\"),\n\t\t\t\tpulumi.String(\"sysops\"),\n\t\t\t},\n\t\t\tUsername: pulumi.String(\"test-user\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nLDAP authentication backend users can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:ldap/authBackendUser:AuthBackendUser foo auth/ldap/users/foo\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "Path to the authentication backend\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Override LDAP groups which should be granted to user\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Policies which should be granted to user\n"
                },
                "username": {
                    "type": "string",
                    "description": "The LDAP username\n"
                }
            },
            "required": [
                "groups",
                "policies",
                "username"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "Path to the authentication backend\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Override LDAP groups which should be granted to user\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Policies which should be granted to user\n"
                },
                "username": {
                    "type": "string",
                    "description": "The LDAP username\n"
                }
            },
            "requiredInputs": [
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendUser resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "Path to the authentication backend\n"
                    },
                    "groups": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Override LDAP groups which should be granted to user\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Policies which should be granted to user\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "The LDAP username\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:okta/authBackend:AuthBackend": {
            "description": "Provides a resource for managing an\n[Okta auth backend within Vault](https://www.vaultproject.io/docs/auth/okta.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.okta.AuthBackend(\"example\", {\n    description: \"Demonstration of the Terraform Okta auth backend\",\n    groups: [{\n        groupName: \"foo\",\n        policies: [\n            \"one\",\n            \"two\",\n        ],\n    }],\n    organization: \"example\",\n    token: \"something that should be kept secret\",\n    users: [{\n        groups: [\"foo\"],\n        username: \"bar\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.okta.AuthBackend(\"example\",\n    description=\"Demonstration of the Terraform Okta auth backend\",\n    groups=[vault.okta.AuthBackendGroupArgs(\n        group_name=\"foo\",\n        policies=[\n            \"one\",\n            \"two\",\n        ],\n    )],\n    organization=\"example\",\n    token=\"something that should be kept secret\",\n    users=[vault.okta.AuthBackendUserArgs(\n        groups=[\"foo\"],\n        username=\"bar\",\n    )])\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.Okta.AuthBackend(\"example\", new Vault.Okta.AuthBackendArgs\n        {\n            Description = \"Demonstration of the Terraform Okta auth backend\",\n            Groups = \n            {\n                new Vault.Okta.Inputs.AuthBackendGroupArgs\n                {\n                    GroupName = \"foo\",\n                    Policies = \n                    {\n                        \"one\",\n                        \"two\",\n                    },\n                },\n            },\n            Organization = \"example\",\n            Token = \"something that should be kept secret\",\n            Users = \n            {\n                new Vault.Okta.Inputs.AuthBackendUserArgs\n                {\n                    Groups = \n                    {\n                        \"foo\",\n                    },\n                    Username = \"bar\",\n                },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/okta\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := okta.NewAuthBackend(ctx, \"example\", \u0026okta.AuthBackendArgs{\n\t\t\tDescription: pulumi.String(\"Demonstration of the Terraform Okta auth backend\"),\n\t\t\tGroups: okta.AuthBackendGroupArray{\n\t\t\t\t\u0026okta.AuthBackendGroupArgs{\n\t\t\t\t\tGroupName: pulumi.String(\"foo\"),\n\t\t\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"one\"),\n\t\t\t\t\t\tpulumi.String(\"two\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tOrganization: pulumi.String(\"example\"),\n\t\t\tToken:        pulumi.String(\"something that should be kept secret\"),\n\t\t\tUsers: okta.AuthBackendUserArray{\n\t\t\t\t\u0026okta.AuthBackendUserArgs{\n\t\t\t\t\tGroups: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"foo\"),\n\t\t\t\t\t},\n\t\t\t\t\tUsername: pulumi.String(\"bar\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "accessor": {
                    "type": "string",
                    "description": "The mount accessor related to the auth mount. It is useful for integration with [Identity Secrets Engine](https://www.vaultproject.io/docs/secrets/identity/index.html).\n"
                },
                "baseUrl": {
                    "type": "string",
                    "description": "The Okta url. Examples: oktapreview.com, okta.com\n"
                },
                "bypassOktaMfa": {
                    "type": "boolean",
                    "description": "When true, requests by Okta for a MFA check will be bypassed. This also disallows certain status checks on the account, such as whether the password is expired.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the auth backend\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:okta/AuthBackendGroup:AuthBackendGroup"
                    },
                    "description": "Associate Okta groups with policies within Vault.\nSee below for more details.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Maximum duration after which authentication will be expired\n[See the documentation for info on valid duration formats](https://golang.org/pkg/time/#ParseDuration).\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The Okta organization. This will be the first part of the url `https://XXX.okta.com`\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to mount the Okta auth backend\n"
                },
                "token": {
                    "type": "string",
                    "description": "The Okta API token. This is required to query Okta for user group membership.\nIf this is not supplied only locally configured groups will be enabled.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Duration after which authentication will be expired.\n[See the documentation for info on valid duration formats](https://golang.org/pkg/time/#ParseDuration).\n"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:okta/AuthBackendUser:AuthBackendUser"
                    },
                    "description": "Associate Okta users with groups or policies within Vault.\nSee below for more details.\n"
                }
            },
            "required": [
                "accessor",
                "groups",
                "organization",
                "users"
            ],
            "inputProperties": {
                "baseUrl": {
                    "type": "string",
                    "description": "The Okta url. Examples: oktapreview.com, okta.com\n"
                },
                "bypassOktaMfa": {
                    "type": "boolean",
                    "description": "When true, requests by Okta for a MFA check will be bypassed. This also disallows certain status checks on the account, such as whether the password is expired.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the auth backend\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:okta/AuthBackendGroup:AuthBackendGroup"
                    },
                    "description": "Associate Okta groups with policies within Vault.\nSee below for more details.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Maximum duration after which authentication will be expired\n[See the documentation for info on valid duration formats](https://golang.org/pkg/time/#ParseDuration).\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The Okta organization. This will be the first part of the url `https://XXX.okta.com`\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path to mount the Okta auth backend\n"
                },
                "token": {
                    "type": "string",
                    "description": "The Okta API token. This is required to query Okta for user group membership.\nIf this is not supplied only locally configured groups will be enabled.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Duration after which authentication will be expired.\n[See the documentation for info on valid duration formats](https://golang.org/pkg/time/#ParseDuration).\n"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:okta/AuthBackendUser:AuthBackendUser"
                    },
                    "description": "Associate Okta users with groups or policies within Vault.\nSee below for more details.\n"
                }
            },
            "requiredInputs": [
                "organization"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackend resources.\n",
                "properties": {
                    "accessor": {
                        "type": "string",
                        "description": "The mount accessor related to the auth mount. It is useful for integration with [Identity Secrets Engine](https://www.vaultproject.io/docs/secrets/identity/index.html).\n"
                    },
                    "baseUrl": {
                        "type": "string",
                        "description": "The Okta url. Examples: oktapreview.com, okta.com\n"
                    },
                    "bypassOktaMfa": {
                        "type": "boolean",
                        "description": "When true, requests by Okta for a MFA check will be bypassed. This also disallows certain status checks on the account, such as whether the password is expired.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the auth backend\n"
                    },
                    "groups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:okta/AuthBackendGroup:AuthBackendGroup"
                        },
                        "description": "Associate Okta groups with policies within Vault.\nSee below for more details.\n"
                    },
                    "maxTtl": {
                        "type": "string",
                        "description": "Maximum duration after which authentication will be expired\n[See the documentation for info on valid duration formats](https://golang.org/pkg/time/#ParseDuration).\n"
                    },
                    "organization": {
                        "type": "string",
                        "description": "The Okta organization. This will be the first part of the url `https://XXX.okta.com`\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "Path to mount the Okta auth backend\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "The Okta API token. This is required to query Okta for user group membership.\nIf this is not supplied only locally configured groups will be enabled.\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Duration after which authentication will be expired.\n[See the documentation for info on valid duration formats](https://golang.org/pkg/time/#ParseDuration).\n"
                    },
                    "users": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:okta/AuthBackendUser:AuthBackendUser"
                        },
                        "description": "Associate Okta users with groups or policies within Vault.\nSee below for more details.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:okta/authBackendGroup:AuthBackendGroup": {
            "description": "Provides a resource to create a group in an\n[Okta auth backend within Vault](https://www.vaultproject.io/docs/auth/okta.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.okta.AuthBackend(\"example\", {\n    organization: \"dummy\",\n    path: \"group_okta\",\n});\nconst foo = new vault.okta.AuthBackendGroup(\"foo\", {\n    groupName: \"foo\",\n    path: example.path,\n    policies: [\n        \"one\",\n        \"two\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.okta.AuthBackend(\"example\",\n    organization=\"dummy\",\n    path=\"group_okta\")\nfoo = vault.okta.AuthBackendGroup(\"foo\",\n    group_name=\"foo\",\n    path=example.path,\n    policies=[\n        \"one\",\n        \"two\",\n    ])\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.Okta.AuthBackend(\"example\", new Vault.Okta.AuthBackendArgs\n        {\n            Organization = \"dummy\",\n            Path = \"group_okta\",\n        });\n        var foo = new Vault.Okta.AuthBackendGroup(\"foo\", new Vault.Okta.AuthBackendGroupArgs\n        {\n            GroupName = \"foo\",\n            Path = example.Path,\n            Policies = \n            {\n                \"one\",\n                \"two\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/okta\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := okta.NewAuthBackend(ctx, \"example\", \u0026okta.AuthBackendArgs{\n\t\t\tOrganization: pulumi.String(\"dummy\"),\n\t\t\tPath:         pulumi.String(\"group_okta\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = okta.NewAuthBackendGroup(ctx, \"foo\", \u0026okta.AuthBackendGroupArgs{\n\t\t\tGroupName: pulumi.String(\"foo\"),\n\t\t\tPath:      example.Path,\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"one\"),\n\t\t\t\tpulumi.String(\"two\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "groupName": {
                    "type": "string",
                    "description": "Name of the group within the Okta\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path where the Okta auth backend is mounted\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Vault policies to associate with this group\n"
                }
            },
            "required": [
                "groupName",
                "path"
            ],
            "inputProperties": {
                "groupName": {
                    "type": "string",
                    "description": "Name of the group within the Okta\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path where the Okta auth backend is mounted\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Vault policies to associate with this group\n"
                }
            },
            "requiredInputs": [
                "groupName",
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendGroup resources.\n",
                "properties": {
                    "groupName": {
                        "type": "string",
                        "description": "Name of the group within the Okta\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path where the Okta auth backend is mounted\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Vault policies to associate with this group\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:okta/authBackendUser:AuthBackendUser": {
            "description": "Provides a resource to create a user in an\n[Okta auth backend within Vault](https://www.vaultproject.io/docs/auth/okta.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.okta.AuthBackend(\"example\", {\n    organization: \"dummy\",\n    path: \"user_okta\",\n});\nconst foo = new vault.okta.AuthBackendUser(\"foo\", {\n    groups: [\n        \"one\",\n        \"two\",\n    ],\n    path: example.path,\n    username: \"foo\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.okta.AuthBackend(\"example\",\n    organization=\"dummy\",\n    path=\"user_okta\")\nfoo = vault.okta.AuthBackendUser(\"foo\",\n    groups=[\n        \"one\",\n        \"two\",\n    ],\n    path=example.path,\n    username=\"foo\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.Okta.AuthBackend(\"example\", new Vault.Okta.AuthBackendArgs\n        {\n            Organization = \"dummy\",\n            Path = \"user_okta\",\n        });\n        var foo = new Vault.Okta.AuthBackendUser(\"foo\", new Vault.Okta.AuthBackendUserArgs\n        {\n            Groups = \n            {\n                \"one\",\n                \"two\",\n            },\n            Path = example.Path,\n            Username = \"foo\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/okta\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := okta.NewAuthBackend(ctx, \"example\", \u0026okta.AuthBackendArgs{\n\t\t\tOrganization: pulumi.String(\"dummy\"),\n\t\t\tPath:         pulumi.String(\"user_okta\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = okta.NewAuthBackendUser(ctx, \"foo\", \u0026okta.AuthBackendUserArgs{\n\t\t\tGroups: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"one\"),\n\t\t\t\tpulumi.String(\"two\"),\n\t\t\t},\n\t\t\tPath:     example.Path,\n\t\t\tUsername: pulumi.String(\"foo\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Okta groups to associate with this user\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path where the Okta auth backend is mounted\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Vault policies to associate with this user\n"
                },
                "username": {
                    "type": "string",
                    "description": "Name of the user within Okta\n"
                }
            },
            "required": [
                "path",
                "username"
            ],
            "inputProperties": {
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Okta groups to associate with this user\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path where the Okta auth backend is mounted\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Vault policies to associate with this user\n"
                },
                "username": {
                    "type": "string",
                    "description": "Name of the user within Okta\n"
                }
            },
            "requiredInputs": [
                "path",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendUser resources.\n",
                "properties": {
                    "groups": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Okta groups to associate with this user\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path where the Okta auth backend is mounted\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Vault policies to associate with this user\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Name of the user within Okta\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackend:SecretBackend": {
            "description": "Creates an PKI Secret Backend for Vault. PKI secret backends can then issue certificates, once a role has been added to\nthe backend.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst pki = new vault.pkiSecret.SecretBackend(\"pki\", {\n    defaultLeaseTtlSeconds: 3600,\n    maxLeaseTtlSeconds: 86400,\n    path: \"pki\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\npki = vault.pki_secret.SecretBackend(\"pki\",\n    default_lease_ttl_seconds=3600,\n    max_lease_ttl_seconds=86400,\n    path=\"pki\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var pki = new Vault.PkiSecret.SecretBackend(\"pki\", new Vault.PkiSecret.SecretBackendArgs\n        {\n            DefaultLeaseTtlSeconds = 3600,\n            MaxLeaseTtlSeconds = 86400,\n            Path = \"pki\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/pkiSecret\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := pkiSecret.NewSecretBackend(ctx, \"pki\", \u0026pkiSecret.SecretBackendArgs{\n\t\t\tDefaultLeaseTtlSeconds: pulumi.Int(3600),\n\t\t\tMaxLeaseTtlSeconds:     pulumi.Int(86400),\n\t\t\tPath:                   pulumi.String(\"pki\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nPKI secret backends can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:pkiSecret/secretBackend:SecretBackend pki pki\n```\n\n ",
            "properties": {
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials issued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested for credentials issued by this backend.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must not begin or end with a `/`.\n"
                }
            },
            "required": [
                "defaultLeaseTtlSeconds",
                "maxLeaseTtlSeconds",
                "path"
            ],
            "inputProperties": {
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials issued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested for credentials issued by this backend.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must not begin or end with a `/`.\n"
                }
            },
            "requiredInputs": [
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackend resources.\n",
                "properties": {
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The default TTL for credentials issued by this backend.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A human-friendly description for this backend.\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The maximum TTL that can be requested for credentials issued by this backend.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must not begin or end with a `/`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendCert:SecretBackendCert": {
            "properties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "autoRenew": {
                    "type": "boolean",
                    "description": "If enabled, a new certificate will be generated if the expiration is within min_seconds_remaining\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "caChain": {
                    "type": "string",
                    "description": "The CA chain\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The certificate\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of certificate to create\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "expiration": {
                    "type": "integer",
                    "description": "The expiration date of the certificate in unix epoch format\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "issuingCa": {
                    "type": "string",
                    "description": "The issuing CA\n"
                },
                "minSecondsRemaining": {
                    "type": "integer",
                    "description": "Generate a new certificate when the expiration is within this number of seconds, default is 604800 (7 days)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the role to create the certificate against\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "The private key\n"
                },
                "privateKeyFormat": {
                    "type": "string",
                    "description": "The private key format\n"
                },
                "privateKeyType": {
                    "type": "string",
                    "description": "The private key type\n"
                },
                "serialNumber": {
                    "type": "string",
                    "description": "The serial number\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs.\n"
                }
            },
            "required": [
                "backend",
                "caChain",
                "certificate",
                "commonName",
                "expiration",
                "issuingCa",
                "name",
                "privateKey",
                "privateKeyType",
                "serialNumber"
            ],
            "inputProperties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "autoRenew": {
                    "type": "boolean",
                    "description": "If enabled, a new certificate will be generated if the expiration is within min_seconds_remaining\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of certificate to create\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "minSecondsRemaining": {
                    "type": "integer",
                    "description": "Generate a new certificate when the expiration is within this number of seconds, default is 604800 (7 days)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the role to create the certificate against\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "privateKeyFormat": {
                    "type": "string",
                    "description": "The private key format\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "commonName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendCert resources.\n",
                "properties": {
                    "altNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative names\n"
                    },
                    "autoRenew": {
                        "type": "boolean",
                        "description": "If enabled, a new certificate will be generated if the expiration is within min_seconds_remaining\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The PKI secret backend the resource belongs to.\n"
                    },
                    "caChain": {
                        "type": "string",
                        "description": "The CA chain\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "The certificate\n"
                    },
                    "commonName": {
                        "type": "string",
                        "description": "CN of certificate to create\n"
                    },
                    "excludeCnFromSans": {
                        "type": "boolean",
                        "description": "Flag to exclude CN from SANs\n"
                    },
                    "expiration": {
                        "type": "integer",
                        "description": "The expiration date of the certificate in unix epoch format\n"
                    },
                    "format": {
                        "type": "string",
                        "description": "The format of data\n"
                    },
                    "ipSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative IPs\n"
                    },
                    "issuingCa": {
                        "type": "string",
                        "description": "The issuing CA\n"
                    },
                    "minSecondsRemaining": {
                        "type": "integer",
                        "description": "Generate a new certificate when the expiration is within this number of seconds, default is 604800 (7 days)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the role to create the certificate against\n"
                    },
                    "otherSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of other SANs\n"
                    },
                    "privateKey": {
                        "type": "string",
                        "description": "The private key\n"
                    },
                    "privateKeyFormat": {
                        "type": "string",
                        "description": "The private key format\n"
                    },
                    "privateKeyType": {
                        "type": "string",
                        "description": "The private key type\n"
                    },
                    "serialNumber": {
                        "type": "string",
                        "description": "The serial number\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Time to live\n"
                    },
                    "uriSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative URIs.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendConfigCa:SecretBackendConfigCa": {
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "pemBundle": {
                    "type": "string",
                    "description": "The key and certificate PEM bundle\n"
                }
            },
            "required": [
                "backend",
                "pemBundle"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "pemBundle": {
                    "type": "string",
                    "description": "The key and certificate PEM bundle\n"
                }
            },
            "requiredInputs": [
                "backend",
                "pemBundle"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendConfigCa resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The PKI secret backend the resource belongs to.\n"
                    },
                    "pemBundle": {
                        "type": "string",
                        "description": "The key and certificate PEM bundle\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendConfigUrls:SecretBackendConfigUrls": {
            "description": "Allows setting the issuing certificate endpoints, CRL distribution points, and OCSP server endpoints that will be encoded into issued certificates.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst pki = new vault.pkiSecret.SecretBackend(\"pki\", {\n    defaultLeaseTtlSeconds: 3600,\n    maxLeaseTtlSeconds: 86400,\n    path: \"%s\",\n});\nconst configUrls = new vault.pkiSecret.SecretBackendConfigUrls(\"config_urls\", {\n    backend: pki.path,\n    issuingCertificates: \"http://127.0.0.1:8200/v1/pki/ca\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\npki = vault.pki_secret.SecretBackend(\"pki\",\n    default_lease_ttl_seconds=3600,\n    max_lease_ttl_seconds=86400,\n    path=\"%s\")\nconfig_urls = vault.pki_secret.SecretBackendConfigUrls(\"configUrls\",\n    backend=pki.path,\n    issuing_certificates=\"http://127.0.0.1:8200/v1/pki/ca\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var pki = new Vault.PkiSecret.SecretBackend(\"pki\", new Vault.PkiSecret.SecretBackendArgs\n        {\n            DefaultLeaseTtlSeconds = 3600,\n            MaxLeaseTtlSeconds = 86400,\n            Path = \"%s\",\n        });\n        var configUrls = new Vault.PkiSecret.SecretBackendConfigUrls(\"configUrls\", new Vault.PkiSecret.SecretBackendConfigUrlsArgs\n        {\n            Backend = pki.Path,\n            IssuingCertificates = \"http://127.0.0.1:8200/v1/pki/ca\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/pkiSecret\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tpki, err := pkiSecret.NewSecretBackend(ctx, \"pki\", \u0026pkiSecret.SecretBackendArgs{\n\t\t\tDefaultLeaseTtlSeconds: pulumi.Int(3600),\n\t\t\tMaxLeaseTtlSeconds:     pulumi.Int(86400),\n\t\t\tPath:                   pulumi.String(fmt.Sprintf(\"%v%v\", \"%\", \"s\")),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = pkiSecret.NewSecretBackendConfigUrls(ctx, \"configUrls\", \u0026pkiSecret.SecretBackendConfigUrlsArgs{\n\t\t\tBackend:             pki.Path,\n\t\t\tIssuingCertificates: \"http://127.0.0.1:8200/v1/pki/ca\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "crlDistributionPoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the URL values for the CRL Distribution Points field. Comma-separated string if multiple.\n"
                },
                "issuingCertificates": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the URL values for the Issuing Certificate field. Comma-separated string if multiple.\n"
                },
                "ocspServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the URL values for the OCSP Servers field. Comma-separated string if multiple.\n"
                }
            },
            "required": [
                "backend"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "crlDistributionPoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the URL values for the CRL Distribution Points field. Comma-separated string if multiple.\n"
                },
                "issuingCertificates": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the URL values for the Issuing Certificate field. Comma-separated string if multiple.\n"
                },
                "ocspServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the URL values for the OCSP Servers field. Comma-separated string if multiple.\n"
                }
            },
            "requiredInputs": [
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendConfigUrls resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                    },
                    "crlDistributionPoints": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the URL values for the CRL Distribution Points field. Comma-separated string if multiple.\n"
                    },
                    "issuingCertificates": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the URL values for the Issuing Certificate field. Comma-separated string if multiple.\n"
                    },
                    "ocspServers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the URL values for the OCSP Servers field. Comma-separated string if multiple.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendCrlConfig:SecretBackendCrlConfig": {
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path of the PKI secret backend the resource belongs to.\n"
                },
                "disable": {
                    "type": "boolean",
                    "description": "Disables or enables CRL building\n"
                },
                "expiry": {
                    "type": "string",
                    "description": "Specifies the time until expiration.\n"
                }
            },
            "required": [
                "backend"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path of the PKI secret backend the resource belongs to.\n"
                },
                "disable": {
                    "type": "boolean",
                    "description": "Disables or enables CRL building\n"
                },
                "expiry": {
                    "type": "string",
                    "description": "Specifies the time until expiration.\n"
                }
            },
            "requiredInputs": [
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendCrlConfig resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path of the PKI secret backend the resource belongs to.\n"
                    },
                    "disable": {
                        "type": "boolean",
                        "description": "Disables or enables CRL building\n"
                    },
                    "expiry": {
                        "type": "string",
                        "description": "Specifies the time until expiration.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendIntermediateCertRequest:SecretBackendIntermediateCertRequest": {
            "properties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of intermediate to create\n"
                },
                "country": {
                    "type": "string",
                    "description": "The country\n"
                },
                "csr": {
                    "type": "string",
                    "description": "The CSR\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "keyBits": {
                    "type": "integer",
                    "description": "The number of bits to use\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "The desired key type\n"
                },
                "locality": {
                    "type": "string",
                    "description": "The locality\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "ou": {
                    "type": "string",
                    "description": "The organization unit\n"
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "The private key\n"
                },
                "privateKeyFormat": {
                    "type": "string",
                    "description": "The private key format\n"
                },
                "privateKeyType": {
                    "type": "string",
                    "description": "The private key type\n"
                },
                "province": {
                    "type": "string",
                    "description": "The province\n"
                },
                "streetAddress": {
                    "type": "string",
                    "description": "The street address\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of intermediate to create. Must be either \\\"exported\\\" or \\\"internal\\\"\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n"
                }
            },
            "required": [
                "backend",
                "commonName",
                "csr",
                "privateKey",
                "privateKeyType",
                "type"
            ],
            "inputProperties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of intermediate to create\n"
                },
                "country": {
                    "type": "string",
                    "description": "The country\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "keyBits": {
                    "type": "integer",
                    "description": "The number of bits to use\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "The desired key type\n"
                },
                "locality": {
                    "type": "string",
                    "description": "The locality\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "ou": {
                    "type": "string",
                    "description": "The organization unit\n"
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code\n"
                },
                "privateKeyFormat": {
                    "type": "string",
                    "description": "The private key format\n"
                },
                "province": {
                    "type": "string",
                    "description": "The province\n"
                },
                "streetAddress": {
                    "type": "string",
                    "description": "The street address\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of intermediate to create. Must be either \\\"exported\\\" or \\\"internal\\\"\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n"
                }
            },
            "requiredInputs": [
                "backend",
                "commonName",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendIntermediateCertRequest resources.\n",
                "properties": {
                    "altNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative names\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The PKI secret backend the resource belongs to.\n"
                    },
                    "commonName": {
                        "type": "string",
                        "description": "CN of intermediate to create\n"
                    },
                    "country": {
                        "type": "string",
                        "description": "The country\n"
                    },
                    "csr": {
                        "type": "string",
                        "description": "The CSR\n"
                    },
                    "excludeCnFromSans": {
                        "type": "boolean",
                        "description": "Flag to exclude CN from SANs\n"
                    },
                    "format": {
                        "type": "string",
                        "description": "The format of data\n"
                    },
                    "ipSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative IPs\n"
                    },
                    "keyBits": {
                        "type": "integer",
                        "description": "The number of bits to use\n"
                    },
                    "keyType": {
                        "type": "string",
                        "description": "The desired key type\n"
                    },
                    "locality": {
                        "type": "string",
                        "description": "The locality\n"
                    },
                    "organization": {
                        "type": "string",
                        "description": "The organization\n"
                    },
                    "otherSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of other SANs\n"
                    },
                    "ou": {
                        "type": "string",
                        "description": "The organization unit\n"
                    },
                    "postalCode": {
                        "type": "string",
                        "description": "The postal code\n"
                    },
                    "privateKey": {
                        "type": "string",
                        "description": "The private key\n"
                    },
                    "privateKeyFormat": {
                        "type": "string",
                        "description": "The private key format\n"
                    },
                    "privateKeyType": {
                        "type": "string",
                        "description": "The private key type\n"
                    },
                    "province": {
                        "type": "string",
                        "description": "The province\n"
                    },
                    "streetAddress": {
                        "type": "string",
                        "description": "The street address\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of intermediate to create. Must be either \\\"exported\\\" or \\\"internal\\\"\n"
                    },
                    "uriSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative URIs\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendIntermediateSetSigned:SecretBackendIntermediateSetSigned": {
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The certificate\n"
                }
            },
            "required": [
                "backend",
                "certificate"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The certificate\n"
                }
            },
            "requiredInputs": [
                "backend",
                "certificate"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendIntermediateSetSigned resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The PKI secret backend the resource belongs to.\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "The certificate\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendRole:SecretBackendRole": {
            "description": "Creates a role on an PKI Secret Backend for Vault.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst pki = new vault.pkiSecret.SecretBackend(\"pki\", {\n    defaultLeaseTtlSeconds: 3600,\n    maxLeaseTtlSeconds: 86400,\n    path: \"%s\",\n});\nconst role = new vault.pkiSecret.SecretBackendRole(\"role\", {\n    backend: pki.path,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\npki = vault.pki_secret.SecretBackend(\"pki\",\n    default_lease_ttl_seconds=3600,\n    max_lease_ttl_seconds=86400,\n    path=\"%s\")\nrole = vault.pki_secret.SecretBackendRole(\"role\", backend=pki.path)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var pki = new Vault.PkiSecret.SecretBackend(\"pki\", new Vault.PkiSecret.SecretBackendArgs\n        {\n            DefaultLeaseTtlSeconds = 3600,\n            MaxLeaseTtlSeconds = 86400,\n            Path = \"%s\",\n        });\n        var role = new Vault.PkiSecret.SecretBackendRole(\"role\", new Vault.PkiSecret.SecretBackendRoleArgs\n        {\n            Backend = pki.Path,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/pkiSecret\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tpki, err := pkiSecret.NewSecretBackend(ctx, \"pki\", \u0026pkiSecret.SecretBackendArgs{\n\t\t\tDefaultLeaseTtlSeconds: pulumi.Int(3600),\n\t\t\tMaxLeaseTtlSeconds:     pulumi.Int(86400),\n\t\t\tPath:                   pulumi.String(fmt.Sprintf(\"%v%v\", \"%\", \"s\")),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = pkiSecret.NewSecretBackendRole(ctx, \"role\", \u0026pkiSecret.SecretBackendRoleArgs{\n\t\t\tBackend: pki.Path,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nPKI secret backend roles can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:pkiSecret/secretBackendRole:SecretBackendRole role pki/roles/my_role\n```\n\n ",
            "properties": {
                "allowAnyName": {
                    "type": "boolean",
                    "description": "Flag to allow any name\n"
                },
                "allowBareDomains": {
                    "type": "boolean",
                    "description": "Flag to allow certificates matching the actual domain\n"
                },
                "allowGlobDomains": {
                    "type": "boolean",
                    "description": "Flag to allow names containing glob patterns.\n"
                },
                "allowIpSans": {
                    "type": "boolean",
                    "description": "Flag to allow IP SANs\n"
                },
                "allowLocalhost": {
                    "type": "boolean",
                    "description": "Flag to allow certificates for localhost\n"
                },
                "allowSubdomains": {
                    "type": "boolean",
                    "description": "Flag to allow certificates matching subdomains\n"
                },
                "allowedDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of allowed domains for certificates\n"
                },
                "allowedOtherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Defines allowed custom SANs\n"
                },
                "allowedUriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Defines allowed URI SANs\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "basicConstraintsValidForNonCa": {
                    "type": "boolean",
                    "description": "Flag to mark basic constraints valid when issuing non-CA certificates\n"
                },
                "clientFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for client use\n"
                },
                "codeSigningFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for code signing use\n"
                },
                "countries": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The country of generated certificates\n"
                },
                "emailProtectionFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for email protection use\n"
                },
                "enforceHostnames": {
                    "type": "boolean",
                    "description": "Flag to allow only valid host names\n"
                },
                "extKeyUsages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify the allowed extended key usage constraint on issued certificates\n"
                },
                "generateLease": {
                    "type": "boolean",
                    "description": "Flag to generate leases with certificates\n"
                },
                "keyBits": {
                    "type": "integer",
                    "description": "The number of bits of generated keys\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "The type of generated keys\n"
                },
                "keyUsages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify the allowed key usage constraint on issued certificates\n"
                },
                "localities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The locality of generated certificates\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "The maximum TTL\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this role within the backend. Must be unique within the backend.\n"
                },
                "noStore": {
                    "type": "boolean",
                    "description": "Flag to not store certificates in the storage backend\n"
                },
                "notBeforeDuration": {
                    "type": "string",
                    "description": "Specifies the duration by which to backdate the NotBefore property.\n"
                },
                "organizationUnit": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The organization unit of generated certificates\n"
                },
                "organizations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The organization of generated certificates\n"
                },
                "policyIdentifiers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify the list of allowed policies IODs\n"
                },
                "postalCodes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The postal code of generated certificates\n"
                },
                "provinces": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The province of generated certificates\n"
                },
                "requireCn": {
                    "type": "boolean",
                    "description": "Flag to force CN usage\n"
                },
                "serverFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for server use\n"
                },
                "streetAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The street address of generated certificates\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "The TTL\n"
                },
                "useCsrCommonName": {
                    "type": "boolean",
                    "description": "Flag to use the CN in the CSR\n"
                },
                "useCsrSans": {
                    "type": "boolean",
                    "description": "Flag to use the SANs in the CSR\n"
                }
            },
            "required": [
                "backend",
                "name",
                "notBeforeDuration"
            ],
            "inputProperties": {
                "allowAnyName": {
                    "type": "boolean",
                    "description": "Flag to allow any name\n"
                },
                "allowBareDomains": {
                    "type": "boolean",
                    "description": "Flag to allow certificates matching the actual domain\n"
                },
                "allowGlobDomains": {
                    "type": "boolean",
                    "description": "Flag to allow names containing glob patterns.\n"
                },
                "allowIpSans": {
                    "type": "boolean",
                    "description": "Flag to allow IP SANs\n"
                },
                "allowLocalhost": {
                    "type": "boolean",
                    "description": "Flag to allow certificates for localhost\n"
                },
                "allowSubdomains": {
                    "type": "boolean",
                    "description": "Flag to allow certificates matching subdomains\n"
                },
                "allowedDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of allowed domains for certificates\n"
                },
                "allowedOtherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Defines allowed custom SANs\n"
                },
                "allowedUriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Defines allowed URI SANs\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                },
                "basicConstraintsValidForNonCa": {
                    "type": "boolean",
                    "description": "Flag to mark basic constraints valid when issuing non-CA certificates\n"
                },
                "clientFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for client use\n"
                },
                "codeSigningFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for code signing use\n"
                },
                "countries": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The country of generated certificates\n"
                },
                "emailProtectionFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for email protection use\n"
                },
                "enforceHostnames": {
                    "type": "boolean",
                    "description": "Flag to allow only valid host names\n"
                },
                "extKeyUsages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify the allowed extended key usage constraint on issued certificates\n"
                },
                "generateLease": {
                    "type": "boolean",
                    "description": "Flag to generate leases with certificates\n"
                },
                "keyBits": {
                    "type": "integer",
                    "description": "The number of bits of generated keys\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "The type of generated keys\n"
                },
                "keyUsages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify the allowed key usage constraint on issued certificates\n"
                },
                "localities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The locality of generated certificates\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "The maximum TTL\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this role within the backend. Must be unique within the backend.\n"
                },
                "noStore": {
                    "type": "boolean",
                    "description": "Flag to not store certificates in the storage backend\n"
                },
                "notBeforeDuration": {
                    "type": "string",
                    "description": "Specifies the duration by which to backdate the NotBefore property.\n"
                },
                "organizationUnit": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The organization unit of generated certificates\n"
                },
                "organizations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The organization of generated certificates\n"
                },
                "policyIdentifiers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify the list of allowed policies IODs\n"
                },
                "postalCodes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The postal code of generated certificates\n"
                },
                "provinces": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The province of generated certificates\n"
                },
                "requireCn": {
                    "type": "boolean",
                    "description": "Flag to force CN usage\n"
                },
                "serverFlag": {
                    "type": "boolean",
                    "description": "Flag to specify certificates for server use\n"
                },
                "streetAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The street address of generated certificates\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "The TTL\n"
                },
                "useCsrCommonName": {
                    "type": "boolean",
                    "description": "Flag to use the CN in the CSR\n"
                },
                "useCsrSans": {
                    "type": "boolean",
                    "description": "Flag to use the SANs in the CSR\n"
                }
            },
            "requiredInputs": [
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRole resources.\n",
                "properties": {
                    "allowAnyName": {
                        "type": "boolean",
                        "description": "Flag to allow any name\n"
                    },
                    "allowBareDomains": {
                        "type": "boolean",
                        "description": "Flag to allow certificates matching the actual domain\n"
                    },
                    "allowGlobDomains": {
                        "type": "boolean",
                        "description": "Flag to allow names containing glob patterns.\n"
                    },
                    "allowIpSans": {
                        "type": "boolean",
                        "description": "Flag to allow IP SANs\n"
                    },
                    "allowLocalhost": {
                        "type": "boolean",
                        "description": "Flag to allow certificates for localhost\n"
                    },
                    "allowSubdomains": {
                        "type": "boolean",
                        "description": "Flag to allow certificates matching subdomains\n"
                    },
                    "allowedDomains": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of allowed domains for certificates\n"
                    },
                    "allowedOtherSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Defines allowed custom SANs\n"
                    },
                    "allowedUriSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Defines allowed URI SANs\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path the PKI secret backend is mounted at, with no leading or trailing `/`s.\n"
                    },
                    "basicConstraintsValidForNonCa": {
                        "type": "boolean",
                        "description": "Flag to mark basic constraints valid when issuing non-CA certificates\n"
                    },
                    "clientFlag": {
                        "type": "boolean",
                        "description": "Flag to specify certificates for client use\n"
                    },
                    "codeSigningFlag": {
                        "type": "boolean",
                        "description": "Flag to specify certificates for code signing use\n"
                    },
                    "countries": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The country of generated certificates\n"
                    },
                    "emailProtectionFlag": {
                        "type": "boolean",
                        "description": "Flag to specify certificates for email protection use\n"
                    },
                    "enforceHostnames": {
                        "type": "boolean",
                        "description": "Flag to allow only valid host names\n"
                    },
                    "extKeyUsages": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specify the allowed extended key usage constraint on issued certificates\n"
                    },
                    "generateLease": {
                        "type": "boolean",
                        "description": "Flag to generate leases with certificates\n"
                    },
                    "keyBits": {
                        "type": "integer",
                        "description": "The number of bits of generated keys\n"
                    },
                    "keyType": {
                        "type": "string",
                        "description": "The type of generated keys\n"
                    },
                    "keyUsages": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specify the allowed key usage constraint on issued certificates\n"
                    },
                    "localities": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The locality of generated certificates\n"
                    },
                    "maxTtl": {
                        "type": "string",
                        "description": "The maximum TTL\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name to identify this role within the backend. Must be unique within the backend.\n"
                    },
                    "noStore": {
                        "type": "boolean",
                        "description": "Flag to not store certificates in the storage backend\n"
                    },
                    "notBeforeDuration": {
                        "type": "string",
                        "description": "Specifies the duration by which to backdate the NotBefore property.\n"
                    },
                    "organizationUnit": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The organization unit of generated certificates\n"
                    },
                    "organizations": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The organization of generated certificates\n"
                    },
                    "policyIdentifiers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specify the list of allowed policies IODs\n"
                    },
                    "postalCodes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The postal code of generated certificates\n"
                    },
                    "provinces": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The province of generated certificates\n"
                    },
                    "requireCn": {
                        "type": "boolean",
                        "description": "Flag to force CN usage\n"
                    },
                    "serverFlag": {
                        "type": "boolean",
                        "description": "Flag to specify certificates for server use\n"
                    },
                    "streetAddresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The street address of generated certificates\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "The TTL\n"
                    },
                    "useCsrCommonName": {
                        "type": "boolean",
                        "description": "Flag to use the CN in the CSR\n"
                    },
                    "useCsrSans": {
                        "type": "boolean",
                        "description": "Flag to use the SANs in the CSR\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendRootCert:SecretBackendRootCert": {
            "properties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The certificate\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of intermediate to create\n"
                },
                "country": {
                    "type": "string",
                    "description": "The country\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "issuingCa": {
                    "type": "string",
                    "description": "The issuing CA\n"
                },
                "keyBits": {
                    "type": "integer",
                    "description": "The number of bits to use\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "The desired key type\n"
                },
                "locality": {
                    "type": "string",
                    "description": "The locality\n"
                },
                "maxPathLength": {
                    "type": "integer",
                    "description": "The maximum path length to encode in the generated certificate\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "ou": {
                    "type": "string",
                    "description": "The organization unit\n"
                },
                "permittedDnsDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of domains for which certificates are allowed to be issued\n"
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code\n"
                },
                "privateKeyFormat": {
                    "type": "string",
                    "description": "The private key format\n"
                },
                "province": {
                    "type": "string",
                    "description": "The province\n"
                },
                "serial": {
                    "type": "string",
                    "description": "The serial\n"
                },
                "streetAddress": {
                    "type": "string",
                    "description": "The street address\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of intermediate to create. Must be either \\\"exported\\\" or \\\"internal\\\"\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n"
                }
            },
            "required": [
                "backend",
                "certificate",
                "commonName",
                "issuingCa",
                "serial",
                "type"
            ],
            "inputProperties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of intermediate to create\n"
                },
                "country": {
                    "type": "string",
                    "description": "The country\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "keyBits": {
                    "type": "integer",
                    "description": "The number of bits to use\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "The desired key type\n"
                },
                "locality": {
                    "type": "string",
                    "description": "The locality\n"
                },
                "maxPathLength": {
                    "type": "integer",
                    "description": "The maximum path length to encode in the generated certificate\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "ou": {
                    "type": "string",
                    "description": "The organization unit\n"
                },
                "permittedDnsDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of domains for which certificates are allowed to be issued\n"
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code\n"
                },
                "privateKeyFormat": {
                    "type": "string",
                    "description": "The private key format\n"
                },
                "province": {
                    "type": "string",
                    "description": "The province\n"
                },
                "streetAddress": {
                    "type": "string",
                    "description": "The street address\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of intermediate to create. Must be either \\\"exported\\\" or \\\"internal\\\"\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n"
                }
            },
            "requiredInputs": [
                "backend",
                "commonName",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRootCert resources.\n",
                "properties": {
                    "altNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative names\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The PKI secret backend the resource belongs to.\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "The certificate\n"
                    },
                    "commonName": {
                        "type": "string",
                        "description": "CN of intermediate to create\n"
                    },
                    "country": {
                        "type": "string",
                        "description": "The country\n"
                    },
                    "excludeCnFromSans": {
                        "type": "boolean",
                        "description": "Flag to exclude CN from SANs\n"
                    },
                    "format": {
                        "type": "string",
                        "description": "The format of data\n"
                    },
                    "ipSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative IPs\n"
                    },
                    "issuingCa": {
                        "type": "string",
                        "description": "The issuing CA\n"
                    },
                    "keyBits": {
                        "type": "integer",
                        "description": "The number of bits to use\n"
                    },
                    "keyType": {
                        "type": "string",
                        "description": "The desired key type\n"
                    },
                    "locality": {
                        "type": "string",
                        "description": "The locality\n"
                    },
                    "maxPathLength": {
                        "type": "integer",
                        "description": "The maximum path length to encode in the generated certificate\n"
                    },
                    "organization": {
                        "type": "string",
                        "description": "The organization\n"
                    },
                    "otherSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of other SANs\n"
                    },
                    "ou": {
                        "type": "string",
                        "description": "The organization unit\n"
                    },
                    "permittedDnsDomains": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of domains for which certificates are allowed to be issued\n"
                    },
                    "postalCode": {
                        "type": "string",
                        "description": "The postal code\n"
                    },
                    "privateKeyFormat": {
                        "type": "string",
                        "description": "The private key format\n"
                    },
                    "province": {
                        "type": "string",
                        "description": "The province\n"
                    },
                    "serial": {
                        "type": "string",
                        "description": "The serial\n"
                    },
                    "streetAddress": {
                        "type": "string",
                        "description": "The street address\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Time to live\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of intermediate to create. Must be either \\\"exported\\\" or \\\"internal\\\"\n"
                    },
                    "uriSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative URIs\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendRootSignIntermediate:SecretBackendRootSignIntermediate": {
            "description": "Creates an PKI certificate.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst root = new vault.pkiSecret.SecretBackendRootSignIntermediate(\"root\", {\n    backend: vault_pki_secret_backend.root.path,\n    csr: vault_pki_secret_backend_intermediate_cert_request.intermediate.csr,\n    commonName: \"Intermediate CA\",\n    excludeCnFromSans: true,\n    ou: \"My OU\",\n    organization: \"My organization\",\n}, {\n    dependsOn: [\"vault_pki_secret_backend_intermediate_cert_request.intermediate\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nroot = vault.pki_secret.SecretBackendRootSignIntermediate(\"root\",\n    backend=vault_pki_secret_backend[\"root\"][\"path\"],\n    csr=vault_pki_secret_backend_intermediate_cert_request[\"intermediate\"][\"csr\"],\n    common_name=\"Intermediate CA\",\n    exclude_cn_from_sans=True,\n    ou=\"My OU\",\n    organization=\"My organization\",\n    opts=ResourceOptions(depends_on=[\"vault_pki_secret_backend_intermediate_cert_request.intermediate\"]))\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var root = new Vault.PkiSecret.SecretBackendRootSignIntermediate(\"root\", new Vault.PkiSecret.SecretBackendRootSignIntermediateArgs\n        {\n            Backend = vault_pki_secret_backend.Root.Path,\n            Csr = vault_pki_secret_backend_intermediate_cert_request.Intermediate.Csr,\n            CommonName = \"Intermediate CA\",\n            ExcludeCnFromSans = true,\n            Ou = \"My OU\",\n            Organization = \"My organization\",\n        }, new CustomResourceOptions\n        {\n            DependsOn = \n            {\n                \"vault_pki_secret_backend_intermediate_cert_request.intermediate\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/pkiSecret\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := pkiSecret.NewSecretBackendRootSignIntermediate(ctx, \"root\", \u0026pkiSecret.SecretBackendRootSignIntermediateArgs{\n\t\t\tBackend:           pulumi.Any(vault_pki_secret_backend.Root.Path),\n\t\t\tCsr:               pulumi.Any(vault_pki_secret_backend_intermediate_cert_request.Intermediate.Csr),\n\t\t\tCommonName:        pulumi.String(\"Intermediate CA\"),\n\t\t\tExcludeCnFromSans: pulumi.Bool(true),\n\t\t\tOu:                pulumi.String(\"My OU\"),\n\t\t\tOrganization:      pulumi.String(\"My organization\"),\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\t\"vault_pki_secret_backend_intermediate_cert_request.intermediate\",\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "caChain": {
                    "type": "string",
                    "description": "The CA chain\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The certificate\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of intermediate to create\n"
                },
                "country": {
                    "type": "string",
                    "description": "The country\n"
                },
                "csr": {
                    "type": "string",
                    "description": "The CSR\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "issuingCa": {
                    "type": "string",
                    "description": "The issuing CA\n"
                },
                "locality": {
                    "type": "string",
                    "description": "The locality\n"
                },
                "maxPathLength": {
                    "type": "integer",
                    "description": "The maximum path length to encode in the generated certificate\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "ou": {
                    "type": "string",
                    "description": "The organization unit\n"
                },
                "permittedDnsDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of domains for which certificates are allowed to be issued\n"
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code\n"
                },
                "province": {
                    "type": "string",
                    "description": "The province\n"
                },
                "serial": {
                    "type": "string",
                    "description": "The serial\n"
                },
                "streetAddress": {
                    "type": "string",
                    "description": "The street address\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n"
                },
                "useCsrValues": {
                    "type": "boolean",
                    "description": "Preserve CSR values\n"
                }
            },
            "required": [
                "backend",
                "caChain",
                "certificate",
                "commonName",
                "csr",
                "issuingCa",
                "serial"
            ],
            "inputProperties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of intermediate to create\n"
                },
                "country": {
                    "type": "string",
                    "description": "The country\n"
                },
                "csr": {
                    "type": "string",
                    "description": "The CSR\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "locality": {
                    "type": "string",
                    "description": "The locality\n"
                },
                "maxPathLength": {
                    "type": "integer",
                    "description": "The maximum path length to encode in the generated certificate\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "ou": {
                    "type": "string",
                    "description": "The organization unit\n"
                },
                "permittedDnsDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of domains for which certificates are allowed to be issued\n"
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code\n"
                },
                "province": {
                    "type": "string",
                    "description": "The province\n"
                },
                "streetAddress": {
                    "type": "string",
                    "description": "The street address\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative URIs\n"
                },
                "useCsrValues": {
                    "type": "boolean",
                    "description": "Preserve CSR values\n"
                }
            },
            "requiredInputs": [
                "backend",
                "commonName",
                "csr"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRootSignIntermediate resources.\n",
                "properties": {
                    "altNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative names\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The PKI secret backend the resource belongs to.\n"
                    },
                    "caChain": {
                        "type": "string",
                        "description": "The CA chain\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "The certificate\n"
                    },
                    "commonName": {
                        "type": "string",
                        "description": "CN of intermediate to create\n"
                    },
                    "country": {
                        "type": "string",
                        "description": "The country\n"
                    },
                    "csr": {
                        "type": "string",
                        "description": "The CSR\n"
                    },
                    "excludeCnFromSans": {
                        "type": "boolean",
                        "description": "Flag to exclude CN from SANs\n"
                    },
                    "format": {
                        "type": "string",
                        "description": "The format of data\n"
                    },
                    "ipSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative IPs\n"
                    },
                    "issuingCa": {
                        "type": "string",
                        "description": "The issuing CA\n"
                    },
                    "locality": {
                        "type": "string",
                        "description": "The locality\n"
                    },
                    "maxPathLength": {
                        "type": "integer",
                        "description": "The maximum path length to encode in the generated certificate\n"
                    },
                    "organization": {
                        "type": "string",
                        "description": "The organization\n"
                    },
                    "otherSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of other SANs\n"
                    },
                    "ou": {
                        "type": "string",
                        "description": "The organization unit\n"
                    },
                    "permittedDnsDomains": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of domains for which certificates are allowed to be issued\n"
                    },
                    "postalCode": {
                        "type": "string",
                        "description": "The postal code\n"
                    },
                    "province": {
                        "type": "string",
                        "description": "The province\n"
                    },
                    "serial": {
                        "type": "string",
                        "description": "The serial\n"
                    },
                    "streetAddress": {
                        "type": "string",
                        "description": "The street address\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Time to live\n"
                    },
                    "uriSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative URIs\n"
                    },
                    "useCsrValues": {
                        "type": "boolean",
                        "description": "Preserve CSR values\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:pkiSecret/secretBackendSign:SecretBackendSign": {
            "properties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "autoRenew": {
                    "type": "boolean",
                    "description": "If enabled, a new certificate will be generated if the expiration is within min_seconds_remaining\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "caChains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The CA chain\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The certificate\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of certificate to create\n"
                },
                "csr": {
                    "type": "string",
                    "description": "The CSR\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "expiration": {
                    "type": "integer",
                    "description": "The expiration date of the certificate in unix epoch format\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "issuingCa": {
                    "type": "string",
                    "description": "The issuing CA\n"
                },
                "minSecondsRemaining": {
                    "type": "integer",
                    "description": "Generate a new certificate when the expiration is within this number of seconds, default is 604800 (7 days)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the role to create the certificate against\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "serial": {
                    "type": "string",
                    "description": "The serial\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alterative URIs\n"
                }
            },
            "required": [
                "backend",
                "caChains",
                "certificate",
                "commonName",
                "csr",
                "expiration",
                "issuingCa",
                "name",
                "serial"
            ],
            "inputProperties": {
                "altNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative names\n"
                },
                "autoRenew": {
                    "type": "boolean",
                    "description": "If enabled, a new certificate will be generated if the expiration is within min_seconds_remaining\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The PKI secret backend the resource belongs to.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "CN of certificate to create\n"
                },
                "csr": {
                    "type": "string",
                    "description": "The CSR\n"
                },
                "excludeCnFromSans": {
                    "type": "boolean",
                    "description": "Flag to exclude CN from SANs\n"
                },
                "format": {
                    "type": "string",
                    "description": "The format of data\n"
                },
                "ipSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alternative IPs\n"
                },
                "minSecondsRemaining": {
                    "type": "integer",
                    "description": "Generate a new certificate when the expiration is within this number of seconds, default is 604800 (7 days)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the role to create the certificate against\n"
                },
                "otherSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of other SANs\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Time to live\n"
                },
                "uriSans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of alterative URIs\n"
                }
            },
            "requiredInputs": [
                "backend",
                "commonName",
                "csr"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendSign resources.\n",
                "properties": {
                    "altNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative names\n"
                    },
                    "autoRenew": {
                        "type": "boolean",
                        "description": "If enabled, a new certificate will be generated if the expiration is within min_seconds_remaining\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The PKI secret backend the resource belongs to.\n"
                    },
                    "caChains": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The CA chain\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "The certificate\n"
                    },
                    "commonName": {
                        "type": "string",
                        "description": "CN of certificate to create\n"
                    },
                    "csr": {
                        "type": "string",
                        "description": "The CSR\n"
                    },
                    "excludeCnFromSans": {
                        "type": "boolean",
                        "description": "Flag to exclude CN from SANs\n"
                    },
                    "expiration": {
                        "type": "integer",
                        "description": "The expiration date of the certificate in unix epoch format\n"
                    },
                    "format": {
                        "type": "string",
                        "description": "The format of data\n"
                    },
                    "ipSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alternative IPs\n"
                    },
                    "issuingCa": {
                        "type": "string",
                        "description": "The issuing CA\n"
                    },
                    "minSecondsRemaining": {
                        "type": "integer",
                        "description": "Generate a new certificate when the expiration is within this number of seconds, default is 604800 (7 days)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the role to create the certificate against\n"
                    },
                    "otherSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of other SANs\n"
                    },
                    "serial": {
                        "type": "string",
                        "description": "The serial\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Time to live\n"
                    },
                    "uriSans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of alterative URIs\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:rabbitMq/secretBackend:SecretBackend": {
            "description": "\n\n\n## Import\n\nRabbitMQ secret backends can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:rabbitMq/secretBackend:SecretBackend rabbitmq rabbitmq\n```\n\n ",
            "properties": {
                "connectionUri": {
                    "type": "string",
                    "description": "Specifies the RabbitMQ connection URI.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials\nissued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Specifies the RabbitMQ management administrator password.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `aws`.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Specifies the RabbitMQ management administrator username.\n"
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Specifies whether to verify connection URI, username, and password.\nDefaults to `true`.\n"
                }
            },
            "required": [
                "connectionUri",
                "defaultLeaseTtlSeconds",
                "maxLeaseTtlSeconds",
                "password",
                "username"
            ],
            "inputProperties": {
                "connectionUri": {
                    "type": "string",
                    "description": "Specifies the RabbitMQ connection URI.\n"
                },
                "defaultLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The default TTL for credentials\nissued by this backend.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-friendly description for this backend.\n"
                },
                "maxLeaseTtlSeconds": {
                    "type": "integer",
                    "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Specifies the RabbitMQ management administrator password.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `aws`.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Specifies the RabbitMQ management administrator username.\n"
                },
                "verifyConnection": {
                    "type": "boolean",
                    "description": "Specifies whether to verify connection URI, username, and password.\nDefaults to `true`.\n"
                }
            },
            "requiredInputs": [
                "connectionUri",
                "password",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackend resources.\n",
                "properties": {
                    "connectionUri": {
                        "type": "string",
                        "description": "Specifies the RabbitMQ connection URI.\n"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The default TTL for credentials\nissued by this backend.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A human-friendly description for this backend.\n"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer",
                        "description": "The maximum TTL that can be requested\nfor credentials issued by this backend.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "Specifies the RabbitMQ management administrator password.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The unique path this backend should be mounted at. Must\nnot begin or end with a `/`. Defaults to `aws`.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Specifies the RabbitMQ management administrator username.\n"
                    },
                    "verifyConnection": {
                        "type": "boolean",
                        "description": "Specifies whether to verify connection URI, username, and password.\nDefaults to `true`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:rabbitMq/secretBackendRole:SecretBackendRole": {
            "description": "\n\n\n## Import\n\nRabbitMQ secret backend roles can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:rabbitMq/secretBackendRole:SecretBackendRole role rabbitmq/roles/deploy\n```\n\n ",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path the RabbitMQ secret backend is mounted at,\nwith no leading or trailing `/`s.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n"
                },
                "tags": {
                    "type": "string",
                    "description": "Specifies a comma-separated RabbitMQ management tags.\n"
                },
                "vhosts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:rabbitMq/SecretBackendRoleVhost:SecretBackendRoleVhost"
                    },
                    "description": "Specifies a map of virtual hosts to permissions.\n"
                }
            },
            "required": [
                "backend",
                "name"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path the RabbitMQ secret backend is mounted at,\nwith no leading or trailing `/`s.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n"
                },
                "tags": {
                    "type": "string",
                    "description": "Specifies a comma-separated RabbitMQ management tags.\n"
                },
                "vhosts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vault:rabbitMq/SecretBackendRoleVhost:SecretBackendRoleVhost"
                    },
                    "description": "Specifies a map of virtual hosts to permissions.\n"
                }
            },
            "requiredInputs": [
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRole resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path the RabbitMQ secret backend is mounted at,\nwith no leading or trailing `/`s.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name to identify this role within the backend.\nMust be unique within the backend.\n"
                    },
                    "tags": {
                        "type": "string",
                        "description": "Specifies a comma-separated RabbitMQ management tags.\n"
                    },
                    "vhosts": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:rabbitMq/SecretBackendRoleVhost:SecretBackendRoleVhost"
                        },
                        "description": "Specifies a map of virtual hosts to permissions.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:ssh/secretBackendCa:SecretBackendCa": {
            "description": "Provides a resource to manage CA information in an SSH secret backend\n[SSH secret backend within Vault](https://www.vaultproject.io/docs/secrets/ssh/index.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.Mount(\"example\", {\n    type: \"ssh\",\n});\nconst foo = new vault.ssh.SecretBackendCa(\"foo\", {\n    backend: example.path,\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.Mount(\"example\", type=\"ssh\")\nfoo = vault.ssh.SecretBackendCa(\"foo\", backend=example.path)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.Mount(\"example\", new Vault.MountArgs\n        {\n            Type = \"ssh\",\n        });\n        var foo = new Vault.Ssh.SecretBackendCa(\"foo\", new Vault.Ssh.SecretBackendCaArgs\n        {\n            Backend = example.Path,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/ssh\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := vault.NewMount(ctx, \"example\", \u0026vault.MountArgs{\n\t\t\tType: pulumi.String(\"ssh\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ssh.NewSecretBackendCa(ctx, \"foo\", \u0026ssh.SecretBackendCaArgs{\n\t\t\tBackend: example.Path,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The path where the SSH secret backend is mounted. Defaults to 'ssh'\n"
                },
                "generateSigningKey": {
                    "type": "boolean",
                    "description": "Whether Vault should generate the signing key pair internally. Defaults to true\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "The private key part the SSH CA key pair; required if generate_signing_key is false.\n"
                },
                "publicKey": {
                    "type": "string",
                    "description": "The public key part the SSH CA key pair; required if generate_signing_key is false.\n"
                }
            },
            "required": [
                "privateKey",
                "publicKey"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The path where the SSH secret backend is mounted. Defaults to 'ssh'\n"
                },
                "generateSigningKey": {
                    "type": "boolean",
                    "description": "Whether Vault should generate the signing key pair internally. Defaults to true\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "The private key part the SSH CA key pair; required if generate_signing_key is false.\n"
                },
                "publicKey": {
                    "type": "string",
                    "description": "The public key part the SSH CA key pair; required if generate_signing_key is false.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendCa resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path where the SSH secret backend is mounted. Defaults to 'ssh'\n"
                    },
                    "generateSigningKey": {
                        "type": "boolean",
                        "description": "Whether Vault should generate the signing key pair internally. Defaults to true\n"
                    },
                    "privateKey": {
                        "type": "string",
                        "description": "The private key part the SSH CA key pair; required if generate_signing_key is false.\n"
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "The public key part the SSH CA key pair; required if generate_signing_key is false.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:ssh/secretBackendRole:SecretBackendRole": {
            "description": "Provides a resource to manage roles in an SSH secret backend\n[SSH secret backend within Vault](https://www.vaultproject.io/docs/secrets/ssh/index.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.Mount(\"example\", {\n    type: \"ssh\",\n});\nconst foo = new vault.ssh.SecretBackendRole(\"foo\", {\n    allowUserCertificates: true,\n    backend: example.path,\n    keyType: \"ca\",\n});\nconst bar = new vault.ssh.SecretBackendRole(\"bar\", {\n    allowedUsers: \"default,baz\",\n    backend: example.path,\n    cidrList: \"0.0.0.0/0\",\n    defaultUser: \"default\",\n    keyType: \"otp\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.Mount(\"example\", type=\"ssh\")\nfoo = vault.ssh.SecretBackendRole(\"foo\",\n    allow_user_certificates=True,\n    backend=example.path,\n    key_type=\"ca\")\nbar = vault.ssh.SecretBackendRole(\"bar\",\n    allowed_users=\"default,baz\",\n    backend=example.path,\n    cidr_list=\"0.0.0.0/0\",\n    default_user=\"default\",\n    key_type=\"otp\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.Mount(\"example\", new Vault.MountArgs\n        {\n            Type = \"ssh\",\n        });\n        var foo = new Vault.Ssh.SecretBackendRole(\"foo\", new Vault.Ssh.SecretBackendRoleArgs\n        {\n            AllowUserCertificates = true,\n            Backend = example.Path,\n            KeyType = \"ca\",\n        });\n        var bar = new Vault.Ssh.SecretBackendRole(\"bar\", new Vault.Ssh.SecretBackendRoleArgs\n        {\n            AllowedUsers = \"default,baz\",\n            Backend = example.Path,\n            CidrList = \"0.0.0.0/0\",\n            DefaultUser = \"default\",\n            KeyType = \"otp\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault\"\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/ssh\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := vault.NewMount(ctx, \"example\", \u0026vault.MountArgs{\n\t\t\tType: pulumi.String(\"ssh\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ssh.NewSecretBackendRole(ctx, \"foo\", \u0026ssh.SecretBackendRoleArgs{\n\t\t\tAllowUserCertificates: pulumi.Bool(true),\n\t\t\tBackend:               example.Path,\n\t\t\tKeyType:               pulumi.String(\"ca\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ssh.NewSecretBackendRole(ctx, \"bar\", \u0026ssh.SecretBackendRoleArgs{\n\t\t\tAllowedUsers: pulumi.String(\"default,baz\"),\n\t\t\tBackend:      example.Path,\n\t\t\tCidrList:     pulumi.String(\"0.0.0.0/0\"),\n\t\t\tDefaultUser:  pulumi.String(\"default\"),\n\t\t\tKeyType:      pulumi.String(\"otp\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nSSH secret backend roles can be imported using the `path`, e.g.\n\n```sh\n $ pulumi import vault:ssh/secretBackendRole:SecretBackendRole foo ssh/roles/my-role\n```\n\n ",
            "properties": {
                "algorithmSigner": {
                    "type": "string"
                },
                "allowBareDomains": {
                    "type": "boolean",
                    "description": "Specifies if host certificates that are requested are allowed to use the base domains listed in `allowed_domains`.\n"
                },
                "allowHostCertificates": {
                    "type": "boolean",
                    "description": "Specifies if certificates are allowed to be signed for use as a 'host'.\n"
                },
                "allowSubdomains": {
                    "type": "boolean",
                    "description": "Specifies if host certificates that are requested are allowed to be subdomains of those listed in `allowed_domains`.\n"
                },
                "allowUserCertificates": {
                    "type": "boolean",
                    "description": "Specifies if certificates are allowed to be signed for use as a 'user'.\n"
                },
                "allowUserKeyIds": {
                    "type": "boolean",
                    "description": "Specifies if users can override the key ID for a signed certificate with the `key_id` field.\n"
                },
                "allowedCriticalOptions": {
                    "type": "string",
                    "description": "Specifies a comma-separated list of critical options that certificates can have when signed.\n"
                },
                "allowedDomains": {
                    "type": "string",
                    "description": "The list of domains for which a client can request a host certificate.\n"
                },
                "allowedExtensions": {
                    "type": "string",
                    "description": "Specifies a comma-separated list of extensions that certificates can have when signed.\n"
                },
                "allowedUserKeyLengths": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "allowedUsers": {
                    "type": "string",
                    "description": "Specifies a comma-separated list of usernames that are to be allowed, only if certain usernames are to be allowed.\n"
                },
                "allowedUsersTemplate": {
                    "type": "boolean"
                },
                "backend": {
                    "type": "string",
                    "description": "The path where the SSH secret backend is mounted.\n"
                },
                "cidrList": {
                    "type": "string",
                    "description": "The comma-separated string of CIDR blocks for which this role is applicable.\n"
                },
                "defaultCriticalOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies a map of critical options that certificates have when signed.\n"
                },
                "defaultExtensions": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies a map of extensions that certificates have when signed.\n"
                },
                "defaultUser": {
                    "type": "string",
                    "description": "Specifies the default username for which a credential will be generated.\n"
                },
                "keyIdFormat": {
                    "type": "string",
                    "description": "Specifies a custom format for the key id of a signed certificate.\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "Specifies the type of credentials generated by this role. This can be either `otp`, `dynamic` or `ca`.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Specifies the Time To Live value.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the role to create.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Specifies the maximum Time To Live value.\n"
                }
            },
            "required": [
                "algorithmSigner",
                "backend",
                "keyType",
                "maxTtl",
                "name",
                "ttl"
            ],
            "inputProperties": {
                "algorithmSigner": {
                    "type": "string"
                },
                "allowBareDomains": {
                    "type": "boolean",
                    "description": "Specifies if host certificates that are requested are allowed to use the base domains listed in `allowed_domains`.\n"
                },
                "allowHostCertificates": {
                    "type": "boolean",
                    "description": "Specifies if certificates are allowed to be signed for use as a 'host'.\n"
                },
                "allowSubdomains": {
                    "type": "boolean",
                    "description": "Specifies if host certificates that are requested are allowed to be subdomains of those listed in `allowed_domains`.\n"
                },
                "allowUserCertificates": {
                    "type": "boolean",
                    "description": "Specifies if certificates are allowed to be signed for use as a 'user'.\n"
                },
                "allowUserKeyIds": {
                    "type": "boolean",
                    "description": "Specifies if users can override the key ID for a signed certificate with the `key_id` field.\n"
                },
                "allowedCriticalOptions": {
                    "type": "string",
                    "description": "Specifies a comma-separated list of critical options that certificates can have when signed.\n"
                },
                "allowedDomains": {
                    "type": "string",
                    "description": "The list of domains for which a client can request a host certificate.\n"
                },
                "allowedExtensions": {
                    "type": "string",
                    "description": "Specifies a comma-separated list of extensions that certificates can have when signed.\n"
                },
                "allowedUserKeyLengths": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "allowedUsers": {
                    "type": "string",
                    "description": "Specifies a comma-separated list of usernames that are to be allowed, only if certain usernames are to be allowed.\n"
                },
                "allowedUsersTemplate": {
                    "type": "boolean"
                },
                "backend": {
                    "type": "string",
                    "description": "The path where the SSH secret backend is mounted.\n"
                },
                "cidrList": {
                    "type": "string",
                    "description": "The comma-separated string of CIDR blocks for which this role is applicable.\n"
                },
                "defaultCriticalOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies a map of critical options that certificates have when signed.\n"
                },
                "defaultExtensions": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Specifies a map of extensions that certificates have when signed.\n"
                },
                "defaultUser": {
                    "type": "string",
                    "description": "Specifies the default username for which a credential will be generated.\n"
                },
                "keyIdFormat": {
                    "type": "string",
                    "description": "Specifies a custom format for the key id of a signed certificate.\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "Specifies the type of credentials generated by this role. This can be either `otp`, `dynamic` or `ca`.\n"
                },
                "maxTtl": {
                    "type": "string",
                    "description": "Specifies the Time To Live value.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the role to create.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Specifies the maximum Time To Live value.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "keyType"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendRole resources.\n",
                "properties": {
                    "algorithmSigner": {
                        "type": "string"
                    },
                    "allowBareDomains": {
                        "type": "boolean",
                        "description": "Specifies if host certificates that are requested are allowed to use the base domains listed in `allowed_domains`.\n"
                    },
                    "allowHostCertificates": {
                        "type": "boolean",
                        "description": "Specifies if certificates are allowed to be signed for use as a 'host'.\n"
                    },
                    "allowSubdomains": {
                        "type": "boolean",
                        "description": "Specifies if host certificates that are requested are allowed to be subdomains of those listed in `allowed_domains`.\n"
                    },
                    "allowUserCertificates": {
                        "type": "boolean",
                        "description": "Specifies if certificates are allowed to be signed for use as a 'user'.\n"
                    },
                    "allowUserKeyIds": {
                        "type": "boolean",
                        "description": "Specifies if users can override the key ID for a signed certificate with the `key_id` field.\n"
                    },
                    "allowedCriticalOptions": {
                        "type": "string",
                        "description": "Specifies a comma-separated list of critical options that certificates can have when signed.\n"
                    },
                    "allowedDomains": {
                        "type": "string",
                        "description": "The list of domains for which a client can request a host certificate.\n"
                    },
                    "allowedExtensions": {
                        "type": "string",
                        "description": "Specifies a comma-separated list of extensions that certificates can have when signed.\n"
                    },
                    "allowedUserKeyLengths": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "allowedUsers": {
                        "type": "string",
                        "description": "Specifies a comma-separated list of usernames that are to be allowed, only if certain usernames are to be allowed.\n"
                    },
                    "allowedUsersTemplate": {
                        "type": "boolean"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The path where the SSH secret backend is mounted.\n"
                    },
                    "cidrList": {
                        "type": "string",
                        "description": "The comma-separated string of CIDR blocks for which this role is applicable.\n"
                    },
                    "defaultCriticalOptions": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Specifies a map of critical options that certificates have when signed.\n"
                    },
                    "defaultExtensions": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Specifies a map of extensions that certificates have when signed.\n"
                    },
                    "defaultUser": {
                        "type": "string",
                        "description": "Specifies the default username for which a credential will be generated.\n"
                    },
                    "keyIdFormat": {
                        "type": "string",
                        "description": "Specifies a custom format for the key id of a signed certificate.\n"
                    },
                    "keyType": {
                        "type": "string",
                        "description": "Specifies the type of credentials generated by this role. This can be either `otp`, `dynamic` or `ca`.\n"
                    },
                    "maxTtl": {
                        "type": "string",
                        "description": "Specifies the Time To Live value.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the name of the role to create.\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Specifies the maximum Time To Live value.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:tokenauth/authBackendRole:AuthBackendRole": {
            "description": "Manages Token auth backend role in a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/docs/auth/token.html) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst example = new vault.tokenauth.AuthBackendRole(\"example\", {\n    allowedPolicies: [\n        \"dev\",\n        \"test\",\n    ],\n    disallowedPolicies: [\"default\"],\n    explicitMaxTtl: \"115200\",\n    orphan: true,\n    pathSuffix: \"path-suffix\",\n    period: \"86400\",\n    renewable: true,\n    roleName: \"my-role\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample = vault.tokenauth.AuthBackendRole(\"example\",\n    allowed_policies=[\n        \"dev\",\n        \"test\",\n    ],\n    disallowed_policies=[\"default\"],\n    explicit_max_ttl=\"115200\",\n    orphan=True,\n    path_suffix=\"path-suffix\",\n    period=\"86400\",\n    renewable=True,\n    role_name=\"my-role\")\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Vault.TokenAuth.AuthBackendRole(\"example\", new Vault.TokenAuth.AuthBackendRoleArgs\n        {\n            AllowedPolicies = \n            {\n                \"dev\",\n                \"test\",\n            },\n            DisallowedPolicies = \n            {\n                \"default\",\n            },\n            ExplicitMaxTtl = \"115200\",\n            Orphan = true,\n            PathSuffix = \"path-suffix\",\n            Period = \"86400\",\n            Renewable = true,\n            RoleName = \"my-role\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/tokenauth\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := tokenauth.NewAuthBackendRole(ctx, \"example\", \u0026tokenauth.AuthBackendRoleArgs{\n\t\t\tAllowedPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\tpulumi.String(\"test\"),\n\t\t\t},\n\t\t\tDisallowedPolicies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"default\"),\n\t\t\t},\n\t\t\tExplicitMaxTtl: pulumi.String(\"115200\"),\n\t\t\tOrphan:         pulumi.Bool(true),\n\t\t\tPathSuffix:     pulumi.String(\"path-suffix\"),\n\t\t\tPeriod:         pulumi.String(\"86400\"),\n\t\t\tRenewable:      pulumi.Bool(true),\n\t\t\tRoleName:       pulumi.String(\"my-role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nToken auth backend roles can be imported with `auth/token/roles/` followed by the `role_name`, e.g.\n\n```sh\n $ pulumi import vault:tokenauth/authBackendRole:AuthBackendRole example auth/token/roles/my-role\n```\n\n ",
            "properties": {
                "allowedPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of allowed policies for given role.\n"
                },
                "boundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, restricts usage of the generated token to client IPs falling within the range of the specified CIDR(s).\n",
                    "deprecationMessage": "use `token_bound_cidrs` instead if you are running Vault \u003e= 1.2"
                },
                "disallowedPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of disallowed policies for given role.\n"
                },
                "explicitMaxTtl": {
                    "type": "string",
                    "description": "If set, the token will have an explicit max TTL set upon it.\n",
                    "deprecationMessage": "use `token_explicit_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "orphan": {
                    "type": "boolean",
                    "description": "If true, tokens created against this policy will be orphan tokens.\n"
                },
                "pathSuffix": {
                    "type": "string",
                    "description": "Tokens created against this role will have the given suffix as part of their path in addition to the role name.\n"
                },
                "period": {
                    "type": "string",
                    "description": "The duration in which a token should be renewed. At each renewal, the token's TTL will be set to the value of this parameter.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "renewable": {
                    "type": "boolean",
                    "description": "Wether to disable the ability of the token to be renewed past its initial TTL.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "Specifies the type of tokens that should be returned by the role. If either service or batch is specified, that kind of token will always be returned.\n"
                }
            },
            "required": [
                "roleName"
            ],
            "inputProperties": {
                "allowedPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of allowed policies for given role.\n"
                },
                "boundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If set, restricts usage of the generated token to client IPs falling within the range of the specified CIDR(s).\n",
                    "deprecationMessage": "use `token_bound_cidrs` instead if you are running Vault \u003e= 1.2"
                },
                "disallowedPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of disallowed policies for given role.\n"
                },
                "explicitMaxTtl": {
                    "type": "string",
                    "description": "If set, the token will have an explicit max TTL set upon it.\n",
                    "deprecationMessage": "use `token_explicit_max_ttl` instead if you are running Vault \u003e= 1.2"
                },
                "orphan": {
                    "type": "boolean",
                    "description": "If true, tokens created against this policy will be orphan tokens.\n"
                },
                "pathSuffix": {
                    "type": "string",
                    "description": "Tokens created against this role will have the given suffix as part of their path in addition to the role name.\n"
                },
                "period": {
                    "type": "string",
                    "description": "The duration in which a token should be renewed. At each renewal, the token's TTL will be set to the value of this parameter.\n",
                    "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                },
                "renewable": {
                    "type": "boolean",
                    "description": "Wether to disable the ability of the token to be renewed past its initial TTL.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "tokenBoundCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                },
                "tokenExplicitMaxTtl": {
                    "type": "integer",
                    "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                },
                "tokenMaxTtl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token\n"
                },
                "tokenNoDefaultPolicy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                },
                "tokenNumUses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                },
                "tokenPeriod": {
                    "type": "integer",
                    "description": "Generated Token's Period\n"
                },
                "tokenPolicies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Generated Token's Policies\n"
                },
                "tokenTtl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate in seconds\n"
                },
                "tokenType": {
                    "type": "string",
                    "description": "Specifies the type of tokens that should be returned by the role. If either service or batch is specified, that kind of token will always be returned.\n"
                }
            },
            "requiredInputs": [
                "roleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthBackendRole resources.\n",
                "properties": {
                    "allowedPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of allowed policies for given role.\n"
                    },
                    "boundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "If set, restricts usage of the generated token to client IPs falling within the range of the specified CIDR(s).\n",
                        "deprecationMessage": "use `token_bound_cidrs` instead if you are running Vault \u003e= 1.2"
                    },
                    "disallowedPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of disallowed policies for given role.\n"
                    },
                    "explicitMaxTtl": {
                        "type": "string",
                        "description": "If set, the token will have an explicit max TTL set upon it.\n",
                        "deprecationMessage": "use `token_explicit_max_ttl` instead if you are running Vault \u003e= 1.2"
                    },
                    "orphan": {
                        "type": "boolean",
                        "description": "If true, tokens created against this policy will be orphan tokens.\n"
                    },
                    "pathSuffix": {
                        "type": "string",
                        "description": "Tokens created against this role will have the given suffix as part of their path in addition to the role name.\n"
                    },
                    "period": {
                        "type": "string",
                        "description": "The duration in which a token should be renewed. At each renewal, the token's TTL will be set to the value of this parameter.\n",
                        "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                    },
                    "renewable": {
                        "type": "boolean",
                        "description": "Wether to disable the ability of the token to be renewed past its initial TTL.\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the blocks of IP addresses which are allowed to use the generated token\n"
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer",
                        "description": "Generated Token's Explicit Maximum TTL in seconds\n"
                    },
                    "tokenMaxTtl": {
                        "type": "integer",
                        "description": "The maximum lifetime of the generated token\n"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean",
                        "description": "If true, the 'default' policy will not automatically be added to generated tokens\n"
                    },
                    "tokenNumUses": {
                        "type": "integer",
                        "description": "The maximum number of times a token may be used, a value of zero means unlimited\n"
                    },
                    "tokenPeriod": {
                        "type": "integer",
                        "description": "Generated Token's Period\n"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Generated Token's Policies\n"
                    },
                    "tokenTtl": {
                        "type": "integer",
                        "description": "The initial ttl of the token to generate in seconds\n"
                    },
                    "tokenType": {
                        "type": "string",
                        "description": "Specifies the type of tokens that should be returned by the role. If either service or batch is specified, that kind of token will always be returned.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:transform/alphabet:Alphabet": {
            "properties": {
                "alphabet": {
                    "type": "string",
                    "description": "A string of characters that contains the alphabet set.\n",
                    "language": {
                        "csharp": {
                            "name": "AlphabetSet"
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of the alphabet.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The mount path for a back-end, for example, the path given in \"$ vault auth enable -path=my-aws aws\".\n"
                }
            },
            "required": [
                "name",
                "path"
            ],
            "inputProperties": {
                "alphabet": {
                    "type": "string",
                    "description": "A string of characters that contains the alphabet set.\n",
                    "language": {
                        "csharp": {
                            "name": "AlphabetSet"
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of the alphabet.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The mount path for a back-end, for example, the path given in \"$ vault auth enable -path=my-aws aws\".\n"
                }
            },
            "requiredInputs": [
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Alphabet resources.\n",
                "properties": {
                    "alphabet": {
                        "type": "string",
                        "description": "A string of characters that contains the alphabet set.\n",
                        "language": {
                            "csharp": {
                                "name": "AlphabetSet"
                            }
                        }
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the alphabet.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The mount path for a back-end, for example, the path given in \"$ vault auth enable -path=my-aws aws\".\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:transform/role:Role": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The mount path for a back-end, for example, the path given in \"$ vault auth enable -path=my-aws aws\".\n"
                },
                "transformations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A comma separated string or slice of transformations to use.\n"
                }
            },
            "required": [
                "name",
                "path"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The mount path for a back-end, for example, the path given in \"$ vault auth enable -path=my-aws aws\".\n"
                },
                "transformations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A comma separated string or slice of transformations to use.\n"
                }
            },
            "requiredInputs": [
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Role resources.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The mount path for a back-end, for example, the path given in \"$ vault auth enable -path=my-aws aws\".\n"
                    },
                    "transformations": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A comma separated string or slice of transformations to use.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:transform/template:Template": {
            "properties": {
                "alphabet": {
                    "type": "string",
                    "description": "The alphabet to use for this template. This is only used during FPE transformations.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the template.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The mount path for a back-end, for example, the path given in \"$ vault auth enable -path=my-aws aws\".\n"
                },
                "pattern": {
                    "type": "string",
                    "description": "The pattern used for matching. Currently, only regular expression pattern is supported.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The pattern type to use for match detection. Currently, only regex is supported.\n"
                }
            },
            "required": [
                "name",
                "path"
            ],
            "inputProperties": {
                "alphabet": {
                    "type": "string",
                    "description": "The alphabet to use for this template. This is only used during FPE transformations.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the template.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The mount path for a back-end, for example, the path given in \"$ vault auth enable -path=my-aws aws\".\n"
                },
                "pattern": {
                    "type": "string",
                    "description": "The pattern used for matching. Currently, only regular expression pattern is supported.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The pattern type to use for match detection. Currently, only regex is supported.\n"
                }
            },
            "requiredInputs": [
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Template resources.\n",
                "properties": {
                    "alphabet": {
                        "type": "string",
                        "description": "The alphabet to use for this template. This is only used during FPE transformations.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the template.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The mount path for a back-end, for example, the path given in \"$ vault auth enable -path=my-aws aws\".\n"
                    },
                    "pattern": {
                        "type": "string",
                        "description": "The pattern used for matching. Currently, only regular expression pattern is supported.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The pattern type to use for match detection. Currently, only regex is supported.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:transform/transformation:Transformation": {
            "properties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The set of roles allowed to perform this transformation.\n"
                },
                "maskingCharacter": {
                    "type": "string",
                    "description": "The character used to replace data when in masking mode\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the transformation.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The mount path for a back-end, for example, the path given in \"$ vault auth enable -path=my-aws aws\".\n"
                },
                "template": {
                    "type": "string",
                    "description": "The name of the template to use.\n"
                },
                "templates": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Templates configured for transformation.\n"
                },
                "tweakSource": {
                    "type": "string",
                    "description": "The source of where the tweak value comes from. Only valid when in FPE mode.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of transformation to perform.\n"
                }
            },
            "required": [
                "name",
                "path",
                "templates"
            ],
            "inputProperties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The set of roles allowed to perform this transformation.\n"
                },
                "maskingCharacter": {
                    "type": "string",
                    "description": "The character used to replace data when in masking mode\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the transformation.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The mount path for a back-end, for example, the path given in \"$ vault auth enable -path=my-aws aws\".\n"
                },
                "template": {
                    "type": "string",
                    "description": "The name of the template to use.\n"
                },
                "templates": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Templates configured for transformation.\n"
                },
                "tweakSource": {
                    "type": "string",
                    "description": "The source of where the tweak value comes from. Only valid when in FPE mode.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of transformation to perform.\n"
                }
            },
            "requiredInputs": [
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Transformation resources.\n",
                "properties": {
                    "allowedRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The set of roles allowed to perform this transformation.\n"
                    },
                    "maskingCharacter": {
                        "type": "string",
                        "description": "The character used to replace data when in masking mode\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the transformation.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The mount path for a back-end, for example, the path given in \"$ vault auth enable -path=my-aws aws\".\n"
                    },
                    "template": {
                        "type": "string",
                        "description": "The name of the template to use.\n"
                    },
                    "templates": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Templates configured for transformation.\n"
                    },
                    "tweakSource": {
                        "type": "string",
                        "description": "The source of where the tweak value comes from. Only valid when in FPE mode.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of transformation to perform.\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:transit/secretBackendKey:SecretBackendKey": {
            "properties": {
                "allowPlaintextBackup": {
                    "type": "boolean",
                    "description": "If set, enables taking backup of named key in the plaintext format. Once set, this cannot be disabled.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The Transit secret backend the resource belongs to.\n"
                },
                "convergentEncryption": {
                    "type": "boolean",
                    "description": "Whether or not to support convergent encryption, where the same plaintext creates the same ciphertext. This requires\nderived to be set to true.\n"
                },
                "deletionAllowed": {
                    "type": "boolean",
                    "description": "Specifies if the key is allowed to be deleted.\n"
                },
                "derived": {
                    "type": "boolean",
                    "description": "Specifies if key derivation is to be used. If enabled, all encrypt/decrypt requests to this key must provide a context\nwhich is used for key derivation.\n"
                },
                "exportable": {
                    "type": "boolean",
                    "description": "Enables keys to be exportable. This allows for all the valid keys in the key ring to be exported. Once set, this cannot\nbe disabled.\n"
                },
                "keys": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "description": "List of key versions in the keyring.\n"
                },
                "latestVersion": {
                    "type": "integer",
                    "description": "Latest key version in use in the keyring\n"
                },
                "minAvailableVersion": {
                    "type": "integer",
                    "description": "Minimum key version available for use.\n"
                },
                "minDecryptionVersion": {
                    "type": "integer",
                    "description": "Minimum key version to use for decryption.\n"
                },
                "minEncryptionVersion": {
                    "type": "integer",
                    "description": "Minimum key version to use for encryption\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the encryption key to create.\n"
                },
                "supportsDecryption": {
                    "type": "boolean",
                    "description": "Whether or not the key supports decryption, based on key type.\n"
                },
                "supportsDerivation": {
                    "type": "boolean",
                    "description": "Whether or not the key supports derivation, based on key type.\n"
                },
                "supportsEncryption": {
                    "type": "boolean",
                    "description": "Whether or not the key supports encryption, based on key type.\n"
                },
                "supportsSigning": {
                    "type": "boolean",
                    "description": "Whether or not the key supports signing, based on key type.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Specifies the type of key to create. The currently-supported types are: aes128-gcm96, aes256-gcm96, chacha20-poly1305,\ned25519, ecdsa-p256, ecdsa-p384, ecdsa-p521, rsa-2048, rsa-3072, rsa-4096\n"
                }
            },
            "required": [
                "backend",
                "keys",
                "latestVersion",
                "minAvailableVersion",
                "name",
                "supportsDecryption",
                "supportsDerivation",
                "supportsEncryption",
                "supportsSigning"
            ],
            "inputProperties": {
                "allowPlaintextBackup": {
                    "type": "boolean",
                    "description": "If set, enables taking backup of named key in the plaintext format. Once set, this cannot be disabled.\n"
                },
                "backend": {
                    "type": "string",
                    "description": "The Transit secret backend the resource belongs to.\n"
                },
                "convergentEncryption": {
                    "type": "boolean",
                    "description": "Whether or not to support convergent encryption, where the same plaintext creates the same ciphertext. This requires\nderived to be set to true.\n"
                },
                "deletionAllowed": {
                    "type": "boolean",
                    "description": "Specifies if the key is allowed to be deleted.\n"
                },
                "derived": {
                    "type": "boolean",
                    "description": "Specifies if key derivation is to be used. If enabled, all encrypt/decrypt requests to this key must provide a context\nwhich is used for key derivation.\n"
                },
                "exportable": {
                    "type": "boolean",
                    "description": "Enables keys to be exportable. This allows for all the valid keys in the key ring to be exported. Once set, this cannot\nbe disabled.\n"
                },
                "minDecryptionVersion": {
                    "type": "integer",
                    "description": "Minimum key version to use for decryption.\n"
                },
                "minEncryptionVersion": {
                    "type": "integer",
                    "description": "Minimum key version to use for encryption\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the encryption key to create.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Specifies the type of key to create. The currently-supported types are: aes128-gcm96, aes256-gcm96, chacha20-poly1305,\ned25519, ecdsa-p256, ecdsa-p384, ecdsa-p521, rsa-2048, rsa-3072, rsa-4096\n"
                }
            },
            "requiredInputs": [
                "backend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretBackendKey resources.\n",
                "properties": {
                    "allowPlaintextBackup": {
                        "type": "boolean",
                        "description": "If set, enables taking backup of named key in the plaintext format. Once set, this cannot be disabled.\n"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The Transit secret backend the resource belongs to.\n"
                    },
                    "convergentEncryption": {
                        "type": "boolean",
                        "description": "Whether or not to support convergent encryption, where the same plaintext creates the same ciphertext. This requires\nderived to be set to true.\n"
                    },
                    "deletionAllowed": {
                        "type": "boolean",
                        "description": "Specifies if the key is allowed to be deleted.\n"
                    },
                    "derived": {
                        "type": "boolean",
                        "description": "Specifies if key derivation is to be used. If enabled, all encrypt/decrypt requests to this key must provide a context\nwhich is used for key derivation.\n"
                    },
                    "exportable": {
                        "type": "boolean",
                        "description": "Enables keys to be exportable. This allows for all the valid keys in the key ring to be exported. Once set, this cannot\nbe disabled.\n"
                    },
                    "keys": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        },
                        "description": "List of key versions in the keyring.\n"
                    },
                    "latestVersion": {
                        "type": "integer",
                        "description": "Latest key version in use in the keyring\n"
                    },
                    "minAvailableVersion": {
                        "type": "integer",
                        "description": "Minimum key version available for use.\n"
                    },
                    "minDecryptionVersion": {
                        "type": "integer",
                        "description": "Minimum key version to use for decryption.\n"
                    },
                    "minEncryptionVersion": {
                        "type": "integer",
                        "description": "Minimum key version to use for encryption\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the encryption key to create.\n"
                    },
                    "supportsDecryption": {
                        "type": "boolean",
                        "description": "Whether or not the key supports decryption, based on key type.\n"
                    },
                    "supportsDerivation": {
                        "type": "boolean",
                        "description": "Whether or not the key supports derivation, based on key type.\n"
                    },
                    "supportsEncryption": {
                        "type": "boolean",
                        "description": "Whether or not the key supports encryption, based on key type.\n"
                    },
                    "supportsSigning": {
                        "type": "boolean",
                        "description": "Whether or not the key supports signing, based on key type.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Specifies the type of key to create. The currently-supported types are: aes128-gcm96, aes256-gcm96, chacha20-poly1305,\ned25519, ecdsa-p256, ecdsa-p384, ecdsa-p521, rsa-2048, rsa-3072, rsa-4096\n"
                    }
                },
                "type": "object"
            }
        },
        "vault:transit/secretCacheConfig:SecretCacheConfig": {
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "The Transit secret backend the resource belongs to.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "Number of cache entries. A size of 0 mean unlimited.\n"
                }
            },
            "required": [
                "backend",
                "size"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "The Transit secret backend the resource belongs to.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "Number of cache entries. A size of 0 mean unlimited.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "size"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecretCacheConfig resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The Transit secret backend the resource belongs to.\n"
                    },
                    "size": {
                        "type": "integer",
                        "description": "Number of cache entries. A size of 0 mean unlimited.\n"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "vault:ad/getAccessCredentials:getAccessCredentials": {
            "inputs": {
                "description": "A collection of arguments for invoking getAccessCredentials.\n",
                "properties": {
                    "backend": {
                        "type": "string"
                    },
                    "role": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "role"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAccessCredentials.\n",
                "properties": {
                    "backend": {
                        "type": "string"
                    },
                    "currentPassword": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "lastPassword": {
                        "type": "string"
                    },
                    "role": {
                        "type": "string"
                    },
                    "username": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "currentPassword",
                    "lastPassword",
                    "role",
                    "username",
                    "id"
                ]
            }
        },
        "vault:appRole/getAuthBackendRoleId:getAuthBackendRoleId": {
            "description": "Reads the Role ID of an AppRole from a Vault server.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst role = pulumi.output(vault.appRole.getAuthBackendRoleId({\n    backend: \"my-approle-backend\",\n    roleName: \"my-role\",\n}, { async: true }));\n\nexport const role_id = role.roleId;\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nrole = vault.appRole.get_auth_backend_role_id(backend=\"my-approle-backend\",\n    role_name=\"my-role\")\npulumi.export(\"role-id\", role.role_id)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var role = Output.Create(Vault.AppRole.GetAuthBackendRoleId.InvokeAsync(new Vault.AppRole.GetAuthBackendRoleIdArgs\n        {\n            Backend = \"my-approle-backend\",\n            RoleName = \"my-role\",\n        }));\n        this.Role_id = role.Apply(role =\u003e role.RoleId);\n    }\n\n    [Output(\"role-id\")]\n    public Output\u003cstring\u003e Role_id { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/appRole\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\topt0 := \"my-approle-backend\"\n\t\trole, err := appRole.GetAuthBackendRoleId(ctx, \u0026appRole.GetAuthBackendRoleIdArgs{\n\t\t\tBackend:  \u0026opt0,\n\t\t\tRoleName: \"my-role\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"role-id\", role.RoleId)\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getAuthBackendRoleId.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The unique name for the AppRole backend the role to\nretrieve a RoleID for resides in. Defaults to \"approle\".\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role to retrieve the Role ID for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "roleName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAuthBackendRoleId.\n",
                "properties": {
                    "backend": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "roleId": {
                        "type": "string",
                        "description": "The RoleID of the role.\n"
                    },
                    "roleName": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "roleId",
                    "roleName",
                    "id"
                ]
            }
        },
        "vault:aws/getAccessCredentials:getAccessCredentials": {
            "inputs": {
                "description": "A collection of arguments for invoking getAccessCredentials.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The path to the AWS secret backend to\nread credentials from, with no leading or trailing `/`s.\n"
                    },
                    "region": {
                        "type": "string"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the AWS secret backend role to read\ncredentials from, with no leading or trailing `/`s.\n"
                    },
                    "roleArn": {
                        "type": "string"
                    },
                    "ttl": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of credentials to read. Defaults\nto `\"creds\"`, which just returns an AWS Access Key ID and Secret\nKey. Can also be set to `\"sts\"`, which will return a security token\nin addition to the keys.\n"
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "role"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAccessCredentials.\n",
                "properties": {
                    "accessKey": {
                        "type": "string",
                        "description": "The AWS Access Key ID returned by Vault.\n"
                    },
                    "backend": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "leaseDuration": {
                        "type": "integer",
                        "description": "The duration of the secret lease, in seconds relative\nto the time the data was requested. Once this time has passed any plan\ngenerated with this data may fail to apply.\n"
                    },
                    "leaseId": {
                        "type": "string",
                        "description": "The lease identifier assigned by Vault.\n"
                    },
                    "leaseRenewable": {
                        "type": "boolean"
                    },
                    "leaseStartTime": {
                        "type": "string"
                    },
                    "region": {
                        "type": "string"
                    },
                    "role": {
                        "type": "string"
                    },
                    "roleArn": {
                        "type": "string"
                    },
                    "secretKey": {
                        "type": "string",
                        "description": "The AWS Secret Key returned by Vault.\n"
                    },
                    "securityToken": {
                        "type": "string",
                        "description": "The STS token returned by Vault, if any.\n"
                    },
                    "ttl": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "accessKey",
                    "backend",
                    "leaseDuration",
                    "leaseId",
                    "leaseRenewable",
                    "leaseStartTime",
                    "role",
                    "secretKey",
                    "securityToken",
                    "id"
                ]
            }
        },
        "vault:azure/getAccessCredentials:getAccessCredentials": {
            "inputs": {
                "description": "A collection of arguments for invoking getAccessCredentials.\n",
                "properties": {
                    "backend": {
                        "type": "string"
                    },
                    "maxCredValidationSeconds": {
                        "type": "integer"
                    },
                    "numSecondsBetweenTests": {
                        "type": "integer"
                    },
                    "numSequentialSuccesses": {
                        "type": "integer"
                    },
                    "role": {
                        "type": "string"
                    },
                    "validateCreds": {
                        "type": "boolean"
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "role"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAccessCredentials.\n",
                "properties": {
                    "backend": {
                        "type": "string"
                    },
                    "clientId": {
                        "type": "string"
                    },
                    "clientSecret": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "leaseDuration": {
                        "type": "integer"
                    },
                    "leaseId": {
                        "type": "string"
                    },
                    "leaseRenewable": {
                        "type": "boolean"
                    },
                    "leaseStartTime": {
                        "type": "string"
                    },
                    "maxCredValidationSeconds": {
                        "type": "integer"
                    },
                    "numSecondsBetweenTests": {
                        "type": "integer"
                    },
                    "numSequentialSuccesses": {
                        "type": "integer"
                    },
                    "role": {
                        "type": "string"
                    },
                    "validateCreds": {
                        "type": "boolean"
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "clientId",
                    "clientSecret",
                    "leaseDuration",
                    "leaseId",
                    "leaseRenewable",
                    "leaseStartTime",
                    "role",
                    "id"
                ]
            }
        },
        "vault:generic/getSecret:getSecret": {
            "inputs": {
                "description": "A collection of arguments for invoking getSecret.\n",
                "properties": {
                    "path": {
                        "type": "string",
                        "description": "The full logical path from which to request data.\nTo read data from the \"generic\" secret backend mounted in Vault by\ndefault, this should be prefixed with `secret/`. Reading from other backends\nwith this data source is possible; consult each backend's documentation\nto see which endpoints support the `GET` method.\n"
                    },
                    "version": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "path"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSecret.\n",
                "properties": {
                    "data": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A mapping whose keys are the top-level data keys returned from\nVault and whose values are the corresponding values. This map can only\nrepresent string data, so any non-string values returned from Vault are\nserialized as JSON.\n"
                    },
                    "dataJson": {
                        "type": "string",
                        "description": "A string containing the full data payload retrieved from\nVault, serialized in JSON format.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "leaseDuration": {
                        "type": "integer",
                        "description": "The duration of the secret lease, in seconds relative\nto the time the data was requested. Once this time has passed any plan\ngenerated with this data may fail to apply.\n"
                    },
                    "leaseId": {
                        "type": "string",
                        "description": "The lease identifier assigned by Vault, if any.\n"
                    },
                    "leaseRenewable": {
                        "type": "boolean"
                    },
                    "leaseStartTime": {
                        "type": "string"
                    },
                    "path": {
                        "type": "string"
                    },
                    "version": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "data",
                    "dataJson",
                    "leaseDuration",
                    "leaseId",
                    "leaseRenewable",
                    "leaseStartTime",
                    "path",
                    "id"
                ]
            }
        },
        "vault:identity/getEntity:getEntity": {
            "inputs": {
                "description": "A collection of arguments for invoking getEntity.\n",
                "properties": {
                    "aliasId": {
                        "type": "string"
                    },
                    "aliasMountAccessor": {
                        "type": "string"
                    },
                    "aliasName": {
                        "type": "string"
                    },
                    "entityId": {
                        "type": "string"
                    },
                    "entityName": {
                        "type": "string"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getEntity.\n",
                "properties": {
                    "aliasId": {
                        "type": "string"
                    },
                    "aliasMountAccessor": {
                        "type": "string"
                    },
                    "aliasName": {
                        "type": "string"
                    },
                    "aliases": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:identity/getEntityAlias:getEntityAlias"
                        }
                    },
                    "creationTime": {
                        "type": "string"
                    },
                    "dataJson": {
                        "type": "string"
                    },
                    "directGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "entityId": {
                        "type": "string"
                    },
                    "entityName": {
                        "type": "string"
                    },
                    "groupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "inheritedGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "lastUpdateTime": {
                        "type": "string"
                    },
                    "mergedEntityIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "namespaceId": {
                        "type": "string"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "aliasId",
                    "aliasMountAccessor",
                    "aliasName",
                    "aliases",
                    "creationTime",
                    "dataJson",
                    "directGroupIds",
                    "disabled",
                    "entityId",
                    "entityName",
                    "groupIds",
                    "inheritedGroupIds",
                    "lastUpdateTime",
                    "mergedEntityIds",
                    "metadata",
                    "namespaceId",
                    "policies",
                    "id"
                ]
            }
        },
        "vault:identity/getGroup:getGroup": {
            "inputs": {
                "description": "A collection of arguments for invoking getGroup.\n",
                "properties": {
                    "aliasId": {
                        "type": "string"
                    },
                    "aliasMountAccessor": {
                        "type": "string"
                    },
                    "aliasName": {
                        "type": "string"
                    },
                    "groupId": {
                        "type": "string"
                    },
                    "groupName": {
                        "type": "string"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getGroup.\n",
                "properties": {
                    "aliasCanonicalId": {
                        "type": "string"
                    },
                    "aliasCreationTime": {
                        "type": "string"
                    },
                    "aliasId": {
                        "type": "string"
                    },
                    "aliasLastUpdateTime": {
                        "type": "string"
                    },
                    "aliasMergedFromCanonicalIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "aliasMetadata": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "aliasMountAccessor": {
                        "type": "string"
                    },
                    "aliasMountPath": {
                        "type": "string"
                    },
                    "aliasMountType": {
                        "type": "string"
                    },
                    "aliasName": {
                        "type": "string"
                    },
                    "creationTime": {
                        "type": "string"
                    },
                    "dataJson": {
                        "type": "string"
                    },
                    "groupId": {
                        "type": "string"
                    },
                    "groupName": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "lastUpdateTime": {
                        "type": "string"
                    },
                    "memberEntityIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "memberGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "modifyIndex": {
                        "type": "integer"
                    },
                    "namespaceId": {
                        "type": "string"
                    },
                    "parentGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "aliasCanonicalId",
                    "aliasCreationTime",
                    "aliasId",
                    "aliasLastUpdateTime",
                    "aliasMergedFromCanonicalIds",
                    "aliasMetadata",
                    "aliasMountAccessor",
                    "aliasMountPath",
                    "aliasMountType",
                    "aliasName",
                    "creationTime",
                    "dataJson",
                    "groupId",
                    "groupName",
                    "lastUpdateTime",
                    "memberEntityIds",
                    "memberGroupIds",
                    "metadata",
                    "modifyIndex",
                    "namespaceId",
                    "parentGroupIds",
                    "policies",
                    "type",
                    "id"
                ]
            }
        },
        "vault:index/getAuthBackend:getAuthBackend": {
            "inputs": {
                "description": "A collection of arguments for invoking getAuthBackend.\n",
                "properties": {
                    "path": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "path"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAuthBackend.\n",
                "properties": {
                    "accessor": {
                        "type": "string"
                    },
                    "defaultLeaseTtlSeconds": {
                        "type": "integer"
                    },
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "listingVisibility": {
                        "type": "string"
                    },
                    "local": {
                        "type": "boolean"
                    },
                    "maxLeaseTtlSeconds": {
                        "type": "integer"
                    },
                    "path": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "accessor",
                    "defaultLeaseTtlSeconds",
                    "description",
                    "listingVisibility",
                    "local",
                    "maxLeaseTtlSeconds",
                    "path",
                    "type",
                    "id"
                ]
            }
        },
        "vault:index/getPolicyDocument:getPolicyDocument": {
            "description": "This is a data source which can be used to construct a HCL representation of an Vault policy document, for use with resources which expect policy documents, such as the `vault.Policy` resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst examplePolicyDocument = vault.getPolicyDocument({\n    rules: [{\n        path: \"secret/*\",\n        capabilities: [\n            \"create\",\n            \"read\",\n            \"update\",\n            \"delete\",\n            \"list\",\n        ],\n        description: \"allow all on secrets\",\n    }],\n});\nconst examplePolicy = new vault.Policy(\"examplePolicy\", {policy: data.vault_policy_document.hcl});\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nexample_policy_document = vault.get_policy_document(rules=[vault.GetPolicyDocumentRuleArgs(\n    path=\"secret/*\",\n    capabilities=[\n        \"create\",\n        \"read\",\n        \"update\",\n        \"delete\",\n        \"list\",\n    ],\n    description=\"allow all on secrets\",\n)])\nexample_policy = vault.Policy(\"examplePolicy\", policy=data[\"vault_policy_document\"][\"hcl\"])\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var examplePolicyDocument = Output.Create(Vault.GetPolicyDocument.InvokeAsync(new Vault.GetPolicyDocumentArgs\n        {\n            Rules = \n            {\n                new Vault.Inputs.GetPolicyDocumentRuleArgs\n                {\n                    Path = \"secret/*\",\n                    Capabilities = \n                    {\n                        \"create\",\n                        \"read\",\n                        \"update\",\n                        \"delete\",\n                        \"list\",\n                    },\n                    Description = \"allow all on secrets\",\n                },\n            },\n        }));\n        var examplePolicy = new Vault.Policy(\"examplePolicy\", new Vault.PolicyArgs\n        {\n            Policy = data.Vault_policy_document.Hcl,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vault.GetPolicyDocument(ctx, \u0026vault.GetPolicyDocumentArgs{\n\t\t\tRules: []vault.GetPolicyDocumentRule{\n\t\t\t\tvault.GetPolicyDocumentRule{\n\t\t\t\t\tPath: \"secret/*\",\n\t\t\t\t\tCapabilities: []string{\n\t\t\t\t\t\t\"create\",\n\t\t\t\t\t\t\"read\",\n\t\t\t\t\t\t\"update\",\n\t\t\t\t\t\t\"delete\",\n\t\t\t\t\t\t\"list\",\n\t\t\t\t\t},\n\t\t\t\t\tDescription: \"allow all on secrets\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vault.NewPolicy(ctx, \"examplePolicy\", \u0026vault.PolicyArgs{\n\t\t\tPolicy: pulumi.Any(data.Vault_policy_document.Hcl),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getPolicyDocument.\n",
                "properties": {
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:index/getPolicyDocumentRule:getPolicyDocumentRule"
                        }
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getPolicyDocument.\n",
                "properties": {
                    "hcl": {
                        "type": "string",
                        "description": "The above arguments serialized as a standard Vault HCL policy document.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vault:index/getPolicyDocumentRule:getPolicyDocumentRule"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "hcl",
                    "rules",
                    "id"
                ]
            }
        },
        "vault:kubernetes/getAuthBackendConfig:getAuthBackendConfig": {
            "description": "Reads the Role of an Kubernetes from a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/api/auth/kubernetes/index.html#read-config) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst config = pulumi.output(vault.kubernetes.getAuthBackendConfig({\n    backend: \"my-kubernetes-backend\",\n}, { async: true }));\n\nexport const tokenReviewerJwt = config.tokenReviewerJwt;\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getAuthBackendConfig.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "The unique name for the Kubernetes backend the config to\nretrieve Role attributes for resides in. Defaults to \"kubernetes\".\n"
                    },
                    "disableIssValidation": {
                        "type": "boolean"
                    },
                    "disableLocalCaJwt": {
                        "type": "boolean"
                    },
                    "issuer": {
                        "type": "string"
                    },
                    "kubernetesCaCert": {
                        "type": "string",
                        "description": "PEM encoded CA cert for use by the TLS client used to talk with the Kubernetes API.\n"
                    },
                    "kubernetesHost": {
                        "type": "string",
                        "description": "Host must be a host string, a host:port pair, or a URL to the base of the Kubernetes API server.\n"
                    },
                    "pemKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Optional list of PEM-formatted public keys or certificates used to verify the signatures of Kubernetes service account JWTs. If a certificate is given, its public key will be extracted. Not every installation of Kubernetes exposes these keys.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getAuthBackendConfig.\n",
                "properties": {
                    "backend": {
                        "type": "string"
                    },
                    "disableIssValidation": {
                        "type": "boolean"
                    },
                    "disableLocalCaJwt": {
                        "type": "boolean"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "issuer": {
                        "type": "string"
                    },
                    "kubernetesCaCert": {
                        "type": "string",
                        "description": "PEM encoded CA cert for use by the TLS client used to talk with the Kubernetes API.\n"
                    },
                    "kubernetesHost": {
                        "type": "string",
                        "description": "Host must be a host string, a host:port pair, or a URL to the base of the Kubernetes API server.\n"
                    },
                    "pemKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Optional list of PEM-formatted public keys or certificates used to verify the signatures of Kubernetes service account JWTs. If a certificate is given, its public key will be extracted. Not every installation of Kubernetes exposes these keys.\n"
                    }
                },
                "type": "object",
                "required": [
                    "disableIssValidation",
                    "disableLocalCaJwt",
                    "issuer",
                    "kubernetesCaCert",
                    "kubernetesHost",
                    "pemKeys",
                    "id"
                ]
            }
        },
        "vault:kubernetes/getAuthBackendRole:getAuthBackendRole": {
            "description": "Reads the Role of an Kubernetes from a Vault server. See the [Vault\ndocumentation](https://www.vaultproject.io/api/auth/kubernetes/index.html#read-role) for more\ninformation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vault from \"@pulumi/vault\";\n\nconst role = pulumi.output(vault.kubernetes.getAuthBackendRole({\n    backend: \"my-kubernetes-backend\",\n    roleName: \"my-role\",\n}, { async: true }));\n\nexport const policies = role.policies!;\n```\n```python\nimport pulumi\nimport pulumi_vault as vault\n\nrole = vault.kubernetes.get_auth_backend_role(backend=\"my-kubernetes-backend\",\n    role_name=\"my-role\")\npulumi.export(\"policies\", role.policies)\n```\n```csharp\nusing Pulumi;\nusing Vault = Pulumi.Vault;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var role = Output.Create(Vault.Kubernetes.GetAuthBackendRole.InvokeAsync(new Vault.Kubernetes.GetAuthBackendRoleArgs\n        {\n            Backend = \"my-kubernetes-backend\",\n            RoleName = \"my-role\",\n        }));\n        this.Policies = role.Apply(role =\u003e role.Policies);\n    }\n\n    [Output(\"policies\")]\n    public Output\u003cstring\u003e Policies { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vault/sdk/v3/go/vault/kubernetes\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\topt0 := \"my-kubernetes-backend\"\n\t\trole, err := kubernetes.LookupAuthBackendRole(ctx, \u0026kubernetes.LookupAuthBackendRoleArgs{\n\t\t\tBackend:  \u0026opt0,\n\t\t\tRoleName: \"my-role\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"policies\", role.Policies)\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getAuthBackendRole.\n",
                "properties": {
                    "audience": {
                        "type": "string"
                    },
                    "backend": {
                        "type": "string",
                        "description": "The unique name for the Kubernetes backend the role to\nretrieve Role attributes for resides in. Defaults to \"kubernetes\".\n"
                    },
                    "boundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "deprecationMessage": "use `token_bound_cidrs` instead if you are running Vault \u003e= 1.2"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "The maximum allowed lifetime of tokens issued in seconds using this role.\n",
                        "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                    },
                    "numUses": {
                        "type": "integer",
                        "description": "Number of times issued tokens can be used. Setting this to 0 or leaving it unset means unlimited uses.\n",
                        "deprecationMessage": "use `token_num_uses` instead if you are running Vault \u003e= 1.2"
                    },
                    "period": {
                        "type": "integer",
                        "description": "If set, indicates that the token generated using this role should never expire. The token should be renewed within the duration specified by this value. At each renewal, the token's TTL will be set to the value of this parameter.\n",
                        "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Policies to be set on tokens issued using this role.\n",
                        "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role to retrieve the Role attributes for.\n"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer"
                    },
                    "tokenMaxTtl": {
                        "type": "integer"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean"
                    },
                    "tokenNumUses": {
                        "type": "integer"
                    },
                    "tokenPeriod": {
                        "type": "integer"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "tokenTtl": {
                        "type": "integer"
                    },
                    "tokenType": {
                        "type": "string"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "The TTL period of tokens issued using this role in seconds.\n",
                        "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                    }
                },
                "type": "object",
                "required": [
                    "roleName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAuthBackendRole.\n",
                "properties": {
                    "audience": {
                        "type": "string"
                    },
                    "backend": {
                        "type": "string"
                    },
                    "boundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "deprecationMessage": "use `token_bound_cidrs` instead if you are running Vault \u003e= 1.2"
                    },
                    "boundServiceAccountNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of service account names able to access this role. If set to \"*\" all names are allowed, both this and bound_service_account_namespaces can not be \"*\".\n"
                    },
                    "boundServiceAccountNamespaces": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of namespaces allowed to access this role. If set to \"*\" all namespaces are allowed, both this and bound_service_account_names can not be set to \"*\".\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "maxTtl": {
                        "type": "integer",
                        "description": "The maximum allowed lifetime of tokens issued in seconds using this role.\n",
                        "deprecationMessage": "use `token_max_ttl` instead if you are running Vault \u003e= 1.2"
                    },
                    "numUses": {
                        "type": "integer",
                        "description": "Number of times issued tokens can be used. Setting this to 0 or leaving it unset means unlimited uses.\n",
                        "deprecationMessage": "use `token_num_uses` instead if you are running Vault \u003e= 1.2"
                    },
                    "period": {
                        "type": "integer",
                        "description": "If set, indicates that the token generated using this role should never expire. The token should be renewed within the duration specified by this value. At each renewal, the token's TTL will be set to the value of this parameter.\n",
                        "deprecationMessage": "use `token_period` instead if you are running Vault \u003e= 1.2"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Policies to be set on tokens issued using this role.\n",
                        "deprecationMessage": "use `token_policies` instead if you are running Vault \u003e= 1.2"
                    },
                    "roleName": {
                        "type": "string"
                    },
                    "tokenBoundCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "tokenExplicitMaxTtl": {
                        "type": "integer"
                    },
                    "tokenMaxTtl": {
                        "type": "integer"
                    },
                    "tokenNoDefaultPolicy": {
                        "type": "boolean"
                    },
                    "tokenNumUses": {
                        "type": "integer"
                    },
                    "tokenPeriod": {
                        "type": "integer"
                    },
                    "tokenPolicies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "tokenTtl": {
                        "type": "integer"
                    },
                    "tokenType": {
                        "type": "string"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "The TTL period of tokens issued using this role in seconds.\n",
                        "deprecationMessage": "use `token_ttl` instead if you are running Vault \u003e= 1.2"
                    }
                },
                "type": "object",
                "required": [
                    "boundServiceAccountNames",
                    "boundServiceAccountNamespaces",
                    "roleName",
                    "id"
                ]
            }
        },
        "vault:transform/getDecode:getDecode": {
            "inputs": {
                "description": "A collection of arguments for invoking getDecode.\n",
                "properties": {
                    "batchInputs": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        }
                    },
                    "batchResults": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        }
                    },
                    "decodedValue": {
                        "type": "string"
                    },
                    "path": {
                        "type": "string"
                    },
                    "roleName": {
                        "type": "string"
                    },
                    "transformation": {
                        "type": "string"
                    },
                    "tweak": {
                        "type": "string"
                    },
                    "value": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "path",
                    "roleName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDecode.\n",
                "properties": {
                    "batchInputs": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        }
                    },
                    "batchResults": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        }
                    },
                    "decodedValue": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "path": {
                        "type": "string"
                    },
                    "roleName": {
                        "type": "string"
                    },
                    "transformation": {
                        "type": "string"
                    },
                    "tweak": {
                        "type": "string"
                    },
                    "value": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "batchResults",
                    "decodedValue",
                    "path",
                    "roleName",
                    "id"
                ]
            }
        },
        "vault:transform/getEncode:getEncode": {
            "inputs": {
                "description": "A collection of arguments for invoking getEncode.\n",
                "properties": {
                    "batchInputs": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        }
                    },
                    "batchResults": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        }
                    },
                    "encodedValue": {
                        "type": "string"
                    },
                    "path": {
                        "type": "string"
                    },
                    "roleName": {
                        "type": "string"
                    },
                    "transformation": {
                        "type": "string"
                    },
                    "tweak": {
                        "type": "string"
                    },
                    "value": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "path",
                    "roleName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getEncode.\n",
                "properties": {
                    "batchInputs": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        }
                    },
                    "batchResults": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        }
                    },
                    "encodedValue": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "path": {
                        "type": "string"
                    },
                    "roleName": {
                        "type": "string"
                    },
                    "transformation": {
                        "type": "string"
                    },
                    "tweak": {
                        "type": "string"
                    },
                    "value": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "batchResults",
                    "encodedValue",
                    "path",
                    "roleName",
                    "id"
                ]
            }
        },
        "vault:transit/getDecrypt:getDecrypt": {
            "inputs": {
                "description": "A collection of arguments for invoking getDecrypt.\n",
                "properties": {
                    "backend": {
                        "type": "string"
                    },
                    "ciphertext": {
                        "type": "string"
                    },
                    "context": {
                        "type": "string"
                    },
                    "key": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "ciphertext",
                    "key"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDecrypt.\n",
                "properties": {
                    "backend": {
                        "type": "string"
                    },
                    "ciphertext": {
                        "type": "string"
                    },
                    "context": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "key": {
                        "type": "string"
                    },
                    "plaintext": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "ciphertext",
                    "key",
                    "plaintext",
                    "id"
                ]
            }
        },
        "vault:transit/getEncrypt:getEncrypt": {
            "inputs": {
                "description": "A collection of arguments for invoking getEncrypt.\n",
                "properties": {
                    "backend": {
                        "type": "string"
                    },
                    "context": {
                        "type": "string"
                    },
                    "key": {
                        "type": "string"
                    },
                    "keyVersion": {
                        "type": "integer"
                    },
                    "plaintext": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "key",
                    "plaintext"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getEncrypt.\n",
                "properties": {
                    "backend": {
                        "type": "string"
                    },
                    "ciphertext": {
                        "type": "string"
                    },
                    "context": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "key": {
                        "type": "string"
                    },
                    "keyVersion": {
                        "type": "integer"
                    },
                    "plaintext": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "backend",
                    "ciphertext",
                    "key",
                    "plaintext",
                    "id"
                ]
            }
        }
    },
    "language": {
        "csharp": {
            "namespaces": {
                "ad": "AD",
                "alicloud": "AliCloud",
                "appRole": "AppRole",
                "aws": "Aws",
                "azure": "Azure",
                "consul": "Consul",
                "database": "Database",
                "gcp": "Gcp",
                "generic": "Generic",
                "github": "GitHub",
                "identity": "Identity",
                "index": "index",
                "jwt": "Jwt",
                "kubernetes": "Kubernetes",
                "ldap": "Ldap",
                "okta": "Okta",
                "pkiSecret": "PkiSecret",
                "rabbitMq": "RabbitMQ",
                "ssh": "Ssh",
                "tokenauth": "TokenAuth",
                "transform": "Transform",
                "transit": "Transit",
                "vault": "Vault"
            },
            "packageReferences": {
                "Pulumi": "2.*",
                "System.Collections.Immutable": "1.6.0"
            }
        },
        "nodejs": {
            "dependencies": {
                "@pulumi/pulumi": "^2.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^8.0.25"
            },
            "disableUnionOutputTypes": true,
            "packageDescription": "A Pulumi package for creating and managing vault cloud resources.",
            "packageName": "",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/terraform-providers/terraform-provider-vault)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi/pulumi-vault` repo](https://github.com/pulumi/pulumi-vault/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-providers/terraform-provider-vault` repo](https://github.com/terraform-providers/terraform-provider-vault/issues).",
            "typescriptVersion": ""
        },
        "python": {
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/terraform-providers/terraform-provider-vault)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi/pulumi-vault` repo](https://github.com/pulumi/pulumi-vault/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-providers/terraform-provider-vault` repo](https://github.com/terraform-providers/terraform-provider-vault/issues).",
            "requires": {
                "pulumi": "\u003e=2.9.0,\u003c3.0.0"
            },
            "usesIOClasses": true
        }
    }
}